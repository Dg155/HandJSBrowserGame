(self.webpackChunkat_alternative_interaction_solution=self.webpackChunkat_alternative_interaction_solution||[]).push([[179],{912:(ce,_e,B)=>{"use strict";var he={};B.r(he),B.d(he,{assertParamsValid:()=>gC,computeFlatOffset:()=>bC,computeOutShape:()=>M$,getNormalizedAxes:()=>z$,isSliceContinous:()=>yC,maskToAxes:()=>gg,parseSliceParams:()=>yg,sliceInfo:()=>vC,startForAxis:()=>H$,startIndicesWithElidedDims:()=>V$,stopForAxis:()=>G$,stopIndicesWithElidedDims:()=>U$,stridesForAxis:()=>W$,stridesWithElidedDims:()=>P$});var st={};B.r(st),B.d(st,{collectGatherOpShapeInfo:()=>CI,computeOutShape:()=>I2,segOpComputeOptimalWindowSize:()=>C2});var X={};B.r(X),B.d(X,{ERF_A1:()=>mI,ERF_A2:()=>gI,ERF_A3:()=>yI,ERF_A4:()=>bI,ERF_A5:()=>vI,ERF_P:()=>pI,PARALLELIZE_THRESHOLD:()=>uI,SELU_SCALE:()=>Vg,SELU_SCALEALPHA:()=>zg,applyActivation:()=>Mg,assertAndGetBroadcastShape:()=>bt,assertAxesAreInnerMostDims:()=>lr,assertParamsConsistent:()=>lI,assignToTypedArray:()=>v2,axesAreInnerMostDims:()=>TC,calculateShapes:()=>Th,combineLocations:()=>Q$,complexWithEvenIndex:()=>y2,complexWithOddIndex:()=>b2,computeConv2DInfo:()=>Zn,computeConv3DInfo:()=>Bi,computeDefaultPad:()=>CC,computeDilation2DInfo:()=>fh,computeOptimalWindowSize:()=>Bg,computeOutAndReduceShapes:()=>Qn,computeOutShape:()=>ci,computePool2DInfo:()=>ks,computePool3DInfo:()=>ri,convertConv2DDataFormat:()=>si,eitherStridesOrDilationsAreOne:()=>ar,expandShapeToKeepDim:()=>vn,exponent:()=>w2,exponents:()=>x2,fromStringArrayToUint8:()=>D2,fromUint8ToStringArray:()=>II,getAxesPermutation:()=>xn,getBroadcastDims:()=>gh,getComplexWithIndex:()=>xI,getFusedBiasGradient:()=>Og,getFusedDyActivation:()=>Fg,getImageCenter:()=>cI,getInnerMostAxes:()=>En,getPermuted:()=>Eh,getReductionAxes:()=>Ln,getReshaped:()=>Sh,getReshapedPermuted:()=>Nh,getSliceBeginCoords:()=>dI,getSliceSize:()=>hI,getUndoAxesPermutation:()=>gu,log:()=>GY,mergeRealAndImagArrays:()=>di,prepareAndValidate:()=>fI,prepareSplitSize:()=>wI,segment_util:()=>st,shouldFuse:()=>Pg,slice_util:()=>he,splitRealAndImagArrays:()=>g2,tupleValuesAreOne:()=>zi,upcastType:()=>ds,validateInput:()=>m2,validateUpdateShape:()=>p2,warn:()=>Iu});var Ze={};B.r(Ze),B.d(Ze,{json:()=>zte});var be={};B.r(be),B.d(be,{json:()=>Vte});var Ce={};B.r(Ce),B.d(Ce,{json:()=>Ute});var ie={};B.r(ie),B.d(ie,{json:()=>Wte});var P={};B.r(P),B.d(P,{json:()=>Hte});var I={};B.r(I),B.d(I,{json:()=>Gte});var k={};B.r(k),B.d(k,{json:()=>jte});var $={};B.r($),B.d($,{json:()=>qte});var E={};B.r(E),B.d(E,{json:()=>Kte});var N={};B.r(N),B.d(N,{json:()=>Xte});var z={};B.r(z),B.d(z,{json:()=>Yte});var W={};B.r(W),B.d(W,{json:()=>Zte});var Qe={};B.r(Qe),B.d(Qe,{json:()=>Qte});var Rt={};B.r(Rt),B.d(Rt,{json:()=>Jte});var wt={};B.r(wt),B.d(wt,{json:()=>ene});var In={};B.r(In),B.d(In,{json:()=>tne});var Dn={};B.r(Dn),B.d(Dn,{json:()=>nne});var fe={};function ae(t){return"function"==typeof t}function Ye(t){const e=t(r=>{Error.call(r),r.stack=(new Error).stack});return e.prototype=Object.create(Error.prototype),e.prototype.constructor=e,e}B.r(fe),B.d(fe,{addImpl:()=>eM,bincountImpl:()=>QD,bincountReduceImpl:()=>iM,ceilImpl:()=>aM,concatImpl:()=>lM,expImpl:()=>hM,expm1Impl:()=>pM,floorImpl:()=>yM,gatherV2Impl:()=>bM,greaterImpl:()=>vM,lessImpl:()=>xM,linSpaceImpl:()=>wM,logImpl:()=>CM,maxImpl:()=>IM,maximumImpl:()=>_M,minimumImpl:()=>SM,multiplyImpl:()=>JD,negImpl:()=>NM,notEqualImpl:()=>TM,prodImpl:()=>$M,rangeImpl:()=>FM,rsqrtImpl:()=>OM,simpleAbsImpl:()=>nM,sliceImpl:()=>oM,squaredDifferenceImpl:()=>LM,stridedSliceImpl:()=>BM,subImpl:()=>mM,tileImpl:()=>zM,topKImpl:()=>VM,transposeImpl:()=>YD,uniqueImpl:()=>WM});const Re=Ye(t=>function(e){t(this),this.message=e?`${e.length} errors occurred during unsubscription:\n${e.map((r,s)=>`${s+1}) ${r.toString()}`).join("\n  ")}`:"",this.name="UnsubscriptionError",this.errors=e});function ke(t,n){if(t){const e=t.indexOf(n);0<=e&&t.splice(e,1)}}class Ve{constructor(n){this.initialTeardown=n,this.closed=!1,this._parentage=null,this._finalizers=null}unsubscribe(){let n;if(!this.closed){this.closed=!0;const{_parentage:e}=this;if(e)if(this._parentage=null,Array.isArray(e))for(const o of e)o.remove(this);else e.remove(this);const{initialTeardown:r}=this;if(ae(r))try{r()}catch(o){n=o instanceof Re?o.errors:[o]}const{_finalizers:s}=this;if(s){this._finalizers=null;for(const o of s)try{Et(o)}catch(i){n=n??[],i instanceof Re?n=[...n,...i.errors]:n.push(i)}}if(n)throw new Re(n)}}add(n){var e;if(n&&n!==this)if(this.closed)Et(n);else{if(n instanceof Ve){if(n.closed||n._hasParent(this))return;n._addParent(this)}(this._finalizers=null!==(e=this._finalizers)&&void 0!==e?e:[]).push(n)}}_hasParent(n){const{_parentage:e}=this;return e===n||Array.isArray(e)&&e.includes(n)}_addParent(n){const{_parentage:e}=this;this._parentage=Array.isArray(e)?(e.push(n),e):e?[e,n]:n}_removeParent(n){const{_parentage:e}=this;e===n?this._parentage=null:Array.isArray(e)&&ke(e,n)}remove(n){const{_finalizers:e}=this;e&&ke(e,n),n instanceof Ve&&n._removeParent(this)}}Ve.EMPTY=(()=>{const t=new Ve;return t.closed=!0,t})();const mt=Ve.EMPTY;function lt(t){return t instanceof Ve||t&&"closed"in t&&ae(t.remove)&&ae(t.add)&&ae(t.unsubscribe)}function Et(t){ae(t)?t():t.unsubscribe()}const dt={onUnhandledError:null,onStoppedNotification:null,Promise:void 0,useDeprecatedSynchronousErrorHandling:!1,useDeprecatedNextContext:!1},Tt={setTimeout(t,n,...e){const{delegate:r}=Tt;return r?.setTimeout?r.setTimeout(t,n,...e):setTimeout(t,n,...e)},clearTimeout(t){const{delegate:n}=Tt;return(n?.clearTimeout||clearTimeout)(t)},delegate:void 0};function hr(t){Tt.setTimeout(()=>{const{onUnhandledError:n}=dt;if(!n)throw t;n(t)})}function kn(){}const cL=Hy("C",void 0,void 0);function Hy(t,n,e){return{kind:t,value:n,error:e}}let ra=null;function sf(t){if(dt.useDeprecatedSynchronousErrorHandling){const n=!ra;if(n&&(ra={errorThrown:!1,error:null}),t(),n){const{errorThrown:e,error:r}=ra;if(ra=null,e)throw r}}else t()}class Gy extends Ve{constructor(n){super(),this.isStopped=!1,n?(this.destination=n,lt(n)&&n.add(this)):this.destination=yL}static create(n,e,r){return new qu(n,e,r)}next(n){this.isStopped?qy(function hL(t){return Hy("N",t,void 0)}(n),this):this._next(n)}error(n){this.isStopped?qy(function dL(t){return Hy("E",void 0,t)}(n),this):(this.isStopped=!0,this._error(n))}complete(){this.isStopped?qy(cL,this):(this.isStopped=!0,this._complete())}unsubscribe(){this.closed||(this.isStopped=!0,super.unsubscribe(),this.destination=null)}_next(n){this.destination.next(n)}_error(n){try{this.destination.error(n)}finally{this.unsubscribe()}}_complete(){try{this.destination.complete()}finally{this.unsubscribe()}}}const pL=Function.prototype.bind;function jy(t,n){return pL.call(t,n)}class mL{constructor(n){this.partialObserver=n}next(n){const{partialObserver:e}=this;if(e.next)try{e.next(n)}catch(r){af(r)}}error(n){const{partialObserver:e}=this;if(e.error)try{e.error(n)}catch(r){af(r)}else af(n)}complete(){const{partialObserver:n}=this;if(n.complete)try{n.complete()}catch(e){af(e)}}}class qu extends Gy{constructor(n,e,r){let s;if(super(),ae(n)||!n)s={next:n??void 0,error:e??void 0,complete:r??void 0};else{let o;this&&dt.useDeprecatedNextContext?(o=Object.create(n),o.unsubscribe=()=>this.unsubscribe(),s={next:n.next&&jy(n.next,o),error:n.error&&jy(n.error,o),complete:n.complete&&jy(n.complete,o)}):s=n}this.destination=new mL(s)}}function af(t){dt.useDeprecatedSynchronousErrorHandling?function fL(t){dt.useDeprecatedSynchronousErrorHandling&&ra&&(ra.errorThrown=!0,ra.error=t)}(t):hr(t)}function qy(t,n){const{onStoppedNotification:e}=dt;e&&Tt.setTimeout(()=>e(t,n))}const yL={closed:!0,next:kn,error:function gL(t){throw t},complete:kn},Ky="function"==typeof Symbol&&Symbol.observable||"@@observable";function sa(t){return t}function D_(t){return 0===t.length?sa:1===t.length?t[0]:function(e){return t.reduce((r,s)=>s(r),e)}}let Un=(()=>{class t{constructor(e){e&&(this._subscribe=e)}lift(e){const r=new t;return r.source=this,r.operator=e,r}subscribe(e,r,s){const o=function xL(t){return t&&t instanceof Gy||function vL(t){return t&&ae(t.next)&&ae(t.error)&&ae(t.complete)}(t)&&lt(t)}(e)?e:new qu(e,r,s);return sf(()=>{const{operator:i,source:a}=this;o.add(i?i.call(o,a):a?this._subscribe(o):this._trySubscribe(o))}),o}_trySubscribe(e){try{return this._subscribe(e)}catch(r){e.error(r)}}forEach(e,r){return new(r=__(r))((s,o)=>{const i=new qu({next:a=>{try{e(a)}catch(l){o(l),i.unsubscribe()}},error:o,complete:s});this.subscribe(i)})}_subscribe(e){var r;return null===(r=this.source)||void 0===r?void 0:r.subscribe(e)}[Ky](){return this}pipe(...e){return D_(e)(this)}toPromise(e){return new(e=__(e))((r,s)=>{let o;this.subscribe(i=>o=i,i=>s(i),()=>r(o))})}}return t.create=n=>new t(n),t})();function __(t){var n;return null!==(n=t??dt.Promise)&&void 0!==n?n:Promise}const wL=Ye(t=>function(){t(this),this.name="ObjectUnsubscribedError",this.message="object unsubscribed"});let Po=(()=>{class t extends Un{constructor(){super(),this.closed=!1,this.currentObservers=null,this.observers=[],this.isStopped=!1,this.hasError=!1,this.thrownError=null}lift(e){const r=new S_(this,this);return r.operator=e,r}_throwIfClosed(){if(this.closed)throw new wL}next(e){sf(()=>{if(this._throwIfClosed(),!this.isStopped){this.currentObservers||(this.currentObservers=Array.from(this.observers));for(const r of this.currentObservers)r.next(e)}})}error(e){sf(()=>{if(this._throwIfClosed(),!this.isStopped){this.hasError=this.isStopped=!0,this.thrownError=e;const{observers:r}=this;for(;r.length;)r.shift().error(e)}})}complete(){sf(()=>{if(this._throwIfClosed(),!this.isStopped){this.isStopped=!0;const{observers:e}=this;for(;e.length;)e.shift().complete()}})}unsubscribe(){this.isStopped=this.closed=!0,this.observers=this.currentObservers=null}get observed(){var e;return(null===(e=this.observers)||void 0===e?void 0:e.length)>0}_trySubscribe(e){return this._throwIfClosed(),super._trySubscribe(e)}_subscribe(e){return this._throwIfClosed(),this._checkFinalizedStatuses(e),this._innerSubscribe(e)}_innerSubscribe(e){const{hasError:r,isStopped:s,observers:o}=this;return r||s?mt:(this.currentObservers=null,o.push(e),new Ve(()=>{this.currentObservers=null,ke(o,e)}))}_checkFinalizedStatuses(e){const{hasError:r,thrownError:s,isStopped:o}=this;r?e.error(s):o&&e.complete()}asObservable(){const e=new Un;return e.source=this,e}}return t.create=(n,e)=>new S_(n,e),t})();class S_ extends Po{constructor(n,e){super(),this.destination=n,this.source=e}next(n){var e,r;null===(r=null===(e=this.destination)||void 0===e?void 0:e.next)||void 0===r||r.call(e,n)}error(n){var e,r;null===(r=null===(e=this.destination)||void 0===e?void 0:e.error)||void 0===r||r.call(e,n)}complete(){var n,e;null===(e=null===(n=this.destination)||void 0===n?void 0:n.complete)||void 0===e||e.call(n)}_subscribe(n){var e,r;return null!==(r=null===(e=this.source)||void 0===e?void 0:e.subscribe(n))&&void 0!==r?r:mt}}function E_(t){return ae(t?.lift)}function nr(t){return n=>{if(E_(n))return n.lift(function(e){try{return t(e,this)}catch(r){this.error(r)}});throw new TypeError("Unable to lift unknown Observable type")}}function rr(t,n,e,r,s){return new CL(t,n,e,r,s)}class CL extends Gy{constructor(n,e,r,s,o,i){super(n),this.onFinalize=o,this.shouldUnsubscribe=i,this._next=e?function(a){try{e(a)}catch(l){n.error(l)}}:super._next,this._error=s?function(a){try{s(a)}catch(l){n.error(l)}finally{this.unsubscribe()}}:super._error,this._complete=r?function(){try{r()}catch(a){n.error(a)}finally{this.unsubscribe()}}:super._complete}unsubscribe(){var n;if(!this.shouldUnsubscribe||this.shouldUnsubscribe()){const{closed:e}=this;super.unsubscribe(),!e&&(null===(n=this.onFinalize)||void 0===n||n.call(this))}}}function It(t,n){return nr((e,r)=>{let s=0;e.subscribe(rr(r,o=>{r.next(t.call(n,o,s++))}))})}function oa(t){return this instanceof oa?(this.v=t,this):new oa(t)}function _L(t,n,e){if(!Symbol.asyncIterator)throw new TypeError("Symbol.asyncIterator is not defined.");var s,r=e.apply(t,n||[]),o=[];return s={},i("next"),i("throw"),i("return"),s[Symbol.asyncIterator]=function(){return this},s;function i(h){r[h]&&(s[h]=function(f){return new Promise(function(p,m){o.push([h,f,p,m])>1||a(h,f)})})}function a(h,f){try{!function l(h){h.value instanceof oa?Promise.resolve(h.value.v).then(u,c):d(o[0][2],h)}(r[h](f))}catch(p){d(o[0][3],p)}}function u(h){a("next",h)}function c(h){a("throw",h)}function d(h,f){h(f),o.shift(),o.length&&a(o[0][0],o[0][1])}}function SL(t){if(!Symbol.asyncIterator)throw new TypeError("Symbol.asyncIterator is not defined.");var e,n=t[Symbol.asyncIterator];return n?n.call(t):(t=function k_(t){var n="function"==typeof Symbol&&Symbol.iterator,e=n&&t[n],r=0;if(e)return e.call(t);if(t&&"number"==typeof t.length)return{next:function(){return t&&r>=t.length&&(t=void 0),{value:t&&t[r++],done:!t}}};throw new TypeError(n?"Object is not iterable.":"Symbol.iterator is not defined.")}(t),e={},r("next"),r("throw"),r("return"),e[Symbol.asyncIterator]=function(){return this},e);function r(o){e[o]=t[o]&&function(i){return new Promise(function(a,l){!function s(o,i,a,l){Promise.resolve(l).then(function(u){o({value:u,done:a})},i)}(a,l,(i=t[o](i)).done,i.value)})}}}const A_=t=>t&&"number"==typeof t.length&&"function"!=typeof t;function R_(t){return ae(t?.then)}function $_(t){return ae(t[Ky])}function F_(t){return Symbol.asyncIterator&&ae(t?.[Symbol.asyncIterator])}function O_(t){return new TypeError(`You provided ${null!==t&&"object"==typeof t?"an invalid object":`'${t}'`} where a stream was expected. You can provide an Observable, Promise, ReadableStream, Array, AsyncIterable, or Iterable.`)}const M_=function NL(){return"function"==typeof Symbol&&Symbol.iterator?Symbol.iterator:"@@iterator"}();function P_(t){return ae(t?.[M_])}function L_(t){return _L(this,arguments,function*(){const e=t.getReader();try{for(;;){const{value:r,done:s}=yield oa(e.read());if(s)return yield oa(void 0);yield yield oa(r)}}finally{e.releaseLock()}})}function B_(t){return ae(t?.getReader)}function fo(t){if(t instanceof Un)return t;if(null!=t){if($_(t))return function TL(t){return new Un(n=>{const e=t[Ky]();if(ae(e.subscribe))return e.subscribe(n);throw new TypeError("Provided object does not correctly implement Symbol.observable")})}(t);if(A_(t))return function kL(t){return new Un(n=>{for(let e=0;e<t.length&&!n.closed;e++)n.next(t[e]);n.complete()})}(t);if(R_(t))return function AL(t){return new Un(n=>{t.then(e=>{n.closed||(n.next(e),n.complete())},e=>n.error(e)).then(null,hr)})}(t);if(F_(t))return z_(t);if(P_(t))return function RL(t){return new Un(n=>{for(const e of t)if(n.next(e),n.closed)return;n.complete()})}(t);if(B_(t))return function $L(t){return z_(L_(t))}(t)}throw O_(t)}function z_(t){return new Un(n=>{(function FL(t,n){var e,r,s,o;return function IL(t,n,e,r){return new(e||(e=Promise))(function(o,i){function a(c){try{u(r.next(c))}catch(d){i(d)}}function l(c){try{u(r.throw(c))}catch(d){i(d)}}function u(c){c.done?o(c.value):function s(o){return o instanceof e?o:new e(function(i){i(o)})}(c.value).then(a,l)}u((r=r.apply(t,n||[])).next())})}(this,void 0,void 0,function*(){try{for(e=SL(t);!(r=yield e.next()).done;)if(n.next(r.value),n.closed)return}catch(i){s={error:i}}finally{try{r&&!r.done&&(o=e.return)&&(yield o.call(e))}finally{if(s)throw s.error}}n.complete()})})(t,n).catch(e=>n.error(e))})}function Lo(t,n,e,r=0,s=!1){const o=n.schedule(function(){e(),s?t.add(this.schedule(null,r)):this.unsubscribe()},r);if(t.add(o),!s)return o}function fr(t,n,e=1/0){return ae(n)?fr((r,s)=>It((o,i)=>n(r,o,s,i))(fo(t(r,s))),e):("number"==typeof n&&(e=n),nr((r,s)=>function OL(t,n,e,r,s,o,i,a){const l=[];let u=0,c=0,d=!1;const h=()=>{d&&!l.length&&!u&&n.complete()},f=m=>u<r?p(m):l.push(m),p=m=>{o&&n.next(m),u++;let g=!1;fo(e(m,c++)).subscribe(rr(n,y=>{s?.(y),o?f(y):n.next(y)},()=>{g=!0},void 0,()=>{if(g)try{for(u--;l.length&&u<r;){const y=l.shift();i?Lo(n,i,()=>p(y)):p(y)}h()}catch(y){n.error(y)}}))};return t.subscribe(rr(n,f,()=>{d=!0,h()})),()=>{a?.()}}(r,s,t,e)))}function sl(t=1/0){return fr(sa,t)}const Bo=new Un(t=>t.complete());function Yy(t){return t[t.length-1]}function Ku(t){return function PL(t){return t&&ae(t.schedule)}(Yy(t))?t.pop():void 0}function V_(t,n=0){return nr((e,r)=>{e.subscribe(rr(r,s=>Lo(r,t,()=>r.next(s),n),()=>Lo(r,t,()=>r.complete(),n),s=>Lo(r,t,()=>r.error(s),n)))})}function U_(t,n=0){return nr((e,r)=>{r.add(t.schedule(()=>e.subscribe(r),n))})}function W_(t,n){if(!t)throw new Error("Iterable cannot be null");return new Un(e=>{Lo(e,n,()=>{const r=t[Symbol.asyncIterator]();Lo(e,n,()=>{r.next().then(s=>{s.done?e.complete():e.next(s.value)})},0,!0)})})}function Wn(t,n){return n?function GL(t,n){if(null!=t){if($_(t))return function zL(t,n){return fo(t).pipe(U_(n),V_(n))}(t,n);if(A_(t))return function UL(t,n){return new Un(e=>{let r=0;return n.schedule(function(){r===t.length?e.complete():(e.next(t[r++]),e.closed||this.schedule())})})}(t,n);if(R_(t))return function VL(t,n){return fo(t).pipe(U_(n),V_(n))}(t,n);if(F_(t))return W_(t,n);if(P_(t))return function WL(t,n){return new Un(e=>{let r;return Lo(e,n,()=>{r=t[M_](),Lo(e,n,()=>{let s,o;try{({value:s,done:o}=r.next())}catch(i){return void e.error(i)}o?e.complete():e.next(s)},0,!0)}),()=>ae(r?.return)&&r.return()})}(t,n);if(B_(t))return function HL(t,n){return W_(L_(t),n)}(t,n)}throw O_(t)}(t,n):fo(t)}function Zy(t,n,...e){if(!0===n)return void t();if(!1===n)return;const r=new qu({next:()=>{r.unsubscribe(),t()}});return n(...e).subscribe(r)}function Ht(t){for(let n in t)if(t[n]===Ht)return n;throw Error("Could not find renamed property on target object.")}function Gt(t){if("string"==typeof t)return t;if(Array.isArray(t))return"["+t.map(Gt).join(", ")+"]";if(null==t)return""+t;if(t.overriddenName)return`${t.overriddenName}`;if(t.name)return`${t.name}`;const n=t.toString();if(null==n)return""+n;const e=n.indexOf("\n");return-1===e?n:n.substring(0,e)}function Jy(t,n){return null==t||""===t?null===n?"":n:null==n||""===n?t:t+" "+n}const KL=Ht({__forward_ref__:Ht});function eb(t){return t.__forward_ref__=eb,t.toString=function(){return Gt(this())},t}function Ge(t){return function tb(t){return"function"==typeof t&&t.hasOwnProperty(KL)&&t.__forward_ref__===eb}(t)?t():t}function nb(t){return t&&!!t.\u0275providers}class xe extends Error{constructor(n,e){super(function lf(t,n){return`NG0${Math.abs(t)}${n?": "+n.trim():""}`}(n,e)),this.code=n}}function nt(t){return"string"==typeof t?t:null==t?"":String(t)}function uf(t,n){throw new xe(-201,!1)}function ts(t,n){null==t&&function Ft(t,n,e,r){throw new Error(`ASSERTION ERROR: ${t}`+(null==r?"":` [Expected=> ${e} ${r} ${n} <=Actual]`))}(n,t,null,"!=")}function ht(t){return{token:t.token,providedIn:t.providedIn||null,factory:t.factory,value:void 0}}function vi(t){return{providers:t.providers||[],imports:t.imports||[]}}function cf(t){return H_(t,df)||H_(t,j_)}function H_(t,n){return t.hasOwnProperty(n)?t[n]:null}function G_(t){return t&&(t.hasOwnProperty(rb)||t.hasOwnProperty(rB))?t[rb]:null}const df=Ht({\u0275prov:Ht}),rb=Ht({\u0275inj:Ht}),j_=Ht({ngInjectableDef:Ht}),rB=Ht({ngInjectorDef:Ht});var je=(()=>((je=je||{})[je.Default=0]="Default",je[je.Host=1]="Host",je[je.Self=2]="Self",je[je.SkipSelf=4]="SkipSelf",je[je.Optional=8]="Optional",je))();let sb;function xs(t){const n=sb;return sb=t,n}function q_(t,n,e){const r=cf(t);return r&&"root"==r.providedIn?void 0===r.value?r.value=r.factory():r.value:e&je.Optional?null:void 0!==n?n:void uf(Gt(t))}const Yt=(()=>typeof globalThis<"u"&&globalThis||typeof global<"u"&&global||typeof window<"u"&&window||typeof self<"u"&&typeof WorkerGlobalScope<"u"&&self instanceof WorkerGlobalScope&&self)(),Xu={},ob="__NG_DI_FLAG__",hf="ngTempTokenPath",iB=/\n/gm,K_="__source";let Yu;function ol(t){const n=Yu;return Yu=t,n}function lB(t,n=je.Default){if(void 0===Yu)throw new xe(-203,!1);return null===Yu?q_(t,void 0,n):Yu.get(t,n&je.Optional?null:void 0,n)}function Ue(t,n=je.Default){return(function sB(){return sb}()||lB)(Ge(t),n)}function jt(t,n=je.Default){return Ue(t,ff(n))}function ff(t){return typeof t>"u"||"number"==typeof t?t:0|(t.optional&&8)|(t.host&&1)|(t.self&&2)|(t.skipSelf&&4)}function ib(t){const n=[];for(let e=0;e<t.length;e++){const r=Ge(t[e]);if(Array.isArray(r)){if(0===r.length)throw new xe(900,!1);let s,o=je.Default;for(let i=0;i<r.length;i++){const a=r[i],l=uB(a);"number"==typeof l?-1===l?s=a.token:o|=l:s=a}n.push(Ue(s,o))}else n.push(Ue(r))}return n}function Zu(t,n){return t[ob]=n,t.prototype[ob]=n,t}function uB(t){return t[ob]}function xi(t){return{toString:t}.toString()}var Hs=(()=>((Hs=Hs||{})[Hs.OnPush=0]="OnPush",Hs[Hs.Default=1]="Default",Hs))(),po=(()=>{return(t=po||(po={}))[t.Emulated=0]="Emulated",t[t.None=2]="None",t[t.ShadowDom=3]="ShadowDom",po;var t})();const Vo={},kt=[],pf=Ht({\u0275cmp:Ht}),ab=Ht({\u0275dir:Ht}),lb=Ht({\u0275pipe:Ht}),Y_=Ht({\u0275mod:Ht}),Uo=Ht({\u0275fac:Ht}),Qu=Ht({__NG_ELEMENT_ID__:Ht});let hB=0;function il(t){return xi(()=>{const e=!0===t.standalone,r={},s={type:t.type,providersResolver:null,decls:t.decls,vars:t.vars,factory:null,template:t.template||null,consts:t.consts||null,ngContentSelectors:t.ngContentSelectors,hostBindings:t.hostBindings||null,hostVars:t.hostVars||0,hostAttrs:t.hostAttrs||null,contentQueries:t.contentQueries||null,declaredInputs:r,inputs:null,outputs:null,exportAs:t.exportAs||null,onPush:t.changeDetection===Hs.OnPush,directiveDefs:null,pipeDefs:null,standalone:e,dependencies:e&&t.dependencies||null,getStandaloneInjector:null,selectors:t.selectors||kt,viewQuery:t.viewQuery||null,features:t.features||null,data:t.data||{},encapsulation:t.encapsulation||po.Emulated,id:"c"+hB++,styles:t.styles||kt,_:null,setInput:null,schemas:t.schemas||null,tView:null,findHostDirectiveDefs:null,hostDirectives:null},o=t.dependencies,i=t.features;return s.inputs=J_(t.inputs,r),s.outputs=J_(t.outputs),i&&i.forEach(a=>a(s)),s.directiveDefs=o?()=>("function"==typeof o?o():o).map(Z_).filter(Q_):null,s.pipeDefs=o?()=>("function"==typeof o?o():o).map(kr).filter(Q_):null,s})}function Z_(t){return Ot(t)||br(t)}function Q_(t){return null!==t}function ia(t){return xi(()=>({type:t.type,bootstrap:t.bootstrap||kt,declarations:t.declarations||kt,imports:t.imports||kt,exports:t.exports||kt,transitiveCompileScopes:null,schemas:t.schemas||null,id:t.id||null}))}function J_(t,n){if(null==t)return Vo;const e={};for(const r in t)if(t.hasOwnProperty(r)){let s=t[r],o=s;Array.isArray(s)&&(o=s[1],s=s[0]),e[s]=r,n&&(n[s]=o)}return e}const Tr=il;function Ot(t){return t[pf]||null}function br(t){return t[ab]||null}function kr(t){return t[lb]||null}function ns(t,n){const e=t[Y_]||null;if(!e&&!0===n)throw new Error(`Type ${Gt(t)} does not have '\u0275mod' property.`);return e}function Ur(t){return Array.isArray(t)&&"object"==typeof t[1]}function js(t){return Array.isArray(t)&&!0===t[1]}function db(t){return 0!=(4&t.flags)}function bf(t){return t.componentOffset>-1}function vf(t){return 1==(1&t.flags)}function qs(t){return null!==t.template}function bB(t){return 0!=(256&t[2])}function da(t,n){return t.hasOwnProperty(Uo)?t[Uo]:null}class wB{constructor(n,e,r){this.previousValue=n,this.currentValue=e,this.firstChange=r}isFirstChange(){return this.firstChange}}function ha(){return nS}function nS(t){return t.type.prototype.ngOnChanges&&(t.setInput=IB),CB}function CB(){const t=sS(this),n=t?.current;if(n){const e=t.previous;if(e===Vo)t.previous=n;else for(let r in n)e[r]=n[r];t.current=null,this.ngOnChanges(n)}}function IB(t,n,e,r){const s=this.declaredInputs[e],o=sS(t)||function DB(t,n){return t[rS]=n}(t,{previous:Vo,current:null}),i=o.current||(o.current={}),a=o.previous,l=a[s];i[s]=new wB(l&&l.currentValue,n,a===Vo),t[r]=n}ha.ngInherit=!0;const rS="__ngSimpleChanges__";function sS(t){return t[rS]||null}function An(t){for(;Array.isArray(t);)t=t[0];return t}function xf(t,n){return An(n[t])}function ss(t,n){return An(n[t.index])}function gb(t,n){return t.data[n]}function os(t,n){const e=n[t];return Ur(e)?e:e[0]}function wf(t){return 64==(64&t[2])}function wi(t,n){return null==n?null:t[n]}function oS(t){t[18]=0}function yb(t,n){t[5]+=n;let e=t,r=t[3];for(;null!==r&&(1===n&&1===e[5]||-1===n&&0===e[5]);)r[5]+=n,e=r,r=r[3]}const Je={lFrame:yS(null),bindingsEnabled:!0};function aS(){return Je.bindingsEnabled}function oe(){return Je.lFrame.lView}function St(){return Je.lFrame.tView}function pr(){let t=cS();for(;null!==t&&64===t.type;)t=t.parent;return t}function cS(){return Je.lFrame.currentTNode}function mo(t,n){const e=Je.lFrame;e.currentTNode=t,e.isParent=n}function bb(){return Je.lFrame.isParent}function hl(){return Je.lFrame.bindingIndex++}function BB(t,n){const e=Je.lFrame;e.bindingIndex=e.bindingRootIndex=t,xb(n)}function xb(t){Je.lFrame.currentDirectiveIndex=t}function pS(){return Je.lFrame.currentQueryIndex}function Cb(t){Je.lFrame.currentQueryIndex=t}function VB(t){const n=t[1];return 2===n.type?n.declTNode:1===n.type?t[6]:null}function mS(t,n,e){if(e&je.SkipSelf){let s=n,o=t;for(;!(s=s.parent,null!==s||e&je.Host||(s=VB(o),null===s||(o=o[15],10&s.type))););if(null===s)return!1;n=s,t=o}const r=Je.lFrame=gS();return r.currentTNode=n,r.lView=t,!0}function Ib(t){const n=gS(),e=t[1];Je.lFrame=n,n.currentTNode=e.firstChild,n.lView=t,n.tView=e,n.contextLView=t,n.bindingIndex=e.bindingStartIndex,n.inI18n=!1}function gS(){const t=Je.lFrame,n=null===t?null:t.child;return null===n?yS(t):n}function yS(t){const n={currentTNode:null,isParent:!0,lView:null,tView:null,selectedIndex:-1,contextLView:null,elementDepthCount:0,currentNamespace:null,currentDirectiveIndex:-1,bindingRootIndex:-1,bindingIndex:-1,currentQueryIndex:0,parent:t,child:null,inI18n:!1};return null!==t&&(t.child=n),n}function bS(){const t=Je.lFrame;return Je.lFrame=t.parent,t.currentTNode=null,t.lView=null,t}const vS=bS;function Db(){const t=bS();t.isParent=!0,t.tView=null,t.selectedIndex=-1,t.contextLView=null,t.elementDepthCount=0,t.currentDirectiveIndex=-1,t.currentNamespace=null,t.bindingRootIndex=-1,t.bindingIndex=-1,t.currentQueryIndex=0}function Rr(){return Je.lFrame.selectedIndex}function fa(t){Je.lFrame.selectedIndex=t}function Cf(t,n){for(let e=n.directiveStart,r=n.directiveEnd;e<r;e++){const o=t.data[e].type.prototype,{ngAfterContentInit:i,ngAfterContentChecked:a,ngAfterViewInit:l,ngAfterViewChecked:u,ngOnDestroy:c}=o;i&&(t.contentHooks||(t.contentHooks=[])).push(-e,i),a&&((t.contentHooks||(t.contentHooks=[])).push(e,a),(t.contentCheckHooks||(t.contentCheckHooks=[])).push(e,a)),l&&(t.viewHooks||(t.viewHooks=[])).push(-e,l),u&&((t.viewHooks||(t.viewHooks=[])).push(e,u),(t.viewCheckHooks||(t.viewCheckHooks=[])).push(e,u)),null!=c&&(t.destroyHooks||(t.destroyHooks=[])).push(e,c)}}function If(t,n,e){xS(t,n,3,e)}function Df(t,n,e,r){(3&t[2])===e&&xS(t,n,e,r)}function _b(t,n){let e=t[2];(3&e)===n&&(e&=2047,e+=1,t[2]=e)}function xS(t,n,e,r){const o=r??-1,i=n.length-1;let a=0;for(let l=void 0!==r?65535&t[18]:0;l<i;l++)if("number"==typeof n[l+1]){if(a=n[l],null!=r&&a>=r)break}else n[l]<0&&(t[18]+=65536),(a<o||-1==o)&&(YB(t,e,n,l),t[18]=(4294901760&t[18])+l+2),l++}function YB(t,n,e,r){const s=e[r]<0,o=e[r+1],a=t[s?-e[r]:e[r]];if(s){if(t[2]>>11<t[18]>>16&&(3&t[2])===n){t[2]+=2048;try{o.call(a)}finally{}}}else try{o.call(a)}finally{}}class sc{constructor(n,e,r){this.factory=n,this.resolving=!1,this.canSeeViewProviders=e,this.injectImpl=r}}function Eb(t,n,e){let r=0;for(;r<e.length;){const s=e[r];if("number"==typeof s){if(0!==s)break;r++;const o=e[r++],i=e[r++],a=e[r++];t.setAttribute(n,i,a,o)}else{const o=s,i=e[++r];CS(o)?t.setProperty(n,o,i):t.setAttribute(n,o,i),r++}}return r}function wS(t){return 3===t||4===t||6===t}function CS(t){return 64===t.charCodeAt(0)}function ic(t,n){if(null!==n&&0!==n.length)if(null===t||0===t.length)t=n.slice();else{let e=-1;for(let r=0;r<n.length;r++){const s=n[r];"number"==typeof s?e=s:0===e||IS(t,e,s,null,-1===e||2===e?n[++r]:null)}}return t}function IS(t,n,e,r,s){let o=0,i=t.length;if(-1===n)i=-1;else for(;o<t.length;){const a=t[o++];if("number"==typeof a){if(a===n){i=-1;break}if(a>n){i=o-1;break}}}for(;o<t.length;){const a=t[o];if("number"==typeof a)break;if(a===e){if(null===r)return void(null!==s&&(t[o+1]=s));if(r===t[o+1])return void(t[o+2]=s)}o++,null!==r&&o++,null!==s&&o++}-1!==i&&(t.splice(i,0,n),o=i+1),t.splice(o++,0,e),null!==r&&t.splice(o++,0,r),null!==s&&t.splice(o++,0,s)}function DS(t){return-1!==t}function fl(t){return 32767&t}function pl(t,n){let e=function tz(t){return t>>16}(t),r=n;for(;e>0;)r=r[15],e--;return r}let Nb=!0;function _f(t){const n=Nb;return Nb=t,n}let nz=0;const go={};function Sf(t,n){const e=kb(t,n);if(-1!==e)return e;const r=n[1];r.firstCreatePass&&(t.injectorIndex=n.length,Tb(r.data,t),Tb(n,null),Tb(r.blueprint,null));const s=Ef(t,n),o=t.injectorIndex;if(DS(s)){const i=fl(s),a=pl(s,n),l=a[1].data;for(let u=0;u<8;u++)n[o+u]=a[i+u]|l[i+u]}return n[o+8]=s,o}function Tb(t,n){t.push(0,0,0,0,0,0,0,0,n)}function kb(t,n){return-1===t.injectorIndex||t.parent&&t.parent.injectorIndex===t.injectorIndex||null===n[t.injectorIndex+8]?-1:t.injectorIndex}function Ef(t,n){if(t.parent&&-1!==t.parent.injectorIndex)return t.parent.injectorIndex;let e=0,r=null,s=n;for(;null!==s;){if(r=$S(s),null===r)return-1;if(e++,s=s[15],-1!==r.injectorIndex)return r.injectorIndex|e<<16}return-1}function Ab(t,n,e){!function rz(t,n,e){let r;"string"==typeof e?r=e.charCodeAt(0)||0:e.hasOwnProperty(Qu)&&(r=e[Qu]),null==r&&(r=e[Qu]=nz++);const s=255&r;n.data[t+(s>>5)]|=1<<s}(t,n,e)}function ES(t,n,e){if(e&je.Optional||void 0!==t)return t;uf()}function NS(t,n,e,r){if(e&je.Optional&&void 0===r&&(r=null),0==(e&(je.Self|je.Host))){const s=t[9],o=xs(void 0);try{return s?s.get(n,r,e&je.Optional):q_(n,r,e&je.Optional)}finally{xs(o)}}return ES(r,0,e)}function TS(t,n,e,r=je.Default,s){if(null!==t){if(1024&n[2]){const i=function uz(t,n,e,r,s){let o=t,i=n;for(;null!==o&&null!==i&&1024&i[2]&&!(256&i[2]);){const a=kS(o,i,e,r|je.Self,go);if(a!==go)return a;let l=o.parent;if(!l){const u=i[21];if(u){const c=u.get(e,go,r);if(c!==go)return c}l=$S(i),i=i[15]}o=l}return s}(t,n,e,r,go);if(i!==go)return i}const o=kS(t,n,e,r,go);if(o!==go)return o}return NS(n,e,r,s)}function kS(t,n,e,r,s){const o=function iz(t){if("string"==typeof t)return t.charCodeAt(0)||0;const n=t.hasOwnProperty(Qu)?t[Qu]:void 0;return"number"==typeof n?n>=0?255&n:az:n}(e);if("function"==typeof o){if(!mS(n,t,r))return r&je.Host?ES(s,0,r):NS(n,e,r,s);try{const i=o(r);if(null!=i||r&je.Optional)return i;uf()}finally{vS()}}else if("number"==typeof o){let i=null,a=kb(t,n),l=-1,u=r&je.Host?n[16][6]:null;for((-1===a||r&je.SkipSelf)&&(l=-1===a?Ef(t,n):n[a+8],-1!==l&&RS(r,!1)?(i=n[1],a=fl(l),n=pl(l,n)):a=-1);-1!==a;){const c=n[1];if(AS(o,a,c.data)){const d=oz(a,n,e,i,r,u);if(d!==go)return d}l=n[a+8],-1!==l&&RS(r,n[1].data[a+8]===u)&&AS(o,a,n)?(i=c,a=fl(l),n=pl(l,n)):a=-1}}return s}function oz(t,n,e,r,s,o){const i=n[1],a=i.data[t+8],c=Nf(a,i,e,null==r?bf(a)&&Nb:r!=i&&0!=(3&a.type),s&je.Host&&o===a);return null!==c?ml(n,i,c,a):go}function Nf(t,n,e,r,s){const o=t.providerIndexes,i=n.data,a=1048575&o,l=t.directiveStart,c=o>>20,h=s?a+c:t.directiveEnd;for(let f=r?a:a+c;f<h;f++){const p=i[f];if(f<l&&e===p||f>=l&&p.type===e)return f}if(s){const f=i[l];if(f&&qs(f)&&f.type===e)return l}return null}function ml(t,n,e,r){let s=t[e];const o=n.data;if(function ZB(t){return t instanceof sc}(s)){const i=s;i.resolving&&function XL(t,n){const e=n?`. Dependency path: ${n.join(" > ")} > ${t}`:"";throw new xe(-200,`Circular dependency in DI detected for ${t}${e}`)}(function $t(t){return"function"==typeof t?t.name||t.toString():"object"==typeof t&&null!=t&&"function"==typeof t.type?t.type.name||t.type.toString():nt(t)}(o[e]));const a=_f(i.canSeeViewProviders);i.resolving=!0;const l=i.injectImpl?xs(i.injectImpl):null;mS(t,r,je.Default);try{s=t[e]=i.factory(void 0,o,t,r),n.firstCreatePass&&e>=r.directiveStart&&function XB(t,n,e){const{ngOnChanges:r,ngOnInit:s,ngDoCheck:o}=n.type.prototype;if(r){const i=nS(n);(e.preOrderHooks||(e.preOrderHooks=[])).push(t,i),(e.preOrderCheckHooks||(e.preOrderCheckHooks=[])).push(t,i)}s&&(e.preOrderHooks||(e.preOrderHooks=[])).push(0-t,s),o&&((e.preOrderHooks||(e.preOrderHooks=[])).push(t,o),(e.preOrderCheckHooks||(e.preOrderCheckHooks=[])).push(t,o))}(e,o[e],n)}finally{null!==l&&xs(l),_f(a),i.resolving=!1,vS()}}return s}function AS(t,n,e){return!!(e[n+(t>>5)]&1<<t)}function RS(t,n){return!(t&je.Self||t&je.Host&&n)}class gl{constructor(n,e){this._tNode=n,this._lView=e}get(n,e,r){return TS(this._tNode,this._lView,n,ff(r),e)}}function az(){return new gl(pr(),oe())}function $S(t){const n=t[1],e=n.type;return 2===e?n.declTNode:1===e?t[6]:null}const bl="__parameters__";function xl(t,n,e){return xi(()=>{const r=function $b(t){return function(...e){if(t){const r=t(...e);for(const s in r)this[s]=r[s]}}}(n);function s(...o){if(this instanceof s)return r.apply(this,o),this;const i=new s(...o);return a.annotation=i,a;function a(l,u,c){const d=l.hasOwnProperty(bl)?l[bl]:Object.defineProperty(l,bl,{value:[]})[bl];for(;d.length<=c;)d.push(null);return(d[c]=d[c]||[]).push(i),l}}return e&&(s.prototype=Object.create(e.prototype)),s.prototype.ngMetadataName=t,s.annotationCls=s,s})}class qe{constructor(n,e){this._desc=n,this.ngMetadataName="InjectionToken",this.\u0275prov=void 0,"number"==typeof e?this.__NG_ELEMENT_ID__=e:void 0!==e&&(this.\u0275prov=ht({token:this,providedIn:e.providedIn||"root",factory:e.factory}))}get multi(){return this}toString(){return`InjectionToken ${this._desc}`}}function is(t,n){void 0===n&&(n=t);for(let e=0;e<t.length;e++){let r=t[e];Array.isArray(r)?(n===t&&(n=t.slice(0,e)),is(r,n)):n!==t&&n.push(r)}return n}function pa(t,n){t.forEach(e=>Array.isArray(e)?pa(e,n):n(e))}function OS(t,n,e){n>=t.length?t.push(e):t.splice(n,0,e)}function kf(t,n){return n>=t.length-1?t.pop():t.splice(n,1)[0]}function as(t,n,e){let r=wl(t,n);return r>=0?t[1|r]=e:(r=~r,function fz(t,n,e,r){let s=t.length;if(s==n)t.push(e,r);else if(1===s)t.push(r,t[0]),t[0]=e;else{for(s--,t.push(t[s-1],t[s]);s>n;)t[s]=t[s-2],s--;t[n]=e,t[n+1]=r}}(t,r,n,e)),r}function Ob(t,n){const e=wl(t,n);if(e>=0)return t[1|e]}function wl(t,n){return function LS(t,n,e){let r=0,s=t.length>>e;for(;s!==r;){const o=r+(s-r>>1),i=t[o<<e];if(n===i)return o<<e;i>n?s=o:r=o+1}return~(s<<e)}(t,n,1)}const cc=Zu(xl("Optional"),8),dc=Zu(xl("SkipSelf"),4);var Wr=(()=>((Wr=Wr||{})[Wr.Important=1]="Important",Wr[Wr.DashCase=2]="DashCase",Wr))();const Vb=new Map;let Oz=0;const Wb="__ngContext__";function wr(t,n){Ur(n)?(t[Wb]=n[20],function Pz(t){Vb.set(t[20],t)}(n)):t[Wb]=n}function Gb(t,n){return undefined(t,n)}function mc(t){const n=t[3];return js(n)?n[3]:n}function jb(t){return o1(t[13])}function qb(t){return o1(t[4])}function o1(t){for(;null!==t&&!js(t);)t=t[4];return t}function Il(t,n,e,r,s){if(null!=r){let o,i=!1;js(r)?o=r:Ur(r)&&(i=!0,r=r[0]);const a=An(r);0===t&&null!==e?null==s?d1(n,e,a):ma(n,e,a,s||null,!0):1===t&&null!==e?ma(n,e,a,s||null,!0):2===t?function ev(t,n,e){const r=Ff(t,n);r&&function s3(t,n,e,r){t.removeChild(n,e,r)}(t,r,n,e)}(n,a,i):3===t&&n.destroyNode(a),null!=o&&function a3(t,n,e,r,s){const o=e[7];o!==An(e)&&Il(n,t,r,o,s);for(let a=10;a<e.length;a++){const l=e[a];gc(l[1],l,t,n,r,o)}}(n,t,o,e,s)}}function Xb(t,n,e){return t.createElement(n,e)}function a1(t,n){const e=t[9],r=e.indexOf(n),s=n[3];512&n[2]&&(n[2]&=-513,yb(s,-1)),e.splice(r,1)}function Yb(t,n){if(t.length<=10)return;const e=10+n,r=t[e];if(r){const s=r[17];null!==s&&s!==t&&a1(s,r),n>0&&(t[e-1][4]=r[4]);const o=kf(t,10+n);!function Yz(t,n){gc(t,n,n[11],2,null,null),n[0]=null,n[6]=null}(r[1],r);const i=o[19];null!==i&&i.detachView(o[1]),r[3]=null,r[4]=null,r[2]&=-65}return r}function l1(t,n){if(!(128&n[2])){const e=n[11];e.destroyNode&&gc(t,n,e,3,null,null),function Jz(t){let n=t[13];if(!n)return Zb(t[1],t);for(;n;){let e=null;if(Ur(n))e=n[13];else{const r=n[10];r&&(e=r)}if(!e){for(;n&&!n[4]&&n!==t;)Ur(n)&&Zb(n[1],n),n=n[3];null===n&&(n=t),Ur(n)&&Zb(n[1],n),e=n&&n[4]}n=e}}(n)}}function Zb(t,n){if(!(128&n[2])){n[2]&=-65,n[2]|=128,function r3(t,n){let e;if(null!=t&&null!=(e=t.destroyHooks))for(let r=0;r<e.length;r+=2){const s=n[e[r]];if(!(s instanceof sc)){const o=e[r+1];if(Array.isArray(o))for(let i=0;i<o.length;i+=2){const a=s[o[i]],l=o[i+1];try{l.call(a)}finally{}}else try{o.call(s)}finally{}}}}(t,n),function n3(t,n){const e=t.cleanup,r=n[7];let s=-1;if(null!==e)for(let o=0;o<e.length-1;o+=2)if("string"==typeof e[o]){const i=e[o+1],a="function"==typeof i?i(n):An(n[i]),l=r[s=e[o+2]],u=e[o+3];"boolean"==typeof u?a.removeEventListener(e[o],l,u):u>=0?r[s=u]():r[s=-u].unsubscribe(),o+=2}else{const i=r[s=e[o+1]];e[o].call(i)}if(null!==r){for(let o=s+1;o<r.length;o++)(0,r[o])();n[7]=null}}(t,n),1===n[1].type&&n[11].destroy();const e=n[17];if(null!==e&&js(n[3])){e!==n[3]&&a1(e,n);const r=n[19];null!==r&&r.detachView(t)}!function Lz(t){Vb.delete(t[20])}(n)}}function u1(t,n,e){return function c1(t,n,e){let r=n;for(;null!==r&&40&r.type;)r=(n=r).parent;if(null===r)return e[0];{const{componentOffset:s}=r;if(s>-1){const{encapsulation:o}=t.data[r.directiveStart+s];if(o===po.None||o===po.Emulated)return null}return ss(r,e)}}(t,n.parent,e)}function ma(t,n,e,r,s){t.insertBefore(n,e,r,s)}function d1(t,n,e){t.appendChild(n,e)}function h1(t,n,e,r,s){null!==r?ma(t,n,e,r,s):d1(t,n,e)}function Ff(t,n){return t.parentNode(n)}let rv,m1=function p1(t,n,e){return 40&t.type?ss(t,e):null};function Of(t,n,e,r){const s=u1(t,r,n),o=n[11],a=function f1(t,n,e){return m1(t,n,e)}(r.parent||n[6],r,n);if(null!=s)if(Array.isArray(e))for(let l=0;l<e.length;l++)h1(o,s,e[l],a,!1);else h1(o,s,e,a,!1)}function Mf(t,n){if(null!==n){const e=n.type;if(3&e)return ss(n,t);if(4&e)return Jb(-1,t[n.index]);if(8&e){const r=n.child;if(null!==r)return Mf(t,r);{const s=t[n.index];return js(s)?Jb(-1,s):An(s)}}if(32&e)return Gb(n,t)()||An(t[n.index]);{const r=y1(t,n);return null!==r?Array.isArray(r)?r[0]:Mf(mc(t[16]),r):Mf(t,n.next)}}return null}function y1(t,n){return null!==n?t[16][6].projection[n.projection]:null}function Jb(t,n){const e=10+t+1;if(e<n.length){const r=n[e],s=r[1].firstChild;if(null!==s)return Mf(r,s)}return n[7]}function tv(t,n,e,r,s,o,i){for(;null!=e;){const a=r[e.index],l=e.type;if(i&&0===n&&(a&&wr(An(a),r),e.flags|=2),32!=(32&e.flags))if(8&l)tv(t,n,e.child,r,s,o,!1),Il(n,t,s,a,o);else if(32&l){const u=Gb(e,r);let c;for(;c=u();)Il(n,t,s,c,o);Il(n,t,s,a,o)}else 16&l?b1(t,n,r,e,s,o):Il(n,t,s,a,o);e=i?e.projectionNext:e.next}}function gc(t,n,e,r,s,o){tv(e,r,t.firstChild,n,s,o,!1)}function b1(t,n,e,r,s,o){const i=e[16],l=i[6].projection[r.projection];if(Array.isArray(l))for(let u=0;u<l.length;u++)Il(n,t,s,l[u],o);else tv(t,n,l,i[3],s,o,!0)}function v1(t,n,e){""===e?t.removeAttribute(n,"class"):t.setAttribute(n,"class",e)}function x1(t,n,e){const{mergedAttrs:r,classes:s,styles:o}=e;null!==r&&Eb(t,n,r),null!==s&&v1(t,n,s),null!==o&&function u3(t,n,e){t.setAttribute(n,"style",e)}(t,n,o)}class _1{constructor(n){this.changingThisBreaksApplicationSecurity=n}toString(){return`SafeValue must use [property]=binding: ${this.changingThisBreaksApplicationSecurity} (see https://g.co/ng/security#xss)`}}function Ii(t){return t instanceof _1?t.changingThisBreaksApplicationSecurity:t}const I3=/^(?:(?:https?|mailto|data|ftp|tel|file|sms):|[^&:/?#]*(?:[/?#]|$))/gi;var Rn=(()=>((Rn=Rn||{})[Rn.NONE=0]="NONE",Rn[Rn.HTML=1]="HTML",Rn[Rn.STYLE=2]="STYLE",Rn[Rn.SCRIPT=3]="SCRIPT",Rn[Rn.URL=4]="URL",Rn[Rn.RESOURCE_URL=5]="RESOURCE_URL",Rn))();function uv(t){const n=function vc(){const t=oe();return t&&t[12]}();return n?n.sanitize(Rn.URL,t)||"":function yc(t,n){const e=function v3(t){return t instanceof _1&&t.getTypeName()||null}(t);if(null!=e&&e!==n){if("ResourceURL"===e&&"URL"===n)return!0;throw new Error(`Required a safe ${n}, got a ${e} (see https://g.co/ng/security#xss)`)}return e===n}(t,"URL")?Ii(t):function ov(t){return(t=String(t)).match(I3)?t:"unsafe:"+t}(nt(t))}const zf=new qe("ENVIRONMENT_INITIALIZER"),F1=new qe("INJECTOR",-1),O1=new qe("INJECTOR_DEF_TYPES");class M1{get(n,e=Xu){if(e===Xu){const r=new Error(`NullInjectorError: No provider for ${Gt(n)}!`);throw r.name="NullInjectorError",r}return e}}function M3(...t){return{\u0275providers:P1(0,t),\u0275fromNgModule:!0}}function P1(t,...n){const e=[],r=new Set;let s;return pa(n,o=>{const i=o;cv(i,e,[],r)&&(s||(s=[]),s.push(i))}),void 0!==s&&L1(s,e),e}function L1(t,n){for(let e=0;e<t.length;e++){const{providers:s}=t[e];dv(s,o=>{n.push(o)})}}function cv(t,n,e,r){if(!(t=Ge(t)))return!1;let s=null,o=G_(t);const i=!o&&Ot(t);if(o||i){if(i&&!i.standalone)return!1;s=t}else{const l=t.ngModule;if(o=G_(l),!o)return!1;s=l}const a=r.has(s);if(i){if(a)return!1;if(r.add(s),i.dependencies){const l="function"==typeof i.dependencies?i.dependencies():i.dependencies;for(const u of l)cv(u,n,e,r)}}else{if(!o)return!1;{if(null!=o.imports&&!a){let u;r.add(s);try{pa(o.imports,c=>{cv(c,n,e,r)&&(u||(u=[]),u.push(c))})}finally{}void 0!==u&&L1(u,n)}if(!a){const u=da(s)||(()=>new s);n.push({provide:s,useFactory:u,deps:kt},{provide:O1,useValue:s,multi:!0},{provide:zf,useValue:()=>Ue(s),multi:!0})}const l=o.providers;null==l||a||dv(l,c=>{n.push(c)})}}return s!==t&&void 0!==t.providers}function dv(t,n){for(let e of t)nb(e)&&(e=e.\u0275providers),Array.isArray(e)?dv(e,n):n(e)}const P3=Ht({provide:String,useValue:Ht});function hv(t){return null!==t&&"object"==typeof t&&P3 in t}function ya(t){return"function"==typeof t}const fv=new qe("Set Injector scope."),Vf={},B3={};let pv;function Uf(){return void 0===pv&&(pv=new M1),pv}class Di{}class V1 extends Di{constructor(n,e,r,s){super(),this.parent=e,this.source=r,this.scopes=s,this.records=new Map,this._ngOnDestroyHooks=new Set,this._onDestroyHooks=[],this._destroyed=!1,gv(n,i=>this.processProvider(i)),this.records.set(F1,Dl(void 0,this)),s.has("environment")&&this.records.set(Di,Dl(void 0,this));const o=this.records.get(fv);null!=o&&"string"==typeof o.value&&this.scopes.add(o.value),this.injectorDefTypes=new Set(this.get(O1.multi,kt,je.Self))}get destroyed(){return this._destroyed}destroy(){this.assertNotDestroyed(),this._destroyed=!0;try{for(const n of this._ngOnDestroyHooks)n.ngOnDestroy();for(const n of this._onDestroyHooks)n()}finally{this.records.clear(),this._ngOnDestroyHooks.clear(),this.injectorDefTypes.clear(),this._onDestroyHooks.length=0}}onDestroy(n){this._onDestroyHooks.push(n)}runInContext(n){this.assertNotDestroyed();const e=ol(this),r=xs(void 0);try{return n()}finally{ol(e),xs(r)}}get(n,e=Xu,r=je.Default){this.assertNotDestroyed(),r=ff(r);const s=ol(this),o=xs(void 0);try{if(!(r&je.SkipSelf)){let a=this.records.get(n);if(void 0===a){const l=function H3(t){return"function"==typeof t||"object"==typeof t&&t instanceof qe}(n)&&cf(n);a=l&&this.injectableDefInScope(l)?Dl(mv(n),Vf):null,this.records.set(n,a)}if(null!=a)return this.hydrate(n,a)}return(r&je.Self?Uf():this.parent).get(n,e=r&je.Optional&&e===Xu?null:e)}catch(i){if("NullInjectorError"===i.name){if((i[hf]=i[hf]||[]).unshift(Gt(n)),s)throw i;return function cB(t,n,e,r){const s=t[hf];throw n[K_]&&s.unshift(n[K_]),t.message=function dB(t,n,e,r=null){t=t&&"\n"===t.charAt(0)&&"\u0275"==t.charAt(1)?t.slice(2):t;let s=Gt(n);if(Array.isArray(n))s=n.map(Gt).join(" -> ");else if("object"==typeof n){let o=[];for(let i in n)if(n.hasOwnProperty(i)){let a=n[i];o.push(i+":"+("string"==typeof a?JSON.stringify(a):Gt(a)))}s=`{${o.join(", ")}}`}return`${e}${r?"("+r+")":""}[${s}]: ${t.replace(iB,"\n  ")}`}("\n"+t.message,s,e,r),t.ngTokenPath=s,t[hf]=null,t}(i,n,"R3InjectorError",this.source)}throw i}finally{xs(o),ol(s)}}resolveInjectorInitializers(){const n=ol(this),e=xs(void 0);try{const r=this.get(zf.multi,kt,je.Self);for(const s of r)s()}finally{ol(n),xs(e)}}toString(){const n=[],e=this.records;for(const r of e.keys())n.push(Gt(r));return`R3Injector[${n.join(", ")}]`}assertNotDestroyed(){if(this._destroyed)throw new xe(205,!1)}processProvider(n){let e=ya(n=Ge(n))?n:Ge(n&&n.provide);const r=function V3(t){return hv(t)?Dl(void 0,t.useValue):Dl(function U1(t,n,e){let r;if(ya(t)){const s=Ge(t);return da(s)||mv(s)}if(hv(t))r=()=>Ge(t.useValue);else if(function z1(t){return!(!t||!t.useFactory)}(t))r=()=>t.useFactory(...ib(t.deps||[]));else if(function B1(t){return!(!t||!t.useExisting)}(t))r=()=>Ue(Ge(t.useExisting));else{const s=Ge(t&&(t.useClass||t.provide));if(!function U3(t){return!!t.deps}(t))return da(s)||mv(s);r=()=>new s(...ib(t.deps))}return r}(t),Vf)}(n);if(ya(n)||!0!==n.multi)this.records.get(e);else{let s=this.records.get(e);s||(s=Dl(void 0,Vf,!0),s.factory=()=>ib(s.multi),this.records.set(e,s)),e=n,s.multi.push(n)}this.records.set(e,r)}hydrate(n,e){return e.value===Vf&&(e.value=B3,e.value=e.factory()),"object"==typeof e.value&&e.value&&function W3(t){return null!==t&&"object"==typeof t&&"function"==typeof t.ngOnDestroy}(e.value)&&this._ngOnDestroyHooks.add(e.value),e.value}injectableDefInScope(n){if(!n.providedIn)return!1;const e=Ge(n.providedIn);return"string"==typeof e?"any"===e||this.scopes.has(e):this.injectorDefTypes.has(e)}}function mv(t){const n=cf(t),e=null!==n?n.factory:da(t);if(null!==e)return e;if(t instanceof qe)throw new xe(204,!1);if(t instanceof Function)return function z3(t){const n=t.length;if(n>0)throw function uc(t,n){const e=[];for(let r=0;r<t;r++)e.push(n);return e}(n,"?"),new xe(204,!1);const e=function tB(t){const n=t&&(t[df]||t[j_]);if(n){const e=function nB(t){if(t.hasOwnProperty("name"))return t.name;const n=(""+t).match(/^function\s*([^\s(]+)/);return null===n?"":n[1]}(t);return console.warn(`DEPRECATED: DI is instantiating a token "${e}" that inherits its @Injectable decorator but does not provide one itself.\nThis will become an error in a future version of Angular. Please add @Injectable() to the "${e}" class.`),n}return null}(t);return null!==e?()=>e.factory(t):()=>new t}(t);throw new xe(204,!1)}function Dl(t,n,e=!1){return{factory:t,value:n,multi:e?[]:void 0}}function gv(t,n){for(const e of t)Array.isArray(e)?gv(e,n):e&&nb(e)?gv(e.\u0275providers,n):n(e)}class G3{}class W1{}class q3{resolveComponentFactory(n){throw function j3(t){const n=Error(`No component factory found for ${Gt(t)}. Did you add it to @NgModule.entryComponents?`);return n.ngComponent=t,n}(n)}}let xc=(()=>{class t{}return t.NULL=new q3,t})();function K3(){return _l(pr(),oe())}function _l(t,n){return new _i(ss(t,n))}let _i=(()=>{class t{constructor(e){this.nativeElement=e}}return t.__NG_ELEMENT_ID__=K3,t})();function X3(t){return t instanceof _i?t.nativeElement:t}class G1{}let Z3=(()=>{class t{}return t.\u0275prov=ht({token:t,providedIn:"root",factory:()=>null}),t})();class Hf{constructor(n){this.full=n,this.major=n.split(".")[0],this.minor=n.split(".")[1],this.patch=n.split(".").slice(2).join(".")}}const Q3=new Hf("15.0.0"),yv={};function vv(t){return t.ngOriginalError}class Sl{constructor(){this._console=console}handleError(n){const e=this._findOriginalError(n);this._console.error("ERROR",n),e&&this._console.error("ORIGINAL ERROR",e)}_findOriginalError(n){let e=n&&vv(n);for(;e&&vv(e);)e=vv(e);return e||null}}function jo(t){return t instanceof Function?t():t}function q1(t,n,e){let r=t.length;for(;;){const s=t.indexOf(n,e);if(-1===s)return s;if(0===s||t.charCodeAt(s-1)<=32){const o=n.length;if(s+o===r||t.charCodeAt(s+o)<=32)return s}e=s+1}}const K1="ng-template";function uV(t,n,e){let r=0;for(;r<t.length;){let s=t[r++];if(e&&"class"===s){if(s=t[r],-1!==q1(s.toLowerCase(),n,0))return!0}else if(1===s){for(;r<t.length&&"string"==typeof(s=t[r++]);)if(s.toLowerCase()===n)return!0;return!1}}return!1}function X1(t){return 4===t.type&&t.value!==K1}function cV(t,n,e){return n===(4!==t.type||e?t.value:K1)}function dV(t,n,e){let r=4;const s=t.attrs||[],o=function pV(t){for(let n=0;n<t.length;n++)if(wS(t[n]))return n;return t.length}(s);let i=!1;for(let a=0;a<n.length;a++){const l=n[a];if("number"!=typeof l){if(!i)if(4&r){if(r=2|1&r,""!==l&&!cV(t,l,e)||""===l&&1===n.length){if(Ks(r))return!1;i=!0}}else{const u=8&r?l:n[++a];if(8&r&&null!==t.attrs){if(!uV(t.attrs,u,e)){if(Ks(r))return!1;i=!0}continue}const d=hV(8&r?"class":l,s,X1(t),e);if(-1===d){if(Ks(r))return!1;i=!0;continue}if(""!==u){let h;h=d>o?"":s[d+1].toLowerCase();const f=8&r?h:null;if(f&&-1!==q1(f,u,0)||2&r&&u!==h){if(Ks(r))return!1;i=!0}}}}else{if(!i&&!Ks(r)&&!Ks(l))return!1;if(i&&Ks(l))continue;i=!1,r=l|1&r}}return Ks(r)||i}function Ks(t){return 0==(1&t)}function hV(t,n,e,r){if(null===n)return-1;let s=0;if(r||!e){let o=!1;for(;s<n.length;){const i=n[s];if(i===t)return s;if(3===i||6===i)o=!0;else{if(1===i||2===i){let a=n[++s];for(;"string"==typeof a;)a=n[++s];continue}if(4===i)break;if(0===i){s+=4;continue}}s+=o?1:2}return-1}return function mV(t,n){let e=t.indexOf(4);if(e>-1)for(e++;e<t.length;){const r=t[e];if("number"==typeof r)return-1;if(r===n)return e;e++}return-1}(n,t)}function Y1(t,n,e=!1){for(let r=0;r<n.length;r++)if(dV(t,n[r],e))return!0;return!1}function Z1(t,n){return t?":not("+n.trim()+")":n}function yV(t){let n=t[0],e=1,r=2,s="",o=!1;for(;e<t.length;){let i=t[e];if("string"==typeof i)if(2&r){const a=t[++e];s+="["+i+(a.length>0?'="'+a+'"':"")+"]"}else 8&r?s+="."+i:4&r&&(s+=" "+i);else""!==s&&!Ks(i)&&(n+=Z1(o,s),s=""),r=i,o=o||!Ks(r);e++}return""!==s&&(n+=Z1(o,s)),n}const rt={};function $n(t){Q1(St(),oe(),Rr()+t,!1)}function Q1(t,n,e,r){if(!r)if(3==(3&n[2])){const o=t.preOrderCheckHooks;null!==o&&If(n,o,e)}else{const o=t.preOrderHooks;null!==o&&Df(n,o,0,e)}fa(e)}function nE(t,n=null,e=null,r){const s=rE(t,n,e,r);return s.resolveInjectorInitializers(),s}function rE(t,n=null,e=null,r,s=new Set){const o=[e||kt,M3(t)];return r=r||("object"==typeof t?void 0:Gt(t)),new V1(o,n||Uf(),r||null,s)}let Xs=(()=>{class t{static create(e,r){if(Array.isArray(e))return nE({name:""},r,e,"");{const s=e.name??"";return nE({name:s},e.parent,e.providers,s)}}}return t.THROW_IF_NOT_FOUND=Xu,t.NULL=new M1,t.\u0275prov=ht({token:t,providedIn:"any",factory:()=>Ue(F1)}),t.__NG_ELEMENT_ID__=-1,t})();function Ke(t,n=je.Default){const e=oe();return null===e?Ue(t,n):TS(pr(),e,Ge(t),n)}function Dv(){throw new Error("invalid")}function jf(t,n){return t<<17|n<<2}function Ys(t){return t>>17&32767}function _v(t){return 2|t}function qo(t){return(131068&t)>>2}function Sv(t,n){return-131069&t|n<<2}function Ev(t){return 1|t}function xE(t,n){const e=t.contentQueries;if(null!==e)for(let r=0;r<e.length;r+=2){const s=e[r],o=e[r+1];if(-1!==o){const i=t.data[o];Cb(s),i.contentQueries(2,n[o],o)}}}function Xf(t,n,e,r,s,o,i,a,l,u,c){const d=n.blueprint.slice();return d[0]=s,d[2]=76|r,(null!==c||t&&1024&t[2])&&(d[2]|=1024),oS(d),d[3]=d[15]=t,d[8]=e,d[10]=i||t&&t[10],d[11]=a||t&&t[11],d[12]=l||t&&t[12]||null,d[9]=u||t&&t[9]||null,d[6]=o,d[20]=function Mz(){return Oz++}(),d[21]=c,d[16]=2==n.type?t[16]:d,d}function Tl(t,n,e,r,s){let o=t.data[n];if(null===o)o=function Ov(t,n,e,r,s){const o=cS(),i=bb(),l=t.data[n]=function JV(t,n,e,r,s,o){return{type:e,index:r,insertBeforeIndex:null,injectorIndex:n?n.injectorIndex:-1,directiveStart:-1,directiveEnd:-1,directiveStylingLast:-1,componentOffset:-1,propertyBindings:null,flags:0,providerIndexes:0,value:s,attrs:o,mergedAttrs:null,localNames:null,initialInputs:void 0,inputs:null,outputs:null,tViews:null,next:null,projectionNext:null,child:null,parent:n,projection:null,styles:null,stylesWithoutHost:null,residualStyles:void 0,classes:null,classesWithoutHost:null,residualClasses:void 0,classBindings:0,styleBindings:0}}(0,i?o:o&&o.parent,e,n,r,s);return null===t.firstChild&&(t.firstChild=l),null!==o&&(i?null==o.child&&null!==l.parent&&(o.child=l):null===o.next&&(o.next=l)),l}(t,n,e,r,s),function LB(){return Je.lFrame.inI18n}()&&(o.flags|=32);else if(64&o.type){o.type=e,o.value=r,o.attrs=s;const i=function rc(){const t=Je.lFrame,n=t.currentTNode;return t.isParent?n:n.parent}();o.injectorIndex=null===i?-1:i.injectorIndex}return mo(o,!0),o}function wc(t,n,e,r){if(0===e)return-1;const s=n.length;for(let o=0;o<e;o++)n.push(r),t.blueprint.push(r),t.data.push(null);return s}function Mv(t,n,e){Ib(n);try{const r=t.viewQuery;null!==r&&jv(1,r,e);const s=t.template;null!==s&&wE(t,n,s,1,e),t.firstCreatePass&&(t.firstCreatePass=!1),t.staticContentQueries&&xE(t,n),t.staticViewQueries&&jv(2,t.viewQuery,e);const o=t.components;null!==o&&function YV(t,n){for(let e=0;e<n.length;e++)bU(t,n[e])}(n,o)}catch(r){throw t.firstCreatePass&&(t.incompleteFirstPass=!0,t.firstCreatePass=!1),r}finally{n[2]&=-5,Db()}}function Yf(t,n,e,r){const s=n[2];if(128!=(128&s)){Ib(n);try{oS(n),function hS(t){return Je.lFrame.bindingIndex=t}(t.bindingStartIndex),null!==e&&wE(t,n,e,2,r);const i=3==(3&s);if(i){const u=t.preOrderCheckHooks;null!==u&&If(n,u,null)}else{const u=t.preOrderHooks;null!==u&&Df(n,u,0,null),_b(n,0)}if(function gU(t){for(let n=jb(t);null!==n;n=qb(n)){if(!n[2])continue;const e=n[9];for(let r=0;r<e.length;r++){const s=e[r],o=s[3];0==(512&s[2])&&yb(o,1),s[2]|=512}}}(n),function mU(t){for(let n=jb(t);null!==n;n=qb(n))for(let e=10;e<n.length;e++){const r=n[e],s=r[1];wf(r)&&Yf(s,r,s.template,r[8])}}(n),null!==t.contentQueries&&xE(t,n),i){const u=t.contentCheckHooks;null!==u&&If(n,u)}else{const u=t.contentHooks;null!==u&&Df(n,u,1),_b(n,1)}!function KV(t,n){const e=t.hostBindingOpCodes;if(null!==e)try{for(let r=0;r<e.length;r++){const s=e[r];if(s<0)fa(~s);else{const o=s,i=e[++r],a=e[++r];BB(i,o),a(2,n[o])}}}finally{fa(-1)}}(t,n);const a=t.components;null!==a&&function XV(t,n){for(let e=0;e<n.length;e++)yU(t,n[e])}(n,a);const l=t.viewQuery;if(null!==l&&jv(2,l,r),i){const u=t.viewCheckHooks;null!==u&&If(n,u)}else{const u=t.viewHooks;null!==u&&Df(n,u,2),_b(n,2)}!0===t.firstUpdatePass&&(t.firstUpdatePass=!1),n[2]&=-41,512&n[2]&&(n[2]&=-513,yb(n[3],-1))}finally{Db()}}}function wE(t,n,e,r,s){const o=Rr(),i=2&r;try{fa(-1),i&&n.length>22&&Q1(t,n,22,!1),e(r,s)}finally{fa(o)}}function Pv(t,n,e){if(db(n)){const s=n.directiveEnd;for(let o=n.directiveStart;o<s;o++){const i=t.data[o];i.contentQueries&&i.contentQueries(1,e[o],o)}}}function Lv(t,n,e){!aS()||(function oU(t,n,e,r){const s=e.directiveStart,o=e.directiveEnd;t.firstCreatePass||Sf(e,n),wr(r,n);const i=e.initialInputs;for(let a=s;a<o;a++){const l=t.data[a],u=qs(l);u&&hU(n,e,l);const c=ml(n,t,a,e);wr(c,n),null!==i&&fU(0,a-s,c,l,0,i),u&&(os(e.index,n)[8]=c)}}(t,n,e,ss(e,n)),64==(64&e.flags)&&NE(t,n,e))}function Bv(t,n,e=ss){const r=n.localNames;if(null!==r){let s=n.index+1;for(let o=0;o<r.length;o+=2){const i=r[o+1],a=-1===i?e(n,t):t[i];t[s++]=a}}}function CE(t){const n=t.tView;return null===n||n.incompleteFirstPass?t.tView=zv(1,null,t.template,t.decls,t.vars,t.directiveDefs,t.pipeDefs,t.viewQuery,t.schemas,t.consts):n}function zv(t,n,e,r,s,o,i,a,l,u){const c=22+r,d=c+s,h=function ZV(t,n){const e=[];for(let r=0;r<n;r++)e.push(r<t?null:rt);return e}(c,d),f="function"==typeof u?u():u;return h[1]={type:t,blueprint:h,template:e,queries:null,viewQuery:a,declTNode:n,data:h.slice().fill(null,c),bindingStartIndex:c,expandoStartIndex:d,hostBindingOpCodes:null,firstCreatePass:!0,firstUpdatePass:!0,staticViewQueries:!1,staticContentQueries:!1,preOrderHooks:null,preOrderCheckHooks:null,contentHooks:null,contentCheckHooks:null,viewHooks:null,viewCheckHooks:null,destroyHooks:null,cleanup:null,contentQueries:null,components:null,directiveRegistry:"function"==typeof o?o():o,pipeRegistry:"function"==typeof i?i():i,firstChild:null,schemas:l,consts:f,incompleteFirstPass:!1}}function IE(t,n,e,r){const s=kE(n);null===e?s.push(r):(s.push(e),t.firstCreatePass&&AE(t).push(r,s.length-1))}function DE(t,n,e,r){for(let s in t)if(t.hasOwnProperty(s)){e=null===e?{}:e;const o=t[s];null===r?_E(e,n,s,o):r.hasOwnProperty(s)&&_E(e,n,r[s],o)}return e}function _E(t,n,e,r){t.hasOwnProperty(e)?t[e].push(n,r):t[e]=[n,r]}function SE(t,n){const e=os(n,t);16&e[2]||(e[2]|=32)}function Vv(t,n,e,r){let s=!1;if(aS()){const o=null===r?null:{"":-1},i=function aU(t,n){const e=t.directiveRegistry;let r=null,s=null;if(e)for(let o=0;o<e.length;o++){const i=e[o];if(Y1(n,i.selectors,!1))if(r||(r=[]),qs(i))if(null!==i.findHostDirectiveDefs){const a=[];s=s||new Map,i.findHostDirectiveDefs(i,a,s),r.unshift(...a,i),Uv(t,n,a.length)}else r.unshift(i),Uv(t,n,0);else s=s||new Map,i.findHostDirectiveDefs?.(i,r,s),r.push(i)}return null===r?null:[r,s]}(t,e);let a,l;null===i?a=l=null:[a,l]=i,null!==a&&(s=!0,EE(t,n,e,a,o,l)),o&&function lU(t,n,e){if(n){const r=t.localNames=[];for(let s=0;s<n.length;s+=2){const o=e[n[s+1]];if(null==o)throw new xe(-301,!1);r.push(n[s],o)}}}(e,r,o)}return e.mergedAttrs=ic(e.mergedAttrs,e.attrs),s}function EE(t,n,e,r,s,o){for(let u=0;u<r.length;u++)Ab(Sf(e,n),t,r[u].type);!function cU(t,n,e){t.flags|=1,t.directiveStart=n,t.directiveEnd=n+e,t.providerIndexes=n}(e,t.data.length,r.length);for(let u=0;u<r.length;u++){const c=r[u];c.providersResolver&&c.providersResolver(c)}let i=!1,a=!1,l=wc(t,n,r.length,null);for(let u=0;u<r.length;u++){const c=r[u];e.mergedAttrs=ic(e.mergedAttrs,c.hostAttrs),dU(t,e,n,l,c),uU(l,c,s),null!==c.contentQueries&&(e.flags|=4),(null!==c.hostBindings||null!==c.hostAttrs||0!==c.hostVars)&&(e.flags|=64);const d=c.type.prototype;!i&&(d.ngOnChanges||d.ngOnInit||d.ngDoCheck)&&((t.preOrderHooks||(t.preOrderHooks=[])).push(e.index),i=!0),!a&&(d.ngOnChanges||d.ngDoCheck)&&((t.preOrderCheckHooks||(t.preOrderCheckHooks=[])).push(e.index),a=!0),l++}!function eU(t,n,e){const s=n.directiveEnd,o=t.data,i=n.attrs,a=[];let l=null,u=null;for(let c=n.directiveStart;c<s;c++){const d=o[c],h=e?e.get(d):null,p=h?h.outputs:null;l=DE(d.inputs,c,l,h?h.inputs:null),u=DE(d.outputs,c,u,p);const m=null===l||null===i||X1(n)?null:pU(l,c,i);a.push(m)}null!==l&&(l.hasOwnProperty("class")&&(n.flags|=8),l.hasOwnProperty("style")&&(n.flags|=16)),n.initialInputs=a,n.inputs=l,n.outputs=u}(t,e,o)}function NE(t,n,e){const r=e.directiveStart,s=e.directiveEnd,o=e.index,i=function zB(){return Je.lFrame.currentDirectiveIndex}();try{fa(o);for(let a=r;a<s;a++){const l=t.data[a],u=n[a];xb(a),(null!==l.hostBindings||0!==l.hostVars||null!==l.hostAttrs)&&iU(l,u)}}finally{fa(-1),xb(i)}}function iU(t,n){null!==t.hostBindings&&t.hostBindings(1,n)}function Uv(t,n,e){n.componentOffset=e,(t.components||(t.components=[])).push(n.index)}function uU(t,n,e){if(e){if(n.exportAs)for(let r=0;r<n.exportAs.length;r++)e[n.exportAs[r]]=t;qs(n)&&(e[""]=t)}}function dU(t,n,e,r,s){t.data[r]=s;const o=s.factory||(s.factory=da(s.type)),i=new sc(o,qs(s),Ke);t.blueprint[r]=i,e[r]=i,function rU(t,n,e,r,s){const o=s.hostBindings;if(o){let i=t.hostBindingOpCodes;null===i&&(i=t.hostBindingOpCodes=[]);const a=~n.index;(function sU(t){let n=t.length;for(;n>0;){const e=t[--n];if("number"==typeof e&&e<0)return e}return 0})(i)!=a&&i.push(a),i.push(e,r,o)}}(t,n,r,wc(t,e,s.hostVars,rt),s)}function hU(t,n,e){const r=ss(n,t),s=CE(e),o=t[10],i=Zf(t,Xf(t,s,null,e.onPush?32:16,r,n,o,o.createRenderer(r,e),null,null,null));t[n.index]=i}function fU(t,n,e,r,s,o){const i=o[n];if(null!==i){const a=r.setInput;for(let l=0;l<i.length;){const u=i[l++],c=i[l++],d=i[l++];null!==a?r.setInput(e,d,u,c):e[c]=d}}}function pU(t,n,e){let r=null,s=0;for(;s<e.length;){const o=e[s];if(0!==o)if(5!==o){if("number"==typeof o)break;if(t.hasOwnProperty(o)){null===r&&(r=[]);const i=t[o];for(let a=0;a<i.length;a+=2)if(i[a]===n){r.push(o,i[a+1],e[s+1]);break}}s+=2}else s+=2;else s+=4}return r}function TE(t,n,e,r){return new Array(t,!0,!1,n,null,0,r,e,null,null)}function yU(t,n){const e=os(n,t);if(wf(e)){const r=e[1];48&e[2]?Yf(r,e,r.template,e[8]):e[5]>0&&Hv(e)}}function Hv(t){for(let r=jb(t);null!==r;r=qb(r))for(let s=10;s<r.length;s++){const o=r[s];if(wf(o))if(512&o[2]){const i=o[1];Yf(i,o,i.template,o[8])}else o[5]>0&&Hv(o)}const e=t[1].components;if(null!==e)for(let r=0;r<e.length;r++){const s=os(e[r],t);wf(s)&&s[5]>0&&Hv(s)}}function bU(t,n){const e=os(n,t),r=e[1];(function vU(t,n){for(let e=n.length;e<t.blueprint.length;e++)n.push(t.blueprint[e])})(r,e),Mv(r,e,e[8])}function Zf(t,n){return t[13]?t[14][4]=n:t[13]=n,t[14]=n,n}function Gv(t){for(;t;){t[2]|=32;const n=mc(t);if(bB(t)&&!n)return t;t=n}return null}function Qf(t,n,e,r=!0){const s=n[10];s.begin&&s.begin();try{Yf(t,n,t.template,e)}catch(i){throw r&&$E(n,i),i}finally{s.end&&s.end()}}function jv(t,n,e){Cb(0),n(t,e)}function kE(t){return t[7]||(t[7]=[])}function AE(t){return t.cleanup||(t.cleanup=[])}function $E(t,n){const e=t[9],r=e?e.get(Sl,null):null;r&&r.handleError(n)}function qv(t,n,e,r,s){for(let o=0;o<e.length;){const i=e[o++],a=e[o++],l=n[i],u=t.data[i];null!==u.setInput?u.setInput(l,s,r,a):l[a]=s}}function Jf(t,n,e){let r=e?t.styles:null,s=e?t.classes:null,o=0;if(null!==n)for(let i=0;i<n.length;i++){const a=n[i];"number"==typeof a?o=a:1==o?s=Jy(s,a):2==o&&(r=Jy(r,a+": "+n[++i]+";"))}e?t.styles=r:t.stylesWithoutHost=r,e?t.classes=s:t.classesWithoutHost=s}function ep(t,n,e,r,s=!1){for(;null!==e;){const o=n[e.index];if(null!==o&&r.push(An(o)),js(o))for(let a=10;a<o.length;a++){const l=o[a],u=l[1].firstChild;null!==u&&ep(l[1],l,u,r)}const i=e.type;if(8&i)ep(t,n,e.child,r);else if(32&i){const a=Gb(e,n);let l;for(;l=a();)r.push(l)}else if(16&i){const a=y1(n,e);if(Array.isArray(a))r.push(...a);else{const l=mc(n[16]);ep(l[1],l,a,r,!0)}}e=s?e.projectionNext:e.next}return r}class Cc{constructor(n,e){this._lView=n,this._cdRefInjectingView=e,this._appRef=null,this._attachedToViewContainer=!1}get rootNodes(){const n=this._lView,e=n[1];return ep(e,n,e.firstChild,[])}get context(){return this._lView[8]}set context(n){this._lView[8]=n}get destroyed(){return 128==(128&this._lView[2])}destroy(){if(this._appRef)this._appRef.detachView(this);else if(this._attachedToViewContainer){const n=this._lView[3];if(js(n)){const e=n[8],r=e?e.indexOf(this):-1;r>-1&&(Yb(n,r),kf(e,r))}this._attachedToViewContainer=!1}l1(this._lView[1],this._lView)}onDestroy(n){IE(this._lView[1],this._lView,null,n)}markForCheck(){Gv(this._cdRefInjectingView||this._lView)}detach(){this._lView[2]&=-65}reattach(){this._lView[2]|=64}detectChanges(){Qf(this._lView[1],this._lView,this.context)}checkNoChanges(){}attachToViewContainerRef(){if(this._appRef)throw new xe(902,!1);this._attachedToViewContainer=!0}detachFromAppRef(){this._appRef=null,function Qz(t,n){gc(t,n,n[11],2,null,null)}(this._lView[1],this._lView)}attachToAppRef(n){if(this._attachedToViewContainer)throw new xe(902,!1);this._appRef=n}}class xU extends Cc{constructor(n){super(n),this._view=n}detectChanges(){const n=this._view;Qf(n[1],n,n[8],!1)}checkNoChanges(){}get context(){return null}}class Kv extends xc{constructor(n){super(),this.ngModule=n}resolveComponentFactory(n){const e=Ot(n);return new Ic(e,this.ngModule)}}function FE(t){const n=[];for(let e in t)t.hasOwnProperty(e)&&n.push({propName:t[e],templateName:e});return n}class CU{constructor(n,e){this.injector=n,this.parentInjector=e}get(n,e,r){r=ff(r);const s=this.injector.get(n,yv,r);return s!==yv||e===yv?s:this.parentInjector.get(n,e,r)}}class Ic extends W1{constructor(n,e){super(),this.componentDef=n,this.ngModule=e,this.componentType=n.type,this.selector=function bV(t){return t.map(yV).join(",")}(n.selectors),this.ngContentSelectors=n.ngContentSelectors?n.ngContentSelectors:[],this.isBoundToModule=!!e}get inputs(){return FE(this.componentDef.inputs)}get outputs(){return FE(this.componentDef.outputs)}create(n,e,r,s){let o=(s=s||this.ngModule)instanceof Di?s:s?.injector;o&&null!==this.componentDef.getStandaloneInjector&&(o=this.componentDef.getStandaloneInjector(o)||o);const i=o?new CU(n,o):n,a=i.get(G1,null);if(null===a)throw new xe(407,!1);const l=i.get(Z3,null),u=a.createRenderer(null,this.componentDef),c=this.componentDef.selectors[0][0]||"div",d=r?function QV(t,n,e){return t.selectRootElement(n,e===po.ShadowDom)}(u,r,this.componentDef.encapsulation):Xb(u,c,function wU(t){const n=t.toLowerCase();return"svg"===n?"svg":"math"===n?"math":null}(c)),h=this.componentDef.onPush?288:272,f=zv(0,null,null,1,0,null,null,null,null,null),p=Xf(null,f,null,h,null,null,a,u,l,i,null);let m,g;Ib(p);try{const y=this.componentDef;let b,v=null;y.findHostDirectiveDefs?(b=[],v=new Map,y.findHostDirectiveDefs(y,b,v),b.push(y)):b=[y];const x=function _U(t,n){const e=t[1];return t[22]=n,Tl(e,22,2,"#host",null)}(p,d),w=function SU(t,n,e,r,s,o,i,a){const l=s[1];!function EU(t,n,e,r){for(const s of t)n.mergedAttrs=ic(n.mergedAttrs,s.hostAttrs);null!==n.mergedAttrs&&(Jf(n,n.mergedAttrs,!0),null!==e&&x1(r,e,n))}(r,t,n,i);const u=o.createRenderer(n,e),c=Xf(s,CE(e),null,e.onPush?32:16,s[t.index],t,o,u,a||null,null,null);return l.firstCreatePass&&Uv(l,t,r.length-1),Zf(s,c),s[t.index]=c}(x,d,y,b,p,a,u);g=gb(f,22),d&&function TU(t,n,e,r){if(r)Eb(t,e,["ng-version",Q3.full]);else{const{attrs:s,classes:o}=function vV(t){const n=[],e=[];let r=1,s=2;for(;r<t.length;){let o=t[r];if("string"==typeof o)2===s?""!==o&&n.push(o,t[++r]):8===s&&e.push(o);else{if(!Ks(s))break;s=o}r++}return{attrs:n,classes:e}}(n.selectors[0]);s&&Eb(t,e,s),o&&o.length>0&&v1(t,e,o.join(" "))}}(u,y,d,r),void 0!==e&&function kU(t,n,e){const r=t.projection=[];for(let s=0;s<n.length;s++){const o=e[s];r.push(null!=o?Array.from(o):null)}}(g,this.ngContentSelectors,e),m=function NU(t,n,e,r,s,o){const i=pr(),a=s[1],l=ss(i,s);EE(a,s,i,e,null,r);for(let c=0;c<e.length;c++)wr(ml(s,a,i.directiveStart+c,i),s);NE(a,s,i),l&&wr(l,s);const u=ml(s,a,i.directiveStart+i.componentOffset,i);if(t[8]=s[8]=u,null!==o)for(const c of o)c(u,n);return Pv(a,i,t),u}(w,y,b,v,p,[AU]),Mv(f,p,null)}finally{Db()}return new DU(this.componentType,m,_l(g,p),p,g)}}class DU extends G3{constructor(n,e,r,s,o){super(),this.location=r,this._rootLView=s,this._tNode=o,this.instance=e,this.hostView=this.changeDetectorRef=new xU(s),this.componentType=n}setInput(n,e){const r=this._tNode.inputs;let s;if(null!==r&&(s=r[n])){const o=this._rootLView;qv(o[1],o,s,n,e),SE(o,this._tNode.index)}}get injector(){return new gl(this._tNode,this._rootLView)}destroy(){this.hostView.destroy()}onDestroy(n){this.hostView.onDestroy(n)}}function AU(){const t=pr();Cf(oe()[1],t)}let tp=null;function ba(){if(!tp){const t=Yt.Symbol;if(t&&t.iterator)tp=t.iterator;else{const n=Object.getOwnPropertyNames(Map.prototype);for(let e=0;e<n.length;++e){const r=n[e];"entries"!==r&&"size"!==r&&Map.prototype[r]===Map.prototype.entries&&(tp=r)}}}return tp}function Cr(t,n,e){return!Object.is(t[n],e)&&(t[n]=e,!0)}function us(t,n,e,r,s,o,i,a){const l=oe(),u=St(),c=t+22,d=u.firstCreatePass?function GU(t,n,e,r,s,o,i,a,l){const u=n.consts,c=Tl(n,t,4,i||null,wi(u,a));Vv(n,e,c,wi(u,l)),Cf(n,c);const d=c.tViews=zv(2,c,r,s,o,n.directiveRegistry,n.pipeRegistry,null,n.schemas,u);return null!==n.queries&&(n.queries.template(n,c),d.queries=n.queries.embeddedTView(c)),c}(c,u,l,n,e,r,s,o,i):u.data[c];mo(d,!1);const h=l[11].createComment("");Of(u,l,h,d),wr(h,l),Zf(l,l[c]=TE(h,l,h,d)),vf(d)&&Lv(u,l,d),null!=i&&Bv(l,d,a)}function Fr(t,n,e){const r=oe();return Cr(r,hl(),n)&&function ls(t,n,e,r,s,o,i,a){const l=ss(n,e);let c,u=n.inputs;!a&&null!=u&&(c=u[r])?(qv(t,e,c,r,s),bf(n)&&SE(e,n.index)):3&n.type&&(r=function tU(t){return"class"===t?"className":"for"===t?"htmlFor":"formaction"===t?"formAction":"innerHtml"===t?"innerHTML":"readonly"===t?"readOnly":"tabindex"===t?"tabIndex":t}(r),s=null!=i?i(s,n.value||"",r):s,o.setProperty(l,r,s))}(St(),function dn(){const t=Je.lFrame;return gb(t.tView,t.selectedIndex)}(),r,t,n,r[11],e,!1),Fr}function Qv(t,n,e,r,s){const i=s?"class":"style";qv(t,e,n.inputs[i],i,r)}function yn(t,n,e,r){const s=oe(),o=St(),i=22+t,a=s[11],l=s[i]=Xb(a,n,function KB(){return Je.lFrame.currentNamespace}()),u=o.firstCreatePass?function KU(t,n,e,r,s,o,i){const a=n.consts,u=Tl(n,t,2,s,wi(a,o));return Vv(n,e,u,wi(a,i)),null!==u.attrs&&Jf(u,u.attrs,!1),null!==u.mergedAttrs&&Jf(u,u.mergedAttrs,!0),null!==n.queries&&n.queries.elementStart(n,u),u}(i,o,s,0,n,e,r):o.data[i];return mo(u,!0),x1(a,l,u),32!=(32&u.flags)&&Of(o,s,l,u),0===function RB(){return Je.lFrame.elementDepthCount}()&&wr(l,s),function $B(){Je.lFrame.elementDepthCount++}(),vf(u)&&(Lv(o,s,u),Pv(o,u,s)),null!==r&&Bv(s,u),yn}function Qt(){let t=pr();bb()?function vb(){Je.lFrame.isParent=!1}():(t=t.parent,mo(t,!1));const n=t;!function FB(){Je.lFrame.elementDepthCount--}();const e=St();return e.firstCreatePass&&(Cf(e,t),db(t)&&e.queries.elementEnd(t)),null!=n.classesWithoutHost&&function JB(t){return 0!=(8&t.flags)}(n)&&Qv(e,n,oe(),n.classesWithoutHost,!0),null!=n.stylesWithoutHost&&function ez(t){return 0!=(16&t.flags)}(n)&&Qv(e,n,oe(),n.stylesWithoutHost,!1),Qt}function Fn(t,n,e,r){return yn(t,n,e,r),Qt(),Fn}function rp(t){return!!t&&"function"==typeof t.then}const QE=function ZE(t){return!!t&&"function"==typeof t.subscribe};function xa(t,n,e,r){const s=oe(),o=St(),i=pr();return function eN(t,n,e,r,s,o,i,a){const l=vf(r),c=t.firstCreatePass&&AE(t),d=n[8],h=kE(n);let f=!0;if(3&r.type||a){const g=ss(r,n),y=a?a(g):g,b=h.length,v=a?w=>a(An(w[r.index])):r.index;let x=null;if(!a&&l&&(x=function YU(t,n,e,r){const s=t.cleanup;if(null!=s)for(let o=0;o<s.length-1;o+=2){const i=s[o];if(i===e&&s[o+1]===r){const a=n[7],l=s[o+2];return a.length>l?a[l]:null}"string"==typeof i&&(o+=2)}return null}(t,n,s,r.index)),null!==x)(x.__ngLastListenerFn__||x).__ngNextListenerFn__=o,x.__ngLastListenerFn__=o,f=!1;else{o=nN(r,n,d,o,!1);const w=e.listen(y,s,o);h.push(o,w),c&&c.push(s,v,b,b+1)}}else o=nN(r,n,d,o,!1);const p=r.outputs;let m;if(f&&null!==p&&(m=p[s])){const g=m.length;if(g)for(let y=0;y<g;y+=2){const _=n[m[y]][m[y+1]].subscribe(o),D=h.length;h.push(o,_),c&&c.push(s,r.index,D,-(D+1))}}}(o,s,s[11],i,t,n,0,r),xa}function tN(t,n,e,r){try{return!1!==e(r)}catch(s){return $E(t,s),!1}}function nN(t,n,e,r,s){return function o(i){if(i===Function)return r;Gv(t.componentOffset>-1?os(t.index,n):n);let l=tN(n,0,r,i),u=o.__ngNextListenerFn__;for(;u;)l=tN(n,0,u,i)&&l,u=u.__ngNextListenerFn__;return s&&!1===l&&(i.preventDefault(),i.returnValue=!1),l}}function Bl(t=1){return function UB(t){return(Je.lFrame.contextLView=function WB(t,n){for(;t>0;)n=n[15],t--;return n}(t,Je.lFrame.contextLView))[8]}(t)}function hN(t,n,e,r,s){const o=t[e+1],i=null===n;let a=r?Ys(o):qo(o),l=!1;for(;0!==a&&(!1===l||i);){const c=t[a+1];n4(t[a],n)&&(l=!0,t[a+1]=r?Ev(c):_v(c)),a=r?Ys(c):qo(c)}l&&(t[e+1]=r?_v(o):Ev(o))}function n4(t,n){return null===t||null==n||(Array.isArray(t)?t[1]:t)===n||!(!Array.isArray(t)||"string"!=typeof n)&&wl(t,n)>=0}function Sc(t,n,e){return function Zs(t,n,e,r){const s=oe(),o=St(),i=function Ho(t){const n=Je.lFrame,e=n.bindingIndex;return n.bindingIndex=n.bindingIndex+t,e}(2);o.firstUpdatePass&&function wN(t,n,e,r){const s=t.data;if(null===s[e+1]){const o=s[Rr()],i=function xN(t,n){return n>=t.expandoStartIndex}(t,e);(function _N(t,n){return 0!=(t.flags&(n?8:16))})(o,r)&&null===n&&!i&&(n=!1),n=function d4(t,n,e,r){const s=function wb(t){const n=Je.lFrame.currentDirectiveIndex;return-1===n?null:t[n]}(t);let o=r?n.residualClasses:n.residualStyles;if(null===s)0===(r?n.classBindings:n.styleBindings)&&(e=Ec(e=nx(null,t,n,e,r),n.attrs,r),o=null);else{const i=n.directiveStylingLast;if(-1===i||t[i]!==s)if(e=nx(s,t,n,e,r),null===o){let l=function h4(t,n,e){const r=e?n.classBindings:n.styleBindings;if(0!==qo(r))return t[Ys(r)]}(t,n,r);void 0!==l&&Array.isArray(l)&&(l=nx(null,t,n,l[1],r),l=Ec(l,n.attrs,r),function f4(t,n,e,r){t[Ys(e?n.classBindings:n.styleBindings)]=r}(t,n,r,l))}else o=function p4(t,n,e){let r;const s=n.directiveEnd;for(let o=1+n.directiveStylingLast;o<s;o++)r=Ec(r,t[o].hostAttrs,e);return Ec(r,n.attrs,e)}(t,n,r)}return void 0!==o&&(r?n.residualClasses=o:n.residualStyles=o),e}(s,o,n,r),function e4(t,n,e,r,s,o){let i=o?n.classBindings:n.styleBindings,a=Ys(i),l=qo(i);t[r]=e;let c,u=!1;if(Array.isArray(e)){const d=e;c=d[1],(null===c||wl(d,c)>0)&&(u=!0)}else c=e;if(s)if(0!==l){const h=Ys(t[a+1]);t[r+1]=jf(h,a),0!==h&&(t[h+1]=Sv(t[h+1],r)),t[a+1]=function LV(t,n){return 131071&t|n<<17}(t[a+1],r)}else t[r+1]=jf(a,0),0!==a&&(t[a+1]=Sv(t[a+1],r)),a=r;else t[r+1]=jf(l,0),0===a?a=r:t[l+1]=Sv(t[l+1],r),l=r;u&&(t[r+1]=_v(t[r+1])),hN(t,c,r,!0),hN(t,c,r,!1),function t4(t,n,e,r,s){const o=s?t.residualClasses:t.residualStyles;null!=o&&"string"==typeof n&&wl(o,n)>=0&&(e[r+1]=Ev(e[r+1]))}(n,c,t,r,o),i=jf(a,l),o?n.classBindings=i:n.styleBindings=i}(s,o,n,e,i,r)}}(o,t,i,r),n!==rt&&Cr(s,i,n)&&function IN(t,n,e,r,s,o,i,a){if(!(3&n.type))return;const l=t.data,u=l[a+1];sp(function hE(t){return 1==(1&t)}(u)?DN(l,n,e,s,qo(u),i):void 0)||(sp(o)||function dE(t){return 2==(2&t)}(u)&&(o=DN(l,null,e,s,a,i)),function l3(t,n,e,r,s){if(n)s?t.addClass(e,r):t.removeClass(e,r);else{let o=-1===r.indexOf("-")?void 0:Wr.DashCase;null==s?t.removeStyle(e,r,o):("string"==typeof s&&s.endsWith("!important")&&(s=s.slice(0,-10),o|=Wr.Important),t.setStyle(e,r,s,o))}}(r,i,xf(Rr(),e),s,o))}(o,o.data[Rr()],s,s[11],t,s[i+1]=function y4(t,n){return null==t||("string"==typeof n?t+=n:"object"==typeof t&&(t=Gt(Ii(t)))),t}(n,e),r,i)}(t,n,e,!1),Sc}function nx(t,n,e,r,s){let o=null;const i=e.directiveEnd;let a=e.directiveStylingLast;for(-1===a?a=e.directiveStart:a++;a<i&&(o=n[a],r=Ec(r,o.hostAttrs,s),o!==t);)a++;return null!==t&&(e.directiveStylingLast=a),r}function Ec(t,n,e){const r=e?1:2;let s=-1;if(null!==n)for(let o=0;o<n.length;o++){const i=n[o];"number"==typeof i?s=i:s===r&&(Array.isArray(t)||(t=void 0===t?[]:["",t]),as(t,i,!!e||n[++o]))}return void 0===t?null:t}function DN(t,n,e,r,s,o){const i=null===n;let a;for(;s>0;){const l=t[s],u=Array.isArray(l),c=u?l[1]:l,d=null===c;let h=e[s+1];h===rt&&(h=d?kt:void 0);let f=d?Ob(h,r):c===r?h:void 0;if(u&&!sp(f)&&(f=Ob(l,r)),sp(f)&&(a=f,i))return a;const p=t[s+1];s=i?Ys(p):qo(p)}if(null!==n){let l=o?n.residualClasses:n.residualStyles;null!=l&&(a=Ob(l,r))}return a}function sp(t){return void 0!==t}function Hr(t,n=""){const e=oe(),r=St(),s=t+22,o=r.firstCreatePass?Tl(r,s,1,n,null):r.data[s],i=e[s]=function Kb(t,n){return t.createText(n)}(e[11],n);Of(r,e,i,o),mo(o,!1)}function Nc(t){return Tc("",t,""),Nc}function Tc(t,n,e){const r=oe(),s=function Al(t,n,e,r){return Cr(t,hl(),e)?n+nt(e)+r:rt}(r,t,n,e);return s!==rt&&function Ko(t,n,e){const r=xf(n,t);!function i1(t,n,e){t.setValue(n,e)}(t[11],r,e)}(r,Rr(),s),Tc}const Ul="en-US";let qN=Ul;class Ca{}class vT{}class xT extends Ca{constructor(n,e){super(),this._parent=e,this._bootstrapComponents=[],this.destroyCbs=[],this.componentFactoryResolver=new Kv(this);const r=ns(n);this._bootstrapComponents=jo(r.bootstrap),this._r3Injector=rE(n,e,[{provide:Ca,useValue:this},{provide:xc,useValue:this.componentFactoryResolver}],Gt(n),new Set(["environment"])),this._r3Injector.resolveInjectorInitializers(),this.instance=this._r3Injector.get(n)}get injector(){return this._r3Injector}destroy(){const n=this._r3Injector;!n.destroyed&&n.destroy(),this.destroyCbs.forEach(e=>e()),this.destroyCbs=null}onDestroy(n){this.destroyCbs.push(n)}}class ux extends vT{constructor(n){super(),this.moduleType=n}create(n){return new xT(this.moduleType,n)}}class LW extends Ca{constructor(n,e,r){super(),this.componentFactoryResolver=new Kv(this),this.instance=null;const s=new V1([...n,{provide:Ca,useValue:this},{provide:xc,useValue:this.componentFactoryResolver}],e||Uf(),r,new Set(["environment"]));this.injector=s,s.resolveInjectorInitializers()}destroy(){this.injector.destroy()}onDestroy(n){this.injector.onDestroy(n)}}function up(t,n,e=null){return new LW(t,n,e).injector}let BW=(()=>{class t{constructor(e){this._injector=e,this.cachedInjectors=new Map}getOrCreateStandaloneInjector(e){if(!e.standalone)return null;if(!this.cachedInjectors.has(e.id)){const r=P1(0,e.type),s=r.length>0?up([r],this._injector,`Standalone[${e.type.name}]`):null;this.cachedInjectors.set(e.id,s)}return this.cachedInjectors.get(e.id)}ngOnDestroy(){try{for(const e of this.cachedInjectors.values())null!==e&&e.destroy()}finally{this.cachedInjectors.clear()}}}return t.\u0275prov=ht({token:t,providedIn:"environment",factory:()=>new t(Ue(Di))}),t})();function wT(t){t.getStandaloneInjector=n=>n.get(BW).getOrCreateStandaloneInjector(t)}function dx(t){return n=>{setTimeout(t,void 0,n)}}const Ir=class dH extends Po{constructor(n=!1){super(),this.__isAsync=n}emit(n){super.next(n)}subscribe(n,e,r){let s=n,o=e||(()=>null),i=r;if(n&&"object"==typeof n){const l=n;s=l.next?.bind(l),o=l.error?.bind(l),i=l.complete?.bind(l)}this.__isAsync&&(o=dx(o),s&&(s=dx(s)),i&&(i=dx(i)));const a=super.subscribe({next:s,error:o,complete:i});return n instanceof Ve&&n.add(a),a}};function hH(){return this._results[ba()]()}class hx{constructor(n=!1){this._emitDistinctChangesOnly=n,this.dirty=!0,this._results=[],this._changesDetected=!1,this._changes=null,this.length=0,this.first=void 0,this.last=void 0;const e=ba(),r=hx.prototype;r[e]||(r[e]=hH)}get changes(){return this._changes||(this._changes=new Ir)}get(n){return this._results[n]}map(n){return this._results.map(n)}filter(n){return this._results.filter(n)}find(n){return this._results.find(n)}reduce(n,e){return this._results.reduce(n,e)}forEach(n){this._results.forEach(n)}some(n){return this._results.some(n)}toArray(){return this._results.slice()}toString(){return this._results.toString()}reset(n,e){const r=this;r.dirty=!1;const s=is(n);(this._changesDetected=!function dz(t,n,e){if(t.length!==n.length)return!1;for(let r=0;r<t.length;r++){let s=t[r],o=n[r];if(e&&(s=e(s),o=e(o)),o!==s)return!1}return!0}(r._results,s,e))&&(r._results=s,r.length=s.length,r.last=s[this.length-1],r.first=s[0])}notifyOnChanges(){this._changes&&(this._changesDetected||!this._emitDistinctChangesOnly)&&this._changes.emit(this)}setDirty(){this.dirty=!0}destroy(){this.changes.complete(),this.changes.unsubscribe()}}let Xo=(()=>{class t{}return t.__NG_ELEMENT_ID__=mH,t})();const fH=Xo,pH=class extends fH{constructor(n,e,r){super(),this._declarationLView=n,this._declarationTContainer=e,this.elementRef=r}createEmbeddedView(n,e){const r=this._declarationTContainer.tViews,s=Xf(this._declarationLView,r,n,16,null,r.declTNode,null,null,null,null,e||null);s[17]=this._declarationLView[this._declarationTContainer.index];const i=this._declarationLView[19];return null!==i&&(s[19]=i.createEmbeddedView(r)),Mv(r,s,n),new Cc(s)}};function mH(){return cp(pr(),oe())}function cp(t,n){return 4&t.type?new pH(n,t,_l(t,n)):null}let Js=(()=>{class t{}return t.__NG_ELEMENT_ID__=gH,t})();function gH(){return OT(pr(),oe())}const yH=Js,$T=class extends yH{constructor(n,e,r){super(),this._lContainer=n,this._hostTNode=e,this._hostLView=r}get element(){return _l(this._hostTNode,this._hostLView)}get injector(){return new gl(this._hostTNode,this._hostLView)}get parentInjector(){const n=Ef(this._hostTNode,this._hostLView);if(DS(n)){const e=pl(n,this._hostLView),r=fl(n);return new gl(e[1].data[r+8],e)}return new gl(null,this._hostLView)}clear(){for(;this.length>0;)this.remove(this.length-1)}get(n){const e=FT(this._lContainer);return null!==e&&e[n]||null}get length(){return this._lContainer.length-10}createEmbeddedView(n,e,r){let s,o;"number"==typeof r?s=r:null!=r&&(s=r.index,o=r.injector);const i=n.createEmbeddedView(e||{},o);return this.insert(i,s),i}createComponent(n,e,r,s,o){const i=n&&!function lc(t){return"function"==typeof t}(n);let a;if(i)a=e;else{const d=e||{};a=d.index,r=d.injector,s=d.projectableNodes,o=d.environmentInjector||d.ngModuleRef}const l=i?n:new Ic(Ot(n)),u=r||this.parentInjector;if(!o&&null==l.ngModule){const h=(i?u:this.parentInjector).get(Di,null);h&&(o=h)}const c=l.create(u,s,void 0,o);return this.insert(c.hostView,a),c}insert(n,e){const r=n._lView,s=r[1];if(function AB(t){return js(t[3])}(r)){const c=this.indexOf(n);if(-1!==c)this.detach(c);else{const d=r[3],h=new $T(d,d[6],d[3]);h.detach(h.indexOf(n))}}const o=this._adjustIndex(e),i=this._lContainer;!function e3(t,n,e,r){const s=10+r,o=e.length;r>0&&(e[s-1][4]=n),r<o-10?(n[4]=e[s],OS(e,10+r,n)):(e.push(n),n[4]=null),n[3]=e;const i=n[17];null!==i&&e!==i&&function t3(t,n){const e=t[9];n[16]!==n[3][3][16]&&(t[2]=!0),null===e?t[9]=[n]:e.push(n)}(i,n);const a=n[19];null!==a&&a.insertView(t),n[2]|=64}(s,r,i,o);const a=Jb(o,i),l=r[11],u=Ff(l,i[7]);return null!==u&&function Zz(t,n,e,r,s,o){r[0]=s,r[6]=n,gc(t,r,e,1,s,o)}(s,i[6],l,r,u,a),n.attachToViewContainerRef(),OS(fx(i),o,n),n}move(n,e){return this.insert(n,e)}indexOf(n){const e=FT(this._lContainer);return null!==e?e.indexOf(n):-1}remove(n){const e=this._adjustIndex(n,-1),r=Yb(this._lContainer,e);r&&(kf(fx(this._lContainer),e),l1(r[1],r))}detach(n){const e=this._adjustIndex(n,-1),r=Yb(this._lContainer,e);return r&&null!=kf(fx(this._lContainer),e)?new Cc(r):null}_adjustIndex(n,e=0){return n??this.length+e}};function FT(t){return t[8]}function fx(t){return t[8]||(t[8]=[])}function OT(t,n){let e;const r=n[t.index];if(js(r))e=r;else{let s;if(8&t.type)s=An(r);else{const o=n[11];s=o.createComment("");const i=ss(t,n);ma(o,Ff(o,i),s,function o3(t,n){return t.nextSibling(n)}(o,i),!1)}n[t.index]=e=TE(r,n,s,t),Zf(n,e)}return new $T(e,t,n)}class px{constructor(n){this.queryList=n,this.matches=null}clone(){return new px(this.queryList)}setDirty(){this.queryList.setDirty()}}class mx{constructor(n=[]){this.queries=n}createEmbeddedView(n){const e=n.queries;if(null!==e){const r=null!==n.contentQueries?n.contentQueries[0]:e.length,s=[];for(let o=0;o<r;o++){const i=e.getByIndex(o);s.push(this.queries[i.indexInDeclarationView].clone())}return new mx(s)}return null}insertView(n){this.dirtyQueriesWithMatches(n)}detachView(n){this.dirtyQueriesWithMatches(n)}dirtyQueriesWithMatches(n){for(let e=0;e<this.queries.length;e++)null!==UT(n,e).matches&&this.queries[e].setDirty()}}class MT{constructor(n,e,r=null){this.predicate=n,this.flags=e,this.read=r}}class gx{constructor(n=[]){this.queries=n}elementStart(n,e){for(let r=0;r<this.queries.length;r++)this.queries[r].elementStart(n,e)}elementEnd(n){for(let e=0;e<this.queries.length;e++)this.queries[e].elementEnd(n)}embeddedTView(n){let e=null;for(let r=0;r<this.length;r++){const s=null!==e?e.length:0,o=this.getByIndex(r).embeddedTView(n,s);o&&(o.indexInDeclarationView=r,null!==e?e.push(o):e=[o])}return null!==e?new gx(e):null}template(n,e){for(let r=0;r<this.queries.length;r++)this.queries[r].template(n,e)}getByIndex(n){return this.queries[n]}get length(){return this.queries.length}track(n){this.queries.push(n)}}class yx{constructor(n,e=-1){this.metadata=n,this.matches=null,this.indexInDeclarationView=-1,this.crossesNgTemplate=!1,this._appliesToNextNode=!0,this._declarationNodeIndex=e}elementStart(n,e){this.isApplyingToNode(e)&&this.matchTNode(n,e)}elementEnd(n){this._declarationNodeIndex===n.index&&(this._appliesToNextNode=!1)}template(n,e){this.elementStart(n,e)}embeddedTView(n,e){return this.isApplyingToNode(n)?(this.crossesNgTemplate=!0,this.addMatch(-n.index,e),new yx(this.metadata)):null}isApplyingToNode(n){if(this._appliesToNextNode&&1!=(1&this.metadata.flags)){const e=this._declarationNodeIndex;let r=n.parent;for(;null!==r&&8&r.type&&r.index!==e;)r=r.parent;return e===(null!==r?r.index:-1)}return this._appliesToNextNode}matchTNode(n,e){const r=this.metadata.predicate;if(Array.isArray(r))for(let s=0;s<r.length;s++){const o=r[s];this.matchTNodeWithReadOption(n,e,xH(e,o)),this.matchTNodeWithReadOption(n,e,Nf(e,n,o,!1,!1))}else r===Xo?4&e.type&&this.matchTNodeWithReadOption(n,e,-1):this.matchTNodeWithReadOption(n,e,Nf(e,n,r,!1,!1))}matchTNodeWithReadOption(n,e,r){if(null!==r){const s=this.metadata.read;if(null!==s)if(s===_i||s===Js||s===Xo&&4&e.type)this.addMatch(e.index,-2);else{const o=Nf(e,n,s,!1,!1);null!==o&&this.addMatch(e.index,o)}else this.addMatch(e.index,r)}}addMatch(n,e){null===this.matches?this.matches=[n,e]:this.matches.push(n,e)}}function xH(t,n){const e=t.localNames;if(null!==e)for(let r=0;r<e.length;r+=2)if(e[r]===n)return e[r+1];return null}function CH(t,n,e,r){return-1===e?function wH(t,n){return 11&t.type?_l(t,n):4&t.type?cp(t,n):null}(n,t):-2===e?function IH(t,n,e){return e===_i?_l(n,t):e===Xo?cp(n,t):e===Js?OT(n,t):void 0}(t,n,r):ml(t,t[1],e,n)}function PT(t,n,e,r){const s=n[19].queries[r];if(null===s.matches){const o=t.data,i=e.matches,a=[];for(let l=0;l<i.length;l+=2){const u=i[l];a.push(u<0?null:CH(n,o[u],i[l+1],e.metadata.read))}s.matches=a}return s.matches}function bx(t,n,e,r){const s=t.queries.getByIndex(e),o=s.matches;if(null!==o){const i=PT(t,n,s,e);for(let a=0;a<o.length;a+=2){const l=o[a];if(l>0)r.push(i[a/2]);else{const u=o[a+1],c=n[-l];for(let d=10;d<c.length;d++){const h=c[d];h[17]===h[3]&&bx(h[1],h,u,r)}if(null!==c[9]){const d=c[9];for(let h=0;h<d.length;h++){const f=d[h];bx(f[1],f,u,r)}}}}}return r}function vx(t){const n=oe(),e=St(),r=pS();Cb(r+1);const s=UT(e,r);if(t.dirty&&function kB(t){return 4==(4&t[2])}(n)===(2==(2&s.metadata.flags))){if(null===s.matches)t.reset([]);else{const o=s.crossesNgTemplate?bx(e,n,r,[]):PT(e,n,s,r);t.reset(o,X3),t.notifyOnChanges()}return!0}return!1}function LT(t,n,e){const r=St();r.firstCreatePass&&(function VT(t,n,e){null===t.queries&&(t.queries=new gx),t.queries.track(new yx(n,e))}(r,new MT(t,n,e),-1),2==(2&n)&&(r.staticViewQueries=!0)),function zT(t,n,e){const r=new hx(4==(4&e));IE(t,n,r,r.destroy),null===n[19]&&(n[19]=new mx),n[19].queries.push(new px(r))}(r,oe(),n)}function UT(t,n){return t.queries.getByIndex(n)}function hp(...t){}const fp=new qe("Application Initializer");let pp=(()=>{class t{constructor(e){this.appInits=e,this.resolve=hp,this.reject=hp,this.initialized=!1,this.done=!1,this.donePromise=new Promise((r,s)=>{this.resolve=r,this.reject=s})}runInitializers(){if(this.initialized)return;const e=[],r=()=>{this.done=!0,this.resolve()};if(this.appInits)for(let s=0;s<this.appInits.length;s++){const o=this.appInits[s]();if(rp(o))e.push(o);else if(QE(o)){const i=new Promise((a,l)=>{o.subscribe({complete:a,error:l})});e.push(i)}}Promise.all(e).then(()=>{r()}).catch(s=>{this.reject(s)}),0===e.length&&r(),this.initialized=!0}}return t.\u0275fac=function(e){return new(e||t)(Ue(fp,8))},t.\u0275prov=ht({token:t,factory:t.\u0275fac,providedIn:"root"}),t})();const Lc=new qe("AppId",{providedIn:"root",factory:function ak(){return`${_x()}${_x()}${_x()}`}});function _x(){return String.fromCharCode(97+Math.floor(25*Math.random()))}const lk=new qe("Platform Initializer"),uk=new qe("Platform ID",{providedIn:"platform",factory:()=>"unknown"}),ck=new qe("appBootstrapListener");let jH=(()=>{class t{log(e){console.log(e)}warn(e){console.warn(e)}}return t.\u0275fac=function(e){return new(e||t)},t.\u0275prov=ht({token:t,factory:t.\u0275fac,providedIn:"platform"}),t})();const Yo=new qe("LocaleId",{providedIn:"root",factory:()=>jt(Yo,je.Optional|je.SkipSelf)||function qH(){return typeof $localize<"u"&&$localize.locale||Ul}()});class XH{constructor(n,e){this.ngModuleFactory=n,this.componentFactories=e}}let Sx=(()=>{class t{compileModuleSync(e){return new ux(e)}compileModuleAsync(e){return Promise.resolve(this.compileModuleSync(e))}compileModuleAndAllComponentsSync(e){const r=this.compileModuleSync(e),o=jo(ns(e).declarations).reduce((i,a)=>{const l=Ot(a);return l&&i.push(new Ic(l)),i},[]);return new XH(r,o)}compileModuleAndAllComponentsAsync(e){return Promise.resolve(this.compileModuleAndAllComponentsSync(e))}clearCache(){}clearCacheFor(e){}getModuleId(e){}}return t.\u0275fac=function(e){return new(e||t)},t.\u0275prov=ht({token:t,factory:t.\u0275fac,providedIn:"root"}),t})();const QH=(()=>Promise.resolve(0))();function Ex(t){typeof Zone>"u"?QH.then(()=>{t&&t.apply(null,null)}):Zone.current.scheduleMicroTask("scheduleMicrotask",t)}class On{constructor({enableLongStackTrace:n=!1,shouldCoalesceEventChangeDetection:e=!1,shouldCoalesceRunChangeDetection:r=!1}){if(this.hasPendingMacrotasks=!1,this.hasPendingMicrotasks=!1,this.isStable=!0,this.onUnstable=new Ir(!1),this.onMicrotaskEmpty=new Ir(!1),this.onStable=new Ir(!1),this.onError=new Ir(!1),typeof Zone>"u")throw new xe(908,!1);Zone.assertZonePatched();const s=this;s._nesting=0,s._outer=s._inner=Zone.current,Zone.TaskTrackingZoneSpec&&(s._inner=s._inner.fork(new Zone.TaskTrackingZoneSpec)),n&&Zone.longStackTraceZoneSpec&&(s._inner=s._inner.fork(Zone.longStackTraceZoneSpec)),s.shouldCoalesceEventChangeDetection=!r&&e,s.shouldCoalesceRunChangeDetection=r,s.lastRequestAnimationFrameId=-1,s.nativeRequestAnimationFrame=function JH(){let t=Yt.requestAnimationFrame,n=Yt.cancelAnimationFrame;if(typeof Zone<"u"&&t&&n){const e=t[Zone.__symbol__("OriginalDelegate")];e&&(t=e);const r=n[Zone.__symbol__("OriginalDelegate")];r&&(n=r)}return{nativeRequestAnimationFrame:t,nativeCancelAnimationFrame:n}}().nativeRequestAnimationFrame,function nG(t){const n=()=>{!function tG(t){t.isCheckStableRunning||-1!==t.lastRequestAnimationFrameId||(t.lastRequestAnimationFrameId=t.nativeRequestAnimationFrame.call(Yt,()=>{t.fakeTopEventTask||(t.fakeTopEventTask=Zone.root.scheduleEventTask("fakeTopEventTask",()=>{t.lastRequestAnimationFrameId=-1,Tx(t),t.isCheckStableRunning=!0,Nx(t),t.isCheckStableRunning=!1},void 0,()=>{},()=>{})),t.fakeTopEventTask.invoke()}),Tx(t))}(t)};t._inner=t._inner.fork({name:"angular",properties:{isAngularZone:!0},onInvokeTask:(e,r,s,o,i,a)=>{try{return fk(t),e.invokeTask(s,o,i,a)}finally{(t.shouldCoalesceEventChangeDetection&&"eventTask"===o.type||t.shouldCoalesceRunChangeDetection)&&n(),pk(t)}},onInvoke:(e,r,s,o,i,a,l)=>{try{return fk(t),e.invoke(s,o,i,a,l)}finally{t.shouldCoalesceRunChangeDetection&&n(),pk(t)}},onHasTask:(e,r,s,o)=>{e.hasTask(s,o),r===s&&("microTask"==o.change?(t._hasPendingMicrotasks=o.microTask,Tx(t),Nx(t)):"macroTask"==o.change&&(t.hasPendingMacrotasks=o.macroTask))},onHandleError:(e,r,s,o)=>(e.handleError(s,o),t.runOutsideAngular(()=>t.onError.emit(o)),!1)})}(s)}static isInAngularZone(){return typeof Zone<"u"&&!0===Zone.current.get("isAngularZone")}static assertInAngularZone(){if(!On.isInAngularZone())throw new xe(909,!1)}static assertNotInAngularZone(){if(On.isInAngularZone())throw new xe(909,!1)}run(n,e,r){return this._inner.run(n,e,r)}runTask(n,e,r,s){const o=this._inner,i=o.scheduleEventTask("NgZoneEvent: "+s,n,eG,hp,hp);try{return o.runTask(i,e,r)}finally{o.cancelTask(i)}}runGuarded(n,e,r){return this._inner.runGuarded(n,e,r)}runOutsideAngular(n){return this._outer.run(n)}}const eG={};function Nx(t){if(0==t._nesting&&!t.hasPendingMicrotasks&&!t.isStable)try{t._nesting++,t.onMicrotaskEmpty.emit(null)}finally{if(t._nesting--,!t.hasPendingMicrotasks)try{t.runOutsideAngular(()=>t.onStable.emit(null))}finally{t.isStable=!0}}}function Tx(t){t.hasPendingMicrotasks=!!(t._hasPendingMicrotasks||(t.shouldCoalesceEventChangeDetection||t.shouldCoalesceRunChangeDetection)&&-1!==t.lastRequestAnimationFrameId)}function fk(t){t._nesting++,t.isStable&&(t.isStable=!1,t.onUnstable.emit(null))}function pk(t){t._nesting--,Nx(t)}class rG{constructor(){this.hasPendingMicrotasks=!1,this.hasPendingMacrotasks=!1,this.isStable=!0,this.onUnstable=new Ir,this.onMicrotaskEmpty=new Ir,this.onStable=new Ir,this.onError=new Ir}run(n,e,r){return n.apply(e,r)}runGuarded(n,e,r){return n.apply(e,r)}runOutsideAngular(n){return n()}runTask(n,e,r,s){return n.apply(e,r)}}const mk=new qe(""),mp=new qe("");let Rx,kx=(()=>{class t{constructor(e,r,s){this._ngZone=e,this.registry=r,this._pendingCount=0,this._isZoneStable=!0,this._didWork=!1,this._callbacks=[],this.taskTrackingZone=null,Rx||(function sG(t){Rx=t}(s),s.addToWindow(r)),this._watchAngularEvents(),e.run(()=>{this.taskTrackingZone=typeof Zone>"u"?null:Zone.current.get("TaskTrackingZone")})}_watchAngularEvents(){this._ngZone.onUnstable.subscribe({next:()=>{this._didWork=!0,this._isZoneStable=!1}}),this._ngZone.runOutsideAngular(()=>{this._ngZone.onStable.subscribe({next:()=>{On.assertNotInAngularZone(),Ex(()=>{this._isZoneStable=!0,this._runCallbacksIfReady()})}})})}increasePendingRequestCount(){return this._pendingCount+=1,this._didWork=!0,this._pendingCount}decreasePendingRequestCount(){if(this._pendingCount-=1,this._pendingCount<0)throw new Error("pending async requests below zero");return this._runCallbacksIfReady(),this._pendingCount}isStable(){return this._isZoneStable&&0===this._pendingCount&&!this._ngZone.hasPendingMacrotasks}_runCallbacksIfReady(){if(this.isStable())Ex(()=>{for(;0!==this._callbacks.length;){let e=this._callbacks.pop();clearTimeout(e.timeoutId),e.doneCb(this._didWork)}this._didWork=!1});else{let e=this.getPendingTasks();this._callbacks=this._callbacks.filter(r=>!r.updateCb||!r.updateCb(e)||(clearTimeout(r.timeoutId),!1)),this._didWork=!0}}getPendingTasks(){return this.taskTrackingZone?this.taskTrackingZone.macroTasks.map(e=>({source:e.source,creationLocation:e.creationLocation,data:e.data})):[]}addCallback(e,r,s){let o=-1;r&&r>0&&(o=setTimeout(()=>{this._callbacks=this._callbacks.filter(i=>i.timeoutId!==o),e(this._didWork,this.getPendingTasks())},r)),this._callbacks.push({doneCb:e,timeoutId:o,updateCb:s})}whenStable(e,r,s){if(s&&!this.taskTrackingZone)throw new Error('Task tracking zone is required when passing an update callback to whenStable(). Is "zone.js/plugins/task-tracking" loaded?');this.addCallback(e,r,s),this._runCallbacksIfReady()}getPendingRequestCount(){return this._pendingCount}registerApplication(e){this.registry.registerApplication(e,this)}unregisterApplication(e){this.registry.unregisterApplication(e)}findProviders(e,r,s){return[]}}return t.\u0275fac=function(e){return new(e||t)(Ue(On),Ue(Ax),Ue(mp))},t.\u0275prov=ht({token:t,factory:t.\u0275fac}),t})(),Ax=(()=>{class t{constructor(){this._applications=new Map}registerApplication(e,r){this._applications.set(e,r)}unregisterApplication(e){this._applications.delete(e)}unregisterAllApplications(){this._applications.clear()}getTestability(e){return this._applications.get(e)||null}getAllTestabilities(){return Array.from(this._applications.values())}getAllRootElements(){return Array.from(this._applications.keys())}findTestabilityInTree(e,r=!0){return Rx?.findTestabilityInTree(this,e,r)??null}}return t.\u0275fac=function(e){return new(e||t)},t.\u0275prov=ht({token:t,factory:t.\u0275fac,providedIn:"platform"}),t})(),Ni=null;const gk=new qe("AllowMultipleToken"),$x=new qe("PlatformDestroyListeners");class yk{constructor(n,e){this.name=n,this.token=e}}function vk(t,n,e=[]){const r=`Platform: ${n}`,s=new qe(r);return(o=[])=>{let i=Fx();if(!i||i.injector.get(gk,!1)){const a=[...e,...o,{provide:s,useValue:!0}];t?t(a):function aG(t){if(Ni&&!Ni.get(gk,!1))throw new xe(400,!1);Ni=t;const n=t.get(wk);(function bk(t){const n=t.get(lk,null);n&&n.forEach(e=>e())})(t)}(function xk(t=[],n){return Xs.create({name:n,providers:[{provide:fv,useValue:"platform"},{provide:$x,useValue:new Set([()=>Ni=null])},...t]})}(a,r))}return function uG(t){const n=Fx();if(!n)throw new xe(401,!1);return n}()}}function Fx(){return Ni?.get(wk)??null}let wk=(()=>{class t{constructor(e){this._injector=e,this._modules=[],this._destroyListeners=[],this._destroyed=!1}bootstrapModuleFactory(e,r){const s=function Ik(t,n){let e;return e="noop"===t?new rG:("zone.js"===t?void 0:t)||new On(n),e}(r?.ngZone,function Ck(t){return{enableLongStackTrace:!1,shouldCoalesceEventChangeDetection:!(!t||!t.ngZoneEventCoalescing)||!1,shouldCoalesceRunChangeDetection:!(!t||!t.ngZoneRunCoalescing)||!1}}(r)),o=[{provide:On,useValue:s}];return s.run(()=>{const i=Xs.create({providers:o,parent:this.injector,name:e.moduleType.name}),a=e.create(i),l=a.injector.get(Sl,null);if(!l)throw new xe(402,!1);return s.runOutsideAngular(()=>{const u=s.onError.subscribe({next:c=>{l.handleError(c)}});a.onDestroy(()=>{yp(this._modules,a),u.unsubscribe()})}),function Dk(t,n,e){try{const r=e();return rp(r)?r.catch(s=>{throw n.runOutsideAngular(()=>t.handleError(s)),s}):r}catch(r){throw n.runOutsideAngular(()=>t.handleError(r)),r}}(l,s,()=>{const u=a.injector.get(pp);return u.runInitializers(),u.donePromise.then(()=>(function KN(t){ts(t,"Expected localeId to be defined"),"string"==typeof t&&(qN=t.toLowerCase().replace(/_/g,"-"))}(a.injector.get(Yo,Ul)||Ul),this._moduleDoBootstrap(a),a))})})}bootstrapModule(e,r=[]){const s=_k({},r);return function oG(t,n,e){const r=new ux(e);return Promise.resolve(r)}(0,0,e).then(o=>this.bootstrapModuleFactory(o,s))}_moduleDoBootstrap(e){const r=e.injector.get(gp);if(e._bootstrapComponents.length>0)e._bootstrapComponents.forEach(s=>r.bootstrap(s));else{if(!e.instance.ngDoBootstrap)throw new xe(403,!1);e.instance.ngDoBootstrap(r)}this._modules.push(e)}onDestroy(e){this._destroyListeners.push(e)}get injector(){return this._injector}destroy(){if(this._destroyed)throw new xe(404,!1);this._modules.slice().forEach(r=>r.destroy()),this._destroyListeners.forEach(r=>r());const e=this._injector.get($x,null);e&&(e.forEach(r=>r()),e.clear()),this._destroyed=!0}get destroyed(){return this._destroyed}}return t.\u0275fac=function(e){return new(e||t)(Ue(Xs))},t.\u0275prov=ht({token:t,factory:t.\u0275fac,providedIn:"platform"}),t})();function _k(t,n){return Array.isArray(n)?n.reduce(_k,t):{...t,...n}}let gp=(()=>{class t{constructor(e,r,s){this._zone=e,this._injector=r,this._exceptionHandler=s,this._bootstrapListeners=[],this._views=[],this._runningTick=!1,this._stable=!0,this._destroyed=!1,this._destroyListeners=[],this.componentTypes=[],this.components=[],this._onMicrotaskEmptySubscription=this._zone.onMicrotaskEmpty.subscribe({next:()=>{this._zone.run(()=>{this.tick()})}});const o=new Un(a=>{this._stable=this._zone.isStable&&!this._zone.hasPendingMacrotasks&&!this._zone.hasPendingMicrotasks,this._zone.runOutsideAngular(()=>{a.next(this._stable),a.complete()})}),i=new Un(a=>{let l;this._zone.runOutsideAngular(()=>{l=this._zone.onStable.subscribe(()=>{On.assertNotInAngularZone(),Ex(()=>{!this._stable&&!this._zone.hasPendingMacrotasks&&!this._zone.hasPendingMicrotasks&&(this._stable=!0,a.next(!0))})})});const u=this._zone.onUnstable.subscribe(()=>{On.assertInAngularZone(),this._stable&&(this._stable=!1,this._zone.runOutsideAngular(()=>{a.next(!1)}))});return()=>{l.unsubscribe(),u.unsubscribe()}});this.isStable=function jL(...t){const n=Ku(t),e=function BL(t,n){return"number"==typeof Yy(t)?t.pop():n}(t,1/0),r=t;return r.length?1===r.length?fo(r[0]):sl(e)(Wn(r,n)):Bo}(o,i.pipe(function qL(t={}){const{connector:n=(()=>new Po),resetOnError:e=!0,resetOnComplete:r=!0,resetOnRefCountZero:s=!0}=t;return o=>{let i,a,l,u=0,c=!1,d=!1;const h=()=>{a?.unsubscribe(),a=void 0},f=()=>{h(),i=l=void 0,c=d=!1},p=()=>{const m=i;f(),m?.unsubscribe()};return nr((m,g)=>{u++,!d&&!c&&h();const y=l=l??n();g.add(()=>{u--,0===u&&!d&&!c&&(a=Zy(p,s))}),y.subscribe(g),!i&&u>0&&(i=new qu({next:b=>y.next(b),error:b=>{d=!0,h(),a=Zy(f,e,b),y.error(b)},complete:()=>{c=!0,h(),a=Zy(f,r),y.complete()}}),fo(m).subscribe(i))})(o)}}()))}get destroyed(){return this._destroyed}get injector(){return this._injector}bootstrap(e,r){const s=e instanceof W1;if(!this._injector.get(pp).done)throw!s&&function al(t){const n=Ot(t)||br(t)||kr(t);return null!==n&&n.standalone}(e),new xe(405,false);let i;i=s?e:this._injector.get(xc).resolveComponentFactory(e),this.componentTypes.push(i.componentType);const a=function iG(t){return t.isBoundToModule}(i)?void 0:this._injector.get(Ca),u=i.create(Xs.NULL,[],r||i.selector,a),c=u.location.nativeElement,d=u.injector.get(mk,null);return d?.registerApplication(c),u.onDestroy(()=>{this.detachView(u.hostView),yp(this.components,u),d?.unregisterApplication(c)}),this._loadComponent(u),u}tick(){if(this._runningTick)throw new xe(101,!1);try{this._runningTick=!0;for(let e of this._views)e.detectChanges()}catch(e){this._zone.runOutsideAngular(()=>this._exceptionHandler.handleError(e))}finally{this._runningTick=!1}}attachView(e){const r=e;this._views.push(r),r.attachToAppRef(this)}detachView(e){const r=e;yp(this._views,r),r.detachFromAppRef()}_loadComponent(e){this.attachView(e.hostView),this.tick(),this.components.push(e),this._injector.get(ck,[]).concat(this._bootstrapListeners).forEach(s=>s(e))}ngOnDestroy(){if(!this._destroyed)try{this._destroyListeners.forEach(e=>e()),this._views.slice().forEach(e=>e.destroy()),this._onMicrotaskEmptySubscription.unsubscribe()}finally{this._destroyed=!0,this._views=[],this._bootstrapListeners=[],this._destroyListeners=[]}}onDestroy(e){return this._destroyListeners.push(e),()=>yp(this._destroyListeners,e)}destroy(){if(this._destroyed)throw new xe(406,!1);const e=this._injector;e.destroy&&!e.destroyed&&e.destroy()}get viewCount(){return this._views.length}warnIfDestroyed(){}}return t.\u0275fac=function(e){return new(e||t)(Ue(On),Ue(Di),Ue(Sl))},t.\u0275prov=ht({token:t,factory:t.\u0275fac,providedIn:"root"}),t})();function yp(t,n){const e=t.indexOf(n);e>-1&&t.splice(e,1)}let Ox=(()=>{class t{}return t.__NG_ELEMENT_ID__=dG,t})();function dG(t){return function hG(t,n,e){if(bf(t)&&!e){const r=os(t.index,n);return new Cc(r,r)}return 47&t.type?new Cc(n[16],n):null}(pr(),oe(),16==(16&t))}const _G=vk(null,"core",[]);let SG=(()=>{class t{constructor(e){}}return t.\u0275fac=function(e){return new(e||t)(Ue(gp))},t.\u0275mod=ia({type:t}),t.\u0275inj=vi({}),t})(),wp=null;function Ti(){return wp}class TG{}const Gr=new qe("DocumentToken");let Vx=(()=>{class t{historyGo(e){throw new Error("Not implemented")}}return t.\u0275fac=function(e){return new(e||t)},t.\u0275prov=ht({token:t,factory:function(){return function kG(){return Ue(Mk)}()},providedIn:"platform"}),t})();const AG=new qe("Location Initialized");let Mk=(()=>{class t extends Vx{constructor(e){super(),this._doc=e,this._init()}_init(){this.location=window.location,this._history=window.history}getBaseHrefFromDOM(){return Ti().getBaseHref(this._doc)}onPopState(e){const r=Ti().getGlobalEventTarget(this._doc,"window");return r.addEventListener("popstate",e,!1),()=>r.removeEventListener("popstate",e)}onHashChange(e){const r=Ti().getGlobalEventTarget(this._doc,"window");return r.addEventListener("hashchange",e,!1),()=>r.removeEventListener("hashchange",e)}get href(){return this.location.href}get protocol(){return this.location.protocol}get hostname(){return this.location.hostname}get port(){return this.location.port}get pathname(){return this.location.pathname}get search(){return this.location.search}get hash(){return this.location.hash}set pathname(e){this.location.pathname=e}pushState(e,r,s){Pk()?this._history.pushState(e,r,s):this.location.hash=s}replaceState(e,r,s){Pk()?this._history.replaceState(e,r,s):this.location.hash=s}forward(){this._history.forward()}back(){this._history.back()}historyGo(e=0){this._history.go(e)}getState(){return this._history.state}}return t.\u0275fac=function(e){return new(e||t)(Ue(Gr))},t.\u0275prov=ht({token:t,factory:function(){return function RG(){return new Mk(Ue(Gr))}()},providedIn:"platform"}),t})();function Pk(){return!!window.history.pushState}function Ux(t,n){if(0==t.length)return n;if(0==n.length)return t;let e=0;return t.endsWith("/")&&e++,n.startsWith("/")&&e++,2==e?t+n.substring(1):1==e?t+n:t+"/"+n}function Lk(t){const n=t.match(/#|\?|$/),e=n&&n.index||t.length;return t.slice(0,e-("/"===t[e-1]?1:0))+t.slice(e)}function Qo(t){return t&&"?"!==t[0]?"?"+t:t}let Da=(()=>{class t{historyGo(e){throw new Error("Not implemented")}}return t.\u0275fac=function(e){return new(e||t)},t.\u0275prov=ht({token:t,factory:function(){return jt(zk)},providedIn:"root"}),t})();const Bk=new qe("appBaseHref");let zk=(()=>{class t extends Da{constructor(e,r){super(),this._platformLocation=e,this._removeListenerFns=[],this._baseHref=r??this._platformLocation.getBaseHrefFromDOM()??jt(Gr).location?.origin??""}ngOnDestroy(){for(;this._removeListenerFns.length;)this._removeListenerFns.pop()()}onPopState(e){this._removeListenerFns.push(this._platformLocation.onPopState(e),this._platformLocation.onHashChange(e))}getBaseHref(){return this._baseHref}prepareExternalUrl(e){return Ux(this._baseHref,e)}path(e=!1){const r=this._platformLocation.pathname+Qo(this._platformLocation.search),s=this._platformLocation.hash;return s&&e?`${r}${s}`:r}pushState(e,r,s,o){const i=this.prepareExternalUrl(s+Qo(o));this._platformLocation.pushState(e,r,i)}replaceState(e,r,s,o){const i=this.prepareExternalUrl(s+Qo(o));this._platformLocation.replaceState(e,r,i)}forward(){this._platformLocation.forward()}back(){this._platformLocation.back()}getState(){return this._platformLocation.getState()}historyGo(e=0){this._platformLocation.historyGo?.(e)}}return t.\u0275fac=function(e){return new(e||t)(Ue(Vx),Ue(Bk,8))},t.\u0275prov=ht({token:t,factory:t.\u0275fac,providedIn:"root"}),t})(),$G=(()=>{class t extends Da{constructor(e,r){super(),this._platformLocation=e,this._baseHref="",this._removeListenerFns=[],null!=r&&(this._baseHref=r)}ngOnDestroy(){for(;this._removeListenerFns.length;)this._removeListenerFns.pop()()}onPopState(e){this._removeListenerFns.push(this._platformLocation.onPopState(e),this._platformLocation.onHashChange(e))}getBaseHref(){return this._baseHref}path(e=!1){let r=this._platformLocation.hash;return null==r&&(r="#"),r.length>0?r.substring(1):r}prepareExternalUrl(e){const r=Ux(this._baseHref,e);return r.length>0?"#"+r:r}pushState(e,r,s,o){let i=this.prepareExternalUrl(s+Qo(o));0==i.length&&(i=this._platformLocation.pathname),this._platformLocation.pushState(e,r,i)}replaceState(e,r,s,o){let i=this.prepareExternalUrl(s+Qo(o));0==i.length&&(i=this._platformLocation.pathname),this._platformLocation.replaceState(e,r,i)}forward(){this._platformLocation.forward()}back(){this._platformLocation.back()}getState(){return this._platformLocation.getState()}historyGo(e=0){this._platformLocation.historyGo?.(e)}}return t.\u0275fac=function(e){return new(e||t)(Ue(Vx),Ue(Bk,8))},t.\u0275prov=ht({token:t,factory:t.\u0275fac}),t})(),Wx=(()=>{class t{constructor(e){this._subject=new Ir,this._urlChangeListeners=[],this._urlChangeSubscription=null,this._locationStrategy=e;const r=this._locationStrategy.getBaseHref();this._baseHref=Lk(Vk(r)),this._locationStrategy.onPopState(s=>{this._subject.emit({url:this.path(!0),pop:!0,state:s.state,type:s.type})})}ngOnDestroy(){this._urlChangeSubscription?.unsubscribe(),this._urlChangeListeners=[]}path(e=!1){return this.normalize(this._locationStrategy.path(e))}getState(){return this._locationStrategy.getState()}isCurrentPathEqualTo(e,r=""){return this.path()==this.normalize(e+Qo(r))}normalize(e){return t.stripTrailingSlash(function OG(t,n){return t&&n.startsWith(t)?n.substring(t.length):n}(this._baseHref,Vk(e)))}prepareExternalUrl(e){return e&&"/"!==e[0]&&(e="/"+e),this._locationStrategy.prepareExternalUrl(e)}go(e,r="",s=null){this._locationStrategy.pushState(s,"",e,r),this._notifyUrlChangeListeners(this.prepareExternalUrl(e+Qo(r)),s)}replaceState(e,r="",s=null){this._locationStrategy.replaceState(s,"",e,r),this._notifyUrlChangeListeners(this.prepareExternalUrl(e+Qo(r)),s)}forward(){this._locationStrategy.forward()}back(){this._locationStrategy.back()}historyGo(e=0){this._locationStrategy.historyGo?.(e)}onUrlChange(e){return this._urlChangeListeners.push(e),this._urlChangeSubscription||(this._urlChangeSubscription=this.subscribe(r=>{this._notifyUrlChangeListeners(r.url,r.state)})),()=>{const r=this._urlChangeListeners.indexOf(e);this._urlChangeListeners.splice(r,1),0===this._urlChangeListeners.length&&(this._urlChangeSubscription?.unsubscribe(),this._urlChangeSubscription=null)}}_notifyUrlChangeListeners(e="",r){this._urlChangeListeners.forEach(s=>s(e,r))}subscribe(e,r,s){return this._subject.subscribe({next:e,error:r,complete:s})}}return t.normalizeQueryParams=Qo,t.joinWithSlash=Ux,t.stripTrailingSlash=Lk,t.\u0275fac=function(e){return new(e||t)(Ue(Da))},t.\u0275prov=ht({token:t,factory:function(){return function FG(){return new Wx(Ue(Da))}()},providedIn:"root"}),t})();function Vk(t){return t.replace(/\/index.html$/,"")}let Jk=(()=>{class t{constructor(e,r){this._viewContainer=e,this._context=new Dj,this._thenTemplateRef=null,this._elseTemplateRef=null,this._thenViewRef=null,this._elseViewRef=null,this._thenTemplateRef=r}set ngIf(e){this._context.$implicit=this._context.ngIf=e,this._updateView()}set ngIfThen(e){eA("ngIfThen",e),this._thenTemplateRef=e,this._thenViewRef=null,this._updateView()}set ngIfElse(e){eA("ngIfElse",e),this._elseTemplateRef=e,this._elseViewRef=null,this._updateView()}_updateView(){this._context.$implicit?this._thenViewRef||(this._viewContainer.clear(),this._elseViewRef=null,this._thenTemplateRef&&(this._thenViewRef=this._viewContainer.createEmbeddedView(this._thenTemplateRef,this._context))):this._elseViewRef||(this._viewContainer.clear(),this._thenViewRef=null,this._elseTemplateRef&&(this._elseViewRef=this._viewContainer.createEmbeddedView(this._elseTemplateRef,this._context)))}static ngTemplateContextGuard(e,r){return!0}}return t.\u0275fac=function(e){return new(e||t)(Ke(Js),Ke(Xo))},t.\u0275dir=Tr({type:t,selectors:[["","ngIf",""]],inputs:{ngIf:"ngIf",ngIfThen:"ngIfThen",ngIfElse:"ngIfElse"},standalone:!0}),t})();class Dj{constructor(){this.$implicit=null,this.ngIf=null}}function eA(t,n){if(n&&!n.createEmbeddedView)throw new Error(`${t} must be a TemplateRef, but received '${Gt(n)}'.`)}let Jj=(()=>{class t{}return t.\u0275fac=function(e){return new(e||t)},t.\u0275mod=ia({type:t}),t.\u0275inj=vi({}),t})();let r8=(()=>{class t{}return t.\u0275prov=ht({token:t,providedIn:"root",factory:()=>new s8(Ue(Gr),window)}),t})();class s8{constructor(n,e){this.document=n,this.window=e,this.offset=()=>[0,0]}setOffset(n){this.offset=Array.isArray(n)?()=>n:n}getScrollPosition(){return this.supportsScrolling()?[this.window.pageXOffset,this.window.pageYOffset]:[0,0]}scrollToPosition(n){this.supportsScrolling()&&this.window.scrollTo(n[0],n[1])}scrollToAnchor(n){if(!this.supportsScrolling())return;const e=function o8(t,n){const e=t.getElementById(n)||t.getElementsByName(n)[0];if(e)return e;if("function"==typeof t.createTreeWalker&&t.body&&(t.body.createShadowRoot||t.body.attachShadow)){const r=t.createTreeWalker(t.body,NodeFilter.SHOW_ELEMENT);let s=r.currentNode;for(;s;){const o=s.shadowRoot;if(o){const i=o.getElementById(n)||o.querySelector(`[name="${n}"]`);if(i)return i}s=r.nextNode()}}return null}(this.document,n);e&&(this.scrollToElement(e),e.focus())}setHistoryScrollRestoration(n){if(this.supportScrollRestoration()){const e=this.window.history;e&&e.scrollRestoration&&(e.scrollRestoration=n)}}scrollToElement(n){const e=n.getBoundingClientRect(),r=e.left+this.window.pageXOffset,s=e.top+this.window.pageYOffset,o=this.offset();this.window.scrollTo(r-o[0],s-o[1])}supportScrollRestoration(){try{if(!this.supportsScrolling())return!1;const n=sA(this.window.history)||sA(Object.getPrototypeOf(this.window.history));return!(!n||!n.writable&&!n.set)}catch{return!1}}supportsScrolling(){try{return!!this.window&&!!this.window.scrollTo&&"pageXOffset"in this.window}catch{return!1}}}function sA(t){return Object.getOwnPropertyDescriptor(t,"scrollRestoration")}class $8 extends TG{constructor(){super(...arguments),this.supportsDOMEvents=!0}}class o0 extends $8{static makeCurrent(){!function NG(t){wp||(wp=t)}(new o0)}onAndCancel(n,e,r){return n.addEventListener(e,r,!1),()=>{n.removeEventListener(e,r,!1)}}dispatchEvent(n,e){n.dispatchEvent(e)}remove(n){n.parentNode&&n.parentNode.removeChild(n)}createElement(n,e){return(e=e||this.getDefaultDocument()).createElement(n)}createHtmlDocument(){return document.implementation.createHTMLDocument("fakeTitle")}getDefaultDocument(){return document}isElementNode(n){return n.nodeType===Node.ELEMENT_NODE}isShadowRoot(n){return n instanceof DocumentFragment}getGlobalEventTarget(n,e){return"window"===e?window:"document"===e?n:"body"===e?n.body:null}getBaseHref(n){const e=function F8(){return Wc=Wc||document.querySelector("base"),Wc?Wc.getAttribute("href"):null}();return null==e?null:function O8(t){Rp=Rp||document.createElement("a"),Rp.setAttribute("href",t);const n=Rp.pathname;return"/"===n.charAt(0)?n:`/${n}`}(e)}resetBaseElement(){Wc=null}getUserAgent(){return window.navigator.userAgent}getCookie(n){return function bj(t,n){n=encodeURIComponent(n);for(const e of t.split(";")){const r=e.indexOf("="),[s,o]=-1==r?[e,""]:[e.slice(0,r),e.slice(r+1)];if(s.trim()===n)return decodeURIComponent(o)}return null}(document.cookie,n)}}let Rp,Wc=null;const cA=new qe("TRANSITION_ID"),P8=[{provide:fp,useFactory:function M8(t,n,e){return()=>{e.get(pp).donePromise.then(()=>{const r=Ti(),s=n.querySelectorAll(`style[ng-transition="${t}"]`);for(let o=0;o<s.length;o++)r.remove(s[o])})}},deps:[cA,Gr,Xs],multi:!0}];let B8=(()=>{class t{build(){return new XMLHttpRequest}}return t.\u0275fac=function(e){return new(e||t)},t.\u0275prov=ht({token:t,factory:t.\u0275fac}),t})();const $p=new qe("EventManagerPlugins");let Fp=(()=>{class t{constructor(e,r){this._zone=r,this._eventNameToPlugin=new Map,e.forEach(s=>s.manager=this),this._plugins=e.slice().reverse()}addEventListener(e,r,s){return this._findPluginFor(r).addEventListener(e,r,s)}addGlobalEventListener(e,r,s){return this._findPluginFor(r).addGlobalEventListener(e,r,s)}getZone(){return this._zone}_findPluginFor(e){const r=this._eventNameToPlugin.get(e);if(r)return r;const s=this._plugins;for(let o=0;o<s.length;o++){const i=s[o];if(i.supports(e))return this._eventNameToPlugin.set(e,i),i}throw new Error(`No event manager plugin found for event ${e}`)}}return t.\u0275fac=function(e){return new(e||t)(Ue($p),Ue(On))},t.\u0275prov=ht({token:t,factory:t.\u0275fac}),t})();class dA{constructor(n){this._doc=n}addGlobalEventListener(n,e,r){const s=Ti().getGlobalEventTarget(this._doc,n);if(!s)throw new Error(`Unsupported event target ${s} for event ${e}`);return this.addEventListener(s,e,r)}}let hA=(()=>{class t{constructor(){this._stylesSet=new Set}addStyles(e){const r=new Set;e.forEach(s=>{this._stylesSet.has(s)||(this._stylesSet.add(s),r.add(s))}),this.onStylesAdded(r)}onStylesAdded(e){}getAllStyles(){return Array.from(this._stylesSet)}}return t.\u0275fac=function(e){return new(e||t)},t.\u0275prov=ht({token:t,factory:t.\u0275fac}),t})(),Hc=(()=>{class t extends hA{constructor(e){super(),this._doc=e,this._hostNodes=new Map,this._hostNodes.set(e.head,[])}_addStylesToHost(e,r,s){e.forEach(o=>{const i=this._doc.createElement("style");i.textContent=o,s.push(r.appendChild(i))})}addHost(e){const r=[];this._addStylesToHost(this._stylesSet,e,r),this._hostNodes.set(e,r)}removeHost(e){const r=this._hostNodes.get(e);r&&r.forEach(fA),this._hostNodes.delete(e)}onStylesAdded(e){this._hostNodes.forEach((r,s)=>{this._addStylesToHost(e,s,r)})}ngOnDestroy(){this._hostNodes.forEach(e=>e.forEach(fA))}}return t.\u0275fac=function(e){return new(e||t)(Ue(Gr))},t.\u0275prov=ht({token:t,factory:t.\u0275fac}),t})();function fA(t){Ti().remove(t)}const a0={svg:"http://www.w3.org/2000/svg",xhtml:"http://www.w3.org/1999/xhtml",xlink:"http://www.w3.org/1999/xlink",xml:"http://www.w3.org/XML/1998/namespace",xmlns:"http://www.w3.org/2000/xmlns/",math:"http://www.w3.org/1998/MathML/"},l0=/%COMP%/g;function Op(t,n,e){for(let r=0;r<n.length;r++){let s=n[r];Array.isArray(s)?Op(t,s,e):(s=s.replace(l0,t),e.push(s))}return e}function gA(t){return n=>{if("__ngUnwrap__"===n)return t;!1===t(n)&&(n.preventDefault(),n.returnValue=!1)}}let u0=(()=>{class t{constructor(e,r,s){this.eventManager=e,this.sharedStylesHost=r,this.appId=s,this.rendererByCompId=new Map,this.defaultRenderer=new c0(e)}createRenderer(e,r){if(!e||!r)return this.defaultRenderer;switch(r.encapsulation){case po.Emulated:{let s=this.rendererByCompId.get(r.id);return s||(s=new G8(this.eventManager,this.sharedStylesHost,r,this.appId),this.rendererByCompId.set(r.id,s)),s.applyToHost(e),s}case 1:case po.ShadowDom:return new j8(this.eventManager,this.sharedStylesHost,e,r);default:if(!this.rendererByCompId.has(r.id)){const s=Op(r.id,r.styles,[]);this.sharedStylesHost.addStyles(s),this.rendererByCompId.set(r.id,this.defaultRenderer)}return this.defaultRenderer}}begin(){}end(){}}return t.\u0275fac=function(e){return new(e||t)(Ue(Fp),Ue(Hc),Ue(Lc))},t.\u0275prov=ht({token:t,factory:t.\u0275fac}),t})();class c0{constructor(n){this.eventManager=n,this.data=Object.create(null),this.destroyNode=null}destroy(){}createElement(n,e){return e?document.createElementNS(a0[e]||e,n):document.createElement(n)}createComment(n){return document.createComment(n)}createText(n){return document.createTextNode(n)}appendChild(n,e){(bA(n)?n.content:n).appendChild(e)}insertBefore(n,e,r){n&&(bA(n)?n.content:n).insertBefore(e,r)}removeChild(n,e){n&&n.removeChild(e)}selectRootElement(n,e){let r="string"==typeof n?document.querySelector(n):n;if(!r)throw new Error(`The selector "${n}" did not match any elements`);return e||(r.textContent=""),r}parentNode(n){return n.parentNode}nextSibling(n){return n.nextSibling}setAttribute(n,e,r,s){if(s){e=s+":"+e;const o=a0[s];o?n.setAttributeNS(o,e,r):n.setAttribute(e,r)}else n.setAttribute(e,r)}removeAttribute(n,e,r){if(r){const s=a0[r];s?n.removeAttributeNS(s,e):n.removeAttribute(`${r}:${e}`)}else n.removeAttribute(e)}addClass(n,e){n.classList.add(e)}removeClass(n,e){n.classList.remove(e)}setStyle(n,e,r,s){s&(Wr.DashCase|Wr.Important)?n.style.setProperty(e,r,s&Wr.Important?"important":""):n.style[e]=r}removeStyle(n,e,r){r&Wr.DashCase?n.style.removeProperty(e):n.style[e]=""}setProperty(n,e,r){n[e]=r}setValue(n,e){n.nodeValue=e}listen(n,e,r){return"string"==typeof n?this.eventManager.addGlobalEventListener(n,e,gA(r)):this.eventManager.addEventListener(n,e,gA(r))}}function bA(t){return"TEMPLATE"===t.tagName&&void 0!==t.content}class G8 extends c0{constructor(n,e,r,s){super(n),this.component=r;const o=Op(s+"-"+r.id,r.styles,[]);e.addStyles(o),this.contentAttr=function U8(t){return"_ngcontent-%COMP%".replace(l0,t)}(s+"-"+r.id),this.hostAttr=function W8(t){return"_nghost-%COMP%".replace(l0,t)}(s+"-"+r.id)}applyToHost(n){super.setAttribute(n,this.hostAttr,"")}createElement(n,e){const r=super.createElement(n,e);return super.setAttribute(r,this.contentAttr,""),r}}class j8 extends c0{constructor(n,e,r,s){super(n),this.sharedStylesHost=e,this.hostEl=r,this.shadowRoot=r.attachShadow({mode:"open"}),this.sharedStylesHost.addHost(this.shadowRoot);const o=Op(s.id,s.styles,[]);for(let i=0;i<o.length;i++){const a=document.createElement("style");a.textContent=o[i],this.shadowRoot.appendChild(a)}}nodeOrShadowRoot(n){return n===this.hostEl?this.shadowRoot:n}destroy(){this.sharedStylesHost.removeHost(this.shadowRoot)}appendChild(n,e){return super.appendChild(this.nodeOrShadowRoot(n),e)}insertBefore(n,e,r){return super.insertBefore(this.nodeOrShadowRoot(n),e,r)}removeChild(n,e){return super.removeChild(this.nodeOrShadowRoot(n),e)}parentNode(n){return this.nodeOrShadowRoot(super.parentNode(this.nodeOrShadowRoot(n)))}}let q8=(()=>{class t extends dA{constructor(e){super(e)}supports(e){return!0}addEventListener(e,r,s){return e.addEventListener(r,s,!1),()=>this.removeEventListener(e,r,s)}removeEventListener(e,r,s){return e.removeEventListener(r,s)}}return t.\u0275fac=function(e){return new(e||t)(Ue(Gr))},t.\u0275prov=ht({token:t,factory:t.\u0275fac}),t})();const vA=["alt","control","meta","shift"],K8={"\b":"Backspace","\t":"Tab","\x7f":"Delete","\x1b":"Escape",Del:"Delete",Esc:"Escape",Left:"ArrowLeft",Right:"ArrowRight",Up:"ArrowUp",Down:"ArrowDown",Menu:"ContextMenu",Scroll:"ScrollLock",Win:"OS"},X8={alt:t=>t.altKey,control:t=>t.ctrlKey,meta:t=>t.metaKey,shift:t=>t.shiftKey};let Y8=(()=>{class t extends dA{constructor(e){super(e)}supports(e){return null!=t.parseEventName(e)}addEventListener(e,r,s){const o=t.parseEventName(r),i=t.eventCallback(o.fullKey,s,this.manager.getZone());return this.manager.getZone().runOutsideAngular(()=>Ti().onAndCancel(e,o.domEventName,i))}static parseEventName(e){const r=e.toLowerCase().split("."),s=r.shift();if(0===r.length||"keydown"!==s&&"keyup"!==s)return null;const o=t._normalizeKey(r.pop());let i="",a=r.indexOf("code");if(a>-1&&(r.splice(a,1),i="code."),vA.forEach(u=>{const c=r.indexOf(u);c>-1&&(r.splice(c,1),i+=u+".")}),i+=o,0!=r.length||0===o.length)return null;const l={};return l.domEventName=s,l.fullKey=i,l}static matchEventFullKeyCode(e,r){let s=K8[e.key]||e.key,o="";return r.indexOf("code.")>-1&&(s=e.code,o="code."),!(null==s||!s)&&(s=s.toLowerCase()," "===s?s="space":"."===s&&(s="dot"),vA.forEach(i=>{i!==s&&(0,X8[i])(e)&&(o+=i+".")}),o+=s,o===r)}static eventCallback(e,r,s){return o=>{t.matchEventFullKeyCode(o,e)&&s.runGuarded(()=>r(o))}}static _normalizeKey(e){return"esc"===e?"escape":e}}return t.\u0275fac=function(e){return new(e||t)(Ue(Gr))},t.\u0275prov=ht({token:t,factory:t.\u0275fac}),t})();const e6=vk(_G,"browser",[{provide:uk,useValue:"browser"},{provide:lk,useValue:function Z8(){o0.makeCurrent()},multi:!0},{provide:Gr,useFactory:function J8(){return function f3(t){rv=t}(document),document},deps:[]}]),CA=new qe(""),IA=[{provide:mp,useClass:class L8{addToWindow(n){Yt.getAngularTestability=(r,s=!0)=>{const o=n.findTestabilityInTree(r,s);if(null==o)throw new Error("Could not find testability for element.");return o},Yt.getAllAngularTestabilities=()=>n.getAllTestabilities(),Yt.getAllAngularRootElements=()=>n.getAllRootElements(),Yt.frameworkStabilizers||(Yt.frameworkStabilizers=[]),Yt.frameworkStabilizers.push(r=>{const s=Yt.getAllAngularTestabilities();let o=s.length,i=!1;const a=function(l){i=i||l,o--,0==o&&r(i)};s.forEach(function(l){l.whenStable(a)})})}findTestabilityInTree(n,e,r){return null==e?null:n.getTestability(e)??(r?Ti().isShadowRoot(e)?this.findTestabilityInTree(n,e.host,!0):this.findTestabilityInTree(n,e.parentElement,!0):null)}},deps:[]},{provide:mk,useClass:kx,deps:[On,Ax,mp]},{provide:kx,useClass:kx,deps:[On,Ax,mp]}],DA=[{provide:fv,useValue:"root"},{provide:Sl,useFactory:function Q8(){return new Sl},deps:[]},{provide:$p,useClass:q8,multi:!0,deps:[Gr,On,uk]},{provide:$p,useClass:Y8,multi:!0,deps:[Gr]},{provide:u0,useClass:u0,deps:[Fp,Hc,Lc]},{provide:G1,useExisting:u0},{provide:hA,useExisting:Hc},{provide:Hc,useClass:Hc,deps:[Gr]},{provide:Fp,useClass:Fp,deps:[$p,On]},{provide:class i8{},useClass:B8,deps:[]},[]];let t6=(()=>{class t{constructor(e){}static withServerTransition(e){return{ngModule:t,providers:[{provide:Lc,useValue:e.appId},{provide:cA,useExisting:Lc},P8]}}}return t.\u0275fac=function(e){return new(e||t)(Ue(CA,12))},t.\u0275mod=ia({type:t}),t.\u0275inj=vi({providers:[...DA,...IA],imports:[Jj,SG]}),t})(),_A=(()=>{class t{constructor(e){this._doc=e}getTitle(){return this._doc.title}setTitle(e){this._doc.title=e||""}}return t.\u0275fac=function(e){return new(e||t)(Ue(Gr))},t.\u0275prov=ht({token:t,factory:function(e){let r=null;return r=e?new e:function r6(){return new _A(Ue(Gr))}(),r},providedIn:"root"}),t})();function ze(...t){return Wn(t,Ku(t))}typeof window<"u"&&window;class ro extends Po{constructor(n){super(),this._value=n}get value(){return this.getValue()}_subscribe(n){const e=super._subscribe(n);return!e.closed&&n.next(this._value),e}getValue(){const{hasError:n,thrownError:e,_value:r}=this;if(n)throw e;return this._throwIfClosed(),r}next(n){super.next(this._value=n)}}const Mp=Ye(t=>function(){t(this),this.name="EmptyError",this.message="no elements in sequence"}),{isArray:d6}=Array,{getPrototypeOf:h6,prototype:f6,keys:p6}=Object;const{isArray:y6}=Array;function NA(...t){const n=Ku(t),e=function LL(t){return ae(Yy(t))?t.pop():void 0}(t),{args:r,keys:s}=function m6(t){if(1===t.length){const n=t[0];if(d6(n))return{args:n,keys:null};if(function g6(t){return t&&"object"==typeof t&&h6(t)===f6}(n)){const e=p6(n);return{args:e.map(r=>n[r]),keys:e}}}return{args:t,keys:null}}(t);if(0===r.length)return Wn([],n);const o=new Un(function w6(t,n,e=sa){return r=>{TA(n,()=>{const{length:s}=t,o=new Array(s);let i=s,a=s;for(let l=0;l<s;l++)TA(n,()=>{const u=Wn(t[l],n);let c=!1;u.subscribe(rr(r,d=>{o[l]=d,c||(c=!0,a--),a||r.next(e(o.slice()))},()=>{--i||r.complete()}))},r)},r)}}(r,n,s?i=>function x6(t,n){return t.reduce((e,r,s)=>(e[r]=n[s],e),{})}(s,i):sa));return e?o.pipe(function v6(t){return It(n=>function b6(t,n){return y6(n)?t(...n):t(n)}(t,n))}(e)):o}function TA(t,n,e){t?Lo(e,t,n):n()}function f0(...t){return function C6(){return sl(1)}()(Wn(t,Ku(t)))}function kA(t){return new Un(n=>{fo(t()).subscribe(n)})}function Gc(t,n){const e=ae(t)?t:()=>t,r=s=>s.error(e());return new Un(n?s=>n.schedule(r,0,s):r)}function p0(){return nr((t,n)=>{let e=null;t._refCount++;const r=rr(n,void 0,void 0,void 0,()=>{if(!t||t._refCount<=0||0<--t._refCount)return void(e=null);const s=t._connection,o=e;e=null,s&&(!o||s===o)&&s.unsubscribe(),n.unsubscribe()});t.subscribe(r),r.closed||(e=t.connect())})}class AA extends Un{constructor(n,e){super(),this.source=n,this.subjectFactory=e,this._subject=null,this._refCount=0,this._connection=null,E_(n)&&(this.lift=n.lift)}_subscribe(n){return this.getSubject().subscribe(n)}getSubject(){const n=this._subject;return(!n||n.isStopped)&&(this._subject=this.subjectFactory()),this._subject}_teardown(){this._refCount=0;const{_connection:n}=this;this._subject=this._connection=null,n?.unsubscribe()}connect(){let n=this._connection;if(!n){n=this._connection=new Ve;const e=this.getSubject();n.add(this.source.subscribe(rr(e,void 0,()=>{this._teardown(),e.complete()},r=>{this._teardown(),e.error(r)},()=>this._teardown()))),n.closed&&(this._connection=null,n=Ve.EMPTY)}return n}refCount(){return p0()(this)}}function wo(t,n){return nr((e,r)=>{let s=null,o=0,i=!1;const a=()=>i&&!s&&r.complete();e.subscribe(rr(r,l=>{s?.unsubscribe();let u=0;const c=o++;fo(t(l,c)).subscribe(s=rr(r,d=>r.next(n?n(l,d,c,u++):d),()=>{s=null,a()}))},()=>{i=!0,a()}))})}function jc(t){return t<=0?()=>Bo:nr((n,e)=>{let r=0;n.subscribe(rr(e,s=>{++r<=t&&(e.next(s),t<=r&&e.complete())}))})}function Ai(t,n){return nr((e,r)=>{let s=0;e.subscribe(rr(r,o=>t.call(n,o,s++)&&r.next(o)))})}function Pp(t){return nr((n,e)=>{let r=!1;n.subscribe(rr(e,s=>{r=!0,e.next(s)},()=>{r||e.next(t),e.complete()}))})}function RA(t=D6){return nr((n,e)=>{let r=!1;n.subscribe(rr(e,s=>{r=!0,e.next(s)},()=>r?e.complete():e.error(t())))})}function D6(){return new Mp}function Ri(t,n){const e=arguments.length>=2;return r=>r.pipe(t?Ai((s,o)=>t(s,o,r)):sa,jc(1),e?Pp(n):RA(()=>new Mp))}function _a(t,n){return ae(n)?fr(t,n,1):fr(t,1)}function Dr(t,n,e){const r=ae(t)||n||e?{next:t,error:n,complete:e}:t;return r?nr((s,o)=>{var i;null===(i=r.subscribe)||void 0===i||i.call(r);let a=!0;s.subscribe(rr(o,l=>{var u;null===(u=r.next)||void 0===u||u.call(r,l),o.next(l)},()=>{var l;a=!1,null===(l=r.complete)||void 0===l||l.call(r),o.complete()},l=>{var u;a=!1,null===(u=r.error)||void 0===u||u.call(r,l),o.error(l)},()=>{var l,u;a&&(null===(l=r.unsubscribe)||void 0===l||l.call(r)),null===(u=r.finalize)||void 0===u||u.call(r)}))}):sa}function $i(t){return nr((n,e)=>{let o,r=null,s=!1;r=n.subscribe(rr(e,void 0,void 0,i=>{o=fo(t(i,$i(t)(n))),r?(r.unsubscribe(),r=null,o.subscribe(e)):s=!0})),s&&(r.unsubscribe(),r=null,o.subscribe(e))})}function _6(t,n,e,r,s){return(o,i)=>{let a=e,l=n,u=0;o.subscribe(rr(i,c=>{const d=u++;l=a?t(l,c,d):(a=!0,c),r&&i.next(l)},s&&(()=>{a&&i.next(l),i.complete()})))}}function $A(t,n){return nr(_6(t,n,arguments.length>=2,!0))}function m0(t){return t<=0?()=>Bo:nr((n,e)=>{let r=[];n.subscribe(rr(e,s=>{r.push(s),t<r.length&&r.shift()},()=>{for(const s of r)e.next(s);e.complete()},void 0,()=>{r=null}))})}function FA(t,n){const e=arguments.length>=2;return r=>r.pipe(t?Ai((s,o)=>t(s,o,r)):sa,m0(1),e?Pp(n):RA(()=>new Mp))}function g0(t){return nr((n,e)=>{try{n.subscribe(e)}finally{e.add(t)}})}const pt="primary",qc=Symbol("RouteTitle");class N6{constructor(n){this.params=n||{}}has(n){return Object.prototype.hasOwnProperty.call(this.params,n)}get(n){if(this.has(n)){const e=this.params[n];return Array.isArray(e)?e[0]:e}return null}getAll(n){if(this.has(n)){const e=this.params[n];return Array.isArray(e)?e:[e]}return[]}get keys(){return Object.keys(this.params)}}function Gl(t){return new N6(t)}function T6(t,n,e){const r=e.path.split("/");if(r.length>t.length||"full"===e.pathMatch&&(n.hasChildren()||r.length<t.length))return null;const s={};for(let o=0;o<r.length;o++){const i=r[o],a=t[o];if(i.startsWith(":"))s[i.substring(1)]=a;else if(i!==a.path)return null}return{consumed:t.slice(0,r.length),posParams:s}}function Co(t,n){const e=t?Object.keys(t):void 0,r=n?Object.keys(n):void 0;if(!e||!r||e.length!=r.length)return!1;let s;for(let o=0;o<e.length;o++)if(s=e[o],!OA(t[s],n[s]))return!1;return!0}function OA(t,n){if(Array.isArray(t)&&Array.isArray(n)){if(t.length!==n.length)return!1;const e=[...t].sort(),r=[...n].sort();return e.every((s,o)=>r[o]===s)}return t===n}function MA(t){return Array.prototype.concat.apply([],t)}function PA(t){return t.length>0?t[t.length-1]:null}function mr(t,n){for(const e in t)t.hasOwnProperty(e)&&n(t[e],e)}function Fi(t){return QE(t)?t:rp(t)?Wn(Promise.resolve(t)):ze(t)}const Lp=!1,A6={exact:function zA(t,n,e){if(!Ea(t.segments,n.segments)||!Bp(t.segments,n.segments,e)||t.numberOfChildren!==n.numberOfChildren)return!1;for(const r in n.children)if(!t.children[r]||!zA(t.children[r],n.children[r],e))return!1;return!0},subset:VA},LA={exact:function R6(t,n){return Co(t,n)},subset:function $6(t,n){return Object.keys(n).length<=Object.keys(t).length&&Object.keys(n).every(e=>OA(t[e],n[e]))},ignored:()=>!0};function BA(t,n,e){return A6[e.paths](t.root,n.root,e.matrixParams)&&LA[e.queryParams](t.queryParams,n.queryParams)&&!("exact"===e.fragment&&t.fragment!==n.fragment)}function VA(t,n,e){return UA(t,n,n.segments,e)}function UA(t,n,e,r){if(t.segments.length>e.length){const s=t.segments.slice(0,e.length);return!(!Ea(s,e)||n.hasChildren()||!Bp(s,e,r))}if(t.segments.length===e.length){if(!Ea(t.segments,e)||!Bp(t.segments,e,r))return!1;for(const s in n.children)if(!t.children[s]||!VA(t.children[s],n.children[s],r))return!1;return!0}{const s=e.slice(0,t.segments.length),o=e.slice(t.segments.length);return!!(Ea(t.segments,s)&&Bp(t.segments,s,r)&&t.children[pt])&&UA(t.children[pt],n,o,r)}}function Bp(t,n,e){return n.every((r,s)=>LA[e](t[s].parameters,r.parameters))}class Sa{constructor(n=new gt([],{}),e={},r=null){this.root=n,this.queryParams=e,this.fragment=r}get queryParamMap(){return this._queryParamMap||(this._queryParamMap=Gl(this.queryParams)),this._queryParamMap}toString(){return M6.serialize(this)}}class gt{constructor(n,e){this.segments=n,this.children=e,this.parent=null,mr(e,(r,s)=>r.parent=this)}hasChildren(){return this.numberOfChildren>0}get numberOfChildren(){return Object.keys(this.children).length}toString(){return zp(this)}}class Kc{constructor(n,e){this.path=n,this.parameters=e}get parameterMap(){return this._parameterMap||(this._parameterMap=Gl(this.parameters)),this._parameterMap}toString(){return jA(this)}}function Ea(t,n){return t.length===n.length&&t.every((e,r)=>e.path===n[r].path)}let WA=(()=>{class t{}return t.\u0275fac=function(e){return new(e||t)},t.\u0275prov=ht({token:t,factory:function(){return new y0},providedIn:"root"}),t})();class y0{parse(n){const e=new G6(n);return new Sa(e.parseRootSegment(),e.parseQueryParams(),e.parseFragment())}serialize(n){const e=`/${Xc(n.root,!0)}`,r=function B6(t){const n=Object.keys(t).map(e=>{const r=t[e];return Array.isArray(r)?r.map(s=>`${Vp(e)}=${Vp(s)}`).join("&"):`${Vp(e)}=${Vp(r)}`}).filter(e=>!!e);return n.length?`?${n.join("&")}`:""}(n.queryParams);return`${e}${r}${"string"==typeof n.fragment?`#${function P6(t){return encodeURI(t)}(n.fragment)}`:""}`}}const M6=new y0;function zp(t){return t.segments.map(n=>jA(n)).join("/")}function Xc(t,n){if(!t.hasChildren())return zp(t);if(n){const e=t.children[pt]?Xc(t.children[pt],!1):"",r=[];return mr(t.children,(s,o)=>{o!==pt&&r.push(`${o}:${Xc(s,!1)}`)}),r.length>0?`${e}(${r.join("//")})`:e}{const e=function O6(t,n){let e=[];return mr(t.children,(r,s)=>{s===pt&&(e=e.concat(n(r,s)))}),mr(t.children,(r,s)=>{s!==pt&&(e=e.concat(n(r,s)))}),e}(t,(r,s)=>s===pt?[Xc(t.children[pt],!1)]:[`${s}:${Xc(r,!1)}`]);return 1===Object.keys(t.children).length&&null!=t.children[pt]?`${zp(t)}/${e[0]}`:`${zp(t)}/(${e.join("//")})`}}function HA(t){return encodeURIComponent(t).replace(/%40/g,"@").replace(/%3A/gi,":").replace(/%24/g,"$").replace(/%2C/gi,",")}function Vp(t){return HA(t).replace(/%3B/gi,";")}function b0(t){return HA(t).replace(/\(/g,"%28").replace(/\)/g,"%29").replace(/%26/gi,"&")}function Up(t){return decodeURIComponent(t)}function GA(t){return Up(t.replace(/\+/g,"%20"))}function jA(t){return`${b0(t.path)}${function L6(t){return Object.keys(t).map(n=>`;${b0(n)}=${b0(t[n])}`).join("")}(t.parameters)}`}const z6=/^[^\/()?;=#]+/;function Wp(t){const n=t.match(z6);return n?n[0]:""}const V6=/^[^=?&#]+/,W6=/^[^&#]+/;class G6{constructor(n){this.url=n,this.remaining=n}parseRootSegment(){return this.consumeOptional("/"),""===this.remaining||this.peekStartsWith("?")||this.peekStartsWith("#")?new gt([],{}):new gt([],this.parseChildren())}parseQueryParams(){const n={};if(this.consumeOptional("?"))do{this.parseQueryParam(n)}while(this.consumeOptional("&"));return n}parseFragment(){return this.consumeOptional("#")?decodeURIComponent(this.remaining):null}parseChildren(){if(""===this.remaining)return{};this.consumeOptional("/");const n=[];for(this.peekStartsWith("(")||n.push(this.parseSegment());this.peekStartsWith("/")&&!this.peekStartsWith("//")&&!this.peekStartsWith("/(");)this.capture("/"),n.push(this.parseSegment());let e={};this.peekStartsWith("/(")&&(this.capture("/"),e=this.parseParens(!0));let r={};return this.peekStartsWith("(")&&(r=this.parseParens(!1)),(n.length>0||Object.keys(e).length>0)&&(r[pt]=new gt(n,e)),r}parseSegment(){const n=Wp(this.remaining);if(""===n&&this.peekStartsWith(";"))throw new xe(4009,Lp);return this.capture(n),new Kc(Up(n),this.parseMatrixParams())}parseMatrixParams(){const n={};for(;this.consumeOptional(";");)this.parseParam(n);return n}parseParam(n){const e=Wp(this.remaining);if(!e)return;this.capture(e);let r="";if(this.consumeOptional("=")){const s=Wp(this.remaining);s&&(r=s,this.capture(r))}n[Up(e)]=Up(r)}parseQueryParam(n){const e=function U6(t){const n=t.match(V6);return n?n[0]:""}(this.remaining);if(!e)return;this.capture(e);let r="";if(this.consumeOptional("=")){const i=function H6(t){const n=t.match(W6);return n?n[0]:""}(this.remaining);i&&(r=i,this.capture(r))}const s=GA(e),o=GA(r);if(n.hasOwnProperty(s)){let i=n[s];Array.isArray(i)||(i=[i],n[s]=i),i.push(o)}else n[s]=o}parseParens(n){const e={};for(this.capture("(");!this.consumeOptional(")")&&this.remaining.length>0;){const r=Wp(this.remaining),s=this.remaining[r.length];if("/"!==s&&")"!==s&&";"!==s)throw new xe(4010,Lp);let o;r.indexOf(":")>-1?(o=r.slice(0,r.indexOf(":")),this.capture(o),this.capture(":")):n&&(o=pt);const i=this.parseChildren();e[o]=1===Object.keys(i).length?i[pt]:new gt([],i),this.consumeOptional("//")}return e}peekStartsWith(n){return this.remaining.startsWith(n)}consumeOptional(n){return!!this.peekStartsWith(n)&&(this.remaining=this.remaining.substring(n.length),!0)}capture(n){if(!this.consumeOptional(n))throw new xe(4011,Lp)}}function v0(t){return t.segments.length>0?new gt([],{[pt]:t}):t}function Hp(t){const n={};for(const r of Object.keys(t.children)){const o=Hp(t.children[r]);(o.segments.length>0||o.hasChildren())&&(n[r]=o)}return function j6(t){if(1===t.numberOfChildren&&t.children[pt]){const n=t.children[pt];return new gt(t.segments.concat(n.segments),n.children)}return t}(new gt(t.segments,n))}function Na(t){return t instanceof Sa}function X6(t,n,e,r,s){if(0===e.length)return jl(n.root,n.root,n.root,r,s);const o=function XA(t){if("string"==typeof t[0]&&1===t.length&&"/"===t[0])return new KA(!0,0,t);let n=0,e=!1;const r=t.reduce((s,o,i)=>{if("object"==typeof o&&null!=o){if(o.outlets){const a={};return mr(o.outlets,(l,u)=>{a[u]="string"==typeof l?l.split("/"):l}),[...s,{outlets:a}]}if(o.segmentPath)return[...s,o.segmentPath]}return"string"!=typeof o?[...s,o]:0===i?(o.split("/").forEach((a,l)=>{0==l&&"."===a||(0==l&&""===a?e=!0:".."===a?n++:""!=a&&s.push(a))}),s):[...s,o]},[]);return new KA(e,n,r)}(e);return o.toRoot()?jl(n.root,n.root,new gt([],{}),r,s):function i(l){const u=function Z6(t,n,e,r){if(t.isAbsolute)return new ql(n.root,!0,0);if(-1===r)return new ql(e,e===n.root,0);return function YA(t,n,e){let r=t,s=n,o=e;for(;o>s;){if(o-=s,r=r.parent,!r)throw new xe(4005,!1);s=r.segments.length}return new ql(r,!1,s-o)}(e,r+(Yc(t.commands[0])?0:1),t.numberOfDoubleDots)}(o,n,t.snapshot?._urlSegment,l),c=u.processChildren?Qc(u.segmentGroup,u.index,o.commands):w0(u.segmentGroup,u.index,o.commands);return jl(n.root,u.segmentGroup,c,r,s)}(t.snapshot?._lastPathIndex)}function Yc(t){return"object"==typeof t&&null!=t&&!t.outlets&&!t.segmentPath}function Zc(t){return"object"==typeof t&&null!=t&&t.outlets}function jl(t,n,e,r,s){let i,o={};r&&mr(r,(l,u)=>{o[u]=Array.isArray(l)?l.map(c=>`${c}`):`${l}`}),i=t===n?e:qA(t,n,e);const a=v0(Hp(i));return new Sa(a,o,s)}function qA(t,n,e){const r={};return mr(t.children,(s,o)=>{r[o]=s===n?e:qA(s,n,e)}),new gt(t.segments,r)}class KA{constructor(n,e,r){if(this.isAbsolute=n,this.numberOfDoubleDots=e,this.commands=r,n&&r.length>0&&Yc(r[0]))throw new xe(4003,!1);const s=r.find(Zc);if(s&&s!==PA(r))throw new xe(4004,!1)}toRoot(){return this.isAbsolute&&1===this.commands.length&&"/"==this.commands[0]}}class ql{constructor(n,e,r){this.segmentGroup=n,this.processChildren=e,this.index=r}}function w0(t,n,e){if(t||(t=new gt([],{})),0===t.segments.length&&t.hasChildren())return Qc(t,n,e);const r=function J6(t,n,e){let r=0,s=n;const o={match:!1,pathIndex:0,commandIndex:0};for(;s<t.segments.length;){if(r>=e.length)return o;const i=t.segments[s],a=e[r];if(Zc(a))break;const l=`${a}`,u=r<e.length-1?e[r+1]:null;if(s>0&&void 0===l)break;if(l&&u&&"object"==typeof u&&void 0===u.outlets){if(!QA(l,u,i))return o;r+=2}else{if(!QA(l,{},i))return o;r++}s++}return{match:!0,pathIndex:s,commandIndex:r}}(t,n,e),s=e.slice(r.commandIndex);if(r.match&&r.pathIndex<t.segments.length){const o=new gt(t.segments.slice(0,r.pathIndex),{});return o.children[pt]=new gt(t.segments.slice(r.pathIndex),t.children),Qc(o,0,s)}return r.match&&0===s.length?new gt(t.segments,{}):r.match&&!t.hasChildren()?C0(t,n,e):r.match?Qc(t,0,s):C0(t,n,e)}function Qc(t,n,e){if(0===e.length)return new gt(t.segments,{});{const r=function Q6(t){return Zc(t[0])?t[0].outlets:{[pt]:t}}(e),s={};return mr(r,(o,i)=>{"string"==typeof o&&(o=[o]),null!==o&&(s[i]=w0(t.children[i],n,o))}),mr(t.children,(o,i)=>{void 0===r[i]&&(s[i]=o)}),new gt(t.segments,s)}}function C0(t,n,e){const r=t.segments.slice(0,n);let s=0;for(;s<e.length;){const o=e[s];if(Zc(o)){const l=e5(o.outlets);return new gt(r,l)}if(0===s&&Yc(e[0])){r.push(new Kc(t.segments[n].path,ZA(e[0]))),s++;continue}const i=Zc(o)?o.outlets[pt]:`${o}`,a=s<e.length-1?e[s+1]:null;i&&a&&Yc(a)?(r.push(new Kc(i,ZA(a))),s+=2):(r.push(new Kc(i,{})),s++)}return new gt(r,{})}function e5(t){const n={};return mr(t,(e,r)=>{"string"==typeof e&&(e=[e]),null!==e&&(n[r]=C0(new gt([],{}),0,e))}),n}function ZA(t){const n={};return mr(t,(e,r)=>n[r]=`${e}`),n}function QA(t,n,e){return t==e.path&&Co(n,e.parameters)}class ei{constructor(n,e){this.id=n,this.url=e}}class I0 extends ei{constructor(n,e,r="imperative",s=null){super(n,e),this.type=0,this.navigationTrigger=r,this.restoredState=s}toString(){return`NavigationStart(id: ${this.id}, url: '${this.url}')`}}class Ta extends ei{constructor(n,e,r){super(n,e),this.urlAfterRedirects=r,this.type=1}toString(){return`NavigationEnd(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}')`}}class Gp extends ei{constructor(n,e,r,s){super(n,e),this.reason=r,this.code=s,this.type=2}toString(){return`NavigationCancel(id: ${this.id}, url: '${this.url}')`}}class JA extends ei{constructor(n,e,r,s){super(n,e),this.error=r,this.target=s,this.type=3}toString(){return`NavigationError(id: ${this.id}, url: '${this.url}', error: ${this.error})`}}class t5 extends ei{constructor(n,e,r,s){super(n,e),this.urlAfterRedirects=r,this.state=s,this.type=4}toString(){return`RoutesRecognized(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}', state: ${this.state})`}}class n5 extends ei{constructor(n,e,r,s){super(n,e),this.urlAfterRedirects=r,this.state=s,this.type=7}toString(){return`GuardsCheckStart(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}', state: ${this.state})`}}class r5 extends ei{constructor(n,e,r,s,o){super(n,e),this.urlAfterRedirects=r,this.state=s,this.shouldActivate=o,this.type=8}toString(){return`GuardsCheckEnd(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}', state: ${this.state}, shouldActivate: ${this.shouldActivate})`}}class s5 extends ei{constructor(n,e,r,s){super(n,e),this.urlAfterRedirects=r,this.state=s,this.type=5}toString(){return`ResolveStart(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}', state: ${this.state})`}}class o5 extends ei{constructor(n,e,r,s){super(n,e),this.urlAfterRedirects=r,this.state=s,this.type=6}toString(){return`ResolveEnd(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}', state: ${this.state})`}}class i5{constructor(n){this.route=n,this.type=9}toString(){return`RouteConfigLoadStart(path: ${this.route.path})`}}class a5{constructor(n){this.route=n,this.type=10}toString(){return`RouteConfigLoadEnd(path: ${this.route.path})`}}class l5{constructor(n){this.snapshot=n,this.type=11}toString(){return`ChildActivationStart(path: '${this.snapshot.routeConfig&&this.snapshot.routeConfig.path||""}')`}}class u5{constructor(n){this.snapshot=n,this.type=12}toString(){return`ChildActivationEnd(path: '${this.snapshot.routeConfig&&this.snapshot.routeConfig.path||""}')`}}class c5{constructor(n){this.snapshot=n,this.type=13}toString(){return`ActivationStart(path: '${this.snapshot.routeConfig&&this.snapshot.routeConfig.path||""}')`}}class d5{constructor(n){this.snapshot=n,this.type=14}toString(){return`ActivationEnd(path: '${this.snapshot.routeConfig&&this.snapshot.routeConfig.path||""}')`}}class eR{constructor(n,e,r){this.routerEvent=n,this.position=e,this.anchor=r,this.type=15}toString(){return`Scroll(anchor: '${this.anchor}', position: '${this.position?`${this.position[0]}, ${this.position[1]}`:null}')`}}class tR{constructor(n){this._root=n}get root(){return this._root.value}parent(n){const e=this.pathFromRoot(n);return e.length>1?e[e.length-2]:null}children(n){const e=D0(n,this._root);return e?e.children.map(r=>r.value):[]}firstChild(n){const e=D0(n,this._root);return e&&e.children.length>0?e.children[0].value:null}siblings(n){const e=_0(n,this._root);return e.length<2?[]:e[e.length-2].children.map(s=>s.value).filter(s=>s!==n)}pathFromRoot(n){return _0(n,this._root).map(e=>e.value)}}function D0(t,n){if(t===n.value)return n;for(const e of n.children){const r=D0(t,e);if(r)return r}return null}function _0(t,n){if(t===n.value)return[n];for(const e of n.children){const r=_0(t,e);if(r.length)return r.unshift(n),r}return[]}class ti{constructor(n,e){this.value=n,this.children=e}toString(){return`TreeNode(${this.value})`}}function Kl(t){const n={};return t&&t.children.forEach(e=>n[e.value.outlet]=e),n}class nR extends tR{constructor(n,e){super(n),this.snapshot=e,S0(this,n)}toString(){return this.snapshot.toString()}}function rR(t,n){const e=function f5(t,n){const i=new jp([],{},{},"",{},pt,n,null,t.root,-1,{});return new oR("",new ti(i,[]))}(t,n),r=new ro([new Kc("",{})]),s=new ro({}),o=new ro({}),i=new ro({}),a=new ro(""),l=new Xl(r,s,i,a,o,pt,n,e.root);return l.snapshot=e.root,new nR(new ti(l,[]),e)}class Xl{constructor(n,e,r,s,o,i,a,l){this.url=n,this.params=e,this.queryParams=r,this.fragment=s,this.data=o,this.outlet=i,this.component=a,this.title=this.data?.pipe(It(u=>u[qc]))??ze(void 0),this._futureSnapshot=l}get routeConfig(){return this._futureSnapshot.routeConfig}get root(){return this._routerState.root}get parent(){return this._routerState.parent(this)}get firstChild(){return this._routerState.firstChild(this)}get children(){return this._routerState.children(this)}get pathFromRoot(){return this._routerState.pathFromRoot(this)}get paramMap(){return this._paramMap||(this._paramMap=this.params.pipe(It(n=>Gl(n)))),this._paramMap}get queryParamMap(){return this._queryParamMap||(this._queryParamMap=this.queryParams.pipe(It(n=>Gl(n)))),this._queryParamMap}toString(){return this.snapshot?this.snapshot.toString():`Future(${this._futureSnapshot})`}}function sR(t,n="emptyOnly"){const e=t.pathFromRoot;let r=0;if("always"!==n)for(r=e.length-1;r>=1;){const s=e[r],o=e[r-1];if(s.routeConfig&&""===s.routeConfig.path)r--;else{if(o.component)break;r--}}return function p5(t){return t.reduce((n,e)=>({params:{...n.params,...e.params},data:{...n.data,...e.data},resolve:{...e.data,...n.resolve,...e.routeConfig?.data,...e._resolvedData}}),{params:{},data:{},resolve:{}})}(e.slice(r))}class jp{constructor(n,e,r,s,o,i,a,l,u,c,d){this.url=n,this.params=e,this.queryParams=r,this.fragment=s,this.data=o,this.outlet=i,this.component=a,this.routeConfig=l,this._urlSegment=u,this._lastPathIndex=c,this._resolve=d}get title(){return this.data?.[qc]}get root(){return this._routerState.root}get parent(){return this._routerState.parent(this)}get firstChild(){return this._routerState.firstChild(this)}get children(){return this._routerState.children(this)}get pathFromRoot(){return this._routerState.pathFromRoot(this)}get paramMap(){return this._paramMap||(this._paramMap=Gl(this.params)),this._paramMap}get queryParamMap(){return this._queryParamMap||(this._queryParamMap=Gl(this.queryParams)),this._queryParamMap}toString(){return`Route(url:'${this.url.map(r=>r.toString()).join("/")}', path:'${this.routeConfig?this.routeConfig.path:""}')`}}class oR extends tR{constructor(n,e){super(e),this.url=n,S0(this,e)}toString(){return iR(this._root)}}function S0(t,n){n.value._routerState=t,n.children.forEach(e=>S0(t,e))}function iR(t){const n=t.children.length>0?` { ${t.children.map(iR).join(", ")} } `:"";return`${t.value}${n}`}function E0(t){if(t.snapshot){const n=t.snapshot,e=t._futureSnapshot;t.snapshot=e,Co(n.queryParams,e.queryParams)||t.queryParams.next(e.queryParams),n.fragment!==e.fragment&&t.fragment.next(e.fragment),Co(n.params,e.params)||t.params.next(e.params),function k6(t,n){if(t.length!==n.length)return!1;for(let e=0;e<t.length;++e)if(!Co(t[e],n[e]))return!1;return!0}(n.url,e.url)||t.url.next(e.url),Co(n.data,e.data)||t.data.next(e.data)}else t.snapshot=t._futureSnapshot,t.data.next(t._futureSnapshot.data)}function N0(t,n){const e=Co(t.params,n.params)&&function F6(t,n){return Ea(t,n)&&t.every((e,r)=>Co(e.parameters,n[r].parameters))}(t.url,n.url);return e&&!(!t.parent!=!n.parent)&&(!t.parent||N0(t.parent,n.parent))}function Jc(t,n,e){if(e&&t.shouldReuseRoute(n.value,e.value.snapshot)){const r=e.value;r._futureSnapshot=n.value;const s=function g5(t,n,e){return n.children.map(r=>{for(const s of e.children)if(t.shouldReuseRoute(r.value,s.value.snapshot))return Jc(t,r,s);return Jc(t,r)})}(t,n,e);return new ti(r,s)}{if(t.shouldAttach(n.value)){const o=t.retrieve(n.value);if(null!==o){const i=o.route;return i.value._futureSnapshot=n.value,i.children=n.children.map(a=>Jc(t,a)),i}}const r=function y5(t){return new Xl(new ro(t.url),new ro(t.params),new ro(t.queryParams),new ro(t.fragment),new ro(t.data),t.outlet,t.component,t)}(n.value),s=n.children.map(o=>Jc(t,o));return new ti(r,s)}}const T0="ngNavigationCancelingError";function aR(t,n){const{redirectTo:e,navigationBehaviorOptions:r}=Na(n)?{redirectTo:n,navigationBehaviorOptions:void 0}:n,s=lR(!1,0,n);return s.url=e,s.navigationBehaviorOptions=r,s}function lR(t,n,e){const r=new Error("NavigationCancelingError: "+(t||""));return r[T0]=!0,r.cancellationCode=n,e&&(r.url=e),r}function uR(t){return cR(t)&&Na(t.url)}function cR(t){return t&&t[T0]}class b5{constructor(){this.outlet=null,this.route=null,this.resolver=null,this.injector=null,this.children=new ed,this.attachRef=null}}let ed=(()=>{class t{constructor(){this.contexts=new Map}onChildOutletCreated(e,r){const s=this.getOrCreateContext(e);s.outlet=r,this.contexts.set(e,s)}onChildOutletDestroyed(e){const r=this.getContext(e);r&&(r.outlet=null,r.attachRef=null)}onOutletDeactivated(){const e=this.contexts;return this.contexts=new Map,e}onOutletReAttached(e){this.contexts=e}getOrCreateContext(e){let r=this.getContext(e);return r||(r=new b5,this.contexts.set(e,r)),r}getContext(e){return this.contexts.get(e)||null}}return t.\u0275fac=function(e){return new(e||t)},t.\u0275prov=ht({token:t,factory:t.\u0275fac,providedIn:"root"}),t})();const qp=!1;let k0=(()=>{class t{constructor(){this.activated=null,this._activatedRoute=null,this.name=pt,this.activateEvents=new Ir,this.deactivateEvents=new Ir,this.attachEvents=new Ir,this.detachEvents=new Ir,this.parentContexts=jt(ed),this.location=jt(Js),this.changeDetector=jt(Ox),this.environmentInjector=jt(Di)}ngOnChanges(e){if(e.name){const{firstChange:r,previousValue:s}=e.name;if(r)return;this.isTrackedInParentContexts(s)&&(this.deactivate(),this.parentContexts.onChildOutletDestroyed(s)),this.initializeOutletWithName()}}ngOnDestroy(){this.isTrackedInParentContexts(this.name)&&this.parentContexts.onChildOutletDestroyed(this.name)}isTrackedInParentContexts(e){return this.parentContexts.getContext(e)?.outlet===this}ngOnInit(){this.initializeOutletWithName()}initializeOutletWithName(){if(this.parentContexts.onChildOutletCreated(this.name,this),this.activated)return;const e=this.parentContexts.getContext(this.name);e?.route&&(e.attachRef?this.attach(e.attachRef,e.route):this.activateWith(e.route,e.injector))}get isActivated(){return!!this.activated}get component(){if(!this.activated)throw new xe(4012,qp);return this.activated.instance}get activatedRoute(){if(!this.activated)throw new xe(4012,qp);return this._activatedRoute}get activatedRouteData(){return this._activatedRoute?this._activatedRoute.snapshot.data:{}}detach(){if(!this.activated)throw new xe(4012,qp);this.location.detach();const e=this.activated;return this.activated=null,this._activatedRoute=null,this.detachEvents.emit(e.instance),e}attach(e,r){this.activated=e,this._activatedRoute=r,this.location.insert(e.hostView),this.attachEvents.emit(e.instance)}deactivate(){if(this.activated){const e=this.component;this.activated.destroy(),this.activated=null,this._activatedRoute=null,this.deactivateEvents.emit(e)}}activateWith(e,r){if(this.isActivated)throw new xe(4013,qp);this._activatedRoute=e;const s=this.location,i=e._futureSnapshot.component,a=this.parentContexts.getOrCreateContext(this.name).children,l=new v5(e,a,s.injector);if(r&&function x5(t){return!!t.resolveComponentFactory}(r)){const u=r.resolveComponentFactory(i);this.activated=s.createComponent(u,s.length,l)}else this.activated=s.createComponent(i,{index:s.length,injector:l,environmentInjector:r??this.environmentInjector});this.changeDetector.markForCheck(),this.activateEvents.emit(this.activated.instance)}}return t.\u0275fac=function(e){return new(e||t)},t.\u0275dir=Tr({type:t,selectors:[["router-outlet"]],inputs:{name:"name"},outputs:{activateEvents:"activate",deactivateEvents:"deactivate",attachEvents:"attach",detachEvents:"detach"},exportAs:["outlet"],standalone:!0,features:[ha]}),t})();class v5{constructor(n,e,r){this.route=n,this.childContexts=e,this.parent=r}get(n,e){return n===Xl?this.route:n===ed?this.childContexts:this.parent.get(n,e)}}let A0=(()=>{class t{}return t.\u0275fac=function(e){return new(e||t)},t.\u0275cmp=il({type:t,selectors:[["ng-component"]],standalone:!0,features:[wT],decls:1,vars:0,template:function(e,r){1&e&&Fn(0,"router-outlet")},dependencies:[k0],encapsulation:2}),t})();function dR(t,n){return t.providers&&!t._injector&&(t._injector=up(t.providers,n,`Route: ${t.path}`)),t._injector??n}function $0(t){const n=t.children&&t.children.map($0),e=n?{...t,children:n}:{...t};return!e.component&&!e.loadComponent&&(n||e.loadChildren)&&e.outlet&&e.outlet!==pt&&(e.component=A0),e}function Ss(t){return t.outlet||pt}function hR(t,n){const e=t.filter(r=>Ss(r)===n);return e.push(...t.filter(r=>Ss(r)!==n)),e}function td(t){if(!t)return null;if(t.routeConfig?._injector)return t.routeConfig._injector;for(let n=t.parent;n;n=n.parent){const e=n.routeConfig;if(e?._loadedInjector)return e._loadedInjector;if(e?._injector)return e._injector}return null}class _5{constructor(n,e,r,s){this.routeReuseStrategy=n,this.futureState=e,this.currState=r,this.forwardEvent=s}activate(n){const e=this.futureState._root,r=this.currState?this.currState._root:null;this.deactivateChildRoutes(e,r,n),E0(this.futureState.root),this.activateChildRoutes(e,r,n)}deactivateChildRoutes(n,e,r){const s=Kl(e);n.children.forEach(o=>{const i=o.value.outlet;this.deactivateRoutes(o,s[i],r),delete s[i]}),mr(s,(o,i)=>{this.deactivateRouteAndItsChildren(o,r)})}deactivateRoutes(n,e,r){const s=n.value,o=e?e.value:null;if(s===o)if(s.component){const i=r.getContext(s.outlet);i&&this.deactivateChildRoutes(n,e,i.children)}else this.deactivateChildRoutes(n,e,r);else o&&this.deactivateRouteAndItsChildren(e,r)}deactivateRouteAndItsChildren(n,e){n.value.component&&this.routeReuseStrategy.shouldDetach(n.value.snapshot)?this.detachAndStoreRouteSubtree(n,e):this.deactivateRouteAndOutlet(n,e)}detachAndStoreRouteSubtree(n,e){const r=e.getContext(n.value.outlet),s=r&&n.value.component?r.children:e,o=Kl(n);for(const i of Object.keys(o))this.deactivateRouteAndItsChildren(o[i],s);if(r&&r.outlet){const i=r.outlet.detach(),a=r.children.onOutletDeactivated();this.routeReuseStrategy.store(n.value.snapshot,{componentRef:i,route:n,contexts:a})}}deactivateRouteAndOutlet(n,e){const r=e.getContext(n.value.outlet),s=r&&n.value.component?r.children:e,o=Kl(n);for(const i of Object.keys(o))this.deactivateRouteAndItsChildren(o[i],s);r&&r.outlet&&(r.outlet.deactivate(),r.children.onOutletDeactivated(),r.attachRef=null,r.resolver=null,r.route=null)}activateChildRoutes(n,e,r){const s=Kl(e);n.children.forEach(o=>{this.activateRoutes(o,s[o.value.outlet],r),this.forwardEvent(new d5(o.value.snapshot))}),n.children.length&&this.forwardEvent(new u5(n.value.snapshot))}activateRoutes(n,e,r){const s=n.value,o=e?e.value:null;if(E0(s),s===o)if(s.component){const i=r.getOrCreateContext(s.outlet);this.activateChildRoutes(n,e,i.children)}else this.activateChildRoutes(n,e,r);else if(s.component){const i=r.getOrCreateContext(s.outlet);if(this.routeReuseStrategy.shouldAttach(s.snapshot)){const a=this.routeReuseStrategy.retrieve(s.snapshot);this.routeReuseStrategy.store(s.snapshot,null),i.children.onOutletReAttached(a.contexts),i.attachRef=a.componentRef,i.route=a.route.value,i.outlet&&i.outlet.attach(a.componentRef,a.route.value),E0(a.route.value),this.activateChildRoutes(n,null,i.children)}else{const a=td(s.snapshot),l=a?.get(xc)??null;i.attachRef=null,i.route=s,i.resolver=l,i.injector=a,i.outlet&&i.outlet.activateWith(s,i.injector),this.activateChildRoutes(n,null,i.children)}}else this.activateChildRoutes(n,null,r)}}class fR{constructor(n){this.path=n,this.route=this.path[this.path.length-1]}}class Kp{constructor(n,e){this.component=n,this.route=e}}function S5(t,n,e){const r=t._root;return nd(r,n?n._root:null,e,[r.value])}function Yl(t,n){const e=Symbol(),r=n.get(t,e);return r===e?"function"!=typeof t||function eB(t){return null!==cf(t)}(t)?n.get(t):t:r}function nd(t,n,e,r,s={canDeactivateChecks:[],canActivateChecks:[]}){const o=Kl(n);return t.children.forEach(i=>{(function N5(t,n,e,r,s={canDeactivateChecks:[],canActivateChecks:[]}){const o=t.value,i=n?n.value:null,a=e?e.getContext(t.value.outlet):null;if(i&&o.routeConfig===i.routeConfig){const l=function T5(t,n,e){if("function"==typeof e)return e(t,n);switch(e){case"pathParamsChange":return!Ea(t.url,n.url);case"pathParamsOrQueryParamsChange":return!Ea(t.url,n.url)||!Co(t.queryParams,n.queryParams);case"always":return!0;case"paramsOrQueryParamsChange":return!N0(t,n)||!Co(t.queryParams,n.queryParams);default:return!N0(t,n)}}(i,o,o.routeConfig.runGuardsAndResolvers);l?s.canActivateChecks.push(new fR(r)):(o.data=i.data,o._resolvedData=i._resolvedData),nd(t,n,o.component?a?a.children:null:e,r,s),l&&a&&a.outlet&&a.outlet.isActivated&&s.canDeactivateChecks.push(new Kp(a.outlet.component,i))}else i&&rd(n,a,s),s.canActivateChecks.push(new fR(r)),nd(t,null,o.component?a?a.children:null:e,r,s)})(i,o[i.value.outlet],e,r.concat([i.value]),s),delete o[i.value.outlet]}),mr(o,(i,a)=>rd(i,e.getContext(a),s)),s}function rd(t,n,e){const r=Kl(t),s=t.value;mr(r,(o,i)=>{rd(o,s.component?n?n.children.getContext(i):null:n,e)}),e.canDeactivateChecks.push(new Kp(s.component&&n&&n.outlet&&n.outlet.isActivated?n.outlet.component:null,s))}function sd(t){return"function"==typeof t}function F0(t){return t instanceof Mp||"EmptyError"===t?.name}const Xp=Symbol("INITIAL_VALUE");function Zl(){return wo(t=>NA(t.map(n=>n.pipe(jc(1),function I6(...t){const n=Ku(t);return nr((e,r)=>{(n?f0(t,e,n):f0(t,e)).subscribe(r)})}(Xp)))).pipe(It(n=>{for(const e of n)if(!0!==e){if(e===Xp)return Xp;if(!1===e||e instanceof Sa)return e}return!0}),Ai(n=>n!==Xp),jc(1)))}function pR(t){return function bL(...t){return D_(t)}(Dr(n=>{if(Na(n))throw aR(0,n)}),It(n=>!0===n))}const O0={matched:!1,consumedSegments:[],remainingSegments:[],parameters:{},positionalParamSegments:{}};function mR(t,n,e,r,s){const o=M0(t,n,e);return o.matched?function j5(t,n,e,r){const s=n.canMatch;return s&&0!==s.length?ze(s.map(i=>{const a=Yl(i,t);return Fi(function O5(t){return t&&sd(t.canMatch)}(a)?a.canMatch(n,e):t.runInContext(()=>a(n,e)))})).pipe(Zl(),pR()):ze(!0)}(r=dR(n,r),n,e).pipe(It(i=>!0===i?o:{...O0})):ze(o)}function M0(t,n,e){if(""===n.path)return"full"===n.pathMatch&&(t.hasChildren()||e.length>0)?{...O0}:{matched:!0,consumedSegments:[],remainingSegments:e,parameters:{},positionalParamSegments:{}};const s=(n.matcher||T6)(e,t,n);if(!s)return{...O0};const o={};mr(s.posParams,(a,l)=>{o[l]=a.path});const i=s.consumed.length>0?{...o,...s.consumed[s.consumed.length-1].parameters}:o;return{matched:!0,consumedSegments:s.consumed,remainingSegments:e.slice(s.consumed.length),parameters:i,positionalParamSegments:s.posParams??{}}}function Yp(t,n,e,r){if(e.length>0&&function X5(t,n,e){return e.some(r=>Zp(t,n,r)&&Ss(r)!==pt)}(t,e,r)){const o=new gt(n,function K5(t,n,e,r){const s={};s[pt]=r,r._sourceSegment=t,r._segmentIndexShift=n.length;for(const o of e)if(""===o.path&&Ss(o)!==pt){const i=new gt([],{});i._sourceSegment=t,i._segmentIndexShift=n.length,s[Ss(o)]=i}return s}(t,n,r,new gt(e,t.children)));return o._sourceSegment=t,o._segmentIndexShift=n.length,{segmentGroup:o,slicedSegments:[]}}if(0===e.length&&function Y5(t,n,e){return e.some(r=>Zp(t,n,r))}(t,e,r)){const o=new gt(t.segments,function q5(t,n,e,r,s){const o={};for(const i of r)if(Zp(t,e,i)&&!s[Ss(i)]){const a=new gt([],{});a._sourceSegment=t,a._segmentIndexShift=n.length,o[Ss(i)]=a}return{...s,...o}}(t,n,e,r,t.children));return o._sourceSegment=t,o._segmentIndexShift=n.length,{segmentGroup:o,slicedSegments:e}}const s=new gt(t.segments,t.children);return s._sourceSegment=t,s._segmentIndexShift=n.length,{segmentGroup:s,slicedSegments:e}}function Zp(t,n,e){return(!(t.hasChildren()||n.length>0)||"full"!==e.pathMatch)&&""===e.path}function gR(t,n,e,r){return!!(Ss(t)===r||r!==pt&&Zp(n,e,t))&&("**"===t.path||M0(n,t,e).matched)}function yR(t,n,e){return 0===n.length&&!t.children[e]}const Qp=!1;class Jp{constructor(n){this.segmentGroup=n||null}}class bR{constructor(n){this.urlTree=n}}function od(t){return Gc(new Jp(t))}function vR(t){return Gc(new bR(t))}class eq{constructor(n,e,r,s,o){this.injector=n,this.configLoader=e,this.urlSerializer=r,this.urlTree=s,this.config=o,this.allowRedirects=!0}apply(){const n=Yp(this.urlTree.root,[],[],this.config).segmentGroup,e=new gt(n.segments,n.children);return this.expandSegmentGroup(this.injector,this.config,e,pt).pipe(It(o=>this.createUrlTree(Hp(o),this.urlTree.queryParams,this.urlTree.fragment))).pipe($i(o=>{if(o instanceof bR)return this.allowRedirects=!1,this.match(o.urlTree);throw o instanceof Jp?this.noMatchError(o):o}))}match(n){return this.expandSegmentGroup(this.injector,this.config,n.root,pt).pipe(It(s=>this.createUrlTree(Hp(s),n.queryParams,n.fragment))).pipe($i(s=>{throw s instanceof Jp?this.noMatchError(s):s}))}noMatchError(n){return new xe(4002,Qp)}createUrlTree(n,e,r){const s=v0(n);return new Sa(s,e,r)}expandSegmentGroup(n,e,r,s){return 0===r.segments.length&&r.hasChildren()?this.expandChildren(n,e,r).pipe(It(o=>new gt([],o))):this.expandSegment(n,r,e,r.segments,s,!0)}expandChildren(n,e,r){const s=[];for(const o of Object.keys(r.children))"primary"===o?s.unshift(o):s.push(o);return Wn(s).pipe(_a(o=>{const i=r.children[o],a=hR(e,o);return this.expandSegmentGroup(n,a,i,o).pipe(It(l=>({segment:l,outlet:o})))}),$A((o,i)=>(o[i.outlet]=i.segment,o),{}),FA())}expandSegment(n,e,r,s,o,i){return Wn(r).pipe(_a(a=>this.expandSegmentAgainstRoute(n,e,r,a,s,o,i).pipe($i(u=>{if(u instanceof Jp)return ze(null);throw u}))),Ri(a=>!!a),$i((a,l)=>{if(F0(a))return yR(e,s,o)?ze(new gt([],{})):od(e);throw a}))}expandSegmentAgainstRoute(n,e,r,s,o,i,a){return gR(s,e,o,i)?void 0===s.redirectTo?this.matchSegmentAgainstRoute(n,e,s,o,i):a&&this.allowRedirects?this.expandSegmentAgainstRouteUsingRedirect(n,e,r,s,o,i):od(e):od(e)}expandSegmentAgainstRouteUsingRedirect(n,e,r,s,o,i){return"**"===s.path?this.expandWildCardWithParamsAgainstRouteUsingRedirect(n,r,s,i):this.expandRegularSegmentAgainstRouteUsingRedirect(n,e,r,s,o,i)}expandWildCardWithParamsAgainstRouteUsingRedirect(n,e,r,s){const o=this.applyRedirectCommands([],r.redirectTo,{});return r.redirectTo.startsWith("/")?vR(o):this.lineralizeSegments(r,o).pipe(fr(i=>{const a=new gt(i,{});return this.expandSegment(n,a,e,i,s,!1)}))}expandRegularSegmentAgainstRouteUsingRedirect(n,e,r,s,o,i){const{matched:a,consumedSegments:l,remainingSegments:u,positionalParamSegments:c}=M0(e,s,o);if(!a)return od(e);const d=this.applyRedirectCommands(l,s.redirectTo,c);return s.redirectTo.startsWith("/")?vR(d):this.lineralizeSegments(s,d).pipe(fr(h=>this.expandSegment(n,e,r,h.concat(u),i,!1)))}matchSegmentAgainstRoute(n,e,r,s,o){return"**"===r.path?(n=dR(r,n),r.loadChildren?(r._loadedRoutes?ze({routes:r._loadedRoutes,injector:r._loadedInjector}):this.configLoader.loadChildren(n,r)).pipe(It(a=>(r._loadedRoutes=a.routes,r._loadedInjector=a.injector,new gt(s,{})))):ze(new gt(s,{}))):mR(e,r,s,n).pipe(wo(({matched:i,consumedSegments:a,remainingSegments:l})=>i?this.getChildConfig(n=r._injector??n,r,s).pipe(fr(c=>{const d=c.injector??n,h=c.routes,{segmentGroup:f,slicedSegments:p}=Yp(e,a,l,h),m=new gt(f.segments,f.children);if(0===p.length&&m.hasChildren())return this.expandChildren(d,h,m).pipe(It(v=>new gt(a,v)));if(0===h.length&&0===p.length)return ze(new gt(a,{}));const g=Ss(r)===o;return this.expandSegment(d,m,h,p,g?pt:o,!0).pipe(It(b=>new gt(a.concat(b.segments),b.children)))})):od(e)))}getChildConfig(n,e,r){return e.children?ze({routes:e.children,injector:n}):e.loadChildren?void 0!==e._loadedRoutes?ze({routes:e._loadedRoutes,injector:e._loadedInjector}):function G5(t,n,e,r){const s=n.canLoad;return void 0===s||0===s.length?ze(!0):ze(s.map(i=>{const a=Yl(i,t);return Fi(function A5(t){return t&&sd(t.canLoad)}(a)?a.canLoad(n,e):t.runInContext(()=>a(n,e)))})).pipe(Zl(),pR())}(n,e,r).pipe(fr(s=>s?this.configLoader.loadChildren(n,e).pipe(Dr(o=>{e._loadedRoutes=o.routes,e._loadedInjector=o.injector})):function Q5(t){return Gc(lR(Qp,3))}())):ze({routes:[],injector:n})}lineralizeSegments(n,e){let r=[],s=e.root;for(;;){if(r=r.concat(s.segments),0===s.numberOfChildren)return ze(r);if(s.numberOfChildren>1||!s.children[pt])return Gc(new xe(4e3,Qp));s=s.children[pt]}}applyRedirectCommands(n,e,r){return this.applyRedirectCreateUrlTree(e,this.urlSerializer.parse(e),n,r)}applyRedirectCreateUrlTree(n,e,r,s){const o=this.createSegmentGroup(n,e.root,r,s);return new Sa(o,this.createQueryParams(e.queryParams,this.urlTree.queryParams),e.fragment)}createQueryParams(n,e){const r={};return mr(n,(s,o)=>{if("string"==typeof s&&s.startsWith(":")){const a=s.substring(1);r[o]=e[a]}else r[o]=s}),r}createSegmentGroup(n,e,r,s){const o=this.createSegments(n,e.segments,r,s);let i={};return mr(e.children,(a,l)=>{i[l]=this.createSegmentGroup(n,a,r,s)}),new gt(o,i)}createSegments(n,e,r,s){return e.map(o=>o.path.startsWith(":")?this.findPosParam(n,o,s):this.findOrReturn(o,r))}findPosParam(n,e,r){const s=r[e.path.substring(1)];if(!s)throw new xe(4001,Qp);return s}findOrReturn(n,e){let r=0;for(const s of e){if(s.path===n.path)return e.splice(r),s;r++}return n}}class nq{}class oq{constructor(n,e,r,s,o,i,a){this.injector=n,this.rootComponentType=e,this.config=r,this.urlTree=s,this.url=o,this.paramsInheritanceStrategy=i,this.urlSerializer=a}recognize(){const n=Yp(this.urlTree.root,[],[],this.config.filter(e=>void 0===e.redirectTo)).segmentGroup;return this.processSegmentGroup(this.injector,this.config,n,pt).pipe(It(e=>{if(null===e)return null;const r=new jp([],Object.freeze({}),Object.freeze({...this.urlTree.queryParams}),this.urlTree.fragment,{},pt,this.rootComponentType,null,this.urlTree.root,-1,{}),s=new ti(r,e),o=new oR(this.url,s);return this.inheritParamsAndData(o._root),o}))}inheritParamsAndData(n){const e=n.value,r=sR(e,this.paramsInheritanceStrategy);e.params=Object.freeze(r.params),e.data=Object.freeze(r.data),n.children.forEach(s=>this.inheritParamsAndData(s))}processSegmentGroup(n,e,r,s){return 0===r.segments.length&&r.hasChildren()?this.processChildren(n,e,r):this.processSegment(n,e,r,r.segments,s)}processChildren(n,e,r){return Wn(Object.keys(r.children)).pipe(_a(s=>{const o=r.children[s],i=hR(e,s);return this.processSegmentGroup(n,i,o,s)}),$A((s,o)=>s&&o?(s.push(...o),s):null),function S6(t,n=!1){return nr((e,r)=>{let s=0;e.subscribe(rr(r,o=>{const i=t(o,s++);(i||n)&&r.next(o),!i&&r.complete()}))})}(s=>null!==s),Pp(null),FA(),It(s=>{if(null===s)return null;const o=wR(s);return function iq(t){t.sort((n,e)=>n.value.outlet===pt?-1:e.value.outlet===pt?1:n.value.outlet.localeCompare(e.value.outlet))}(o),o}))}processSegment(n,e,r,s,o){return Wn(e).pipe(_a(i=>this.processSegmentAgainstRoute(i._injector??n,i,r,s,o)),Ri(i=>!!i),$i(i=>{if(F0(i))return yR(r,s,o)?ze([]):ze(null);throw i}))}processSegmentAgainstRoute(n,e,r,s,o){if(e.redirectTo||!gR(e,r,s,o))return ze(null);let i;if("**"===e.path){const a=s.length>0?PA(s).parameters:{},l=IR(r)+s.length;i=ze({snapshot:new jp(s,a,Object.freeze({...this.urlTree.queryParams}),this.urlTree.fragment,DR(e),Ss(e),e.component??e._loadedComponent??null,e,CR(r),l,_R(e)),consumedSegments:[],remainingSegments:[]})}else i=mR(r,e,s,n).pipe(It(({matched:a,consumedSegments:l,remainingSegments:u,parameters:c})=>{if(!a)return null;const d=IR(r)+l.length;return{snapshot:new jp(l,c,Object.freeze({...this.urlTree.queryParams}),this.urlTree.fragment,DR(e),Ss(e),e.component??e._loadedComponent??null,e,CR(r),d,_R(e)),consumedSegments:l,remainingSegments:u}}));return i.pipe(wo(a=>{if(null===a)return ze(null);const{snapshot:l,consumedSegments:u,remainingSegments:c}=a;n=e._injector??n;const d=e._loadedInjector??n,h=function aq(t){return t.children?t.children:t.loadChildren?t._loadedRoutes:[]}(e),{segmentGroup:f,slicedSegments:p}=Yp(r,u,c,h.filter(g=>void 0===g.redirectTo));if(0===p.length&&f.hasChildren())return this.processChildren(d,h,f).pipe(It(g=>null===g?null:[new ti(l,g)]));if(0===h.length&&0===p.length)return ze([new ti(l,[])]);const m=Ss(e)===o;return this.processSegment(d,h,f,p,m?pt:o).pipe(It(g=>null===g?null:[new ti(l,g)]))}))}}function lq(t){const n=t.value.routeConfig;return n&&""===n.path&&void 0===n.redirectTo}function wR(t){const n=[],e=new Set;for(const r of t){if(!lq(r)){n.push(r);continue}const s=n.find(o=>r.value.routeConfig===o.value.routeConfig);void 0!==s?(s.children.push(...r.children),e.add(s)):n.push(r)}for(const r of e){const s=wR(r.children);n.push(new ti(r.value,s))}return n.filter(r=>!e.has(r))}function CR(t){let n=t;for(;n._sourceSegment;)n=n._sourceSegment;return n}function IR(t){let n=t,e=n._segmentIndexShift??0;for(;n._sourceSegment;)n=n._sourceSegment,e+=n._segmentIndexShift??0;return e-1}function DR(t){return t.data||{}}function _R(t){return t.resolve||{}}function SR(t){return"string"==typeof t.title||null===t.title}function P0(t){return wo(n=>{const e=t(n);return e?Wn(e).pipe(It(()=>n)):ze(n)})}let ER=(()=>{class t{buildTitle(e){let r,s=e.root;for(;void 0!==s;)r=this.getResolvedTitleForRoute(s)??r,s=s.children.find(o=>o.outlet===pt);return r}getResolvedTitleForRoute(e){return e.data[qc]}}return t.\u0275fac=function(e){return new(e||t)},t.\u0275prov=ht({token:t,factory:function(){return jt(NR)},providedIn:"root"}),t})(),NR=(()=>{class t extends ER{constructor(e){super(),this.title=e}updateTitle(e){const r=this.buildTitle(e);void 0!==r&&this.title.setTitle(r)}}return t.\u0275fac=function(e){return new(e||t)(Ue(_A))},t.\u0275prov=ht({token:t,factory:t.\u0275fac,providedIn:"root"}),t})();class gq{}class yq{shouldDetach(n){return!1}store(n,e){}shouldAttach(n){return!1}retrieve(n){return null}shouldReuseRoute(n,e){return n.routeConfig===e.routeConfig}}class bq extends yq{}const em=new qe("",{providedIn:"root",factory:()=>({})}),Ql=new qe("ROUTES");let L0=(()=>{class t{constructor(e,r){this.injector=e,this.compiler=r,this.componentLoaders=new WeakMap,this.childrenLoaders=new WeakMap}loadComponent(e){if(this.componentLoaders.get(e))return this.componentLoaders.get(e);if(e._loadedComponent)return ze(e._loadedComponent);this.onLoadStartListener&&this.onLoadStartListener(e);const r=Fi(e.loadComponent()).pipe(It(kR),Dr(o=>{this.onLoadEndListener&&this.onLoadEndListener(e),e._loadedComponent=o}),g0(()=>{this.componentLoaders.delete(e)})),s=new AA(r,()=>new Po).pipe(p0());return this.componentLoaders.set(e,s),s}loadChildren(e,r){if(this.childrenLoaders.get(r))return this.childrenLoaders.get(r);if(r._loadedRoutes)return ze({routes:r._loadedRoutes,injector:r._loadedInjector});this.onLoadStartListener&&this.onLoadStartListener(r);const o=this.loadModuleFactoryOrRoutes(r.loadChildren).pipe(It(a=>{this.onLoadEndListener&&this.onLoadEndListener(r);let l,u,c=!1;Array.isArray(a)?u=a:(l=a.create(e).injector,u=MA(l.get(Ql,[],je.Self|je.Optional)));return{routes:u.map($0),injector:l}}),g0(()=>{this.childrenLoaders.delete(r)})),i=new AA(o,()=>new Po).pipe(p0());return this.childrenLoaders.set(r,i),i}loadModuleFactoryOrRoutes(e){return Fi(e()).pipe(It(kR),fr(s=>s instanceof vT||Array.isArray(s)?ze(s):Wn(this.compiler.compileModuleAsync(s))))}}return t.\u0275fac=function(e){return new(e||t)(Ue(Xs),Ue(Sx))},t.\u0275prov=ht({token:t,factory:t.\u0275fac,providedIn:"root"}),t})();function kR(t){return function wq(t){return t&&"object"==typeof t&&"default"in t}(t)?t.default:t}class Cq{}class Iq{shouldProcessUrl(n){return!0}extract(n){return n}merge(n,e){return n}}function Dq(t){throw t}function _q(t,n,e){return n.parse("/")}const Sq={paths:"exact",fragment:"ignored",matrixParams:"ignored",queryParams:"exact"},Eq={paths:"subset",fragment:"ignored",matrixParams:"ignored",queryParams:"subset"};function AR(){const t=jt(WA),n=jt(ed),e=jt(Wx),r=jt(Xs),s=jt(Sx),o=jt(Ql,{optional:!0})??[],i=jt(em,{optional:!0})??{},a=jt(NR),l=jt(ER,{optional:!0}),u=jt(Cq,{optional:!0}),c=jt(gq,{optional:!0}),d=new _r(null,t,n,e,r,s,MA(o));return u&&(d.urlHandlingStrategy=u),c&&(d.routeReuseStrategy=c),d.titleStrategy=l??a,function Nq(t,n){t.errorHandler&&(n.errorHandler=t.errorHandler),t.malformedUriErrorHandler&&(n.malformedUriErrorHandler=t.malformedUriErrorHandler),t.onSameUrlNavigation&&(n.onSameUrlNavigation=t.onSameUrlNavigation),t.paramsInheritanceStrategy&&(n.paramsInheritanceStrategy=t.paramsInheritanceStrategy),t.urlUpdateStrategy&&(n.urlUpdateStrategy=t.urlUpdateStrategy),t.canceledNavigationResolution&&(n.canceledNavigationResolution=t.canceledNavigationResolution)}(i,d),d}let _r=(()=>{class t{constructor(e,r,s,o,i,a,l){this.rootComponentType=e,this.urlSerializer=r,this.rootContexts=s,this.location=o,this.config=l,this.lastSuccessfulNavigation=null,this.currentNavigation=null,this.disposed=!1,this.navigationId=0,this.currentPageId=0,this.isNgZoneEnabled=!1,this.events=new Po,this.errorHandler=Dq,this.malformedUriErrorHandler=_q,this.navigated=!1,this.lastSuccessfulId=-1,this.afterPreactivation=()=>ze(void 0),this.urlHandlingStrategy=new Iq,this.routeReuseStrategy=new bq,this.onSameUrlNavigation="ignore",this.paramsInheritanceStrategy="emptyOnly",this.urlUpdateStrategy="deferred",this.canceledNavigationResolution="replace",this.configLoader=i.get(L0),this.configLoader.onLoadEndListener=h=>this.triggerEvent(new a5(h)),this.configLoader.onLoadStartListener=h=>this.triggerEvent(new i5(h)),this.ngModule=i.get(Ca),this.console=i.get(jH);const d=i.get(On);this.isNgZoneEnabled=d instanceof On&&On.isInAngularZone(),this.resetConfig(l),this.currentUrlTree=new Sa,this.rawUrlTree=this.currentUrlTree,this.browserUrlTree=this.currentUrlTree,this.routerState=rR(this.currentUrlTree,this.rootComponentType),this.transitions=new ro({id:0,targetPageId:0,currentUrlTree:this.currentUrlTree,currentRawUrl:this.currentUrlTree,extractedUrl:this.urlHandlingStrategy.extract(this.currentUrlTree),urlAfterRedirects:this.urlHandlingStrategy.extract(this.currentUrlTree),rawUrl:this.currentUrlTree,extras:{},resolve:null,reject:null,promise:Promise.resolve(!0),source:"imperative",restoredState:null,currentSnapshot:this.routerState.snapshot,targetSnapshot:null,currentRouterState:this.routerState,targetRouterState:null,guards:{canActivateChecks:[],canDeactivateChecks:[]},guardsResult:null}),this.navigations=this.setupNavigations(this.transitions),this.processNavigations()}get browserPageId(){return this.location.getState()?.\u0275routerPageId}setupNavigations(e){const r=this.events;return e.pipe(Ai(s=>0!==s.id),It(s=>({...s,extractedUrl:this.urlHandlingStrategy.extract(s.rawUrl)})),wo(s=>{let o=!1,i=!1;return ze(s).pipe(Dr(a=>{this.currentNavigation={id:a.id,initialUrl:a.rawUrl,extractedUrl:a.extractedUrl,trigger:a.source,extras:a.extras,previousNavigation:this.lastSuccessfulNavigation?{...this.lastSuccessfulNavigation,previousNavigation:null}:null}}),wo(a=>{const l=this.browserUrlTree.toString(),u=!this.navigated||a.extractedUrl.toString()!==l||l!==this.currentUrlTree.toString();if(("reload"===this.onSameUrlNavigation||u)&&this.urlHandlingStrategy.shouldProcessUrl(a.rawUrl))return RR(a.source)&&(this.browserUrlTree=a.extractedUrl),ze(a).pipe(wo(d=>{const h=this.transitions.getValue();return r.next(new I0(d.id,this.serializeUrl(d.extractedUrl),d.source,d.restoredState)),h!==this.transitions.getValue()?Bo:Promise.resolve(d)}),function tq(t,n,e,r){return wo(s=>function J5(t,n,e,r,s){return new eq(t,n,e,r,s).apply()}(t,n,e,s.extractedUrl,r).pipe(It(o=>({...s,urlAfterRedirects:o}))))}(this.ngModule.injector,this.configLoader,this.urlSerializer,this.config),Dr(d=>{this.currentNavigation={...this.currentNavigation,finalUrl:d.urlAfterRedirects},s.urlAfterRedirects=d.urlAfterRedirects}),function cq(t,n,e,r,s){return fr(o=>function sq(t,n,e,r,s,o,i="emptyOnly"){return new oq(t,n,e,r,s,i,o).recognize().pipe(wo(a=>null===a?function rq(t){return new Un(n=>n.error(t))}(new nq):ze(a)))}(t,n,e,o.urlAfterRedirects,r.serialize(o.urlAfterRedirects),r,s).pipe(It(i=>({...o,targetSnapshot:i}))))}(this.ngModule.injector,this.rootComponentType,this.config,this.urlSerializer,this.paramsInheritanceStrategy),Dr(d=>{if(s.targetSnapshot=d.targetSnapshot,"eager"===this.urlUpdateStrategy){if(!d.extras.skipLocationChange){const f=this.urlHandlingStrategy.merge(d.urlAfterRedirects,d.rawUrl);this.setBrowserUrl(f,d)}this.browserUrlTree=d.urlAfterRedirects}const h=new t5(d.id,this.serializeUrl(d.extractedUrl),this.serializeUrl(d.urlAfterRedirects),d.targetSnapshot);r.next(h)}));if(u&&this.rawUrlTree&&this.urlHandlingStrategy.shouldProcessUrl(this.rawUrlTree)){const{id:h,extractedUrl:f,source:p,restoredState:m,extras:g}=a,y=new I0(h,this.serializeUrl(f),p,m);r.next(y);const b=rR(f,this.rootComponentType).snapshot;return ze(s={...a,targetSnapshot:b,urlAfterRedirects:f,extras:{...g,skipLocationChange:!1,replaceUrl:!1}})}return this.rawUrlTree=a.rawUrl,a.resolve(null),Bo}),Dr(a=>{const l=new n5(a.id,this.serializeUrl(a.extractedUrl),this.serializeUrl(a.urlAfterRedirects),a.targetSnapshot);this.triggerEvent(l)}),It(a=>s={...a,guards:S5(a.targetSnapshot,a.currentSnapshot,this.rootContexts)}),function P5(t,n){return fr(e=>{const{targetSnapshot:r,currentSnapshot:s,guards:{canActivateChecks:o,canDeactivateChecks:i}}=e;return 0===i.length&&0===o.length?ze({...e,guardsResult:!0}):function L5(t,n,e,r){return Wn(t).pipe(fr(s=>function H5(t,n,e,r,s){const o=n&&n.routeConfig?n.routeConfig.canDeactivate:null;return o&&0!==o.length?ze(o.map(a=>{const l=td(n)??s,u=Yl(a,l);return Fi(function F5(t){return t&&sd(t.canDeactivate)}(u)?u.canDeactivate(t,n,e,r):l.runInContext(()=>u(t,n,e,r))).pipe(Ri())})).pipe(Zl()):ze(!0)}(s.component,s.route,e,n,r)),Ri(s=>!0!==s,!0))}(i,r,s,t).pipe(fr(a=>a&&function k5(t){return"boolean"==typeof t}(a)?function B5(t,n,e,r){return Wn(n).pipe(_a(s=>f0(function V5(t,n){return null!==t&&n&&n(new l5(t)),ze(!0)}(s.route.parent,r),function z5(t,n){return null!==t&&n&&n(new c5(t)),ze(!0)}(s.route,r),function W5(t,n,e){const r=n[n.length-1],o=n.slice(0,n.length-1).reverse().map(i=>function E5(t){const n=t.routeConfig?t.routeConfig.canActivateChild:null;return n&&0!==n.length?{node:t,guards:n}:null}(i)).filter(i=>null!==i).map(i=>kA(()=>ze(i.guards.map(l=>{const u=td(i.node)??e,c=Yl(l,u);return Fi(function $5(t){return t&&sd(t.canActivateChild)}(c)?c.canActivateChild(r,t):u.runInContext(()=>c(r,t))).pipe(Ri())})).pipe(Zl())));return ze(o).pipe(Zl())}(t,s.path,e),function U5(t,n,e){const r=n.routeConfig?n.routeConfig.canActivate:null;if(!r||0===r.length)return ze(!0);const s=r.map(o=>kA(()=>{const i=td(n)??e,a=Yl(o,i);return Fi(function R5(t){return t&&sd(t.canActivate)}(a)?a.canActivate(n,t):i.runInContext(()=>a(n,t))).pipe(Ri())}));return ze(s).pipe(Zl())}(t,s.route,e))),Ri(s=>!0!==s,!0))}(r,o,t,n):ze(a)),It(a=>({...e,guardsResult:a})))})}(this.ngModule.injector,a=>this.triggerEvent(a)),Dr(a=>{if(s.guardsResult=a.guardsResult,Na(a.guardsResult))throw aR(0,a.guardsResult);const l=new r5(a.id,this.serializeUrl(a.extractedUrl),this.serializeUrl(a.urlAfterRedirects),a.targetSnapshot,!!a.guardsResult);this.triggerEvent(l)}),Ai(a=>!!a.guardsResult||(this.restoreHistory(a),this.cancelNavigationTransition(a,"",3),!1)),P0(a=>{if(a.guards.canActivateChecks.length)return ze(a).pipe(Dr(l=>{const u=new s5(l.id,this.serializeUrl(l.extractedUrl),this.serializeUrl(l.urlAfterRedirects),l.targetSnapshot);this.triggerEvent(u)}),wo(l=>{let u=!1;return ze(l).pipe(function dq(t,n){return fr(e=>{const{targetSnapshot:r,guards:{canActivateChecks:s}}=e;if(!s.length)return ze(e);let o=0;return Wn(s).pipe(_a(i=>function hq(t,n,e,r){const s=t.routeConfig,o=t._resolve;return void 0!==s?.title&&!SR(s)&&(o[qc]=s.title),function fq(t,n,e,r){const s=function pq(t){return[...Object.keys(t),...Object.getOwnPropertySymbols(t)]}(t);if(0===s.length)return ze({});const o={};return Wn(s).pipe(fr(i=>function mq(t,n,e,r){const s=td(n)??r,o=Yl(t,s);return Fi(o.resolve?o.resolve(n,e):s.runInContext(()=>o(n,e)))}(t[i],n,e,r).pipe(Ri(),Dr(a=>{o[i]=a}))),m0(1),function E6(t){return It(()=>t)}(o),$i(i=>F0(i)?Bo:Gc(i)))}(o,t,n,r).pipe(It(i=>(t._resolvedData=i,t.data=sR(t,e).resolve,s&&SR(s)&&(t.data[qc]=s.title),null)))}(i.route,r,t,n)),Dr(()=>o++),m0(1),fr(i=>o===s.length?ze(e):Bo))})}(this.paramsInheritanceStrategy,this.ngModule.injector),Dr({next:()=>u=!0,complete:()=>{u||(this.restoreHistory(l),this.cancelNavigationTransition(l,"",2))}}))}),Dr(l=>{const u=new o5(l.id,this.serializeUrl(l.extractedUrl),this.serializeUrl(l.urlAfterRedirects),l.targetSnapshot);this.triggerEvent(u)}))}),P0(a=>{const l=u=>{const c=[];u.routeConfig?.loadComponent&&!u.routeConfig._loadedComponent&&c.push(this.configLoader.loadComponent(u.routeConfig).pipe(Dr(d=>{u.component=d}),It(()=>{})));for(const d of u.children)c.push(...l(d));return c};return NA(l(a.targetSnapshot.root)).pipe(Pp(),jc(1))}),P0(()=>this.afterPreactivation()),It(a=>{const l=function m5(t,n,e){const r=Jc(t,n._root,e?e._root:void 0);return new nR(r,n)}(this.routeReuseStrategy,a.targetSnapshot,a.currentRouterState);return s={...a,targetRouterState:l}}),Dr(a=>{this.currentUrlTree=a.urlAfterRedirects,this.rawUrlTree=this.urlHandlingStrategy.merge(a.urlAfterRedirects,a.rawUrl),this.routerState=a.targetRouterState,"deferred"===this.urlUpdateStrategy&&(a.extras.skipLocationChange||this.setBrowserUrl(this.rawUrlTree,a),this.browserUrlTree=a.urlAfterRedirects)}),((t,n,e)=>It(r=>(new _5(n,r.targetRouterState,r.currentRouterState,e).activate(t),r)))(this.rootContexts,this.routeReuseStrategy,a=>this.triggerEvent(a)),Dr({next(){o=!0},complete(){o=!0}}),g0(()=>{o||i||this.cancelNavigationTransition(s,"",1),this.currentNavigation?.id===s.id&&(this.currentNavigation=null)}),$i(a=>{if(i=!0,cR(a)){uR(a)||(this.navigated=!0,this.restoreHistory(s,!0));const l=new Gp(s.id,this.serializeUrl(s.extractedUrl),a.message,a.cancellationCode);if(r.next(l),uR(a)){const u=this.urlHandlingStrategy.merge(a.url,this.rawUrlTree),c={skipLocationChange:s.extras.skipLocationChange,replaceUrl:"eager"===this.urlUpdateStrategy||RR(s.source)};this.scheduleNavigation(u,"imperative",null,c,{resolve:s.resolve,reject:s.reject,promise:s.promise})}else s.resolve(!1)}else{this.restoreHistory(s,!0);const l=new JA(s.id,this.serializeUrl(s.extractedUrl),a,s.targetSnapshot??void 0);r.next(l);try{s.resolve(this.errorHandler(a))}catch(u){s.reject(u)}}return Bo}))}))}resetRootComponentType(e){this.rootComponentType=e,this.routerState.root.component=this.rootComponentType}setTransition(e){this.transitions.next({...this.transitions.value,...e})}initialNavigation(){this.setUpLocationChangeListener(),0===this.navigationId&&this.navigateByUrl(this.location.path(!0),{replaceUrl:!0})}setUpLocationChangeListener(){this.locationSubscription||(this.locationSubscription=this.location.subscribe(e=>{const r="popstate"===e.type?"popstate":"hashchange";"popstate"===r&&setTimeout(()=>{const s={replaceUrl:!0},o=e.state?.navigationId?e.state:null;if(o){const a={...o};delete a.navigationId,delete a.\u0275routerPageId,0!==Object.keys(a).length&&(s.state=a)}const i=this.parseUrl(e.url);this.scheduleNavigation(i,r,o,s)},0)}))}get url(){return this.serializeUrl(this.currentUrlTree)}getCurrentNavigation(){return this.currentNavigation}triggerEvent(e){this.events.next(e)}resetConfig(e){this.config=e.map($0),this.navigated=!1,this.lastSuccessfulId=-1}ngOnDestroy(){this.dispose()}dispose(){this.transitions.complete(),this.locationSubscription&&(this.locationSubscription.unsubscribe(),this.locationSubscription=void 0),this.disposed=!0}createUrlTree(e,r={}){const{relativeTo:s,queryParams:o,fragment:i,queryParamsHandling:a,preserveFragment:l}=r,u=s||this.routerState.root,c=l?this.currentUrlTree.fragment:i;let d=null;switch(a){case"merge":d={...this.currentUrlTree.queryParams,...o};break;case"preserve":d=this.currentUrlTree.queryParams;break;default:d=o||null}return null!==d&&(d=this.removeEmptyProps(d)),X6(u,this.currentUrlTree,e,d,c??null)}navigateByUrl(e,r={skipLocationChange:!1}){const s=Na(e)?e:this.parseUrl(e),o=this.urlHandlingStrategy.merge(s,this.rawUrlTree);return this.scheduleNavigation(o,"imperative",null,r)}navigate(e,r={skipLocationChange:!1}){return function Tq(t){for(let n=0;n<t.length;n++){if(null==t[n])throw new xe(4008,false)}}(e),this.navigateByUrl(this.createUrlTree(e,r),r)}serializeUrl(e){return this.urlSerializer.serialize(e)}parseUrl(e){let r;try{r=this.urlSerializer.parse(e)}catch(s){r=this.malformedUriErrorHandler(s,this.urlSerializer,e)}return r}isActive(e,r){let s;if(s=!0===r?{...Sq}:!1===r?{...Eq}:r,Na(e))return BA(this.currentUrlTree,e,s);const o=this.parseUrl(e);return BA(this.currentUrlTree,o,s)}removeEmptyProps(e){return Object.keys(e).reduce((r,s)=>{const o=e[s];return null!=o&&(r[s]=o),r},{})}processNavigations(){this.navigations.subscribe(e=>{this.navigated=!0,this.lastSuccessfulId=e.id,this.currentPageId=e.targetPageId,this.events.next(new Ta(e.id,this.serializeUrl(e.extractedUrl),this.serializeUrl(this.currentUrlTree))),this.lastSuccessfulNavigation=this.currentNavigation,this.titleStrategy?.updateTitle(this.routerState.snapshot),e.resolve(!0)},e=>{this.console.warn(`Unhandled Navigation Error: ${e}`)})}scheduleNavigation(e,r,s,o,i){if(this.disposed)return Promise.resolve(!1);let a,l,u;i?(a=i.resolve,l=i.reject,u=i.promise):u=new Promise((h,f)=>{a=h,l=f});const c=++this.navigationId;let d;return"computed"===this.canceledNavigationResolution?(0===this.currentPageId&&(s=this.location.getState()),d=s&&s.\u0275routerPageId?s.\u0275routerPageId:o.replaceUrl||o.skipLocationChange?this.browserPageId??0:(this.browserPageId??0)+1):d=0,this.setTransition({id:c,targetPageId:d,source:r,restoredState:s,currentUrlTree:this.currentUrlTree,currentRawUrl:this.rawUrlTree,rawUrl:e,extras:o,resolve:a,reject:l,promise:u,currentSnapshot:this.routerState.snapshot,currentRouterState:this.routerState}),u.catch(h=>Promise.reject(h))}setBrowserUrl(e,r){const s=this.urlSerializer.serialize(e),o={...r.extras.state,...this.generateNgRouterState(r.id,r.targetPageId)};this.location.isCurrentPathEqualTo(s)||r.extras.replaceUrl?this.location.replaceState(s,"",o):this.location.go(s,"",o)}restoreHistory(e,r=!1){if("computed"===this.canceledNavigationResolution){const s=this.currentPageId-e.targetPageId;"popstate"!==e.source&&"eager"!==this.urlUpdateStrategy&&this.currentUrlTree!==this.currentNavigation?.finalUrl||0===s?this.currentUrlTree===this.currentNavigation?.finalUrl&&0===s&&(this.resetState(e),this.browserUrlTree=e.currentUrlTree,this.resetUrlToCurrentUrlTree()):this.location.historyGo(s)}else"replace"===this.canceledNavigationResolution&&(r&&this.resetState(e),this.resetUrlToCurrentUrlTree())}resetState(e){this.routerState=e.currentRouterState,this.currentUrlTree=e.currentUrlTree,this.rawUrlTree=this.urlHandlingStrategy.merge(this.currentUrlTree,e.rawUrl)}resetUrlToCurrentUrlTree(){this.location.replaceState(this.urlSerializer.serialize(this.rawUrlTree),"",this.generateNgRouterState(this.lastSuccessfulId,this.currentPageId))}cancelNavigationTransition(e,r,s){const o=new Gp(e.id,this.serializeUrl(e.extractedUrl),r,s);this.triggerEvent(o),e.resolve(!1)}generateNgRouterState(e,r){return"computed"===this.canceledNavigationResolution?{navigationId:e,\u0275routerPageId:r}:{navigationId:e}}}return t.\u0275fac=function(e){Dv()},t.\u0275prov=ht({token:t,factory:function(){return AR()},providedIn:"root"}),t})();function RR(t){return"imperative"!==t}class $R{}let Rq=(()=>{class t{constructor(e,r,s,o,i){this.router=e,this.injector=s,this.preloadingStrategy=o,this.loader=i}setUpPreloading(){this.subscription=this.router.events.pipe(Ai(e=>e instanceof Ta),_a(()=>this.preload())).subscribe(()=>{})}preload(){return this.processRoutes(this.injector,this.router.config)}ngOnDestroy(){this.subscription&&this.subscription.unsubscribe()}processRoutes(e,r){const s=[];for(const o of r){o.providers&&!o._injector&&(o._injector=up(o.providers,e,`Route: ${o.path}`));const i=o._injector??e,a=o._loadedInjector??i;o.loadChildren&&!o._loadedRoutes&&void 0===o.canLoad||o.loadComponent&&!o._loadedComponent?s.push(this.preloadConfig(i,o)):(o.children||o._loadedRoutes)&&s.push(this.processRoutes(a,o.children??o._loadedRoutes))}return Wn(s).pipe(sl())}preloadConfig(e,r){return this.preloadingStrategy.preload(r,()=>{let s;s=r.loadChildren&&void 0===r.canLoad?this.loader.loadChildren(e,r):ze(null);const o=s.pipe(fr(i=>null===i?ze(void 0):(r._loadedRoutes=i.routes,r._loadedInjector=i.injector,this.processRoutes(i.injector??e,i.routes))));return r.loadComponent&&!r._loadedComponent?Wn([o,this.loader.loadComponent(r)]).pipe(sl()):o})}}return t.\u0275fac=function(e){return new(e||t)(Ue(_r),Ue(Sx),Ue(Di),Ue($R),Ue(L0))},t.\u0275prov=ht({token:t,factory:t.\u0275fac,providedIn:"root"}),t})();const z0=new qe("");let FR=(()=>{class t{constructor(e,r,s,o={}){this.router=e,this.viewportScroller=r,this.zone=s,this.options=o,this.lastId=0,this.lastSource="imperative",this.restoredId=0,this.store={},o.scrollPositionRestoration=o.scrollPositionRestoration||"disabled",o.anchorScrolling=o.anchorScrolling||"disabled"}init(){"disabled"!==this.options.scrollPositionRestoration&&this.viewportScroller.setHistoryScrollRestoration("manual"),this.routerEventsSubscription=this.createScrollEvents(),this.scrollEventsSubscription=this.consumeScrollEvents()}createScrollEvents(){return this.router.events.subscribe(e=>{e instanceof I0?(this.store[this.lastId]=this.viewportScroller.getScrollPosition(),this.lastSource=e.navigationTrigger,this.restoredId=e.restoredState?e.restoredState.navigationId:0):e instanceof Ta&&(this.lastId=e.id,this.scheduleScrollEvent(e,this.router.parseUrl(e.urlAfterRedirects).fragment))})}consumeScrollEvents(){return this.router.events.subscribe(e=>{e instanceof eR&&(e.position?"top"===this.options.scrollPositionRestoration?this.viewportScroller.scrollToPosition([0,0]):"enabled"===this.options.scrollPositionRestoration&&this.viewportScroller.scrollToPosition(e.position):e.anchor&&"enabled"===this.options.anchorScrolling?this.viewportScroller.scrollToAnchor(e.anchor):"disabled"!==this.options.scrollPositionRestoration&&this.viewportScroller.scrollToPosition([0,0]))})}scheduleScrollEvent(e,r){this.zone.runOutsideAngular(()=>{setTimeout(()=>{this.zone.run(()=>{this.router.triggerEvent(new eR(e,"popstate"===this.lastSource?this.store[this.restoredId]:null,r))})},0)})}ngOnDestroy(){this.routerEventsSubscription&&this.routerEventsSubscription.unsubscribe(),this.scrollEventsSubscription&&this.scrollEventsSubscription.unsubscribe()}}return t.\u0275fac=function(e){Dv()},t.\u0275prov=ht({token:t,factory:t.\u0275fac}),t})();function eu(t,n){return{\u0275kind:t,\u0275providers:n}}function MR(){const t=jt(Xs);return n=>{const e=t.get(gp);if(n!==e.components[0])return;const r=t.get(_r),s=t.get(PR);1===t.get(U0)&&r.initialNavigation(),t.get(LR,null,je.Optional)?.setUpPreloading(),t.get(z0,null,je.Optional)?.init(),r.resetRootComponentType(e.componentTypes[0]),s.next(),s.complete()}}const PR=new qe("",{factory:()=>new Po}),U0=new qe("",{providedIn:"root",factory:()=>1});const LR=new qe("");function Pq(t){return eu(0,[{provide:LR,useExisting:Rq},{provide:$R,useExisting:t}])}const BR=new qe("ROUTER_FORROOT_GUARD"),Lq=[Wx,{provide:WA,useClass:y0},{provide:_r,useFactory:AR},ed,{provide:Xl,useFactory:function OR(t){return t.routerState.root},deps:[_r]},L0,[]];function Bq(){return new yk("Router",_r)}let zR=(()=>{class t{constructor(e){}static forRoot(e,r){return{ngModule:t,providers:[Lq,[],{provide:Ql,multi:!0,useValue:e},{provide:BR,useFactory:Wq,deps:[[_r,new cc,new dc]]},{provide:em,useValue:r||{}},r?.useHash?{provide:Da,useClass:$G}:{provide:Da,useClass:zk},{provide:z0,useFactory:()=>{const t=jt(_r),n=jt(r8),e=jt(On),r=jt(em);return r.scrollOffset&&n.setOffset(r.scrollOffset),new FR(t,n,e,r)}},r?.preloadingStrategy?Pq(r.preloadingStrategy).\u0275providers:[],{provide:yk,multi:!0,useFactory:Bq},r?.initialNavigation?Hq(r):[],[{provide:VR,useFactory:MR},{provide:ck,multi:!0,useExisting:VR}]]}}static forChild(e){return{ngModule:t,providers:[{provide:Ql,multi:!0,useValue:e}]}}}return t.\u0275fac=function(e){return new(e||t)(Ue(BR,8))},t.\u0275mod=ia({type:t}),t.\u0275inj=vi({imports:[A0]}),t})();function Wq(t){return"guarded"}function Hq(t){return["disabled"===t.initialNavigation?eu(3,[{provide:fp,multi:!0,useFactory:()=>{const n=jt(_r);return()=>{n.setUpLocationChangeListener()}}},{provide:U0,useValue:2}]).\u0275providers:[],"enabledBlocking"===t.initialNavigation?eu(2,[{provide:U0,useValue:0},{provide:fp,multi:!0,deps:[Xs],useFactory:n=>{const e=n.get(AG,Promise.resolve());let r=!1;return()=>e.then(()=>new Promise(o=>{const i=n.get(_r),a=n.get(PR);(function s(o){n.get(_r).events.pipe(Ai(a=>a instanceof Ta||a instanceof Gp||a instanceof JA),It(a=>a instanceof Ta||a instanceof Gp&&(0===a.code||1===a.code)&&null),Ai(a=>null!==a),jc(1)).subscribe(()=>{o()})})(()=>{o(!0),r=!0}),i.afterPreactivation=()=>(o(!0),r||a.closed?ze(void 0):a),i.initialNavigation()}))}}]).\u0275providers:[]]}const VR=new qe("");function UR(t,n,e,r,s,o,i){try{var a=t[o](i),l=a.value}catch(u){return void e(u)}a.done?n(l):Promise.resolve(l).then(r,s)}function J(t){return function(){var n=this,e=arguments;return new Promise(function(r,s){var o=t.apply(n,e);function i(l){UR(o,r,s,i,a,"next",l)}function a(l){UR(o,r,s,i,a,"throw",l)}i(void 0)})}}class WR{constructor(n,e){this.backend=n,this.dataMover=e,this.data=new WeakMap,this.dataIdsCount=0}get(n){return this.data.has(n)||this.dataMover.moveData(this.backend,n),this.data.get(n)}set(n,e){this.dataIdsCount++,this.data.set(n,e)}has(n){return this.data.has(n)}delete(n){return this.dataIdsCount--,this.data.delete(n)}numDataIds(){return this.dataIdsCount}}class W0{refCount(n){return Es("refCount")}incRef(n){return Es("incRef")}timerAvailable(){return!0}time(n){return Es("time")}read(n){return Es("read")}readSync(n){return Es("readSync")}numDataIds(){return Es("numDataIds")}disposeData(n,e){return Es("disposeData")}write(n,e,r){return Es("write")}move(n,e,r,s,o){return Es("move")}memory(){return Es("memory")}floatPrecision(){return Es("floatPrecision")}epsilon(){return 32===this.floatPrecision()?1e-7:1e-4}dispose(){return Es("dispose")}}function Es(t){throw new Error(`'${t}' not yet implemented or not found in the registry. This kernel may not be supported by the tfjs backend you have chosen`)}function HR(t){let n=t.length,e=0,r=0;for(;n>0;)r=Math.random()*n|0,n--,e=t[n],t[n]=t[r],t[r]=e}function ka(t,n,e){return Math.max(t,Math.min(n,e))}function GR(t){return t%2==0?t:t+1}function S(t,n){if(!t)throw new Error("string"==typeof n?n:n())}function cs(t,n,e=""){S(Mt(t,n),()=>e+` Shapes ${t} and ${n} must match`)}function H0(t){S(null!=t,()=>"The input to the tensor constructor must be a non-null value.")}function tu(t,n=[],e=!1){if(null==n&&(n=[]),Array.isArray(t)||Io(t)&&!e)for(let r=0;r<t.length;++r)tu(t[r],n,e);else n.push(t);return n}function te(t){if(0===t.length)return 1;let n=t[0];for(let e=1;e<t.length;e++)n*=t[e];return n}function Mt(t,n){if(t===n)return!0;if(null==t||null==n||t.length!==n.length)return!1;for(let e=0;e<t.length;e++)if(t[e]!==n[e])return!1;return!0}function Kn(t){return t%1==0}function G0(t){const n=Math.ceil(Math.sqrt(t));return[n,Math.ceil(t/n)]}function nu(t,n){return n<=t.length?t:t+" ".repeat(n-t.length)}function jR(t,n=(r=>0),e){return new Promise((r,s)=>{let o=0;const i=()=>{if(t())return void r();o++;const a=n(o);null!=e&&o>=e?s():setTimeout(i,a)};i()})}function qR(t,n){let e=1,r=-1;for(let o=0;o<t.length;++o)if(t[o]>=0)e*=t[o];else if(-1===t[o]){if(-1!==r)throw Error(`Shapes can only have 1 implicit size. Found -1 at dim ${r} and dim ${o}`);r=o}else if(t[o]<0)throw Error(`Shapes can not be < 0. Found ${t[o]} at dim ${o}`);if(-1===r){if(n>0&&n!==e)throw Error(`Size(${n}) must match the product of shape ${t}`);return t}if(0===e)throw Error(`Cannot infer the missing size in [${t}] when there are 0 elements`);if(n%e!=0)throw Error(`The implicit shape can't be a fractional number. Got ${n} / ${e}`);const s=t.slice();return s[r]=n/e,s}function ft(t,n){const e=n.length;return S((t=null==t?n.map((r,s)=>s):[].concat(t)).every(r=>r>=-e&&r<e),()=>`All values in axis param must be in range [-${e}, ${e}) but got axis ${t}`),S(t.every(r=>Kn(r)),()=>`All values in axis param must be integers but got axis ${t}`),t.map(r=>r<0?e+r:r)}function Aa(t,n){const e=[],r=[],s=null!=n&&Array.isArray(n)&&0===n.length,o=null==n||s?null:ft(n,t).sort();let i=0;for(let a=0;a<t.length;++a){if(null!=o){if(o[i]===a&&1!==t[a])throw new Error(`Can't squeeze axis ${a} since its dim '${t[a]}' is not 1`);(null==o[i]||o[i]>a)&&1===t[a]&&(e.push(t[a]),r.push(a)),o[i]<=a&&i++}1!==t[a]&&(e.push(t[a]),r.push(a))}return{newShape:e,keptDims:r}}function or(t,n){let e=null;if(null==t||"float32"===t)e=new Float32Array(n);else if("int32"===t)e=new Int32Array(n);else{if("bool"!==t)throw new Error(`Unknown data type ${t}`);e=new Uint8Array(n)}return e}function ru(t,n){let e=null;if(null==t||"float32"===t)e=new Float32Array(n);else if("int32"===t)e=new Int32Array(n);else if("bool"===t)e=new Uint8Array(n);else{if("string"!==t)throw new Error(`Unknown data type ${t}`);e=new Array(n)}return e}function KR(t,n){return!("complex64"===n||"float32"===n&&"complex64"!==t||"int32"===n&&"float32"!==t&&"complex64"!==t||"bool"===n&&"bool"===t)}function Io(t){return t instanceof Float32Array||t instanceof Int32Array||t instanceof Uint8Array}function j0(t){if("float32"===t||"int32"===t)return 4;if("complex64"===t)return 8;if("bool"===t)return 1;throw new Error(`Unknown dtype ${t}`)}function ad(t){return"string"==typeof t||t instanceof String}function q0(t){return"number"==typeof t}function ld(t){return Array.isArray(t)?ld(t[0]):t instanceof Float32Array?"float32":t instanceof Int32Array||t instanceof Uint8Array?"int32":q0(t)?"float32":ad(t)?"string":function Qq(t){return"boolean"==typeof t}(t)?"bool":"float32"}function K0(t){return!!(t&&t.constructor&&t.call&&t.apply)}function X0(t,n){for(let e=n;e<t;++e)if(t%e==0)return e;return t}function Le(t){const n=t.length;if(n<2)return[];const e=new Array(n-1);e[n-2]=t[n-1];for(let r=n-3;r>=0;--r)e[r]=e[r+1]*t[r+1];return e}function XR(t,n,e){const r=new Array;if(1===n.length){const s=n[0];for(let o=0;o<s;o++)r[o]=e[t+o]}else{const s=n[0],o=n.slice(1),i=o.reduce((a,l)=>a*l);for(let a=0;a<s;a++)r[a]=XR(t+a*i,o,e)}return r}function Ns(t,n){if(0===t.length)return n[0];const e=t.reduce((r,s)=>r*s);if(0===e)return[];if(e!==n.length)throw new Error(`[${t}] does not match the input size ${n.length}.`);return XR(0,t,n)}function YR(t,n){const e=gr(t,n);for(let r=0;r<e.length;r++)e[r]=1;return e}function gr(t,n){if(null==n||"float32"===n||"complex64"===n)return new Float32Array(t);if("int32"===n)return new Int32Array(t);if("bool"===n)return new Uint8Array(t);throw new Error(`Unknown data type ${n}`)}function ZR(t,n){const e=t.reduce((r,s)=>r*s,1);if(null==n||"float32"===n)return Ns(t,new Float32Array(e));if("int32"===n)return Ns(t,new Int32Array(e));if("bool"===n)return Ns(t,new Uint8Array(e));throw new Error(`Unknown data type ${n}`)}function QR(t){t.forEach(n=>{S(Number.isInteger(n)&&n>=0,()=>`Tensor must have a shape comprised of positive integers but got shape [${t}].`)})}function Do(t,n,e){if(0===n)return 0;if(1===n)return t[0];let r=t[t.length-1];for(let s=0;s<t.length-1;++s)r+=e[s]*t[s];return r}function ud(t,n,e){if(0===n)return[];if(1===n)return[t];const r=new Array(n);for(let s=0;s<r.length-1;++s)r[s]=Math.floor(t/e[s]),t-=r[s]*e[s];return r[r.length-1]=t,r}function cd(t){return t&&t.then&&"function"==typeof t.then}const JR="tfjsflags";class Jq{constructor(n){this.global=n,this.flags={},this.flagRegistry={},this.urlFlags={},this.populateURLFlags()}setPlatform(n,e){null!=this.platform&&console.warn(`Platform ${this.platformName} has already been set. Overwriting the platform with ${e}.`),this.platformName=n,this.platform=e}registerFlag(n,e,r){if(this.flagRegistry[n]={evaluationFn:e,setHook:r},null!=this.urlFlags[n]){const s=this.urlFlags[n];console.warn(`Setting feature override from URL ${n}: ${s}.`),this.set(n,s)}}getAsync(n){var e=this;return J(function*(){return n in e.flags||(e.flags[n]=yield e.evaluateFlag(n)),e.flags[n]})()}get(n){if(n in this.flags)return this.flags[n];const e=this.evaluateFlag(n);if(cd(e))throw new Error(`Flag ${n} cannot be synchronously evaluated. Please use getAsync() instead.`);return this.flags[n]=e,this.flags[n]}getNumber(n){return this.get(n)}getBool(n){return this.get(n)}getFlags(){return this.flags}get features(){return this.flags}set(n,e){if(null==this.flagRegistry[n])throw new Error(`Cannot set flag ${n} as it has not been registered.`);this.flags[n]=e,null!=this.flagRegistry[n].setHook&&this.flagRegistry[n].setHook(e)}evaluateFlag(n){if(null==this.flagRegistry[n])throw new Error(`Cannot evaluate flag '${n}': no evaluation function found.`);return this.flagRegistry[n].evaluationFn()}setFlags(n){this.flags=Object.assign({},n)}reset(){this.flags={},this.urlFlags={},this.populateURLFlags()}populateURLFlags(){if(typeof this.global>"u"||typeof this.global.location>"u"||typeof this.global.location.search>"u")return;const n=function eK(t){const n={};return t.replace(/[?&]([^=?&]+)(?:=([^&]*))?/g,(e,...r)=>(function tK(t,n,e){t[decodeURIComponent(n)]=decodeURIComponent(e||"")}(n,r[0],r[1]),r.join("="))),n}(this.global.location.search);JR in n&&n[JR].split(",").forEach(r=>{const[s,o]=r.split(":");this.urlFlags[s]=function nK(t,n){if("true"===(n=n.toLowerCase())||"false"===n)return"true"===n;if(""+ +n===n)return+n;throw new Error(`Could not parse value flag value ${n} for flag ${t}.`)}(s,o)})}}function ne(){return e$}let Y0,e$=null;function t$(){if(null==Y0){let t;if(typeof window<"u")t=window;else if(typeof global<"u")t=global;else if(typeof process<"u")t=process;else{if(!(typeof self<"u"))throw new Error("Could not find a global object");t=self}Y0=t}return Y0}function Z0(t,n){const e=function sK(){const t=t$();return null==t._tfGlobals&&(t._tfGlobals=new Map),t._tfGlobals}();if(e.has(t))return e.get(t);{const r=n();return e.set(t,r),e.get(t)}}const nm="Abs",dd="Acos",hd="Acosh",su="Add",rm="AddN",sm="ArgMax",om="ArgMin",fd="Asin",pd="Asinh",md="Atan",gd="Atanh",yd="Atan2",im="AvgPool",ew="AvgPoolGrad",am="AvgPool3D",tw="AvgPool3DGrad",lm="BatchMatMul",um="BatchToSpaceND",nw="Bincount",bd="Cast",vd="Ceil",xd="ClipByValue",rw="Complex",cm="ComplexAbs",dm="Concat",hm="Conv2D",sw="Conv2DBackpropFilter",fm="Conv2DBackpropInput",pm="Conv3D",ow="Conv3DBackpropFilterV2",iw="Conv3DBackpropInputV2",wd="Cos",Cd="Cosh",mm="Cumsum",aw="CropAndResize",lw="DenseBincount",uw="DepthToSpace",gm="DepthwiseConv2dNative",cw="DepthwiseConv2dNativeBackpropFilter",dw="DepthwiseConv2dNativeBackpropInput",ym="Dilation2D",hw="Dilation2DBackpropInput",fw="Dilation2DBackpropFilter",Id="RealDiv",Dd="Elu",pw="EluGrad",_d="Erf",bm="Equal",Sd="Exp",vm="ExpandDims",Ed="Expm1",gw="Fill",yw="FlipLeftRight",Nd="Floor",Td="FloorDiv",xm="FusedBatchNorm",wm="GatherV2",bw="GatherNd",Cm="Greater",kd="GreaterEqual",Ad="Identity",vw="IFFT",xw="Imag",Rd="IsFinite",$d="IsInf",Fd="IsNan",Im="LeakyRelu",Dm="Less",_m="LessEqual",ww="LinSpace",Od="Log",Md="Log1p",Sm="LogicalAnd",Em="LogicalNot",Nm="LogicalOr",Tm="LRN",Cw="LRNGrad",km="Max",Pd="Maximum",Am="MaxPool",Iw="MaxPoolGrad",Rm="MaxPool3D",Dw="MaxPool3DGrad",_w="MaxPoolWithArgmax",$m="Mean",Fm="Min",Ld="Minimum",Om="MirrorPad",Bd="Mod",Sw="Multinomial",zd="Multiply",Mm="Neg",Pm="NotEqual",Ew="NonMaxSuppressionV3",Nw="NonMaxSuppressionV4",Tw="NonMaxSuppressionV5",Lm="OnesLike",Bm="OneHot",zm="Pack",Vm="PadV2",Vd="Pow",Um="Prelu",kw="Prod",Aw="Range",Rw="Real",Ud="Reciprocal",Wd="Relu",Wm="Reshape",Hm="ResizeNearestNeighbor",$w="ResizeNearestNeighborGrad",Gm="ResizeBilinear",Fw="ResizeBilinearGrad",Hd="Relu6",jm="Reverse",Gd="Round",jd="Rsqrt",Ow="ScatterNd",qm="Select",qd="Selu",Km="Slice",Kd="Sin",Xd="Sinh",Yd="Sign",Zd="Sigmoid",Qd="Softplus",Jd="Sqrt",Xm="Sum",Ym="SpaceToBatchND",Zm="SplitV",Qm="Softmax",eh="SquaredDifference",Mw="Square",th="Sub",Pw="SparseToDense",Lw="StridedSlice",nh="Tan",rh="Tanh",sh="Tile",Bw="TopK",zw="Transform",Jm="Transpose",Vw="Unique",eg="Unpack",tg="UnsortedSegmentSum",ng="ZerosLike",oh="Step",Uw="FromPixels",Ww="RotateWithOffset",rg="_FusedMatMul",sg="FusedConv2D",og="FusedDepthwiseConv2D",ou=Z0("kernelRegistry",()=>new Map),ih=Z0("gradRegistry",()=>new Map);function Hw(t,n){const e=qw(t,n);return ou.get(e)}function r$(t){return ih.get(t)}function Gw(t){const n=ou.entries(),e=[];for(;;){const{done:r,value:s}=n.next();if(r)break;const[o,i]=s,[a]=o.split("_");a===t&&e.push(i)}return e}function jw(t){const{kernelName:n,backendName:e}=t,r=qw(n,e);ou.has(r)&&console.warn(`The kernel '${n}' for backend '${e}' is already registered`),ou.set(r,t)}function aK(t){const{kernelName:n}=t;ih.has(n)&&ne().getBool("DEBUG")&&console.warn(`Overriding the gradient for '${n}'`),ih.set(n,t)}function qw(t,n){return`${n}_${t}`}function Oi(t,n){return"string"===n?ah(t):Ra([t],n)}function Ra(t,n){if("string"===n)throw new Error("Cannot convert a string[] to a TypedArray");if(Array.isArray(t)&&(t=tu(t)),ne().getBool("DEBUG")&&function Xq(t,n){for(let e=0;e<t.length;e++){const r=t[e];if(isNaN(r)||!isFinite(r))throw Error(`A tensor of type ${n} being uploaded contains ${r}.`)}}(t,n),function lK(t,n){return t instanceof Float32Array&&"float32"===n||t instanceof Int32Array&&"int32"===n||t instanceof Uint8Array&&"bool"===n}(t,n))return t;if(null==n||"float32"===n||"complex64"===n)return new Float32Array(t);if("int32"===n)return new Int32Array(t);if("bool"===n){const e=new Uint8Array(t.length);for(let r=0;r<e.length;++r)0!==Math.round(t[r])&&(e[r]=1);return e}throw new Error(`Unknown data type ${n}`)}function Pr(){return ne().platform.now()}function ah(t,n="utf-8"){return n=n||"utf-8",ne().platform.encode(t,n)}function iu(t,n="utf-8"){return n=n||"utf-8",ne().platform.decode(t,n)}class uK{constructor(n,e){this.backendTimer=n,this.logger=e,null==e&&(this.logger=new dK)}profileKernel(n,e,r){let s;const o=()=>{s=r()};let i;const a=Pr();if(this.backendTimer.timerAvailable())i=this.backendTimer.time(o);else{o();for(const u of s)u.dataSync();i=Promise.resolve({kernelMs:Pr()-a})}if(ne().getBool("CHECK_COMPUTATION_FOR_ERRORS"))for(let u=0;u<s.length;u++){const c=s[u];c.data().then(d=>{cK(d,c.dtype,n)})}return{kernelName:n,outputs:s,inputs:e,timeMs:i.then(u=>u.kernelMs),extraInfo:i.then(u=>null!=u.getExtraProfileInfo?u.getExtraProfileInfo():"")}}logKernelProfile(n){const{kernelName:e,outputs:r,timeMs:s,inputs:o,extraInfo:i}=n;r.forEach(a=>{Promise.all([a.data(),s,i]).then(l=>{this.logger.logKernelProfile(e,a,l[0],l[1],o,l[2])})})}}function cK(t,n,e){if("float32"!==n)return!1;for(let r=0;r<t.length;r++){const s=t[r];if(isNaN(s)||!isFinite(s))return console.warn(`Found ${s} in the result of '${e}'`),!0}return!1}class dK{logKernelProfile(n,e,r,s,o,i){const a="number"==typeof s?nu(`${s}ms`,9):s.error,l=nu(n,25),u=e.rank,c=e.size,d=nu(e.shape.toString(),14);let h="";for(const f in o){const p=o[f];if(null!=p){const m=p.shape||e.shape,g=m.length;h+=`${f}: ${g}D ${g>0?m:""} `}}console.log(`%c${l}\t%c${a}\t%c${u}D ${d}\t%c${c}\t%c${h}\t%c${i}`,"font-weight:bold","color:red","color:blue","color: orange","color: green","color: steelblue")}}function pK(t,n,e,r){const s=Le(n),o=function mK(t,n,e,r){const s=te(n),o=r[r.length-1],i=new Array(o).fill(0),a=n.length,l="complex64"===e?ch(t):t;if(a>1)for(let u=0;u<s/o;u++){const c=u*o;for(let d=0;d<o;d++)i[d]=Math.max(i[d],uh(l[c+d],0,e).length)}return i}(t,n,e,s),i=n.length,a=ig(t,n,e,s,o),l=["Tensor"];return r&&(l.push(`  dtype: ${e}`),l.push(`  rank: ${i}`),l.push(`  shape: [${n}]`),l.push("  values:")),l.push(a.map(u=>"    "+u).join("\n")),l.join("\n")}function uh(t,n,e){let r;return r=Array.isArray(t)?`${parseFloat(t[0].toFixed(7))} + ${parseFloat(t[1].toFixed(7))}j`:ad(t)?`'${t}'`:"bool"===e?o$(t):parseFloat(t.toFixed(7)).toString(),nu(r,n)}function o$(t){return 0===t?"false":"true"}function ig(t,n,e,r,s,o=!0){const i="complex64"===e?2:1,a=n[0],l=n.length;if(0===l)return"complex64"===e?[uh(ch(t)[0],0,e)]:"bool"===e?[o$(t[0])]:[t[0].toString()];if(1===l){if(a>20){let y=Array.from(t.slice(0,3*i)),b=Array.from(t.slice((a-3)*i,a*i));return"complex64"===e&&(y=ch(y),b=ch(b)),["["+y.map((v,x)=>uh(v,s[x],e)).join(", ")+", ..., "+b.map((v,x)=>uh(v,s[a-3+x],e)).join(", ")+"]"]}return["["+("complex64"===e?ch(t):Array.from(t)).map((g,y)=>uh(g,s[y],e)).join(", ")+"]"]}const u=n.slice(1),c=r.slice(1),d=r[0]*i,h=[];if(a>20){for(let m=0;m<3;m++){const g=m*d;h.push(...ig(t.slice(g,g+d),u,e,c,s,!1))}h.push("...");for(let m=a-3;m<a;m++){const g=m*d;h.push(...ig(t.slice(g,g+d),u,e,c,s,m===a-1))}}else for(let m=0;m<a;m++){const g=m*d;h.push(...ig(t.slice(g,g+d),u,e,c,s,m===a-1))}const f=2===l?",":"";h[0]="["+h[0]+f;for(let m=1;m<h.length-1;m++)h[m]=" "+h[m]+f;let p=",\n";for(let m=2;m<l;m++)p+="\n";return h[h.length-1]=" "+h[h.length-1]+"]"+(o?"":p),h}function ch(t){const n=[];for(let e=0;e<t.length;e+=2)n.push([t[e],t[e+1]]);return n}class Xn{constructor(n,e,r){if(this.dtype=e,this.shape=n.slice(),this.size=te(n),null!=r){const s=r.length;S(s===this.size,()=>`Length of values '${s}' does not match the size inferred by the shape '${this.size}'.`)}if("complex64"===e)throw new Error("complex64 dtype TensorBuffers are not supported. Please create a TensorBuffer for the real and imaginary parts separately and call tf.complex(real, imag).");this.values=r||ru(e,this.size),this.strides=Le(n)}set(n,...e){0===e.length&&(e=[0]),S(e.length===this.rank,()=>`The number of provided coordinates (${e.length}) must match the rank (${this.rank})`);const r=this.locToIndex(e);this.values[r]=n}get(...n){0===n.length&&(n=[0]);let e=0;for(const s of n){if(s<0||s>=this.shape[e])throw new Error(`Requested out of range element at ${n}.   Buffer shape=${this.shape}`);e++}let r=n[n.length-1];for(let s=0;s<n.length-1;++s)r+=this.strides[s]*n[s];return this.values[r]}locToIndex(n){if(0===this.rank)return 0;if(1===this.rank)return n[0];let e=n[n.length-1];for(let r=0;r<n.length-1;++r)e+=this.strides[r]*n[r];return e}indexToLoc(n){if(0===this.rank)return[];if(1===this.rank)return[n];const e=new Array(this.shape.length);for(let r=0;r<e.length-1;++r)e[r]=Math.floor(n/this.strides[r]),n-=e[r]*this.strides[r];return e[e.length-1]=n,e}get rank(){return this.shape.length}toTensor(){return _o().makeTensor(this.values,this.shape,this.dtype)}}let _o=null,au=null,i$=null;class an{constructor(n,e,r,s){this.kept=!1,this.isDisposedInternal=!1,this.shape=n.slice(),this.dtype=e||"float32",this.size=te(n),this.strides=Le(n),this.dataId=r,this.id=s,this.rankType=this.rank<5?this.rank.toString():"higher"}get rank(){return this.shape.length}buffer(){var n=this;return J(function*(){const e=yield n.data();return au.buffer(n.shape,n.dtype,e)})()}bufferSync(){return au.buffer(this.shape,this.dtype,this.dataSync())}array(){var n=this;return J(function*(){const e=yield n.data();return Ns(n.shape,e)})()}arraySync(){return Ns(this.shape,this.dataSync())}data(){var n=this;return J(function*(){n.throwIfDisposed();const e=_o().read(n.dataId);if("string"===n.dtype){const r=yield e;try{return r.map(s=>iu(s))}catch{throw new Error("Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().")}}return e})()}dataSync(){this.throwIfDisposed();const n=_o().readSync(this.dataId);if("string"===this.dtype)try{return n.map(e=>iu(e))}catch{throw new Error("Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().")}return n}bytes(){var n=this;return J(function*(){n.throwIfDisposed();const e=yield _o().read(n.dataId);return"string"===n.dtype?e:new Uint8Array(e.buffer)})()}dispose(){this.isDisposed||(_o().disposeTensor(this),this.isDisposedInternal=!0)}get isDisposed(){return this.isDisposedInternal}throwIfDisposed(){if(this.isDisposed)throw new Error("Tensor is disposed.")}print(n=!1){return au.print(this,n)}clone(){return this.throwIfDisposed(),au.clone(this)}toString(n=!1){return pK(this.dataSync(),this.shape,this.dtype,n)}cast(n){return this.throwIfDisposed(),au.cast(this,n)}variable(n=!0,e,r){return this.throwIfDisposed(),_o().makeVariable(this,n,e,r)}}function Z(){return Z0("Tensor",()=>an)}Object.defineProperty(an,Symbol.hasInstance,{value:t=>!!t&&null!=t.data&&null!=t.dataSync&&null!=t.throwIfDisposed}),Z();class ag extends an{constructor(n,e,r,s){super(n.shape,n.dtype,n.dataId,s),this.trainable=e,this.name=r}assign(n){if(n.dtype!==this.dtype)throw new Error(`dtype of the new value (${n.dtype}) and previous value (${this.dtype}) must match`);if(!Mt(n.shape,this.shape))throw new Error(`shape of the new value (${n.shape}) and previous value (${this.shape}) must match`);_o().disposeTensor(this),this.dataId=n.dataId,_o().incRef(this,null)}dispose(){_o().disposeVariable(this),this.isDisposedInternal=!0}}Object.defineProperty(ag,Symbol.hasInstance,{value:t=>t instanceof an&&null!=t.assign&&t.assign instanceof Function});var lg=(()=>{return(t=lg||(lg={})).float32="float32",t.int32="int32",t.bool="int32",t.complex64="complex64",lg;var t})(),ug=(()=>{return(t=ug||(ug={})).float32="float32",t.int32="int32",t.bool="bool",t.complex64="complex64",ug;var t})(),cg=(()=>{return(t=cg||(cg={})).float32="float32",t.int32="float32",t.bool="float32",t.complex64="complex64",cg;var t})(),dg=(()=>{return(t=dg||(dg={})).float32="complex64",t.int32="complex64",t.bool="complex64",t.complex64="complex64",dg;var t})();const vK={float32:cg,int32:lg,bool:ug,complex64:dg};function ds(t,n){if("string"===t||"string"===n){if("string"===t&&"string"===n)return"string";throw new Error(`Can not upcast ${t} with ${n}`)}return vK[t][n]}function Xw(t){return ds(t,"int32")}function fn(t,n){if(t.dtype===n.dtype)return[t,n];const e=ds(t.dtype,n.dtype);return[t.cast(e),n.cast(e)]}function a$(t){const n=[];return l$(t,n,new Set),n}function l$(t,n,e){if(null==t)return;if(t instanceof an)return void n.push(t);if(!function xK(t){return Array.isArray(t)||"object"==typeof t}(t))return;const r=t;for(const s in r){const o=r[s];e.has(o)||(e.add(o),l$(o,n,e))}}function Yw(t){return null!=t.kernelName}class u${constructor(){this.registeredVariables={},this.nextTapeNodeId=0,this.numBytes=0,this.numTensors=0,this.numStringTensors=0,this.numDataBuffers=0,this.gradientDepth=0,this.kernelDepth=0,this.scopeStack=[],this.numDataMovesStack=[],this.nextScopeId=0,this.tensorInfo=new WeakMap,this.profiling=!1,this.activeProfile={newBytes:0,newTensors:0,peakBytes:0,kernels:[],result:null,get kernelNames(){return Array.from(new Set(this.kernels.map(n=>n.name)))}}}dispose(){for(const n in this.registeredVariables)this.registeredVariables[n].dispose()}}let wK=(()=>{class t{constructor(e){this.ENV=e,this.registry={},this.registryFactory={},this.pendingBackendInitId=0,this.state=new u$}ready(){var e=this;return J(function*(){if(null!=e.pendingBackendInit)return e.pendingBackendInit.then(()=>{});if(null!=e.backendInstance)return;const r=e.getSortedBackends();for(let s=0;s<r.length;s++){const o=r[s];if(yield e.initializeBackend(o).success)return void(yield e.setBackend(o))}throw new Error("Could not initialize any backends, all backend initializations failed.")})()}get backend(){if(null!=this.pendingBackendInit)throw new Error(`Backend '${this.backendName}' has not yet been initialized. Make sure to await tf.ready() or await tf.setBackend() before calling other methods`);if(null==this.backendInstance){const{name:e,asyncInit:r}=this.initializeBackendsAndReturnBest();if(r)throw new Error(`The highest priority backend '${e}' has not yet been initialized. Make sure to await tf.ready() or await tf.setBackend() before calling other methods`);this.setBackend(e)}return this.backendInstance}backendNames(){return Object.keys(this.registryFactory)}findBackend(e){if(!(e in this.registry)){if(!(e in this.registryFactory))return null;{const{asyncInit:r}=this.initializeBackend(e);if(r)return null}}return this.registry[e]}findBackendFactory(e){return e in this.registryFactory?this.registryFactory[e].factory:null}registerBackend(e,r,s=1){return e in this.registryFactory?(console.warn(`${e} backend was already registered. Reusing existing backend factory.`),!1):(this.registryFactory[e]={factory:r,priority:s},!0)}setBackend(e){var r=this;return J(function*(){if(null==r.registryFactory[e])throw new Error(`Backend name '${e}' not found in registry`);if(r.backendName=e,null==r.registry[e]){r.backendInstance=null;const{success:s,asyncInit:o}=r.initializeBackend(e);if(!(o?yield s:s))return!1}return r.backendInstance=r.registry[e],r.setupRegisteredKernels(),r.profiler=new uK(r.backendInstance),!0})()}setupRegisteredKernels(){Gw(this.backendName).forEach(r=>{null!=r.setupFunc&&r.setupFunc(this.backendInstance)})}disposeRegisteredKernels(e){Gw(e).forEach(s=>{null!=s.disposeFunc&&s.disposeFunc(this.registry[e])})}initializeBackend(e){const r=this.registryFactory[e];if(null==r)throw new Error(`Cannot initialize backend ${e}, no registration found.`);try{const s=r.factory();if(!s||s instanceof W0||"function"!=typeof s.then)return this.registry[e]=s,{success:!0,asyncInit:!1};{const o=++this.pendingBackendInitId,i=s.then(a=>!(o<this.pendingBackendInitId||(this.registry[e]=a,this.pendingBackendInit=null,0))).catch(a=>(o<this.pendingBackendInitId||(this.pendingBackendInit=null,console.warn(`Initialization of backend ${e} failed`),console.warn(a.stack||a.message)),!1));return this.pendingBackendInit=i,{success:i,asyncInit:!0}}}catch(s){return console.warn(`Initialization of backend ${e} failed`),console.warn(s.stack||s.message),{success:!1,asyncInit:!1}}}removeBackend(e){if(!(e in this.registryFactory))throw new Error(`${e} backend not found in registry`);this.backendName===e&&null!=this.pendingBackendInit&&this.pendingBackendInitId++,e in this.registry&&(this.disposeRegisteredKernels(e),this.registry[e].dispose(),delete this.registry[e]),delete this.registryFactory[e],this.backendName===e&&(this.pendingBackendInit=null,this.backendName=null,this.backendInstance=null)}getSortedBackends(){if(0===Object.keys(this.registryFactory).length)throw new Error("No backend found in registry.");return Object.keys(this.registryFactory).sort((e,r)=>this.registryFactory[r].priority-this.registryFactory[e].priority)}initializeBackendsAndReturnBest(){const e=this.getSortedBackends();for(let r=0;r<e.length;r++){const s=e[r],{success:o,asyncInit:i}=this.initializeBackend(s);if(i||o)return{name:s,asyncInit:i}}throw new Error("Could not initialize any backends, all backend initializations failed.")}moveData(e,r){const s=this.state.tensorInfo.get(r),o=s.backend,i=this.readSync(r),a=o.refCount(r);o.disposeData(r,!0),s.backend=e,e.move(r,i,s.shape,s.dtype,a),this.shouldCheckForMemLeaks()&&this.state.numDataMovesStack[this.state.numDataMovesStack.length-1]++}tidy(e,r){let o,s=null;if(null==r){if("function"!=typeof e)throw new Error("Please provide a function to tidy()");r=e}else{if("string"!=typeof e&&!(e instanceof String))throw new Error("When calling with two arguments, the first argument to tidy() must be a string");if("function"!=typeof r)throw new Error("When calling with two arguments, the 2nd argument to tidy() must be a function");s=e}return this.scopedRun(()=>this.startScope(s),()=>this.endScope(o),()=>(o=r(),o instanceof Promise&&console.error("Cannot return a Promise inside of tidy."),o))}scopedRun(e,r,s){e();try{const o=s();return r(),o}catch(o){throw r(),o}}nextTensorId(){return t.nextTensorId++}nextVariableId(){return t.nextVariableId++}clone(e){const r=F.runKernel(Ad,{x:e});return this.addTapeNode(this.state.activeScope.name,{x:e},[r],a=>({x:()=>F.runKernel(bd,{x:a},{dtype:"float32"})}),[],{}),r}runKernel(e,r,s){if(null==Hw(e,this.backendName))throw new Error(`Kernel '${e}' not registered for backend '${this.backendName}'`);return this.runKernelFunc({kernelName:e,inputs:r,attrs:s})}shouldCheckForMemLeaks(){return this.ENV.getBool("IS_TEST")}checkKernelForMemLeak(e,r,s){const o=this.backend.numDataIds();let i=0;s.forEach(u=>{i+="complex64"===u.dtype?3:1});const l=o-r-i-this.state.numDataMovesStack[this.state.numDataMovesStack.length-1];if(l>0)throw new Error(`Backend '${this.backendName}' has an internal memory leak (${l} data ids) after running '${e}'`)}runKernelFunc(e){let r,s=[];const o=this.isTapeOn(),i=this.state.numBytes,a=this.state.numTensors;let l,u;this.shouldCheckForMemLeaks()&&this.state.numDataMovesStack.push(0);const c=Yw(e)?e.kernelName:null!=this.state.activeScope?this.state.activeScope.name:"";if(Yw(e)){const{kernelName:m,inputs:g,attrs:y}=e,b=Hw(m,this.backendName);S(null!=b,()=>`Cannot find registered kernel '${m}' for backend '${this.backendName}'`),l=()=>{const v=this.backend.numDataIds();u=b.kernelFunc({inputs:g,attrs:y,backend:this.backend});const x=Array.isArray(u)?u:[u];this.shouldCheckForMemLeaks()&&this.checkKernelForMemLeak(m,v,x);const w=x.map(_=>{if(null!=_.rank)return _;const{dataId:D,shape:A,dtype:R}=_;return this.makeTensorFromDataId(D,A,R)});if(o){const _=this.getTensorsForGradient(m,g,w);s=this.saveTensorsForBackwardMode(_)}return w}}else{const{forwardFunc:m}=e,g=y=>{!o||(s=y.map(b=>this.keep(this.clone(b))))};l=()=>{const y=this.backend.numDataIds();u=this.tidy(()=>m(this.backend,g));const b=Array.isArray(u)?u:[u];return this.shouldCheckForMemLeaks()&&this.checkKernelForMemLeak(c,y,b),b}}const{inputs:d,attrs:h}=e,f=Yw(e)?null:e.backwardsFunc;let p;return this.scopedRun(()=>this.state.kernelDepth++,()=>this.state.kernelDepth--,()=>{this.ENV.getBool("DEBUG")||this.state.profiling?(p=this.profiler.profileKernel(c,d,()=>l()),this.ENV.getBool("DEBUG")&&this.profiler.logKernelProfile(p),r=p.outputs):r=l()}),o&&this.addTapeNode(c,d,r,f,s,h),this.state.profiling&&this.state.activeProfile.kernels.push({name:c,bytesAdded:this.state.numBytes-i,totalBytesSnapshot:this.state.numBytes,tensorsAdded:this.state.numTensors-a,totalTensorsSnapshot:this.state.numTensors,inputShapes:Object.keys(d).map(m=>null!=d[m]?d[m].shape:null),outputShapes:r.map(m=>m.shape),kernelTimeMs:p.timeMs,extraInfo:p.extraInfo}),Array.isArray(u)?r:r[0]}saveTensorsForBackwardMode(e){return e.map(s=>this.keep(this.clone(s)))}getTensorsForGradient(e,r,s){const o=r$(e);if(null!=o){const i=o.inputsToSave||[],a=o.outputsToSave||[];let l;o.saveAllInputs?(S(Array.isArray(r),()=>"saveAllInputs is true, expected inputs to be an array."),l=Object.keys(r).map(c=>r[c])):l=i.map(c=>r[c]);const u=s.filter((c,d)=>a[d]);return l.concat(u)}return[]}makeTensor(e,r,s,o){if(null==e)throw new Error("Values passed to engine.makeTensor() are null");o=o||this.backend;let i=e;"string"===(s=s||"float32")&&ad(e[0])&&(i=e.map(u=>ah(u)));const a=o.write(i,r,s),l=new an(r,s,a,this.nextTensorId());if(this.trackTensor(l,o),"string"===s){const u=this.state.tensorInfo.get(a),c=function Zq(t){if(null==t)return 0;let n=0;return t.forEach(e=>n+=e.length),n}(i);this.state.numBytes+=c-u.bytes,u.bytes=c}return l}makeTensorFromDataId(e,r,s,o){const i=new an(r,s=s||"float32",e,this.nextTensorId());return this.trackTensor(i,o),i}makeVariable(e,r=!0,s,o){s=s||this.nextVariableId().toString(),null!=o&&o!==e.dtype&&(e=e.cast(o));const i=new ag(e,r,s,this.nextTensorId());if(null!=this.state.registeredVariables[i.name])throw new Error(`Variable with name ${i.name} was already registered`);return this.state.registeredVariables[i.name]=i,this.incRef(i,this.backend),i}trackTensor(e,r){this.state.numTensors++,"string"===e.dtype&&this.state.numStringTensors++;let s=0;"complex64"!==e.dtype&&"string"!==e.dtype&&(s=e.size*j0(e.dtype)),this.state.numBytes+=s,this.state.tensorInfo.has(e.dataId)||(this.state.numDataBuffers++,this.state.tensorInfo.set(e.dataId,{backend:r||this.backend,dtype:e.dtype,shape:e.shape,bytes:s})),e instanceof ag||this.track(e)}incRef(e,r){this.trackTensor(e,r),this.backend.incRef(e.dataId)}removeDataId(e,r){this.state.tensorInfo.has(e)&&this.state.tensorInfo.get(e).backend===r&&(this.state.tensorInfo.delete(e),this.state.numDataBuffers--)}disposeTensor(e){if(!this.state.tensorInfo.has(e.dataId))return;const r=this.state.tensorInfo.get(e.dataId);if(this.state.numTensors--,"string"===e.dtype&&(this.state.numStringTensors--,this.state.numBytes-=r.bytes),"complex64"!==e.dtype&&"string"!==e.dtype){const s=e.size*j0(e.dtype);this.state.numBytes-=s}r.backend.disposeData(e.dataId)&&this.removeDataId(e.dataId,r.backend)}disposeVariables(){for(const e in this.state.registeredVariables)this.disposeVariable(this.state.registeredVariables[e])}disposeVariable(e){this.disposeTensor(e),null!=this.state.registeredVariables[e.name]&&delete this.state.registeredVariables[e.name]}memory(){const e=this.backend.memory();return e.numTensors=this.state.numTensors,e.numDataBuffers=this.state.numDataBuffers,e.numBytes=this.state.numBytes,this.state.numStringTensors>0&&(e.unreliable=!0,null==e.reasons&&(e.reasons=[]),e.reasons.push("Memory usage by string tensors is approximate (2 bytes per character)")),e}profile(e){var r=this;return J(function*(){r.state.profiling=!0;const s=r.state.numBytes,o=r.state.numTensors;r.state.activeProfile.kernels=[],r.state.activeProfile.result=yield e(),r.state.profiling=!1,r.state.activeProfile.peakBytes=Math.max(...r.state.activeProfile.kernels.map(i=>i.totalBytesSnapshot)),r.state.activeProfile.newBytes=r.state.numBytes-s,r.state.activeProfile.newTensors=r.state.numTensors-o;for(const i of r.state.activeProfile.kernels)i.kernelTimeMs=yield i.kernelTimeMs,i.extraInfo=yield i.extraInfo;return r.state.activeProfile})()}isTapeOn(){return this.state.gradientDepth>0&&0===this.state.kernelDepth}addTapeNode(e,r,s,o,i,a){const l={id:this.state.nextTapeNodeId++,kernelName:e,inputs:r,outputs:s,saved:i},u=r$(e);null!=u&&(o=u.gradFunc),null!=o&&(l.gradient=c=>(c=c.map((d,h)=>{if(null==d){const f=s[h],p=gr(f.size,f.dtype);return this.makeTensor(p,f.shape,f.dtype)}return d}),o(c.length>1?c:c[0],i,a))),this.state.activeTape.push(l)}keep(e){return e.kept=!0,e}startTape(){0===this.state.gradientDepth&&(this.state.activeTape=[]),this.state.gradientDepth++}endTape(){this.state.gradientDepth--}startScope(e){const r={track:[],name:"unnamed scope",id:this.state.nextScopeId++};e&&(r.name=e),this.state.scopeStack.push(r),this.state.activeScope=r}endScope(e){const r=a$(e),s=new Set(r.map(i=>i.id));for(let i=0;i<this.state.activeScope.track.length;i++){const a=this.state.activeScope.track[i];!a.kept&&!s.has(a.id)&&a.dispose()}const o=this.state.scopeStack.pop();this.state.activeScope=0===this.state.scopeStack.length?null:this.state.scopeStack[this.state.scopeStack.length-1],r.forEach(i=>{!i.kept&&i.scopeId===o.id&&this.track(i)})}gradients(e,r,s,o=!1){if(S(r.length>0,()=>"gradients() received an empty list of xs."),null!=s&&"float32"!==s.dtype)throw new Error(`dy must have 'float32' dtype, but has '${s.dtype}'`);const i=this.scopedRun(()=>this.startTape(),()=>this.endTape(),()=>this.tidy("forward",e));S(i instanceof an,()=>"The result y returned by f() must be a tensor.");const a=function hK(t,n,e){const r={},s={};for(let l=0;l<n.length;l++)r[n[l].id]=!0;for(let l=0;l<t.length;l++){const u=t[l],c=u.inputs;for(const d in c){const h=c[d];let f=!1;for(let p=0;p<n.length;p++)if(r[h.id]){u.outputs.forEach(m=>r[m.id]=!0),f=!0,s[u.id]=!0;break}if(f)break}}const o={};o[e.id]=!0;const i={};for(let l=t.length-1;l>=0;l--){const u=t[l],c=u.inputs;for(let d=0;d<u.outputs.length;d++)if(o[u.outputs[d].id]){for(const h in c)o[c[h].id]=!0,i[u.id]=!0;break}}const a=[];for(let l=0;l<t.length;l++){const u=t[l];if(s[u.id]&&i[u.id]){const c={};for(const h in u.inputs){const f=u.inputs[h];r[f.id]&&(c[h]=f)}const d=Object.assign({},u);d.inputs=c,d.outputs=u.outputs,a.push(d)}}return a}(this.state.activeTape,r,i);if(!o&&0===a.length&&r.length>0)throw new Error("Cannot compute gradient of y=f(x) with respect to x. Make sure that the f you passed encloses all operations that lead from x to y.");return this.tidy("backward",()=>{const l={};l[i.id]=s??function CK(t){const n=YR(te(t),"float32");return F.makeTensor(n,t,"float32")}(i.shape),function fK(t,n,e,r){for(let s=n.length-1;s>=0;s--){const o=n[s],i=[];if(o.outputs.forEach(l=>{const u=t[l.id];i.push(null!=u?u:null)}),null==o.gradient)throw new Error(`Cannot compute gradient: gradient function not found for ${o.kernelName}.`);const a=o.gradient(i);for(const l in o.inputs){if(!(l in a))throw new Error(`Cannot backprop through input ${l}. Available gradients found: ${Object.keys(a)}.`);const u=e(()=>a[l]());if("float32"!==u.dtype)throw new Error(`Error in gradient for op ${o.kernelName}. The gradient of input ${l} must have 'float32' dtype, but has '${u.dtype}'`);const c=o.inputs[l];if(!Mt(u.shape,c.shape))throw new Error(`Error in gradient for op ${o.kernelName}. The gradient of input '${l}' has shape '${u.shape}', which does not match the shape of the input '${c.shape}'`);if(null==t[c.id])t[c.id]=u;else{const d=t[c.id];t[c.id]=r(d,u),d.dispose()}}}}(l,a,c=>this.tidy(c),IK);const u=r.map(c=>l[c.id]);return 0===this.state.gradientDepth&&(this.state.activeTape.forEach(c=>{for(const d of c.saved)d.dispose()}),this.state.activeTape=null),{value:i,grads:u}})}customGrad(e){return S(K0(e),()=>"The f passed in customGrad(f) must be a function."),(...r)=>{let s;S(r.every(l=>l instanceof an),()=>"The args passed in customGrad(f)(x1, x2,...) must all be tensors");const o={};return r.forEach((l,u)=>{o[u]=l}),this.runKernelFunc({forwardFunc:(l,u)=>(s=e(...r,u),S(s.value instanceof an,()=>"The function f passed in customGrad(f) must return an object where `obj.value` is a tensor"),S(K0(s.gradFunc),()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function."),s.value),backwardsFunc:(l,u)=>{const c=s.gradFunc(l,u),d=Array.isArray(c)?c:[c];S(d.length===r.length,()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns the same number of tensors as inputs passed to f(...)."),S(d.every(f=>f instanceof an),()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns a list of only tensors.");const h={};return d.forEach((f,p)=>{h[p]=()=>f}),h},inputs:o})}}readSync(e){return this.state.tensorInfo.get(e).backend.readSync(e)}read(e){return this.state.tensorInfo.get(e).backend.read(e)}time(e){var r=this;return J(function*(){const s=Pr(),o=yield r.backend.time(e);return o.wallMs=Pr()-s,o})()}track(e){return null!=this.state.activeScope&&(e.scopeId=this.state.activeScope.id,this.state.activeScope.track.push(e)),e}get registeredVariables(){return this.state.registeredVariables}reset(){this.pendingBackendInitId++,this.state.dispose(),this.ENV.reset(),this.state=new u$;for(const e in this.registry)this.disposeRegisteredKernels(e),this.registry[e].dispose(),delete this.registry[e];this.backendName=null,this.backendInstance=null,this.pendingBackendInit=null}}return t.nextTensorId=0,t.nextVariableId=0,t})();function c$(){const t=t$();if(null==t._tfengine){const n=new Jq(t);t._tfengine=new wK(n)}return function rK(t){e$=t}(t._tfengine.ENV),function gK(t){_o=t}(()=>t._tfengine),t._tfengine}const F=c$();function IK(t,n){return F.runKernel(su,{a:t,b:n})}function d$(){if(function DK(){return typeof navigator<"u"&&null!=navigator}()){const t=navigator.userAgent||navigator.vendor||window.opera;return/(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino/i.test(t)||/1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i.test(t.substr(0,4))}return!1}function h$(){return typeof window<"u"&&null!=window.document||typeof WorkerGlobalScope<"u"}const so=ne();function dh(t,n){let e=t;if(Io(t))return"string"===n?[]:[t.length];if(!Array.isArray(t))return[];const r=[];for(;Array.isArray(e)||Io(e)&&"string"!==n;)r.push(e.length),e=e[0];return Array.isArray(t)&&ne().getBool("TENSORLIKE_CHECK_SHAPE_CONSISTENCY")&&f$(t,r,[]),r}function f$(t,n,e){if(e=e||[],!Array.isArray(t)&&!Io(t))return void S(0===n.length,()=>`Element arr[${e.join("][")}] is a primitive, but should be an array/TypedArray of ${n[0]} elements`);S(n.length>0,()=>`Element arr[${e.join("][")}] should be a primitive, but is an array of ${t.length} elements`),S(t.length===n[0],()=>`Element arr[${e.join("][")}] should have ${n[0]} elements, but has ${t.length} elements`);const r=n.slice(1);for(let s=0;s<t.length;++s)f$(t[s],r,e.concat(s))}function p$(t,n,e,r){if("string_or_numeric"!==t){if(null==t)throw new Error("Expected dtype cannot be null.");if("numeric"!==t&&t!==n||"numeric"===t&&"string"===n)throw new Error(`Argument '${e}' passed to '${r}' must be ${t} tensor, but got ${n} tensor`)}}function T(t,n,e,r="numeric"){if(t instanceof an)return p$(r,t.dtype,n,e),t;let s=ld(t);if("string"!==s&&["bool","int32","float32"].indexOf(r)>=0&&(s=r),p$(r,s,n,e),null==t||!Io(t)&&!Array.isArray(t)&&"number"!=typeof t&&"boolean"!=typeof t&&"string"!=typeof t)throw new Error(`Argument '${n}' passed to '${e}' must be a Tensor or TensorLike, but got '${null==t?"null":t.constructor.name}'`);const o=dh(t,s);!Io(t)&&!Array.isArray(t)&&(t=[t]);const a="string"!==s?Ra(t,s):tu(t,[],!0);return F.makeTensor(a,o,s)}function m$(t,n,e,r="numeric"){if(!Array.isArray(t))throw new Error(`Argument ${n} passed to ${e} must be a \`Tensor[]\` or \`TensorLike[]\``);return t.map((o,i)=>T(o,`${n}[${i}]`,e,r))}function M(t){const n=Object.keys(t);if(1!==n.length)throw new Error(`Please provide an object with a single key (operation name) mapping to a function. Got an object with ${n.length} keys.`);let e=n[0];const r=t[e];e.endsWith("_")&&(e=e.substring(0,e.length-1)),e+="__op";const s=(...o)=>{F.startScope(e);try{const i=r(...o);return cd(i)&&console.error("Cannot return a Promise inside of tidy."),F.endScope(i),i}catch(i){throw F.endScope(null),i}};return Object.defineProperty(s,"name",{value:e,configurable:!0}),s}so.registerFlag("DEBUG",()=>!1,t=>{t&&console.warn("Debugging mode is ON. The output of every math call will be downloaded to CPU and checked for NaNs. This significantly impacts performance.")}),so.registerFlag("IS_BROWSER",()=>h$()),so.registerFlag("IS_NODE",()=>typeof process<"u"&&typeof process.versions<"u"&&typeof process.versions.node<"u"),so.registerFlag("IS_CHROME",()=>typeof navigator<"u"&&null!=navigator&&null!=navigator.userAgent&&/Chrome/.test(navigator.userAgent)&&/Google Inc/.test(navigator.vendor)),so.registerFlag("PROD",()=>!1),so.registerFlag("TENSORLIKE_CHECK_SHAPE_CONSISTENCY",()=>so.getBool("DEBUG")),so.registerFlag("DEPRECATION_WARNINGS_ENABLED",()=>!0),so.registerFlag("IS_TEST",()=>!1),so.registerFlag("CHECK_COMPUTATION_FOR_ERRORS",()=>!0),so.registerFlag("WRAP_TO_IMAGEBITMAP",()=>!1);const $a=M({complex_:function SK(t,n){const e=T(t,"real","complex"),r=T(n,"imag","complex");return cs(e.shape,r.shape,`real and imag shapes, ${e.shape} and ${r.shape}, must match in call to tf.complex().`),F.runKernel(rw,{real:e,imag:r})}});function hh(t,n,e,r){if(null==r&&(r=ld(t)),"complex64"===r)throw new Error("Cannot construct a complex64 tensor directly. Please use tf.complex(real, imag).");if(!Io(t)&&!Array.isArray(t)&&"number"!=typeof t&&"boolean"!=typeof t&&"string"!=typeof t)throw new Error("values passed to tensor(values) must be a number/boolean/string or an array of numbers/booleans/strings, or a TypedArray");if(null!=n){QR(n);const s=te(n),o=te(e);S(s===o,()=>`Based on the provided shape, [${n}], the tensor should have ${s} values but has ${o}`);for(let i=0;i<e.length;++i){const a=e[i],l=i!==e.length-1||a!==te(n.slice(i));S(e[i]===n[i]||!l,()=>`Error creating a new Tensor. Inferred shape (${e}) does not match the provided shape (${n}). `)}}return!Io(t)&&!Array.isArray(t)&&(t=[t]),n=n||e,t="string"!==r?Ra(t,r):tu(t,[],!0),F.makeTensor(t,n,r)}function Fa(t,n,e){return hh(t,n,dh(t,e),e)}const Zw={float32:4,float16:2,int32:4,uint16:2,uint8:1,bool:1,complex64:8};function g$(t,n){return Qw.apply(this,arguments)}function Qw(){return Qw=J(function*(t,n){const e=[],r=[],s=Array.isArray(t)?t.map(i=>i.name):Object.keys(t);for(let i=0;i<s.length;++i){const a=s[i],l=Array.isArray(t)?t[i].tensor:t[a];if("float32"!==l.dtype&&"int32"!==l.dtype&&"bool"!==l.dtype&&"string"!==l.dtype&&"complex64"!==l.dtype)throw new Error(`Unsupported dtype in weight '${a}': ${l.dtype}`);const u={name:a,shape:l.shape,dtype:l.dtype};if("string"===l.dtype){const c=new Promise(function(){var d=J(function*(h){const f=yield l.bytes(),p=f.reduce((y,b)=>y+b.length,0)+4*f.length,m=new Uint8Array(p);let g=0;for(let y=0;y<f.length;y++){const b=f[y],v=new Uint8Array(new Uint32Array([b.length]).buffer);m.set(v,g),g+=4,m.set(b,g),g+=b.length}h(m)});return function(h){return d.apply(this,arguments)}}());r.push(c)}else r.push(l.data());null!=n&&(u.group=n),e.push(u)}return{data:EK(yield Promise.all(r)),specs:e}}),Qw.apply(this,arguments)}function EK(t){if(null===t)throw new Error(`Invalid input value: ${JSON.stringify(t)}`);let n=0;const e=[];t.forEach(o=>{if(n+=o.byteLength,e.push(o.byteLength===o.buffer.byteLength?o:new o.constructor(o)),!(o instanceof Float32Array||o instanceof Int32Array||o instanceof Uint8Array))throw new Error(`Unsupported TypedArray subtype: ${o.constructor.name}`)});const r=new Uint8Array(n);let s=0;return e.forEach(o=>{r.set(new Uint8Array(o.buffer),s),s+=o.byteLength}),r.buffer}const Jw=typeof Buffer<"u"&&(typeof Blob>"u"||typeof atob>"u"||typeof btoa>"u");function b$(t){return Jw?Buffer.byteLength(t):new Blob([t]).size}function eC(t){if(1===t.length)return t[0];let n=0;t.forEach(s=>{n+=s.byteLength});const e=new Uint8Array(n);let r=0;return t.forEach(s=>{e.set(new Uint8Array(s),r),r+=s.byteLength}),e.buffer}function fg(t){if(t.modelTopology instanceof ArrayBuffer)throw new Error("Expected JSON model topology, received ArrayBuffer.");return{dateSaved:new Date,modelTopologyType:"JSON",modelTopologyBytes:null==t.modelTopology?0:b$(JSON.stringify(t.modelTopology)),weightSpecsBytes:null==t.weightSpecs?0:b$(JSON.stringify(t.weightSpecs)),weightDataBytes:null==t.weightData?0:t.weightData.byteLength}}function $K(){const t=function kK(){const t=e=>{let r=e<<13,s=0;for(;0==(8388608&r);)s-=8388608,r<<=1;return r&=-8388609,s+=947912704,r|s},n=new Uint32Array(2048);n[0]=0;for(let e=1;e<1024;e++)n[e]=t(e);for(let e=1024;e<2048;e++)n[e]=939524096+(e-1024<<13);return n}(),n=function AK(){const t=new Uint32Array(64);t[0]=0,t[31]=1199570944,t[32]=2147483648,t[63]=3347054592;for(let n=1;n<31;n++)t[n]=n<<23;for(let n=33;n<63;n++)t[n]=2147483648+(n-32<<23);return t}(),e=function RK(){const t=new Uint32Array(64);for(let n=0;n<64;n++)t[n]=1024;return t[0]=t[32]=0,t}();return r=>{const s=new ArrayBuffer(4*r.length),o=new Uint32Array(s);for(let i=0;i<r.length;i++){const a=r[i];o[i]=t[e[a>>10]+(1023&a)]+n[a>>10]}return new Float32Array(s)}}class ln{constructor(){this.saveRouters=[],this.loadRouters=[]}static getInstance(){return null==ln.instance&&(ln.instance=new ln),ln.instance}static registerSaveRouter(n){ln.getInstance().saveRouters.push(n)}static registerLoadRouter(n){ln.getInstance().loadRouters.push(n)}static getSaveHandlers(n){return ln.getHandlers(n,"save")}static getLoadHandlers(n,e){return ln.getHandlers(n,"load",e)}static getHandlers(n,e,r){const s=[];return("load"===e?ln.getInstance().loadRouters:ln.getInstance().saveRouters).forEach(i=>{const a=i(n,r);null!==a&&s.push(a)}),s}}const x$=t=>ln.getSaveHandlers(t),pg="tensorflowjs",Oa="models_store",Mi="model_info_store";function rC(){if(!ne().getBool("IS_BROWSER"))throw new Error("Failed to obtain IndexedDB factory because the current environmentis not a web browser.");const t=typeof window>"u"?self:window,n=t.indexedDB||t.mozIndexedDB||t.webkitIndexedDB||t.msIndexedDB||t.shimIndexedDB;if(null==n)throw new Error("The current browser does not appear to support IndexedDB.");return n}function sC(t){const n=t.result;n.createObjectStore(Oa,{keyPath:"modelPath"}),n.createObjectStore(Mi,{keyPath:"modelPath"})}let lu=(()=>{class t{constructor(e){if(this.indexedDB=rC(),null==e||!e)throw new Error("For IndexedDB, modelPath must not be null, undefined or empty.");this.modelPath=e}save(e){var r=this;return J(function*(){if(e.modelTopology instanceof ArrayBuffer)throw new Error("BrowserLocalStorage.save() does not support saving model topology in binary formats yet.");return r.databaseAction(r.modelPath,e)})()}load(){var e=this;return J(function*(){return e.databaseAction(e.modelPath)})()}databaseAction(e,r){return new Promise((s,o)=>{const i=this.indexedDB.open(pg,1);i.onupgradeneeded=()=>sC(i),i.onsuccess=()=>{const a=i.result;if(null==r){const l=a.transaction(Oa,"readonly"),c=l.objectStore(Oa).get(this.modelPath);c.onsuccess=()=>{if(null==c.result)return a.close(),o(new Error(`Cannot find model with path '${this.modelPath}' in IndexedDB.`));s(c.result.modelArtifacts)},c.onerror=d=>(a.close(),o(c.error)),l.oncomplete=()=>a.close()}else{const l=fg(r),u=a.transaction(Mi,"readwrite");let c=u.objectStore(Mi);const d=c.put({modelPath:this.modelPath,modelArtifactsInfo:l});let h;d.onsuccess=()=>{h=a.transaction(Oa,"readwrite");const p=h.objectStore(Oa).put({modelPath:this.modelPath,modelArtifacts:r,modelArtifactsInfo:l});p.onsuccess=()=>s({modelArtifactsInfo:l}),p.onerror=m=>{c=u.objectStore(Mi);const g=c.delete(this.modelPath);g.onsuccess=()=>(a.close(),o(p.error)),g.onerror=y=>(a.close(),o(p.error))}},d.onerror=f=>(a.close(),o(d.error)),u.oncomplete=()=>{null==h?a.close():h.oncomplete=()=>a.close()}}},i.onerror=a=>o(i.error)})}}return t.URL_SCHEME="indexeddb://",t})();const w$=t=>ne().getBool("IS_BROWSER")&&!Array.isArray(t)&&t.startsWith(lu.URL_SCHEME)?function OK(t){return new lu(t)}(t.slice(lu.URL_SCHEME.length)):null;ln.registerSaveRouter(w$),ln.registerLoadRouter(w$);class PK{constructor(){this.indexedDB=rC()}listModels(){var n=this;return J(function*(){return new Promise((e,r)=>{const s=n.indexedDB.open(pg,1);s.onupgradeneeded=()=>sC(s),s.onsuccess=()=>{const o=s.result,i=o.transaction(Mi,"readonly"),l=i.objectStore(Mi).getAll();l.onsuccess=()=>{const u={};for(const c of l.result)u[c.modelPath]=c.modelArtifactsInfo;e(u)},l.onerror=u=>(o.close(),r(l.error)),i.oncomplete=()=>o.close()},s.onerror=o=>r(s.error)})})()}removeModel(n){var e=this;return J(function*(){return n=function MK(t){return t.startsWith(lu.URL_SCHEME)?t.slice(lu.URL_SCHEME.length):t}(n),new Promise((r,s)=>{const o=e.indexedDB.open(pg,1);o.onupgradeneeded=()=>sC(o),o.onsuccess=()=>{const i=o.result,a=i.transaction(Mi,"readwrite"),l=a.objectStore(Mi),u=l.get(n);let c;u.onsuccess=()=>{if(null==u.result)return i.close(),s(new Error(`Cannot find model with path '${n}' in IndexedDB.`));{const d=l.delete(n),h=()=>{c=i.transaction(Oa,"readwrite");const p=c.objectStore(Oa).delete(n);p.onsuccess=()=>r(u.result.modelArtifactsInfo),p.onerror=m=>s(u.error)};d.onsuccess=h,d.onerror=f=>(h(),i.close(),s(u.error))}},u.onerror=d=>(i.close(),s(u.error)),a.oncomplete=()=>{null==c?i.close():c.oncomplete=()=>i.close()}},o.onerror=i=>s(o.error)})})()}}const So="/",Ma="tensorflowjs_models",C$="info",LK="model_topology",BK="weight_specs",zK="weight_data",VK="model_metadata";function I$(t){return{info:[Ma,t,C$].join(So),topology:[Ma,t,LK].join(So),weightSpecs:[Ma,t,BK].join(So),weightData:[Ma,t,zK].join(So),modelMetadata:[Ma,t,VK].join(So)}}function D$(t){const n=t.split(So);if(n.length<3)throw new Error(`Invalid key format: ${t}`);return n.slice(1,n.length-1).join(So)}let uu=(()=>{class t{constructor(e){if(!ne().getBool("IS_BROWSER")||typeof window>"u"||typeof window.localStorage>"u")throw new Error("The current environment does not support local storage.");if(this.LS=window.localStorage,null==e||!e)throw new Error("For local storage, modelPath must not be null, undefined or empty.");this.modelPath=e,this.keys=I$(this.modelPath)}save(e){var r=this;return J(function*(){if(e.modelTopology instanceof ArrayBuffer)throw new Error("BrowserLocalStorage.save() does not support saving model topology in binary formats yet.");{const s=JSON.stringify(e.modelTopology),o=JSON.stringify(e.weightSpecs),i=fg(e);try{r.LS.setItem(r.keys.info,JSON.stringify(i)),r.LS.setItem(r.keys.topology,s),r.LS.setItem(r.keys.weightSpecs,o),r.LS.setItem(r.keys.weightData,function NK(t){if(Jw)return Buffer.from(t).toString("base64");const n=new Uint8Array(t);let e="";for(let r=0,s=n.length;r<s;r++)e+=String.fromCharCode(n[r]);return btoa(e)}(e.weightData));const a={format:e.format,generatedBy:e.generatedBy,convertedBy:e.convertedBy};return null!=e.signature&&(a.signature=e.signature),null!=e.userDefinedMetadata&&(a.userDefinedMetadata=e.userDefinedMetadata),null!=e.modelInitializer&&(a.modelInitializer=e.modelInitializer),r.LS.setItem(r.keys.modelMetadata,JSON.stringify(a)),{modelArtifactsInfo:i}}catch{throw r.LS.removeItem(r.keys.info),r.LS.removeItem(r.keys.topology),r.LS.removeItem(r.keys.weightSpecs),r.LS.removeItem(r.keys.weightData),r.LS.removeItem(r.keys.modelMetadata),new Error(`Failed to save model '${r.modelPath}' to local storage: size quota being exceeded is a possible cause of this failure: modelTopologyBytes=${i.modelTopologyBytes}, weightSpecsBytes=${i.weightSpecsBytes}, weightDataBytes=${i.weightDataBytes}.`)}}})()}load(){var e=this;return J(function*(){const r=JSON.parse(e.LS.getItem(e.keys.info));if(null==r)throw new Error(`In local storage, there is no model with name '${e.modelPath}'`);if("JSON"!==r.modelTopologyType)throw new Error("BrowserLocalStorage does not support loading non-JSON model topology yet.");const s={},o=JSON.parse(e.LS.getItem(e.keys.topology));if(null==o)throw new Error(`In local storage, the topology of model '${e.modelPath}' is missing.`);s.modelTopology=o;const i=JSON.parse(e.LS.getItem(e.keys.weightSpecs));if(null==i)throw new Error(`In local storage, the weight specs of model '${e.modelPath}' are missing.`);s.weightSpecs=i;const a=e.LS.getItem(e.keys.modelMetadata);if(null!=a){const u=JSON.parse(a);s.format=u.format,s.generatedBy=u.generatedBy,s.convertedBy=u.convertedBy,null!=u.signature&&(s.signature=u.signature),null!=u.userDefinedMetadata&&(s.userDefinedMetadata=u.userDefinedMetadata),null!=u.modelInitializer&&(s.modelInitializer=u.modelInitializer)}const l=e.LS.getItem(e.keys.weightData);if(null==l)throw new Error(`In local storage, the binary weight values of model '${e.modelPath}' are missing.`);return s.weightData=function TK(t){if(Jw){const r=Buffer.from(t,"base64");return r.buffer.slice(r.byteOffset,r.byteOffset+r.byteLength)}const n=atob(t),e=new Uint8Array(n.length);for(let r=0;r<n.length;++r)e.set([n.charCodeAt(r)],r);return e.buffer}(l),s})()}}return t.URL_SCHEME="localstorage://",t})();const _$=t=>ne().getBool("IS_BROWSER")&&!Array.isArray(t)&&t.startsWith(uu.URL_SCHEME)?function WK(t){return new uu(t)}(t.slice(uu.URL_SCHEME.length)):null;ln.registerSaveRouter(_$),ln.registerLoadRouter(_$);class HK{constructor(){S(ne().getBool("IS_BROWSER"),()=>"Current environment is not a web browser"),S(typeof window>"u"||typeof window.localStorage<"u",()=>"Current browser does not appear to support localStorage"),this.LS=window.localStorage}listModels(){var n=this;return J(function*(){const e={},r=Ma+So,s=So+C$;for(let o=0;o<n.LS.length;++o){const i=n.LS.key(o);i.startsWith(r)&&i.endsWith(s)&&(e[D$(i)]=JSON.parse(n.LS.getItem(i)))}return e})()}removeModel(n){var e=this;return J(function*(){const r=I$(n=function UK(t){return t.startsWith(uu.URL_SCHEME)?t.slice(uu.URL_SCHEME.length):t}(n));if(null==e.LS.getItem(r.info))throw new Error(`Cannot find model at path '${n}'`);const s=JSON.parse(e.LS.getItem(r.info));return e.LS.removeItem(r.info),e.LS.removeItem(r.topology),e.LS.removeItem(r.weightSpecs),e.LS.removeItem(r.weightData),s})()}}class qr{constructor(){this.managers={}}static getInstance(){return null==qr.instance&&(qr.instance=new qr),qr.instance}static registerManager(n,e){S(null!=n,()=>"scheme must not be undefined or null."),n.endsWith("://")&&(n=n.slice(0,n.indexOf("://"))),S(n.length>0,()=>"scheme must not be an empty string.");const r=qr.getInstance();S(null==r.managers[n],()=>`A model store manager is already registered for scheme '${n}'.`),r.managers[n]=e}static getManager(n){const e=this.getInstance().managers[n];if(null==e)throw new Error(`Cannot find model manager for scheme '${n}'`);return e}static getSchemes(){return Object.keys(this.getInstance().managers)}}class GK{fetch(n,e){return fetch(n,e)}now(){return performance.now()}encode(n,e){if("utf-8"!==e&&"utf8"!==e)throw new Error(`Browser's encoder only supports utf-8, but got ${e}`);return null==this.textEncoder&&(this.textEncoder=new TextEncoder),this.textEncoder.encode(n)}decode(n,e){return new TextDecoder(e).decode(n)}}if(ne().get("IS_BROWSER")){ne().setPlatform("browser",new GK);try{qr.registerManager(uu.URL_SCHEME,new HK)}catch{}try{qr.registerManager(lu.URL_SCHEME,new PK)}catch{}}let du;function yt(t,n="float32",e){return n=n||"float32",QR(t),new Xn(t,n,e)}ne().get("IS_NODE")&&ne().setPlatform("node",new class qK{constructor(){this.util=B(628),this.textEncoder=new this.util.TextEncoder}fetch(n,e){return null!=ne().global.fetch?ne().global.fetch(n,e):(null==du&&(du=B(410)),du(n,e))}now(){const n=process.hrtime();return 1e3*n[0]+n[1]/1e6}encode(n,e){if("utf-8"!==e&&"utf8"!==e)throw new Error(`Node built-in encoder only supports utf-8, but got ${e}`);return this.textEncoder.encode(n)}decode(n,e){return 0===n.length?"":new this.util.TextDecoder(e).decode(n)}});const Ae=M({cast_:function KK(t,n){const e=T(t,"x","cast");if(!function Yq(t){return"bool"===t||"complex64"===t||"float32"===t||"int32"===t||"string"===t}(n))throw new Error(`Failed to cast to unknown dtype ${n}`);if("string"===n&&"string"!==e.dtype||"string"!==n&&"string"===e.dtype)throw new Error("Only strings can be casted to strings");return F.runKernel(bd,{x:e},{dtype:n})}}),Pa=M({clone_:function XK(t){const e={x:T(t,"x","clone","string_or_numeric")};return F.runKernel(Ad,e)}});function E$(t){return new Promise(n=>setTimeout(n)).then(t)}c$(),function yK(t){au=t}({buffer:yt,cast:Ae,clone:Pa,print:function YK(t,n=!1){console.log(t.toString(n))}});let cC=(()=>{class t{constructor(e){if(!ne().getBool("IS_BROWSER"))throw new Error("browserDownloads() cannot proceed because the current environment is not a browser.");e.startsWith(t.URL_SCHEME)&&(e=e.slice(t.URL_SCHEME.length)),(null==e||0===e.length)&&(e="model"),this.modelTopologyFileName=e+".json",this.weightDataFileName=e+".weights.bin"}save(e){var r=this;return J(function*(){if(typeof document>"u")throw new Error("Browser downloads are not supported in this environment since `document` is not present");const s=window.URL.createObjectURL(new Blob([e.weightData],{type:"application/octet-stream"}));if(e.modelTopology instanceof ArrayBuffer)throw new Error("BrowserDownloads.save() does not support saving model topology in binary formats yet.");{const i={modelTopology:e.modelTopology,format:e.format,generatedBy:e.generatedBy,convertedBy:e.convertedBy,weightsManifest:[{paths:["./"+r.weightDataFileName],weights:e.weightSpecs}]};null!=e.signature&&(i.signature=e.signature),null!=e.userDefinedMetadata&&(i.userDefinedMetadata=e.userDefinedMetadata),null!=e.modelInitializer&&(i.modelInitializer=e.modelInitializer);const a=window.URL.createObjectURL(new Blob([JSON.stringify(i)],{type:"application/json"})),l=r.jsonAnchor??document.createElement("a");if(l.download=r.modelTopologyFileName,l.href=a,yield E$(()=>l.dispatchEvent(new MouseEvent("click"))),null!=e.weightData){const u=r.weightDataAnchor??document.createElement("a");u.download=r.weightDataFileName,u.href=s,yield E$(()=>u.dispatchEvent(new MouseEvent("click")))}return{modelArtifactsInfo:fg(e)}}})()}}return t.URL_SCHEME="downloads://",t})();function N$(t,n,e,r){(function i(l){S(null!=l&&Array.isArray(l)&&l.length>0,()=>"promises must be a none empty array")})(t),function a(l,u){S(l>=0&&l<=1,()=>`Progress fraction must be in range [0, 1], but got startFraction ${l}`),S(u>=0&&u<=1,()=>`Progress fraction must be in range [0, 1], but got endFraction ${u}`),S(u>=l,()=>`startFraction must be no more than endFraction, but got startFraction ${l} and endFraction ${u}`)}(e=e??0,r=r??1);let s=0;return Promise.all(t.map(l=>(l.then(u=>{const c=e+ ++s/t.length*(r-e);return n(c),u}),l)))}function T$(t,n){return dC.apply(this,arguments)}function dC(){return(dC=J(function*(t,n){null==n&&(n={});const e=n.fetchFunc??ne().platform.fetch,r=t.map(d=>e(d,n.requestInit,{isBinary:!0})),a=(null==n.onProgress?yield Promise.all(r):yield N$(r,n.onProgress,0,.5)).map(d=>d.arrayBuffer());return null==n.onProgress?yield Promise.all(a):yield N$(a,n.onProgress,.5,1)})).apply(this,arguments)}ln.registerSaveRouter(t=>ne().getBool("IS_BROWSER")&&!Array.isArray(t)&&t.startsWith(cC.URL_SCHEME)?function nX(t="model"){return new cC(t)}(t.slice(cC.URL_SCHEME.length)):null);let k$=(()=>{class t{constructor(e,r){if(this.DEFAULT_METHOD="POST",null==r&&(r={}),this.weightPathPrefix=r.weightPathPrefix,this.onProgress=r.onProgress,this.weightUrlConverter=r.weightUrlConverter,null!=r.fetchFunc?(S("function"==typeof r.fetchFunc,()=>"Must pass a function that matches the signature of `fetch` (see https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API)"),this.fetch=r.fetchFunc):this.fetch=ne().platform.fetch,S(null!=e&&e.length>0,()=>"URL path for http must not be null, undefined or empty."),Array.isArray(e)&&S(2===e.length,()=>`URL paths for http must have a length of 2, (actual length is ${e.length}).`),this.path=e,null!=r.requestInit&&null!=r.requestInit.body)throw new Error("requestInit is expected to have no pre-existing body, but has one.");this.requestInit=r.requestInit||{}}save(e){var r=this;return J(function*(){if(e.modelTopology instanceof ArrayBuffer)throw new Error("BrowserHTTPRequest.save() does not support saving model topology in binary formats yet.");const s=Object.assign({method:r.DEFAULT_METHOD},r.requestInit);s.body=new FormData;const i={modelTopology:e.modelTopology,format:e.format,generatedBy:e.generatedBy,convertedBy:e.convertedBy,weightsManifest:[{paths:["./model.weights.bin"],weights:e.weightSpecs}]};null!=e.signature&&(i.signature=e.signature),null!=e.userDefinedMetadata&&(i.userDefinedMetadata=e.userDefinedMetadata),null!=e.modelInitializer&&(i.modelInitializer=e.modelInitializer),s.body.append("model.json",new Blob([JSON.stringify(i)],{type:"application/json"}),"model.json"),null!=e.weightData&&s.body.append("model.weights.bin",new Blob([e.weightData],{type:"application/octet-stream"}),"model.weights.bin");const a=yield r.fetch(r.path,s);if(a.ok)return{modelArtifactsInfo:fg(e),responses:[a]};throw new Error(`BrowserHTTPRequest.save() failed due to HTTP response status ${a.status}.`)})()}load(){var e=this;return J(function*(){const r=yield e.fetch(e.path,e.requestInit);if(!r.ok)throw new Error(`Request to ${e.path} failed with status code ${r.status}. Please verify this URL points to the model JSON of the model to load.`);let s;try{s=yield r.json()}catch{let y=`Failed to parse model JSON of response from ${e.path}.`;throw e.path.endsWith(".pb")?y+=" Your path contains a .pb file extension. Support for .pb models have been removed in TensorFlow.js 1.0 in favor of .json models. You can re-convert your Python TensorFlow model using the TensorFlow.js 1.0 conversion scripts or you can convert your.pb models with the 'pb2json'NPM script in the tensorflow/tfjs-converter repository.":y+=" Please make sure the server is serving valid JSON for this request.",new Error(y)}const o=s.modelTopology,i=s.weightsManifest,a=s.generatedBy,l=s.convertedBy,u=s.format,c=s.signature,d=s.userDefinedMetadata;if(null==o&&null==i)throw new Error(`The JSON from HTTP path ${e.path} contains neither model topology or manifest for weights.`);let h,f;null!=i&&([h,f]=yield e.loadWeights(i));const p={modelTopology:o,weightSpecs:h,weightData:f,generatedBy:a,convertedBy:l,format:u};null!=c&&(p.signature=c),null!=d&&(p.userDefinedMetadata=d);const m=s.modelInitializer;return m&&(p.modelInitializer=m),p})()}loadWeights(e){var r=this;return J(function*(){const s=Array.isArray(r.path)?r.path[1]:r.path,[o,i]=function iX(t){const n=t.lastIndexOf("/"),e=t.lastIndexOf("?");return[t.substring(0,n)+"/",e>n?t.substring(e):""]}(s),a=r.weightPathPrefix||o,l=[];for(const h of e)l.push(...h.weights);const u=[],c=[];for(const h of e)for(const f of h.paths)null!=r.weightUrlConverter?c.push(r.weightUrlConverter(f)):u.push(a+f+i);return r.weightUrlConverter&&u.push(...yield Promise.all(c)),[l,eC(yield T$(u,{requestInit:r.requestInit,fetchFunc:r.fetch,onProgress:r.onProgress}))]})()}}return t.URL_SCHEME_REGEX=/^https?:\/\//,t})();function A$(t){return null!=t.match(k$.URL_SCHEME_REGEX)}const R$=(t,n)=>{if(typeof fetch>"u"&&(null==n||null==n.fetchFunc))return null;{let e=!0;if(e=Array.isArray(t)?t.every(r=>A$(r)):A$(t),e)return $$(t,n)}return null};function $$(t,n){return new k$(t,n)}function F$(t,n){return $$(t,n)}let hu;ln.registerSaveRouter(R$),ln.registerLoadRouter(R$);const fX=M({fromPixels_:function O$(t,n=3){if(n>4)throw new Error("Cannot construct Tensor with more than 4 channels from pixels.");if(null==t)throw new Error("pixels passed to tf.browser.fromPixels() can not be null");let e=!1,r=!1,s=!1,o=!1,i=!1,a=!1;if(t.data instanceof Uint8Array)e=!0;else if(typeof ImageData<"u"&&t instanceof ImageData)r=!0;else if(typeof HTMLVideoElement<"u"&&t instanceof HTMLVideoElement)s=!0;else if(typeof HTMLImageElement<"u"&&t instanceof HTMLImageElement)o=!0;else if(null!=t.getContext)i=!0;else{if(!(typeof ImageBitmap<"u"&&t instanceof ImageBitmap))throw new Error(`pixels passed to tf.browser.fromPixels() must be either an HTMLVideoElement, HTMLImageElement, HTMLCanvasElement, ImageData in browser, or OffscreenCanvas, ImageData in webworker or {data: Uint32Array, width: number, height: number}, but was ${t.constructor.name}`);a=!0}if(s&&s&&t.readyState<2)throw new Error("The video element has not loaded data yet. Please wait for `loadeddata` event on the <video> element.");if(null!=Hw(Uw,F.backendName))return F.runKernel(Uw,{pixels:t},{numChannels:n});const[u,c]=s?[t.videoWidth,t.videoHeight]:[t.width,t.height];let d,h;if(i?d=t.getContext("2d").getImageData(0,0,u,c).data:r||e?d=t.data:(o||s||a)&&(null==hu&&(hu=document.createElement("canvas").getContext("2d")),hu.canvas.width=u,hu.canvas.height=c,hu.drawImage(t,0,0,u,c),d=hu.getImageData(0,0,u,c).data),4===n)h=new Int32Array(d);else{const p=u*c;h=new Int32Array(p*n);for(let m=0;m<p;m++)for(let g=0;g<n;++g)h[m*n+g]=d[4*m+g]}return function lX(t,n,e){if(H0(t),null!=n&&3!==n.length)throw new Error("tensor3d() requires shape to have three numbers");const r=dh(t,e);if(3!==r.length&&1!==r.length)throw new Error("tensor3d() requires values to be number[][][] or flat/TypedArray");if(1===r.length&&null==n)throw new Error("tensor3d() requires shape to be provided when `values` are a flat array");return hh(t,n,r,e)}(h,[c,u,n],"int32")}});function gC(t,n,e){const r=t.shape.length;S(r===n.length,()=>`Error in slice${r}D: Length of begin ${n} must match the rank of the array (${r}).`),S(r===e.length,()=>`Error in slice${r}D: Length of size ${e} must match the rank of the array (${r}).`);for(let s=0;s<r;++s)S(n[s]+e[s]<=t.shape[s],()=>`Error in slice${r}D: begin[${s}] + size[${s}] (${n[s]+e[s]}) would overflow input.shape[${s}] (${t.shape[s]})`)}function gg(t){const n=[];let e=0;for(;t>0;)1&t&&n.push(e),t/=2,e++;return n}function M$(t,n,e){const r=[];for(let s=0;s<t.length;s++)r[s]=Math.ceil((n[s]-t[s])/e[s]);return r}function P$(t,n,e,r){const s=[...t];for(let o=s.length;o<r.length;o++)s.push(1);for(let o=0;o<e;o++)0===o?s[n]=1:(s.splice(n,0,1),s.pop());return s}function L$(t,n,e){return e<=t?e:e-(n-1)}function B$(t,n){const e=[];for(let r=0;r<t;r++)e.push(n+r);return e}function z$(t,n,e,r,s,o,i,a,l){const u=t.length;let c=new Array(u),d=new Array(u),h=new Array(u);if(n.length&&e>0){const f=n[0],p=e+1;c=V$(i,f,p,r,t),d=U$(a,f,p,s,t),h=P$(o,f,p,t)}else for(let f=0;f<u;f++)c[f]=H$(i,r,o,t,f,l),d[f]=G$(a,s,o,t,f,l),h[f]=W$(o,f,l);return{begin:c,end:d,strides:h}}function V$(t,n,e,r,s){const o=[...s],i=B$(e,n);for(let a=0;a<o.length;a++)if(i.indexOf(a)>-1)o[a]=0;else{const l=L$(n,e,a);let u=r[l];t&1<<l&&(u=0),o[a]=u}return o}function U$(t,n,e,r,s){const o=[...s],i=B$(e,n);for(let a=0;a<o.length;a++)if(i.indexOf(a)>-1)o[a]=Number.MAX_SAFE_INTEGER;else{const l=L$(n,e,a);let u=r[l];t&1<<l&&(u=Number.MAX_SAFE_INTEGER),o[a]=u}for(let a=0;a<o.length;a++){const l=s[a];o[a]<0&&(o[a]+=l),o[a]=ka(0,o[a],s[a])}return o}function W$(t,n,e){let r=t[n];return(e&1<<n||null==r)&&(r=1),r}function H$(t,n,e,r,s,o){let i=n[s];(t&1<<s||o&1<<s||null==i)&&(i=(e[s]||1)>0?Number.MIN_SAFE_INTEGER:Number.MAX_SAFE_INTEGER);const l=r[s];return i<0&&(i+=l),i=ka(0,i,l-1),i}function G$(t,n,e,r,s,o){let i=n[s];const a=e[s]||1;(t&1<<s||o&1<<s||null==i)&&(i=a>0?Number.MAX_SAFE_INTEGER:Number.MIN_SAFE_INTEGER);const l=r[s];return i<0&&(i+=l),i=a>0?ka(0,i,l):ka(-1,i,l-1),i}function yC(t,n,e){let r=e.length;for(let s=0;s<e.length;s++)if(e[s]>1){r=s;break}for(let s=r+1;s<e.length;s++)if(n[s]>0||e[s]!==t[s])return!1;return!0}function bC(t,n){let e=t.length>0?t[t.length-1]:1;for(let r=0;r<t.length-1;r++)e+=t[r]*n[r];return e}function yg(t,n,e){let r;const s=t.shape.length;let o;return r="number"==typeof n?[n,...new Array(s-1).fill(0)]:n.length<s?n.concat(new Array(s-n.length).fill(0)):n.slice(),r.forEach(i=>{S(-1!==i,()=>"slice() does not support negative begin indexing.")}),o=null==e?new Array(s).fill(-1):"number"==typeof e?[e,...new Array(s-1).fill(-1)]:e.length<s?e.concat(new Array(s-e.length).fill(-1)):e,o=o.map((i,a)=>i>=0?i:(S(-1===i,()=>`Negative size values should be exactly -1 but got ${i} for the slice() size at index ${a}.`),t.shape[a]-r[a])),[r,o]}function vC(t,n,e,r,s,o,i,a,l){let u=n.slice(),c=e.slice(),d=r;null==r&&(d=new Array(u.length));const h=gg(i);if(h.length>1)throw new Error("Multiple ellipses in slice is not allowed.");if(0!==i&&0!==a)throw new Error("Using both ellipsisMask and newAxisMask is not yet supported.");if(0!==i&&0!==l)throw new Error("Using both ellipsisMask and shrinkAxisMask is not yet supported.");const f=t.length-u.length,p=gg(a),m=t.slice();p.forEach(D=>{u[D]=0,c[D]=1,m.splice(D,0,1)});const{begin:g,end:y,strides:b}=z$(m,h,f,u,c,d,s,o,i);u=g,c=y,d=b;const v=gg(l);v.forEach(D=>{c[D]=u[D]+1,d[D]=1});const x=M$(u,c,d),w=x.filter((D,A)=>-1===v.indexOf(A));return{nonStrided:d.every(D=>1===D),$begin:u,$end:c,$strides:d,size:x,newShape:m,outShape:w}}class fu{getClassName(){return this.constructor.className}static fromConfig(n,e){return new n(e)}}class Ts{constructor(){this.classNameMap={}}static getMap(){return null==Ts.instance&&(Ts.instance=new Ts),Ts.instance}static register(n){Ts.getMap().classNameMap[n.className]=[n,n.fromConfig]}}function le(t){S(null!=t.className,()=>"Class being registered does not have the static className property defined."),S("string"==typeof t.className,()=>"className is required to be a string, but got type "+typeof t.className),S(t.className.length>0,()=>"Class being registered has an empty-string as its className, which is disallowed."),Ts.register(t)}function Pi(){return F}function xC(){return F.memory()}function U(t,n){return F.tidy(t,n)}function it(t){a$(t).forEach(e=>e.dispose())}function ir(t){return F.keep(t)}function j$(t){return F.setBackend(t)}function q$(t,n,e=1){return F.registerBackend(t,n,e)}function ni(t){return F.customGrad(t)}function Fe(t,n){if((Io(t)&&"string"!==n||Array.isArray(t))&&"complex64"!==n)throw new Error("Error creating a new Scalar: value must be a primitive (number|boolean|string)");if("string"===n&&Io(t)&&!(t instanceof Uint8Array))throw new Error("When making a scalar from encoded string, the value must be `Uint8Array`.");return hh(t,[],[],n)}!function bK(t){i$=t}(function mX(t){ne().getBool("DEPRECATION_WARNINGS_ENABLED")&&console.warn(t+" You can disable deprecation warnings with tf.disableDeprecationWarnings().")});class Li extends fu{minimize(n,e=!1,r){const{value:s,grads:o}=this.computeGradients(n,r);if(null!=r){const i=r.map(a=>({name:a.name,tensor:o[a.name]}));this.applyGradients(i)}else this.applyGradients(o);return it(o),e?s:(s.dispose(),null)}get iterations(){return null==this.iterations_&&(this.iterations_=0),this.iterations_}incrementIterations(){this.iterations_=this.iterations+1}computeGradients(n,e){return function bX(t,n){S(K0(t),()=>"The f passed in variableGrads(f) must be a function"),S(null==n||Array.isArray(n)&&n.every(u=>u instanceof ag),()=>"The varList passed in variableGrads(f, varList) must be an array of variables");const e=null!=n;if(!e){n=[];for(const u in F.registeredVariables)n.push(F.registeredVariables[u])}const r=e?n.filter(u=>!u.trainable):null,s=n.length;S((n=n.filter(u=>u.trainable)).length>0,()=>`variableGrads() expects at least one of the input variables to be trainable, but none of the ${s} variables is trainable.`);const{value:i,grads:a}=F.gradients(t,n,null,!0);S(a.some(u=>null!=u),()=>"Cannot find a connection between any variable and the result of the loss function y=f(x). Please make sure the operations that use variables are inside the function f passed to minimize()."),S(0===i.rank,()=>`The f passed in variableGrads(f) must return a scalar, but it returned a rank-${i.rank} tensor`);const l={};return n.forEach((u,c)=>{null!=a[c]&&(l[u.name]=a[c])}),r?.forEach(u=>l[u.name]=null),{value:i,grads:l}}(n,e)}dispose(){null!=this.iterations_&&it(this.iterations_)}saveIterations(){var n=this;return J(function*(){return null==n.iterations_&&(n.iterations_=0),{name:"iter",tensor:Fe(n.iterations_,"int32")}})()}getWeights(){return J(function*(){throw new Error("getWeights() is not implemented for this optimizer yet.")})()}setWeights(n){var e=this;return J(function*(){throw new Error(`setWeights() is not implemented for this optimizer class ${e.getClassName()}`)})()}extractIterations(n){var e=this;return J(function*(){return e.iterations_=(yield n[0].tensor.data())[0],n.slice(1)})()}}Object.defineProperty(Li,Symbol.hasInstance,{value:t=>null!=t.minimize&&null!=t.computeGradients&&null!=t.applyGradients});const Yn=M({abs_:function vX(t){const n=T(t,"x","abs");return F.runKernel("complex64"===n.dtype?cm:nm,{x:n})}}),me=M({add_:function xX(t,n){let e=T(t,"a","add"),r=T(n,"b","add");return[e,r]=fn(e,r),F.runKernel(su,{a:e,b:r})}}),wC=M({all_:function wX(t,n=null,e=!1){const s={x:T(t,"x","all","bool")};return F.runKernel("All",s,{axis:n,keepDims:e})}}),vg=M({any_:function CX(t,n=null,e=!1){const s={x:T(t,"x","any","bool")};return F.runKernel("Any",s,{axis:n,keepDims:e})}}),xg=M({argMax_:function IX(t,n=0){const r={x:T(t,"x","argMax")};return F.runKernel(sm,r,{axis:n})}});function fh(t,n,e,r,s="NHWC",o){return Zn(t,[...n,t[3]],e,o,r,null,null,si(s))}function ks(t,n,e,r,s,o,i="channelsLast"){const[a,l]=wg(n);let u;if("channelsLast"===i)u=[a,l,t[3],t[3]];else{if("channelsFirst"!==i)throw new Error(`Unknown dataFormat ${i}`);u=[a,l,t[1],t[1]]}return Zn(t,u,e,r,s,o,!1,i)}function ri(t,n,e,r,s,o,i="NDHWC"){const[a,l,u]=IC(n);let c,d;if("NDHWC"===i)d="channelsLast",c=[a,l,u,t[4],t[4]];else{if("NCDHW"!==i)throw new Error(`Unknown dataFormat ${i}`);d="channelsFirst",c=[a,l,u,t[1],t[1]]}return Bi(t,c,e,r,s,!1,d,o)}function Zn(t,n,e,r,s,o,i=!1,a="channelsLast"){let[l,u,c,d]=[-1,-1,-1,-1];if("channelsLast"===a)[l,u,c,d]=t;else{if("channelsFirst"!==a)throw new Error(`Unknown dataFormat ${a}`);[l,d,u,c]=t}const[h,f,,p]=n,[m,g]=wg(e),[y,b]=wg(r),v=pu(h,y),x=pu(f,b),{padInfo:w,outHeight:_,outWidth:D}=function SX(t,n,e,r,s,o,i,a,l){let u,c,d;if("number"==typeof t){u={top:t,bottom:t,left:t,right:t,type:0===t?"VALID":"NUMBER"};const f=function DX(t,n,e,r,s){null==r&&(r=CC(t,n,e));const i=t[1];return[La((t[0]-n+2*r)/e+1,s),La((i-n+2*r)/e+1,s)]}([n,e],o,r,t,a);c=f[0],d=f[1]}else if("same"===t){c=Math.ceil(n/r),d=Math.ceil(e/s);const h=Math.max(0,(c-1)*r+o-n),f=Math.max(0,(d-1)*s+i-e),p=Math.floor(h/2),m=h-p,g=Math.floor(f/2);u={top:p,bottom:m,left:g,right:f-g,type:"SAME"}}else if("valid"===t)u={top:0,bottom:0,left:0,right:0,type:"VALID"},c=Math.ceil((n-o+1)/r),d=Math.ceil((e-i+1)/s);else{if("object"!=typeof t)throw Error(`Unknown padding parameter: ${t}`);{const h="channelsLast"===l?t[1][0]:t[2][0],f="channelsLast"===l?t[1][1]:t[2][1],p="channelsLast"===l?t[2][0]:t[3][0],m="channelsLast"===l?t[2][1]:t[3][1];u={top:h,bottom:f,left:p,right:m,type:0===h&&0===f&&0===p&&0===m?"VALID":"EXPLICIT"},c=La((n-o+h+f)/r+1,a),d=La((e-i+p+m)/s+1,a)}}return{padInfo:u,outHeight:c,outWidth:d}}(s,u,c,m,g,v,x,o,a),A=i?p*d:p;let R;return"channelsFirst"===a?R=[l,A,_,D]:"channelsLast"===a&&(R=[l,_,D,A]),{batchSize:l,dataFormat:a,inHeight:u,inWidth:c,inChannels:d,outHeight:_,outWidth:D,outChannels:A,padInfo:w,strideHeight:m,strideWidth:g,filterHeight:h,filterWidth:f,effectiveFilterHeight:v,effectiveFilterWidth:x,dilationHeight:y,dilationWidth:b,inShape:t,outShape:R,filterShape:n}}function Bi(t,n,e,r,s,o=!1,i="channelsLast",a){let[l,u,c,d,h]=[-1,-1,-1,-1,-1];if("channelsLast"===i)[l,u,c,d,h]=t;else{if("channelsFirst"!==i)throw new Error(`Unknown dataFormat ${i}`);[l,h,u,c,d]=t}const[f,p,m,,g]=n,[y,b,v]=IC(e),[x,w,_]=IC(r),D=pu(f,x),A=pu(p,w),R=pu(m,_),{padInfo:O,outDepth:G,outHeight:K,outWidth:j}=function EX(t,n,e,r,s,o,i,a,l,u,c){let d,h,f,p;if("number"==typeof t){d={top:t,bottom:t,left:t,right:t,front:t,back:t,type:0===t?"VALID":"NUMBER"};const g=function _X(t,n,e,r,s,o){null==s&&(s=CC(t,n,r));const a=t[1],l=t[2];return[La((t[0]-n+2*s)/r+1,o),La((a-n+2*s)/r+1,o),La((l-n+2*s)/r+1,o),e]}([n,e,r,1],a,1,s,t,c);h=g[0],f=g[1],p=g[2]}else if("same"===t){h=Math.ceil(n/s),f=Math.ceil(e/o),p=Math.ceil(r/i);const m=(h-1)*s+a-n,g=(f-1)*o+l-e,y=(p-1)*i+u-r,b=Math.floor(m/2),v=m-b,x=Math.floor(g/2),w=g-x,_=Math.floor(y/2);d={top:x,bottom:w,left:_,right:y-_,front:b,back:v,type:"SAME"}}else{if("valid"!==t)throw Error(`Unknown padding parameter: ${t}`);d={top:0,bottom:0,left:0,right:0,front:0,back:0,type:"VALID"},h=Math.ceil((n-a+1)/s),f=Math.ceil((e-l+1)/o),p=Math.ceil((r-u+1)/i)}return{padInfo:d,outDepth:h,outHeight:f,outWidth:p}}(s,u,c,d,y,b,v,D,A,R,a),Q=o?g*h:g;let q;return"channelsFirst"===i?q=[l,Q,G,K,j]:"channelsLast"===i&&(q=[l,G,K,j,Q]),{batchSize:l,dataFormat:i,inDepth:u,inHeight:c,inWidth:d,inChannels:h,outDepth:G,outHeight:K,outWidth:j,outChannels:Q,padInfo:O,strideDepth:y,strideHeight:b,strideWidth:v,filterDepth:f,filterHeight:p,filterWidth:m,effectiveFilterDepth:D,effectiveFilterHeight:A,effectiveFilterWidth:R,dilationDepth:x,dilationHeight:w,dilationWidth:_,inShape:t,outShape:q,filterShape:n}}function CC(t,n,e,r=1){const s=pu(n,r);return Math.floor((t[0]*(e-1)-e+s)/2)}function wg(t){return"number"==typeof t?[t,t,t]:2===t.length?[t[0],t[1],1]:t}function IC(t){return"number"==typeof t?[t,t,t]:t}function pu(t,n){return n<=1?t:t+(t-1)*(n-1)}function La(t,n){if(!n)return Math.trunc(t);switch(n){case"round":return Math.round(t);case"ceil":return Math.ceil(t);case"floor":return Math.floor(t);default:throw new Error(`Unknown roundingMode ${n}`)}}function zi(t){const[n,e,r]=wg(t);return 1===n&&1===e&&1===r}function ar(t,n){return zi(t)||zi(n)}function si(t){if("NHWC"===t)return"channelsLast";if("NCHW"===t)return"channelsFirst";throw new Error(`Unknown dataFormat ${t}`)}const H=M({reshape_:function NX(t,n){const r={x:T(t,"x","reshape","string_or_numeric")};return F.runKernel(Wm,r,{shape:n})}}),Cg=M({avgPool_:function TX(t,n,e,r,s){const o=T(t,"x","avgPool","float32");S(ar(e,1),()=>`Error in avgPool: Either strides or dilations must be 1. Got strides ${e} and dilations '1'`);let a=o,l=!1;3===o.rank&&(l=!0,a=H(o,[1,o.shape[0],o.shape[1],o.shape[2]])),S(4===a.rank,()=>`Error in avgPool: x must be rank 4 but got rank ${a.rank}.`),null!=s&&S(Kn(r),()=>`Error in avgPool: pad must be an integer when using, dimRoundingMode ${s} but got pad ${r}.`);let d=F.runKernel(im,{x:a},{filterSize:n,strides:e,pad:r,dimRoundingMode:s});return d=Ae(d,o.dtype),l?H(d,[d.shape[1],d.shape[2],d.shape[3]]):d}}),K$=M({avgPool3d_:function kX(t,n,e,r,s,o="NDHWC"){const i=T(t,"x","avgPool3d","float32");let a=i,l=!1;4===i.rank&&(l=!0,a=H(i,[1,i.shape[0],i.shape[1],i.shape[2],i.shape[3]])),S(5===a.rank,()=>`Error in avgPool3d: x must be rank 5 but got rank ${a.rank}.`),S("NDHWC"===o,()=>`Error in avgPool3d: Only NDHWC is currently supported, but got dataFormat of ${o}`),null!=s&&S(Kn(r),()=>`Error in avgPool3d: pad must be an integer when using, dimRoundingMode ${s} but got pad ${r}.`);let d=F.runKernel(am,{x:a},{filterSize:n,strides:e,pad:r,dimRoundingMode:s,dataFormat:o});return d=Ae(d,a.dtype),l?H(d,[d.shape[1],d.shape[2],d.shape[3],d.shape[4]]):d}});function AX(t){let n;return n=0===t.rank||1===t.rank?H(t,[1,1,1,t.size]):2===t.rank?H(t,[1,1,t.shape[0],t.shape[1]]):3===t.rank?H(t,[1,t.shape[0],t.shape[1],t.shape[2]]):t,n}const mu=M({batchNorm_:function RX(t,n,e,r,s,o){null==o&&(o=.001);const i=T(t,"x","batchNorm"),a=T(n,"mean","batchNorm"),l=T(e,"variance","batchNorm");let u,c;null!=s&&(u=T(s,"scale","batchNorm")),null!=r&&(c=T(r,"offset","batchNorm")),S(a.rank===l.rank,()=>"Batch normalization gradient requires mean and variance to have equal ranks."),S(null==c||a.rank===c.rank,()=>"Batch normalization gradient requires mean and offset to have equal ranks."),S(null==u||a.rank===u.rank,()=>"Batch normalization gradient requires mean and scale to have equal ranks.");const h={x:AX(i),scale:u,offset:c,mean:a,variance:l},p=F.runKernel(xm,h,{varianceEpsilon:o});return H(p,i.shape)}}),FX=M({batchNorm2d_:function $X(t,n,e,r,s,o){const i=T(t,"x","batchNorm"),a=T(n,"mean","batchNorm"),l=T(e,"variance","batchNorm");let u,c;return null!=s&&(u=T(s,"scale","batchNorm")),null!=r&&(c=T(r,"offset","batchNorm")),S(2===i.rank,()=>`Error in batchNorm2D: x must be rank 2 but got rank ${i.rank}.`),S(2===a.rank||1===a.rank,()=>`Error in batchNorm2D: mean must be rank 2 or rank 1 but got rank ${a.rank}.`),S(2===l.rank||1===l.rank,()=>`Error in batchNorm2D: variance must be rank 2 or rank 1 but got rank ${l.rank}.`),null!=u&&S(2===u.rank||1===u.rank,()=>`Error in batchNorm2D: scale must be rank 2 or rank 1 but got rank ${u.rank}.`),null!=c&&S(2===c.rank||1===c.rank,()=>`Error in batchNorm2D: offset must be rank 2 or rank 1 but got rank ${c.rank}.`),mu(i,a,l,c,u,o)}}),MX=M({batchNorm3d_:function OX(t,n,e,r,s,o){const i=T(t,"x","batchNorm"),a=T(n,"mean","batchNorm"),l=T(e,"variance","batchNorm");let u,c;return null!=s&&(u=T(s,"scale","batchNorm")),null!=r&&(c=T(r,"offset","batchNorm")),S(3===i.rank,()=>`Error in batchNorm3D: x must be rank 3 but got rank ${i.rank}.`),S(3===a.rank||1===a.rank,()=>`Error in batchNorm3D: mean must be rank 3 or rank 1 but got rank ${a.rank}.`),S(3===l.rank||1===l.rank,()=>`Error in batchNorm3D: variance must be rank 3 or rank 1 but got rank ${l.rank}.`),null!=u&&S(3===u.rank||1===u.rank,()=>`Error in batchNorm3D: scale must be rank 3 or rank 1 but got rank ${u.rank}.`),null!=c&&S(3===c.rank||1===c.rank,()=>`Error in batchNorm3D: offset must be rank 3 or rank 1 but got rank ${c.rank}.`),mu(i,a,l,c,u,o)}}),LX=M({batchNorm4d_:function PX(t,n,e,r,s,o){const i=T(t,"x","batchNorm"),a=T(n,"mean","batchNorm"),l=T(e,"variance","batchNorm");let u,c;return null!=s&&(u=T(s,"scale","batchNorm")),null!=r&&(c=T(r,"offset","batchNorm")),S(4===i.rank,()=>`Error in batchNorm4D: x must be rank 4 but got rank ${i.rank}.`),S(4===a.rank||1===a.rank,()=>`Error in batchNorm4D: mean must be rank 4 or rank 1 but got rank ${a.rank}.`),S(4===l.rank||1===l.rank,()=>`Error in batchNorm4D: variance must be rank 4 or rank 1 but got rank ${l.rank}.`),null!=u&&S(4===u.rank||1===u.rank,()=>`Error in batchNorm4D: scale must be rank 4 or rank 1 but got rank ${u.rank}.`),null!=c&&S(4===c.rank||1===c.rank,()=>`Error in batchNorm4D: offset must be rank 4 or rank 1 but got rank ${c.rank}.`),mu(i,a,l,c,u,o)}}),Kr=M({clipByValue_:function BX(t,n,e){const r=T(t,"x","clipByValue");return S(n<=e,()=>`Error in clip: min (${n}) must be less than or equal to max (${e}).`),F.runKernel(xd,{x:r},{clipValueMin:n,clipValueMax:e})}}),Sn=M({concat_:function zX(t,n=0){S(t.length>=1,()=>"Pass at least one tensor to concat");const e=m$(t,"tensors","concat","string_or_numeric");return"complex64"===e[0].dtype&&e.forEach(o=>{if("complex64"!==o.dtype)throw new Error(`Cannot concatenate complex64 tensors with a tensor\n          with dtype ${o.dtype}. `)}),1===e.length?Pa(e[0]):F.runKernel(dm,e,{axis:n})}}),UX=M({concat1d_:function VX(t){return Sn(t,0)}}),HX=M({concat2d_:function WX(t,n){return Sn(t,n)}}),jX=M({concat3d_:function GX(t,n){return Sn(t,n)}}),KX=M({concat4d_:function qX(t,n){return Sn(t,n)}}),Vi=M({conv2d_:function XX(t,n,e,r,s="NHWC",o=[1,1],i){const a=T(t,"x","conv2d"),l=T(n,"filter","conv2d");let u=a,c=!1;3===a.rank&&(c=!0,u=H(a,[1,a.shape[0],a.shape[1],a.shape[2]])),S(4===u.rank,()=>`Error in conv2d: input must be rank 4, but got rank ${u.rank}.`),S(4===l.rank,()=>`Error in conv2d: filter must be rank 4, but got rank ${l.rank}.`),null!=i&&S(Kn(r),()=>`Error in conv2d: pad must be an integer when using, dimRoundingMode ${i} but got pad ${r}.`);const d="NHWC"===s?u.shape[3]:u.shape[1];S(d===l.shape[2],()=>`Error in conv2d: depth of input (${d}) must match input depth for filter ${l.shape[2]}.`),S(ar(e,o),()=>`Error in conv2D: Either strides or dilations must be 1. Got strides ${e} and dilations '${o}'`);const p=F.runKernel(hm,{x:u,filter:l},{strides:e,pad:r,dataFormat:s,dilations:o,dimRoundingMode:i});return c?H(p,[p.shape[1],p.shape[2],p.shape[3]]):p}}),DC=M({conv1d_:function YX(t,n,e,r,s="NWC",o=1,i){const a=T(t,"x","conv1d"),l=T(n,"filter","conv1d");let u=a,c=!1;2===a.rank&&(c=!0,u=H(a,[1,a.shape[0],a.shape[1]])),S(3===u.rank,()=>`Error in conv1d: input must be rank 3, but got rank ${u.rank}.`),S(3===l.rank,()=>`Error in conv1d: filter must be rank 3, but got rank ${l.rank}.`),null!=i&&S(Kn(r),()=>`Error in conv1d: pad must be an integer when using, dimRoundingMode ${i} but got pad ${r}.`),S(u.shape[2]===l.shape[1],()=>`Error in conv1d: depth of input (${u.shape[2]}) must match input depth for filter ${l.shape[1]}.`),S(ar(e,o),()=>`Error in conv1D: Either stride or dilation must be 1. Got stride ${e} and dilation '${o}'`),S("NWC"===s,()=>`Error in conv1d: got dataFormat of ${s} but only NWC is currently supported.`);const d=H(l,[1,l.shape[0],l.shape[1],l.shape[2]]),h=H(u,[u.shape[0],1,u.shape[1],u.shape[2]]),g=Vi(h,d,[1,e],r,"NHWC",[1,o],i);return H(g,c?[g.shape[2],g.shape[3]]:[g.shape[0],g.shape[2],g.shape[3]])}}),_C=M({conv2DBackpropInput_:function ZX(t,n,e,r,s,o="NHWC",i){S(t.length===n.rank,()=>`Length of inShape (${t.length}) and rank of dy (${n.rank}) must match`);let a=t,l=n,u=!1;3===n.rank&&(u=!0,l=H(n,[1,n.shape[0],n.shape[1],n.shape[2]]),a=[1,t[0],t[1],t[2]]),S(4===a.length,()=>`Error in conv2dDerInput: inShape must be length 4, but got length ${a.length}.`),S(4===l.rank,()=>`Error in conv2dDerInput: dy must be rank 4, but got rank ${l.rank}`),S(4===e.rank,()=>`Error in conv2dDerInput: filter must be rank 4, but got rank ${e.rank}`);const c="NHWC"===o?a[3]:a[1],d="NHWC"===o?l.shape[3]:l.shape[1];S(c===e.shape[2],()=>`Error in conv2dDerInput: depth of input (${c}) must match input depth for filter ${e.shape[2]}.`),S(d===e.shape[3],()=>`Error in conv2dDerInput: depth of output (${d}) must match output depth for filter ${e.shape[3]}.`),null!=i&&S(Kn(s),()=>`Error in conv2dDerInput: pad must be an integer when using, dimRoundingMode ${i} but got pad ${s}.`);const p=F.runKernel(fm,{dy:l,filter:e},{strides:r,pad:s,dataFormat:o,dimRoundingMode:i,inputShape:a});return u?H(p,[p.shape[1],p.shape[2],p.shape[3]]):p}}),SC=M({conv2dTranspose_:function QX(t,n,e,r,s,o){const i=T(t,"x","conv2dTranspose"),a=T(n,"filter","conv2dTranspose");return _C(e,i,a,r,s,"NHWC",o)}}),X$=M({conv3d_:function JX(t,n,e,r,s="NDHWC",o=[1,1,1]){const i=T(t,"x","conv3d"),a=T(n,"filter","conv3d");let l=i,u=!1;4===i.rank&&(u=!0,l=H(i,[1,i.shape[0],i.shape[1],i.shape[2],i.shape[3]])),S(5===l.rank,()=>`Error in conv3d: input must be rank 5, but got rank ${l.rank}.`),S(5===a.rank,()=>`Error in conv3d: filter must be rank 5, but got rank ${a.rank}.`),S(l.shape[4]===a.shape[3],()=>`Error in conv3d: depth of input (${l.shape[4]}) must match input depth for filter ${a.shape[3]}.`),S(ar(e,o),()=>`Error in conv3D: Either strides or dilations must be 1. Got strides ${e} and dilations '${o}'`),S("NDHWC"===s,()=>`Error in conv3d: got dataFormat of ${s} but only NDHWC is currently supported.`);const h=F.runKernel(pm,{x:l,filter:a},{strides:e,pad:r,dataFormat:s,dilations:o});return u?H(h,[h.shape[1],h.shape[2],h.shape[3],h.shape[4]]):h}}),ph=M({depthwiseConv2d_:function e7(t,n,e,r,s="NHWC",o=[1,1],i){const a=T(t,"x","depthwiseConv2d"),l=T(n,"filter","depthwiseConv2d");let u=a,c=!1;3===a.rank&&(c=!0,u=H(a,[1,a.shape[0],a.shape[1],a.shape[2]])),S(4===u.rank,()=>`Error in depthwiseConv2d: input must be rank 4, but got rank ${u.rank}.`),S(4===l.rank,()=>`Error in depthwiseConv2d: filter must be rank 4, but got rank ${l.rank}.`),S(u.shape[3]===l.shape[2],()=>`Error in depthwiseConv2d: number of input channels (${u.shape[3]}) must match the inChannels dimension in filter ${l.shape[2]}.`),null!=i&&S(Kn(r),()=>`Error in depthwiseConv2d: pad must be an integer when using, dimRoundingMode ${i} but got pad ${r}.`);const f=F.runKernel(gm,{x:u,filter:l},{strides:e,pad:r,dataFormat:s,dilations:o,dimRoundingMode:i});return c?H(f,[f.shape[1],f.shape[2],f.shape[3]]):f}}),EC=M({floorDiv_:function t7(t,n){let e=T(t,"a","floorDiv"),r=T(n,"b","floorDiv");return[e,r]=fn(e,r),F.runKernel(Td,{a:e,b:r})}}),Me=M({div_:function n7(t,n){let e=T(t,"a","div"),r=T(n,"b","div");return[e,r]=fn(e,r),"int32"===e.dtype&&"int32"===r.dtype?EC(e,r):F.runKernel(Id,{a:e,b:r},{})}}),mh=M({elu_:function r7(t){const e={x:T(t,"x","elu")};return F.runKernel(Dd,e)}});function gh(t,n){const e=t.length,r=[];for(let s=0;s<e;s++){const o=e-1-s,i=t[o]||1;(n[n.length-1-s]||1)>1&&1===i&&r.unshift(o)}return r}function Ln(t,n){const e=[];for(let r=0;r<n.length;r++){const s=t[t.length-r-1],o=n.length-r-1,i=n[o];(null==s||1===s&&i>1)&&e.unshift(o)}return e}function bt(t,n){const e=[],r=Math.max(t.length,n.length);for(let s=0;s<r;s++){let o=t[t.length-s-1];null==o&&(o=1);let i=n[n.length-s-1];if(null==i&&(i=1),1===o)e.unshift(i);else if(1===i)e.unshift(o);else{if(o!==i)throw Error(`Operands could not be broadcast together with shapes ${t} and ${n}.`);e.unshift(o)}}return e}const Ba=M({equal_:function s7(t,n){let e=T(t,"a","equal"),r=T(n,"b","equal");return[e,r]=fn(e,r),bt(e.shape,r.shape),F.runKernel(bm,{a:e,b:r})}}),As=M({expandDims_:function o7(t,n=0){const e=T(t,"x","expandDims","string_or_numeric");return S(n<=e.rank,()=>"Axis must be <= rank of the tensor"),F.runKernel(vm,{input:e},{dim:n})}}),za=M({tile_:function i7(t,n){const e=T(t,"x","tile","string_or_numeric");return S(e.rank===n.length,()=>`Error in transpose: rank of input ${e.rank} must match length of reps ${n}.`),F.runKernel(sh,{x:e},{reps:n})}}),Y$=M({eye_:function a7(t,n,e,r="float32"){null==n&&(n=t);const s=yt([t,n],r),o=t<=n?t:n;for(let a=0;a<o;++a)s.set(1,a,a);const i=H(s.toTensor(),[t,n]);if(null==e)return i;if(1===e.length)return za(As(i,0),[e[0],1,1]);if(2===e.length)return za(As(As(i,0),0),[e[0],e[1],1,1]);if(3===e.length)return za(As(As(As(i,0),0),0),[e[0],e[1],e[2],1,1]);throw new Error(`eye() currently supports only 1D and 2D batchShapes, but received ${e.length}D.`)}});function Ig(t,n,e){return F.runKernel(gw,{},{shape:t,value:n,dtype:e})}const yh=M({floor_:function l7(t){const e={x:T(t,"x","floor")};return F.runKernel(Nd,e)}}),bh=M({gather_:function u7(t,n,e=0,r=0){const s=T(t,"x","gather"),o=T(n,"indices","gather","int32");return F.runKernel(wm,{x:s,indices:o},{axis:e,batchDims:r})}}),Eo=M({greater_:function c7(t,n){let e=T(t,"a","greater"),r=T(n,"b","greater");return[e,r]=fn(e,r),bt(e.shape,r.shape),F.runKernel(Cm,{a:e,b:r})}}),Va=M({greaterEqual_:function d7(t,n){let e=T(t,"a","greaterEqual"),r=T(n,"b","greaterEqual");return[e,r]=fn(e,r),bt(e.shape,r.shape),F.runKernel(kd,{a:e,b:r})}}),Dg=M({leakyRelu_:function h7(t,n=.2){const r={x:T(t,"x","leakyRelu")};return F.runKernel(Im,r,{alpha:n})}}),hs=M({log_:function f7(t){const e={x:T(t,"x","log")};return F.runKernel(Od,e)}}),Rs=M({exp_:function p7(t){const e={x:T(t,"x","exp")};return F.runKernel(Sd,e)}}),$s=M({max_:function m7(t,n=null,e=!1){const s={x:T(t,"x","max")};return F.runKernel(km,s,{reductionIndices:n,keepDims:e})}}),V=M({mul_:function g7(t,n){let e=T(t,"a","mul"),r=T(n,"b","mul");return[e,r]=fn(e,r),F.runKernel(zd,{a:e,b:r})}}),$e=M({sub_:function y7(t,n){let e=T(t,"a","sub"),r=T(n,"b","sub");return[e,r]=fn(e,r),F.runKernel(th,{a:e,b:r})}}),Oe=M({sum_:function b7(t,n=null,e=!1){let r=T(t,"x","sum");return"bool"===r.dtype&&(r=Ae(r,"int32")),F.runKernel(Xm,{x:r},{axis:n,keepDims:e})}}),NC=M({logSoftmax_:function v7(t,n=-1){const e=T(t,"logits","logSoftmax");if(-1===n&&(n=e.rank-1),n!==e.rank-1)throw Error(`Log Softmax along a non-last dimension is not yet supported. Logits was rank ${e.rank} and axis was ${n}`);return ni((s,o)=>{const a=$s(s,n,!0),l=$e(s,a),u=$e(Ae(l,"float32"),hs(Oe(Rs(l),n,!0)));return o([u]),{value:u,gradFunc:(d,h)=>{const[f]=h,m=Rs(f);return $e(d,V(Oe(d,n,!0),m))}}})(e)}}),No=M({logicalAnd_:function x7(t,n){const e=T(t,"a","logicalAnd","bool"),r=T(n,"b","logicalAnd","bool");return bt(e.shape,r.shape),F.runKernel(Sm,{a:e,b:r})}}),_g=M({maxPool_:function w7(t,n,e,r,s){const o=T(t,"x","maxPool");let a=o,l=!1;3===o.rank&&(l=!0,a=H(o,[1,o.shape[0],o.shape[1],o.shape[2]])),S(4===a.rank,()=>`Error in maxPool: input must be rank 4 but got rank ${a.rank}.`),S(ar(e,1),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${e} and dilations '1'`),null!=s&&S(Kn(r),()=>`Error in maxPool: pad must be an integer when using, dimRoundingMode ${s} but got pad ${r}.`);const d=F.runKernel(Am,{x:a},{filterSize:n,strides:e,pad:r,dimRoundingMode:s});return l?H(d,[d.shape[1],d.shape[2],d.shape[3]]):d}}),Z$=M({maxPool3d_:function C7(t,n=[1,1,1],e,r,s,o="NDHWC"){const i=T(t,"x","maxPool3d");let a=i,l=!1;4===i.rank&&(l=!0,a=H(i,[1,i.shape[0],i.shape[1],i.shape[2],i.shape[3]])),S(5===a.rank,()=>`Error in maxPool3d: x must be rank 5 but got rank ${a.rank}.`),S("NDHWC"===o,()=>`Error in maxPool3d: Only NDHWC is currently supported, but got dataFormat of ${o}`),null!=s&&S(Kn(r),()=>`Error in maxPool3d: pad must be an integer when using, dimRoundingMode ${s} but got pad ${r}.`);const d=F.runKernel(Rm,{x:a},{filterSize:n,strides:e,pad:r,dimRoundingMode:s,dataFormat:o});return l?H(d,[d.shape[1],d.shape[2],d.shape[3],d.shape[4]]):d}}),oi=M({maximum_:function I7(t,n){let e=T(t,"a","maximum"),r=T(n,"b","maximum");return[e,r]=fn(e,r),"bool"===e.dtype&&(e=Ae(e,"int32"),r=Ae(r,"int32")),bt(e.shape,r.shape),F.runKernel(Pd,{a:e,b:r})}}),pn=M({mean_:function D7(t,n=null,e=!1){const s={x:T(t,"x","mean")};return F.runKernel($m,s,{axis:n,keepDims:e})}}),vh=M({min_:function _7(t,n=null,e=!1){const s={x:T(t,"x","min")};return F.runKernel(Fm,s,{axis:n,keepDims:e})}}),xh=M({minimum_:function S7(t,n){let e=T(t,"a","minimum"),r=T(n,"b","minimum");return[e,r]=fn(e,r),"bool"===e.dtype&&(e=Ae(e,"int32"),r=Ae(r,"int32")),bt(e.shape,r.shape),F.runKernel(Ld,{a:e,b:r})}});function TC(t,n){for(let e=0;e<t.length;++e)if(t[t.length-e-1]!==n-1-e)return!1;return!0}function Q$(t,n,e){const r=t.length+n.length,s=[];let o=0,i=0;for(let a=0;a<r;a++)-1===e.indexOf(a)?s.push(t[o++]):s.push(n[i++]);return s}function Qn(t,n){const e=[],r=t.length;for(let o=0;o<r;o++)-1===n.indexOf(o)&&e.push(t[o]);return[e,n.map(o=>t[o])]}function vn(t,n){return Q$(t,n.map(r=>1),n)}function lr(t,n,e){S(TC(n,e),()=>`${t} supports only inner-most axes for now. Got axes ${n} and rank-${e} input.`)}function xn(t,n){if(TC(t,n))return null;const e=[];for(let r=0;r<n;++r)-1===t.indexOf(r)&&e.push(r);return t.forEach(r=>e.push(r)),e}function gu(t){return t.map((n,e)=>[e,n]).sort((n,e)=>n[1]-e[1]).map(n=>n[0])}function En(t,n){const e=[];for(let r=n-t;r<n;++r)e.push(r);return e}const zt=M({square_:function E7(t){const n=T(t,"x","square");return F.runKernel("Square",{x:n},{})}}),kC=M({moments_:function N7(t,n=null,e=!1){const r=ft(n,(t=T(t,"x","moments")).shape),s=pn(t,r,e);let o=s.shape;e||(o=vn(s.shape,r));const i=zt($e(Ae(t,"float32"),H(s,o)));return{mean:s,variance:pn(i,r,e)}}}),mn=M({neg_:function T7(t){const e={x:T(t,"x","neg")};return F.runKernel(Mm,e)}}),yu=M({notEqual_:function k7(t,n){let e=T(t,"a","notEqual"),r=T(n,"b","notEqual");return[e,r]=fn(e,r),bt(e.shape,r.shape),F.runKernel(Pm,{a:e,b:r})}}),AC=M({oneHot_:function A7(t,n,e=1,r=0){if(n<2)throw new Error(`Error in oneHot: depth must be >=2, but it is ${n}`);const o={indices:T(t,"indices","oneHot","int32")};return F.runKernel(Bm,o,{depth:n,onValue:e,offValue:r})}});function Nn(t,n="float32"){if("complex64"===n){const r=Nn(t,"float32"),s=Nn(t,"float32");return $a(r,s)}const e=gr(te(t),n);return F.makeTensor(e,t,n)}function ii(t,n="float32"){if("complex64"===n){const r=ii(t,"float32"),s=Nn(t,"float32");return $a(r,s)}const e=YR(te(t),n);return F.makeTensor(e,t,n)}const fs=M({onesLike_:function R7(t){const e={x:T(t,"x","onesLike")};return F.runKernel(Lm,e)}}),Sg=M({pad_:function $7(t,n,e=0){const r=T(t,"x","pad");if(0===r.rank)throw new Error("pad(scalar) is not defined. Pass non-scalar to pad");return F.runKernel(Vm,{x:r},{paddings:n,constantValue:e})}}),Eg=M({prelu_:function F7(t,n){const e=T(t,"x","prelu"),r=T(n,"alpha","prelu");return F.runKernel(Um,{x:e,alpha:r})}});var J$=B(349);class RC{constructor(n,e,r,s,o){this.mean=n,this.stdDev=e,this.dtype=r,this.nextVal=NaN,this.truncated=s,this.truncated&&(this.upper=this.mean+2*this.stdDev,this.lower=this.mean-2*this.stdDev);const i=o||Math.random();this.random=J$.alea(i.toString())}nextValue(){if(!isNaN(this.nextVal)){const s=this.nextVal;return this.nextVal=NaN,s}let n,e,r=!1;for(;!r;){let s,o,i;do{s=2*this.random()-1,o=2*this.random()-1,i=s*s+o*o}while(i>=1||0===i);const a=Math.sqrt(-2*Math.log(i)/i);n=this.mean+this.stdDev*s*a,e=this.mean+this.stdDev*o*a,(!this.truncated||this.isValidTruncated(n))&&(r=!0)}return(!this.truncated||this.isValidTruncated(e))&&(this.nextVal=this.convertValue(e)),this.convertValue(n)}convertValue(n){return null==this.dtype||"float32"===this.dtype?n:Math.round(n)}isValidTruncated(n){return n<=this.upper&&n>=this.lower}}class O7{constructor(n=0,e=1,r,s){if(this.canReturnFloat=()=>null==this.dtype||"float32"===this.dtype,this.min=n,this.range=e-n,this.dtype=r,null==s&&(s=Math.random()),"number"==typeof s&&(s=s.toString()),!this.canReturnFloat()&&this.range<=1)throw new Error(`The difference between ${n} - ${e} <= 1 and dtype is not float`);this.random=J$.alea(s)}convertValue(n){return this.canReturnFloat()?n:Math.round(n)}nextValue(){return this.convertValue(this.min+this.range*this.random())}}const z7=M({randomNormal_:function B7(t,n=0,e=1,r,s){if(null!=r&&"bool"===r)throw new Error(`Unsupported data type ${r}`);const o=new RC(n,e,r,!1,s),i=yt(t,r);for(let a=0;a<i.values.length;a++)i.values[a]=o.nextValue();return i.toTensor()}}),wh=M({randomUniform_:function V7(t,n=0,e=1,r="float32",s){const o=yt(t,r),i=new O7(n,e,null,s);for(let a=0;a<o.values.length;a++)o.values[a]=i.nextValue();return o.toTensor()}}),ai=M({relu_:function U7(t){const e={x:T(t,"x","relu")};return F.runKernel(Wd,e)}}),li=M({reverse_:function W7(t,n){const r={x:T(t,"x","reverse")};return F.runKernel(jm,r,{dims:n})}}),FC=M({selu_:function H7(t){const e={x:T(t,"x","selu")};return F.runKernel(qd,e)}}),e2=M({separableConv2d_:function G7(t,n,e,r,s,o=[1,1],i="NHWC"){const a=T(t,"x","separableConv2d"),l=T(n,"depthwiseFilter","separableConv2d"),u=T(e,"pointwiseFilter","separableConv2d");let c=a,d=!1;if(3===a.rank&&(d=!0,c=H(a,[1,a.shape[0],a.shape[1],a.shape[2]])),"NCHW"===i)throw new Error("separableConv2d currently does not support dataFormat NCHW; only NHWC is supported");S(4===c.rank,()=>`Error in separableConv2d: input must be rank 4, but got rank ${c.rank}.`),S(4===l.rank,()=>`Error in separableConv2d: depthwise filter must be rank 4, but got rank ${l.rank}.`),S(4===u.rank,()=>`Error in separableConv2d: pointwise filter must be rank 4, but got rank ${l.rank}.`),S(1===u.shape[0],()=>`Error in separableConv2d: the first dimension of pointwise filter  must be 1, but got ${u.shape[0]}.`),S(1===u.shape[1],()=>`Error in separableConv2d: the second dimension of pointwise filter must be 1, but got ${u.shape[1]}.`);const h=l.shape[2],f=l.shape[3];S(u.shape[2]===h*f,()=>`Error in separableConv2d: the third dimension of pointwise filter must be ${h*f}, but got ${u.shape[2]}.`);const p=ph(c,l,r,s,i,o),g=Vi(p,u,1,"valid",i);return d?H(g,[g.shape[1],g.shape[2],g.shape[3]]):g}}),bu=M({sigmoid_:function j7(t){const e={x:T(t,"x","sigmoid")};return F.runKernel(Zd,e)}}),At=M({slice_:function q7(t,n,e){const r=T(t,"x","slice","string_or_numeric");if(0===r.rank)throw new Error("Slicing scalar is not possible");return F.runKernel(Km,{x:r},{begin:n,size:e})}}),OC=M({slice1d_:function K7(t,n,e){const r=T(t,"x","slice1d");return S(1===r.rank,()=>`slice1d expects a rank-1 tensor, but got a rank-${r.rank} tensor`),At(r,[n],[e])}}),t2=M({slice2d_:function X7(t,n,e){const r=T(t,"x","slice2d");return S(2===r.rank,()=>`slice2d expects a rank-2 tensor, but got a rank-${r.rank} tensor`),At(r,n,e)}}),MC=M({slice3d_:function Y7(t,n,e){const r=T(t,"x","slice3d");return S(3===r.rank,()=>`slice3d expects a rank-3 tensor, but got a rank-${r.rank} tensor`),At(r,n,e)}}),Ng=M({slice4d_:function Z7(t,n,e){const r=T(t,"x","slice4d");return S(4===r.rank,()=>`slice4d expects a rank-4 tensor, but got a rank-${r.rank} tensor`),At(r,n,e)}}),Tg=M({softmax_:function Q7(t,n=-1){const e=T(t,"logits","softmax","float32");if(-1===n&&(n=e.rank-1),n!==e.rank-1)throw Error(`Softmax along a non-last dimension is not yet supported. Logits was rank ${e.rank} and dim was ${n}`);return F.runKernel(Qm,{logits:e},{dim:n})}}),Ch=M({softplus_:function J7(t){const e={x:T(t,"x","softplus")};return F.runKernel(Qd,e)}}),ps=M({split_:function e9(t,n,e=0){const s={x:T(t,"x","split")};return F.runKernel(Zm,s,{numOrSizeSplits:n,axis:e})}}),yr=M({sqrt_:function t9(t){const e={x:T(t,"x","sqrt")};return F.runKernel(Jd,e)}}),vu=M({squeeze_:function n9(t,n){const e=T(t,"x","squeeze");return H(e,Aa(e.shape,n).newShape)}}),Fs=M({stack_:function r9(t,n=0){const e=m$(t,"tensors","stack","string_or_numeric");return S(e.length>=1,()=>"Pass at least one tensor to tf.stack"),e.length>0&&S(n<=e[0].rank,()=>"Axis must be <= rank of the tensor"),F.runKernel(zm,e,{axis:n})}}),PC=M({tanh_:function s9(t){const e={x:T(t,"x","tanh")};return F.runKernel(rh,e)}});function Os(t,n){H0(t);const e=dh(t,n);if(1!==e.length)throw new Error("tensor1d() requires values to be a flat/TypedArray");return hh(t,null,e,n)}function Ih(t,n,e){if(H0(t),null!=n&&2!==n.length)throw new Error("tensor2d() requires shape to have two numbers");const r=dh(t,e);if(2!==r.length&&1!==r.length)throw new Error("tensor2d() requires values to be number[][] or flat/TypedArray");if(1===r.length&&null==n)throw new Error("tensor2d() requires shape to be provided when `values` are a flat/TypedArray");return hh(t,n,r,e)}const LC=M({truncatedNormal_:function o9(t,n=0,e=1,r,s){if(null!=r&&"bool"===r)throw new Error("Unsupported data type $ { dtype }");const o=new RC(n,e,r,!0,s),i=yt(t,r);for(let a=0;a<i.values.length;a++)i.values[a]=o.nextValue();return i.toTensor()}}),oo=M({unstack_:function i9(t,n=0){const e=T(t,"x","unstack","string_or_numeric");return S(n>=-e.shape.length&&n<e.shape.length,()=>`Axis = ${n} is not in [-${e.shape.length}, ${e.shape.length})`),F.runKernel(eg,{value:e},{axis:n})}}),kg=M({broadcastTo_:function l9(t,n){let e=T(t,"broadcastTo","x");const r=e.shape;if(n.some(u=>!(u>0)||u%1!=0))throw new Error(`broadcastTo(): Invalid broadcast shape [${n}].`);if(n.length<e.rank)throw new Error(`broadcastTo(): shape.length=${n.length} < input.rank=${e.rank}.`);if(n.length>e.rank){const u=e.shape.slice();for(;u.length<n.length;)u.unshift(1);e=H(e,u)}const s=e.shape,o=Array.from(n);for(let u=n.length-1;u>=0;u--)if(s[u]===n[u])o[u]=1;else if(1!==e.shape[u])throw new Error(`broadcastTo(): [${r}] cannot be broadcast to [${n}].`);return 0===o.map((u,c)=>u>1?c:-1).filter(u=>u>=0).length?Pa(e):F.runKernel(sh,{x:e},{reps:o})}}),ms=M({where_:function u9(t,n,e){const r=T(n,"a","where"),s=T(e,"b","where"),o=T(t,"condition","where","bool"),i=bt(r.shape,s.shape),a=kg(r,i),l=kg(s,i);return 1===o.rank&&S(o.shape[0]===r.shape[0],()=>"The first dimension of `a` must match the size of `condition`."),1!==o.rank&&cs(o.shape,l.shape,"Error in where: "),F.runKernel(qm,{condition:o,t:a,e:l})}}),Ct=M({zerosLike_:function c9(t){const e={x:T(t,"x","zerosLike")};return F.runKernel(ng,e)}}),Bt=M({transpose_:function d9(t,n){const e=T(t,"x","transpose");return null==n&&(n=e.shape.map((o,i)=>i).reverse()),S(e.rank===n.length,()=>`Error in transpose: rank of input ${e.rank} must match length of perm ${n}.`),n.forEach(o=>{S(o>=0&&o<e.rank,()=>`All entries in 'perm' must be between 0 and ${e.rank-1} but got ${n}`)}),e.rank<=1?e.clone():F.runKernel(Jm,{x:e},{perm:n})}}),p9=M({dropout_:function f9(t,n,e,r){const s=T(t,"x","dropout");if(S("float32"===s.dtype,()=>`x has to be a floating point tensor since it's going to be scaled, but got a ${s.dtype} tensor instead.`),S(n>=0&&n<1,()=>`rate must be a float in the range [0, 1), but got ${n}.`),0===n)return t instanceof an?s.clone():s;const o=function h9(t,n){if(null==n)return t.shape.slice();if(Mt(t.shape,n))return n;if(t.shape.length===n.length){const e=[];for(let r=0;r<t.shape.length;r++)e.push(null==n[r]&&null!=t.shape[r]?t.shape[r]:n[r]);return e}return n}(s,e),i=1-n,a=Me(yh(me(wh(o,0,1,"float32",r),i)),i);return V(s,a)}}),BC=M({imag_:function m9(t){const e={input:T(t,"input","imag")};return F.runKernel(xw,e)}}),Ag=M({real_:function g9(t){const e={input:T(t,"input","real")};return F.runKernel(Rw,e)}}),Rg=M({fft_:function y9(t){return S("complex64"===t.dtype,()=>`The dtype for tf.spectral.fft() must be complex64 but got ${t.dtype}.`),F.runKernel("FFT",{input:t})}}),$g=M({rfft_:function b9(t,n){S("float32"===t.dtype,()=>`The dtype for rfft() must be real value but got ${t.dtype}`);let e=t.shape[t.shape.length-1];const r=t.size/e;let s;if(null!=n&&n<e){const p=t.shape.map(g=>0),m=t.shape.map(g=>g);m[t.shape.length-1]=n,s=At(t,p,m),e=n}else if(null!=n&&n>e){const p=t.shape.map(m=>m);p[t.shape.length-1]=n-e,s=Sn([t,Nn(p)],t.shape.length-1),e=n}else s=t;const o=Ct(s),i=H($a(s,o),[r,e]),a=Rg(i),l=Math.floor(e/2)+1,u=Ag(a),c=BC(a),d=ps(u,[l,e-l],u.shape.length-1),h=ps(c,[l,e-l],c.shape.length-1),f=s.shape.slice();return f[s.shape.length-1]=l,H($a(d[0],h[0]),f)}}),Dh=M({ifft_:function v9(t){return S("complex64"===t.dtype,()=>`The dtype for tf.spectral.ifft() must be complex64 but got ${t.dtype}.`),F.runKernel(vw,{input:t})}}),zC=M({irfft_:function x9(t){const n=t.shape[t.shape.length-1],e=t.size/n;let r;if(n<=2){const s=H(t,[e,n]);r=Dh(s)}else{const s=[e,2*(n-1)],o=H(Ag(t),[e,n]),i=H(BC(t),[e,n]),a=li(At(o,[0,1],[e,n-2]),1),l=V(li(At(i,[0,1],[e,n-2]),1),Fe(-1)),u=Sn([o,a],1),c=Sn([i,l],1),d=H($a(u,c),[s[0],s[1]]);r=Dh(d)}if(r=Ag(r),3===t.rank&&0!==t.shape[0]){const s=r,o=t.shape[0];r=H(r,[o,r.shape[0]/o,r.shape[1]]),s.dispose()}return r}}),VC=M({conv2DBackpropFilter_:function w9(t,n,e,r,s,o="NHWC",i){let a=t;3===t.rank&&(a=H(t,[1,t.shape[0],t.shape[1],t.shape[2]]));let l=n;3===l.rank&&(l=H(n,[1,n.shape[0],n.shape[1],n.shape[2]])),S(4===a.rank,()=>`Error in conv2dDerFilter: input must be rank 4, but got shape ${a.shape}.`),S(4===l.rank,()=>`Error in conv2dDerFilter: dy must be rank 4, but got shape ${l.shape}.`),S(4===e.length,()=>`Error in conv2dDerFilter: filterShape must be length 4, but got ${e}.`);const u="NHWC"===o?a.shape[3]:a.shape[1],c="NHWC"===o?l.shape[3]:l.shape[1];return S(u===e[2],()=>`Error in conv2dDerFilter: depth of input ${u}) must match input depth in filter (${e[2]}.`),S(c===e[3],()=>`Error in conv2dDerFilter: depth of dy (${c}) must match output depth for filter (${e[3]}).`),null!=i&&S(Kn(s),()=>`Error in conv2dDerFilter: pad must be an integer when using, dimRoundingMode ${i} but got pad ${s}.`),F.runKernel(sw,{x:a,dy:l},{strides:r,pad:s,dataFormat:o,dimRoundingMode:i,filterShape:e})}}),UC=M({relu6_:function C9(t){const e={x:T(t,"x","relu6")};return F.runKernel(Hd,e)}}),_h=M({step_:function I9(t,n=0){const r={x:T(t,"x","step")};return F.runKernel(oh,r,{alpha:n})}});function Fg(t,n,e){if(null==e||"linear"===e)return t;if("relu"===e)return V(t,_h(n));throw new Error(`Cannot compute gradient for fused activation ${e}.`)}function Og(t,n){let e=n;const r=Ln(t.shape,n.shape);return r.length>0&&(e=Oe(e,r)),H(e,t.shape)}function Mg(t,n,e,r){if("linear"===n)return t;if("relu"===n)return ai(t);if("elu"===n)return mh(t);if("relu6"===n)return UC(t);if("prelu"===n)return Eg(t,e);if("leakyrelu"===n)return Dg(t,r);throw new Error(`Unknown fused activation ${n}.`)}const Pg=(t,n)=>!(t>0)||"linear"===n,n2=M({fusedConv2d_:function D9({x:t,filter:n,strides:e,pad:r,dataFormat:s="NHWC",dilations:o=[1,1],dimRoundingMode:i,bias:a,activation:l="linear",preluActivationWeights:u,leakyreluAlpha:c}){if(!1===Pg(F.state.gradientDepth,l=l||"linear")){let w=Vi(t,n,e,r,s,o,i);return null!=a&&(w=me(w,a)),Mg(w,l,u,c)}const d=T(t,"x","conv2d"),h=T(n,"filter","conv2d");let f=d,p=!1;3===d.rank&&(p=!0,f=H(d,[1,d.shape[0],d.shape[1],d.shape[2]])),S(4===f.rank,()=>`Error in fused conv2d: input must be rank 4, but got rank ${f.rank}.`),S(4===h.rank,()=>`Error in fused conv2d: filter must be rank 4, but got rank ${h.rank}.`),null!=i&&S(Kn(r),()=>`Error in fused conv2d: pad must be an integer when using, dimRoundingMode ${i} but got pad ${r}.`),S(f.shape[3]===h.shape[2],()=>`Error in conv2d: depth of input (${f.shape[3]}) must match input depth for filter ${h.shape[2]}.`),S(ar(e,o),()=>`Error in conv2D: Either strides or dilations must be 1. Got strides ${e} and dilations '${o}'`),S("NHWC"===s,()=>`Error in conv2d: got dataFormat of ${s} but only NHWC is currently supported.`);const m=Zn(f.shape,h.shape,e,o,r,i);let g,y;null!=a&&(g=T(a,"bias","fused conv2d"),[g]=fn(g,d),bt(m.outShape,g.shape)),null!=u&&(y=T(u,"prelu weights","fused conv2d"));const b=(w,_)=>{const[D,A,R,O]=_,G=Fg(w,R,l);S(zi(o),()=>`Error in gradient of fused conv2D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '${o}'`);const Q=[_C(A.shape,G,D,e,r),VC(A,G,D.shape,e,r)];if(null!=O){const q=Og(O,G);Q.push(q)}return Q},v={x:f,filter:h,bias:g,preluActivationWeights:y},x={strides:e,pad:r,dataFormat:s,dilations:o,dimRoundingMode:i,activation:l,leakyreluAlpha:c};return null==a?ni((_,D,A)=>{let R=F.runKernel(sg,v,x);return A([D,_,R]),p&&(R=H(R,[R.shape[1],R.shape[2],R.shape[3]])),{value:R,gradFunc:b}})(f,h):ni((_,D,A,R)=>{let O=F.runKernel(sg,v,x);return R([D,_,O,A]),p&&(O=H(O,[O.shape[1],O.shape[2],O.shape[3]])),{value:O,gradFunc:b}})(f,h,g)}}),r2=M({depthwiseConv2dNativeBackpropFilter_:function _9(t,n,e,r,s,o=[1,1],i){let a=t;3===t.rank&&(a=H(t,[1,t.shape[0],t.shape[1],t.shape[2]]));let l=n;return 3===l.rank&&(l=H(n,[1,n.shape[0],n.shape[1],n.shape[2]])),F.runKernel(cw,{x:a,dy:l},{strides:r,pad:s,dimRoundingMode:i,dilations:o,filterShape:e})}}),s2=M({depthwiseConv2dNativeBackpropInput_:function S9(t,n,e,r,s,o=[1,1],i){let a=n,l=!1;3===n.rank&&(l=!0,a=H(n,[1,n.shape[0],n.shape[1],n.shape[2]]));const d=F.runKernel(dw,{dy:a,filter:e},{strides:r,pad:s,dimRoundingMode:i,dilations:o,inputShape:t});return l?H(d,[d.shape[1],d.shape[2],d.shape[3]]):d}}),N9=M({fusedDepthwiseConv2d_:function E9({x:t,filter:n,strides:e,pad:r,dataFormat:s="NHWC",dilations:o=[1,1],dimRoundingMode:i,bias:a,activation:l="linear",preluActivationWeights:u,leakyreluAlpha:c}){if(!1===Pg(F.state.gradientDepth,l)){let w=ph(t,n,e,r,s,o,i);return null!=a&&(w=me(w,a)),Mg(w,l,u,c)}const d=T(t,"x","depthwiseConv2d"),h=T(n,"filter","depthwiseConv2d");let f=d,p=!1;3===d.rank&&(p=!0,f=H(d,[1,d.shape[0],d.shape[1],d.shape[2]])),S(4===f.rank,()=>`Error in fused depthwiseConv2d: input must be rank 4, but got rank ${f.rank}.`),S(4===h.rank,()=>`Error in fused depthwiseConv2d: filter must be rank 4, but got rank ${h.rank}.`),S(f.shape[3]===h.shape[2],()=>`Error in fused depthwiseConv2d: number of input channels (${f.shape[3]}) must match the inChannels dimension in filter ${h.shape[2]}.`),null==o&&(o=[1,1]),S(ar(e,o),()=>`Error in fused depthwiseConv2d: Either strides or dilations must be 1. Got strides ${e} and dilations '${o}'`),null!=i&&S(Kn(r),()=>`Error in fused depthwiseConv2d: pad must be an integer when using dimRoundingMode ${i} but got pad ${r}.`);const m=Zn(f.shape,h.shape,e,o,r,i,!0);let g,y;null!=a&&(g=T(a,"bias","fused conv2d"),[g]=fn(g,d),bt(m.outShape,g.shape)),null!=u&&(y=T(u,"prelu weights","fused depthwiseConv2d"));const b=(w,_)=>{S(zi(o),()=>`Error in gradient of fused depthwiseConv2d: dilation rates greater than 1 are not yet supported. Got dilations '${o}'`);const[D,A,R,O]=_,G=Fg(w,R,l),K=s2(A.shape,G,D,e,r,o,i),j=r2(A,G,D.shape,e,r,o,i);return null!=O?[K,j,Og(g,G)]:[K,j]},v={x:f,filter:h,bias:g,preluActivationWeights:y},x={strides:e,pad:r,dataFormat:s,dilations:o,dimRoundingMode:i,activation:l,leakyreluAlpha:c};return null==a?ni((_,D,A)=>{let R=F.runKernel(og,v,x);return A([D,_,R]),p&&(R=H(R,[R.shape[1],R.shape[2],R.shape[3]])),{value:R,gradFunc:b}})(f,h):ni((_,D,A,R)=>{let O=F.runKernel(og,v,x);return R([D,_,O,A]),p&&(O=H(O,[O.shape[1],O.shape[2],O.shape[3]])),{value:O,gradFunc:b}})(f,h,g)}}),Nt=M({matMul_:function T9(t,n,e=!1,r=!1){let s=T(t,"a","matMul"),o=T(n,"b","matMul");return[s,o]=fn(s,o),F.runKernel(lm,{a:s,b:o},{transposeA:e,transposeB:r})}}),WC=M({fusedMatMul_:function k9({a:t,b:n,transposeA:e=!1,transposeB:r=!1,bias:s,activation:o="linear",preluActivationWeights:i,leakyreluAlpha:a}){if(!1===Pg(F.state.gradientDepth,o)){let O=Nt(t,n,e,r);return null!=s&&(O=me(O,s)),Mg(O,o,i,a)}let l=T(t,"a","fused matMul"),u=T(n,"b","fused matMul");[l,u]=fn(l,u);const c=e?l.shape[l.rank-2]:l.shape[l.rank-1],d=r?u.shape[u.rank-1]:u.shape[u.rank-2],h=e?l.shape[l.rank-1]:l.shape[l.rank-2],f=r?u.shape[u.rank-2]:u.shape[u.rank-1],p=l.shape.slice(0,-2),m=u.shape.slice(0,-2),g=te(p),y=te(m);S(l.rank>=2&&u.rank>=2&&l.rank===u.rank,()=>`Error in fused matMul: inputs must have the same rank of at least 2, got ranks ${l.rank} and ${u.rank}.`),S(Mt(p,m),()=>`Error in fused matMul: outer dimensions (${p}) and (${m}) of Tensors with shapes ${l.shape} and ${u.shape} must match.`),S(c===d,()=>`Error in fused matMul: inner shapes (${c}) and (${d}) of Tensors with shapes ${l.shape} and ${u.shape} and transposeA=${e} and transposeB=${r} must match.`);const b=l.shape.slice(0,-2).concat([h,f]),v=H(l,e?[g,c,h]:[g,h,c]),x=H(u,r?[y,f,d]:[y,d,f]);let w,_;null!=s&&(w=T(s,"bias","fused matMul"),[w]=fn(w,l),bt(b,w.shape)),null!=i&&(_=T(i,"prelu weights","fused matMul"));const D=(O,G)=>{const[K,j,Q,q]=G,Y=Fg(H(O,Q.shape),Q,o);let re,ee;return e||r?!e&&r?(re=Nt(Y,j,!1,!1),ee=Nt(Y,K,!0,!1)):e&&!r?(re=Nt(j,Y,!1,!0),ee=Nt(K,Y,!1,!1)):(re=Nt(j,Y,!0,!0),ee=Nt(Y,K,!0,!0)):(re=Nt(Y,j,!1,!0),ee=Nt(K,Y,!0,!1)),null!=s?[re,ee,Og(q,Y)]:[re,ee]},A={a:v,b:x,bias:w,preluActivationWeights:_},R={transposeA:e,transposeB:r,activation:o,leakyreluAlpha:a};return null==s?ni((G,K,j)=>{const Q=F.runKernel(rg,A,R);return j([G,K,Q]),{value:H(Q,b),gradFunc:D}})(v,x):ni((G,K,j,Q)=>{const q=F.runKernel(rg,A,R);return Q([G,K,q,j]),{value:H(q,b),gradFunc:D}})(v,x,w)}});function o2(t,n,e){const r=1-t%2,s=new Float32Array(t);for(let o=0;o<t;++o){const i=2*Math.PI*o/(t+r-1);s[o]=n-e*Math.cos(i)}return Os(s,"float32")}M({hammingWindow_:function R9(t){return o2(t,.54,.46)}});const i2=M({hannWindow_:function F9(t){return o2(t,.5,.5)}}),a2=M({frame_:function O9(t,n,e,r=!1,s=0){let o=0;const i=[];for(;o+n<=t.size;)i.push(At(t,o,n)),o+=e;if(r)for(;o<t.size;){const a=o+n-t.size,l=Sn([At(t,o,n-a),Ig([a],s)]);i.push(l),o+=e}return 0===i.length?Ih([],[0,n]):H(Sn(i),[i.length,n])}});M({stft_:function M9(t,n,e,r,s=i2){null==r&&(r=function A9(t){return Math.floor(Math.pow(2,Math.ceil(Math.log(t)/Math.log(2))))}(n));const o=a2(t,n,e),i=V(o,s(n)),a=[];for(let l=0;l<o.shape[0];l++)a.push($g(At(i,[l,0],[1,n]),r));return Sn(a)}});const B9=M({cropAndResize_:function L9(t,n,e,r,s="bilinear",o=0){const i=T(t,"image","cropAndResize"),a=T(n,"boxes","cropAndResize","float32"),l=T(e,"boxInd","cropAndResize","int32"),u=a.shape[0];return S(4===i.rank,()=>`Error in cropAndResize: image must be rank 4,but got rank ${i.rank}.`),S(2===a.rank&&4===a.shape[1],()=>`Error in cropAndResize: boxes must be have size [${u},4] but had shape ${a.shape}.`),S(1===l.rank&&l.shape[0]===u,()=>`Error in cropAndResize: boxInd must be have size [${u}] but had shape ${a.shape}.`),S(2===r.length,()=>`Error in cropAndResize: cropSize must be of length 2, but got length ${r.length}.`),S(r[0]>=1&&r[1]>=1,()=>`cropSize must be atleast [1,1], but was ${r}`),S("bilinear"===s||"nearest"===s,()=>`method must be bilinear or nearest, but was ${s}`),F.runKernel(aw,{image:i,boxes:a,boxInd:l},{method:s,extrapolationValue:o,cropSize:r})}}),V9=M({flipLeftRight_:function z9(t){const n=T(t,"image","flipLeftRight","float32");return S(4===n.rank,()=>`Error in flipLeftRight: image must be rank 4,but got rank ${n.rank}.`),F.runKernel(yw,{image:n},{})}}),W9=M({rotateWithOffset_:function U9(t,n,e=0,r=.5){const s=T(t,"image","rotateWithOffset","float32");return S(4===s.rank,()=>`Error in rotateWithOffset: image must be rank 4,but got rank ${s.rank}.`),F.runKernel(Ww,{image:s},{radians:n,fillValue:e,center:r})}});function xu(t,n,e,r,s,o){null==r&&(r=.5),null==s&&(s=Number.NEGATIVE_INFINITY),null==o&&(o=0);const i=t.shape[0];return e=Math.min(e,i),S(0<=r&&r<=1,()=>`iouThreshold must be in [0, 1], but was '${r}'`),S(2===t.rank,()=>`boxes must be a 2D tensor, but was of rank '${t.rank}'`),S(4===t.shape[1],()=>`boxes must have 4 columns, but 2nd dimension was ${t.shape[1]}`),S(1===n.rank,()=>"scores must be a 1D tensor"),S(n.shape[0]===i,()=>`scores has incompatible shape with boxes. Expected ${i}, but was ${n.shape[0]}`),S(0<=o&&o<=1,()=>`softNmsSigma must be in [0, 1], but was '${o}'`),{maxOutputSize:e,iouThreshold:r,scoreThreshold:s,softNmsSigma:o}}const G9=M({nonMaxSuppression_:function H9(t,n,e,r=.5,s=Number.NEGATIVE_INFINITY){const o=T(t,"boxes","nonMaxSuppression"),i=T(n,"scores","nonMaxSuppression"),a=xu(o,i,e,r,s);return F.runKernel(Ew,{boxes:o,scores:i},{maxOutputSize:e=a.maxOutputSize,iouThreshold:r=a.iouThreshold,scoreThreshold:s=a.scoreThreshold})}});function j9(t,n,e){const r=function q9(t,n,e){return function X9(t,n,e){let r=0,s=t.length,o=0,i=!1;for(;r<s;){o=r+(s-r>>>1);const a=e(n,t[o]);a>0?r=o+1:(s=o,i=!a)}return i?r:-r-1}(t,n,e||K9)}(t,n,e);t.splice(r<0?-(r+1):r,0,n)}function K9(t,n){return t>n?1:t<n?-1:0}function HC(t,n,e,r,s){return qC(t,n,e,r,s,0)}function GC(t,n,e,r,s,o){return qC(t,n,e,r,s,0,!1,o,!0)}function jC(t,n,e,r,s,o){return qC(t,n,e,r,s,o,!0)}function qC(t,n,e,r,s,o,i=!1,a=!1,l=!1){const u=[];for(let g=0;g<n.length;g++)n[g]>s&&u.push({score:n[g],boxIndex:g,suppressBeginIndex:0});u.sort(l2);const c=o>0?-.5/o:0,d=[],h=[];for(;d.length<e&&u.length>0;){const g=u.pop(),{score:y,boxIndex:b,suppressBeginIndex:v}=g;if(y<s)break;let x=!1;for(let w=d.length-1;w>=v;--w){const _=Y9(t,b,d[w]);if(_>=r){x=!0;break}if(g.score=g.score*Z9(r,c,_),g.score<=s)break}g.suppressBeginIndex=d.length,x||(g.score===y?(d.push(b),h.push(g.score)):g.score>s&&j9(u,g,l2))}const f=d.length,p=e-f;a&&p>0&&(d.push(...new Array(p).fill(0)),h.push(...new Array(p).fill(0)));const m={selectedIndices:d};return i&&(m.selectedScores=h),l&&(m.validOutputs=f),m}function Y9(t,n,e){const r=t.subarray(4*n,4*n+4),s=t.subarray(4*e,4*e+4),o=Math.min(r[0],r[2]),i=Math.min(r[1],r[3]),a=Math.max(r[0],r[2]),l=Math.max(r[1],r[3]),u=Math.min(s[0],s[2]),c=Math.min(s[1],s[3]),d=Math.max(s[0],s[2]),h=Math.max(s[1],s[3]),f=(a-o)*(l-i),p=(d-u)*(h-c);if(f<=0||p<=0)return 0;const m=Math.max(o,u),g=Math.max(i,c),y=Math.min(a,d),b=Math.min(l,h),v=Math.max(y-m,0)*Math.max(b-g,0);return v/(f+p-v)}function Z9(t,n,e){const r=Math.exp(n*e*e);return e<=t?r:0}function l2(t,n){return t.score-n.score||t.score===n.score&&n.boxIndex-t.boxIndex}function KC(){return(KC=J(function*(t,n,e,r=.5,s=Number.NEGATIVE_INFINITY){const o=T(t,"boxes","nonMaxSuppressionAsync"),i=T(n,"scores","nonMaxSuppressionAsync"),a=xu(o,i,e,r,s);e=a.maxOutputSize,r=a.iouThreshold,s=a.scoreThreshold;const l=yield Promise.all([o.data(),i.data()]),u=l[0],c=l[1],{selectedIndices:d}=HC(u,c,e,r,s);return o!==t&&o.dispose(),i!==n&&i.dispose(),Os(d,"int32")})).apply(this,arguments)}const tY=M({nonMaxSuppressionWithScore_:function eY(t,n,e,r=.5,s=Number.NEGATIVE_INFINITY,o=0){const i=T(t,"boxes","nonMaxSuppression"),a=T(n,"scores","nonMaxSuppression"),l=xu(i,a,e,r,s,o),d=F.runKernel(Tw,{boxes:i,scores:a},{maxOutputSize:e=l.maxOutputSize,iouThreshold:r=l.iouThreshold,scoreThreshold:s=l.scoreThreshold,softNmsSigma:o=l.softNmsSigma});return{selectedIndices:d[0],selectedScores:d[1]}}});function XC(){return(XC=J(function*(t,n,e,r=.5,s=Number.NEGATIVE_INFINITY,o=0){const i=T(t,"boxes","nonMaxSuppressionAsync"),a=T(n,"scores","nonMaxSuppressionAsync"),l=xu(i,a,e,r,s,o);e=l.maxOutputSize,r=l.iouThreshold,s=l.scoreThreshold,o=l.softNmsSigma;const u=yield Promise.all([i.data(),a.data()]),c=u[0],d=u[1],{selectedIndices:h,selectedScores:f}=jC(c,d,e,r,s,o);return i!==t&&i.dispose(),a!==n&&a.dispose(),{selectedIndices:Os(h,"int32"),selectedScores:Os(f)}})).apply(this,arguments)}const oY=M({nonMaxSuppressionPadded_:function sY(t,n,e,r=.5,s=Number.NEGATIVE_INFINITY,o=!1){const i=T(t,"boxes","nonMaxSuppression"),a=T(n,"scores","nonMaxSuppression"),l=xu(i,a,e,r,s,null),p=F.runKernel(Nw,{boxes:i,scores:a},{maxOutputSize:l.maxOutputSize,iouThreshold:l.iouThreshold,scoreThreshold:l.scoreThreshold,padToMaxOutputSize:o});return{selectedIndices:p[0],validOutputs:p[1]}}});function YC(){return(YC=J(function*(t,n,e,r=.5,s=Number.NEGATIVE_INFINITY,o=!1){const i=T(t,"boxes","nonMaxSuppressionAsync"),a=T(n,"scores","nonMaxSuppressionAsync"),l=xu(i,a,e,r,s,null),u=l.maxOutputSize,c=l.iouThreshold,d=l.scoreThreshold,[h,f]=yield Promise.all([i.data(),a.data()]),{selectedIndices:p,validOutputs:m}=GC(h,f,u,c,d,o);return i!==t&&i.dispose(),a!==n&&a.dispose(),{selectedIndices:Os(p,"int32"),validOutputs:Fe(m,"int32")}})).apply(this,arguments)}const u2=M({resizeBilinear_:function lY(t,n,e=!1,r=!1){const s=T(t,"images","resizeBilinear");S(3===s.rank||4===s.rank,()=>`Error in resizeBilinear: x must be rank 3 or 4, but got rank ${s.rank}.`),S(2===n.length,()=>`Error in resizeBilinear: new shape must 2D, but got shape ${n}.`),S(!1===r||!1===e,()=>"Error in resizeBilinear: If halfPixelCenters is true, alignCorners must be false.");let o=s,i=!1;3===s.rank&&(i=!0,o=H(s,[1,s.shape[0],s.shape[1],s.shape[2]]));const[]=n,u=F.runKernel(Gm,{images:o},{alignCorners:e,halfPixelCenters:r,size:n});return i?H(u,[u.shape[1],u.shape[2],u.shape[3]]):u}}),c2=M({resizeNearestNeighbor_:function uY(t,n,e=!1,r=!1){const s=T(t,"images","resizeNearestNeighbor");S(3===s.rank||4===s.rank,()=>`Error in resizeNearestNeighbor: x must be rank 3 or 4, but got rank ${s.rank}.`),S(2===n.length,()=>`Error in resizeNearestNeighbor: new shape must 2D, but got shape ${n}.`),S("float32"===s.dtype||"int32"===s.dtype,()=>"`images` must have `int32` or `float32` as dtype"),S(!1===r||!1===e,()=>"Error in resizeNearestNeighbor: If halfPixelCenters is true, alignCorners must be false.");let o=s,i=!1;3===s.rank&&(i=!0,o=H(s,[1,s.shape[0],s.shape[1],s.shape[2]]));const[]=n,u=F.runKernel(Hm,{images:o},{alignCorners:e,halfPixelCenters:r,size:n});return i?H(u,[u.shape[1],u.shape[2],u.shape[3]]):u}}),dY=M({transform_:function cY(t,n,e="nearest",r="constant",s=0,o){const i=T(t,"image","transform","float32"),a=T(n,"transforms","transform","float32");return S(4===i.rank,()=>`Error in transform: image must be rank 4,but got rank ${i.rank}.`),S(2===a.rank&&(a.shape[0]===i.shape[0]||1===a.shape[0])&&8===a.shape[1],()=>"Error in transform: Input transform should be batch x 8 or 1 x 8"),S(null==o||2===o.length,()=>`Error in transform: outputShape must be [height, width] or null, but got ${o}.`),F.runKernel(zw,{image:i,transforms:a},{interpolation:e,fillMode:r,fillValue:s,outputShape:o})}}),wu=M({lessEqual_:function hY(t,n){let e=T(t,"a","lessEqual"),r=T(n,"b","lessEqual");return[e,r]=fn(e,r),bt(e.shape,r.shape),F.runKernel(_m,{a:e,b:r})}});function ZC(t,n,e=1,r="float32"){if(0===e)throw new Error("Cannot have a step of zero");return F.runKernel(Aw,{},{start:t,stop:n,step:e,dtype:r})}const pY=M({bandPart_:function fY(t,n,e){S(n%1==0,()=>`bandPart(): numLower must be an integer, got ${n}.`),S(e%1==0,()=>`bandPart(): numUpper must be an integer, got ${e}.`);const r=T(t,"a","bandPart");S(r.rank>=2,()=>`bandPart(): Rank must be at least 2, got ${r.rank}.`);const s=r.shape,[o,i]=r.shape.slice(-2);if(!(n<=o))throw new Error(`bandPart(): numLower (${n}) must not be greater than the number of rows (${o}).`);if(!(e<=i))throw new Error(`bandPart(): numUpper (${e}) must not be greater than the number of columns (${i}).`);n<0&&(n=o),e<0&&(e=i);const a=H(ZC(0,o,1,"int32"),[-1,1]),l=ZC(0,i,1,"int32"),u=$e(a,l),c=No(wu(u,Fe(+n,"int32")),Va(u,Fe(-e,"int32"))),d=Nn([o,i],r.dtype);return H(Fs(oo(H(r,[-1,o,i])).map(h=>ms(c,h,d))),s)}}),Ua=M({pow_:function mY(t,n){let e=T(t,"base","pow"),r=T(n,"exp","pow");return[e,r]=fn(e,r),F.runKernel(Vd,{a:e,b:r})}});function d2(t,n,e=null){if(0===t.rank)return Yn(t);if(1!==t.rank&&null===e)return d2(H(t,[-1]),n,e);if(1===t.rank||"number"==typeof e||Array.isArray(e)&&1===e.length){if(1===n)return Oe(Yn(t),e);if(n===1/0)return $s(Yn(t),e);if(n===-1/0)return vh(Yn(t),e);if("euclidean"===n||2===n)return yr(Oe(Ua(Yn(t),Fe(2,"int32")),e));throw new Error(`Error in norm: invalid ord value: ${n}`)}if(Array.isArray(e)&&2===e.length){if(1===n)return $s(Oe(Yn(t),e[0]),e[1]-1);if(n===1/0)return $s(Oe(Yn(t),e[1]),e[0]);if(n===-1/0)return vh(Oe(Yn(t),e[1]),e[0]);if("fro"===n||"euclidean"===n)return yr(Oe(zt(t),e));throw new Error(`Error in norm: invalid ord value: ${n}`)}throw new Error(`Error in norm: invalid axis: ${e}`)}const QC=M({norm_:function gY(t,n="euclidean",e=null,r=!1){const s=d2(t=T(t,"x","norm"),n,e);let o=s.shape;if(r){const i=ft(e,t.shape);o=vn(s.shape,i)}return H(s,o)}}),bY=M({gramSchmidt_:function yY(t){let n;if(Array.isArray(t)){n=!1,S(null!=t&&t.length>0,()=>"Gram-Schmidt process: input must not be null, undefined, or empty");const s=t[0].shape[0];for(let o=1;o<t.length;++o)S(t[o].shape[0]===s,()=>`Gram-Schmidt: Non-unique lengths found in the input vectors: (${t[o].shape[0]} vs. ${s})`)}else n=!0,t=ps(t,t.shape[0],0).map(s=>vu(s,[0]));S(t.length<=t[0].shape[0],()=>`Gram-Schmidt: Number of vectors (${t.length}) exceeds number of dimensions (${t[0].shape[0]}).`);const e=[],r=t;for(let s=0;s<t.length;++s)e.push(F.tidy(()=>{let o=r[s];if(s>0)for(let i=0;i<s;++i){const a=V(Oe(V(e[i],o)),e[i]);o=$e(o,a)}return Me(o,QC(o,"euclidean"))}));return n?Fs(e,0):e}});function h2(t,n=!1){return F.tidy(()=>{S(2===t.shape.length,()=>`qr2d() requires a 2D Tensor, but got a ${t.shape.length}D Tensor.`);const e=t.shape[0],r=t.shape[1];let s=Y$(e),o=Pa(t);const i=Ih([[1]],[1,1]);let a=Pa(i);const l=e>=r?r:e;for(let u=0;u<l;++u){const c=o,d=a,h=s;[a,o,s]=F.tidy(()=>{const f=At(o,[u,u],[e-u,1]),p=QC(f),m=At(o,[u,u],[1,1]),g=ms(Eo(m,0),Ih([[-1]]),Ih([[1]])),y=$e(m,V(g,p)),b=Me(f,y);a=1===b.shape[0]?Pa(i):Sn([i,At(b,[1,0],[b.shape[0]-1,b.shape[1]])],0);const v=mn(Me(Nt(g,y),p)),x=At(o,[u,0],[e-u,r]),w=V(v,a),_=Bt(a);if(0===u)o=$e(x,Nt(w,Nt(_,x)));else{const R=$e(x,Nt(w,Nt(_,x)));o=Sn([At(o,[0,0],[u,r]),R],0)}const D=Bt(w),A=At(s,[0,u],[e,s.shape[1]-u]);if(0===u)s=$e(A,Nt(Nt(A,a),D));else{const R=$e(A,Nt(Nt(A,a),D));s=Sn([At(s,[0,0],[e,u]),R],1)}return[a,o,s]}),it([c,d,h])}return!n&&e>r&&(s=At(s,[0,0],[e,r]),o=At(o,[0,0],[r,r])),[s,o]})}const xY=M({qr_:function vY(t,n=!1){if(S(t.rank>=2,()=>`qr() requires input tensor to have a rank >= 2, but got rank ${t.rank}`),2===t.rank)return h2(t,n);{const e=t.shape.slice(0,t.shape.length-2).reduce((l,u)=>l*u),r=oo(H(t,[e,t.shape[t.shape.length-2],t.shape[t.shape.length-1]]),0),s=[],o=[];return r.forEach(l=>{const[u,c]=h2(l,n);s.push(u),o.push(c)}),[H(Fs(s,0),t.shape),H(Fs(o,0),t.shape)]}}});var Sr=(()=>{return(t=Sr||(Sr={}))[t.NONE=0]="NONE",t[t.MEAN=1]="MEAN",t[t.SUM=2]="SUM",t[t.SUM_BY_NONZERO_WEIGHTS=3]="SUM_BY_NONZERO_WEIGHTS",Sr;var t})();const ui=M({computeWeightedLoss_:function wY(t,n,e=Sr.SUM_BY_NONZERO_WEIGHTS){const r=T(t,"losses","computeWeightedLoss");let s=null;null!=n&&(s=T(n,"weights","computeWeightedLoss"));const o=null==s?r:V(r,s);if(e===Sr.NONE)return o;if(e===Sr.SUM)return Oe(o);if(e===Sr.MEAN){if(null==s)return pn(o);{const i=r.size/s.size,a=Me(Oe(o),Oe(s));return i>1?Me(a,Fe(i)):a}}if(e===Sr.SUM_BY_NONZERO_WEIGHTS){if(null==s)return Me(Oe(o),Fe(r.size));{const i=V(s,ii(r.shape)),a=Ae(Oe(yu(i,Fe(0))),"float32");return Me(Oe(o),a)}}throw Error(`Unknown reduction: ${e}`)}});M({absoluteDifference_:function CY(t,n,e,r=Sr.SUM_BY_NONZERO_WEIGHTS){const s=T(t,"labels","absoluteDifference"),o=T(n,"predictions","absoluteDifference");let i=null;null!=e&&(i=T(e,"weights","absoluteDifference")),cs(s.shape,o.shape,"Error in absoluteDifference: ");const a=Yn($e(s,o));return ui(a,i,r)}}),M({cosineDistance_:function DY(t,n,e,r,s=Sr.SUM_BY_NONZERO_WEIGHTS){const o=T(t,"labels","cosineDistance"),i=T(n,"predictions","cosineDistance");let a=null;null!=r&&(a=T(r,"weights","cosineDistance")),cs(o.shape,i.shape,"Error in cosineDistance: ");const l=Fe(1),u=$e(l,Oe(V(o,i),e,!0));return ui(u,a,s)}}),M({hingeLoss_:function SY(t,n,e,r=Sr.SUM_BY_NONZERO_WEIGHTS){let s=T(t,"labels","hingeLoss");const o=T(n,"predictions","hingeLoss");let i=null;null!=e&&(i=T(e,"weights","hingeLoss")),cs(s.shape,o.shape,"Error in hingeLoss: ");const a=Fe(1);s=$e(V(Fe(2),s),a);const l=ai($e(a,V(s,o)));return ui(l,i,r)}}),M({huberLoss_:function NY(t,n,e,r=1,s=Sr.SUM_BY_NONZERO_WEIGHTS){const o=T(t,"labels","huberLoss"),i=T(n,"predictions","huberLoss");let a=null;null!=e&&(a=T(e,"weights","huberLoss")),cs(o.shape,i.shape,"Error in huberLoss: ");const l=Fe(r),u=Yn($e(i,o)),c=xh(u,l),d=$e(u,c),h=me(V(Fe(.5),zt(c)),V(l,d));return ui(h,a,s)}}),M({logLoss_:function kY(t,n,e,r=1e-7,s=Sr.SUM_BY_NONZERO_WEIGHTS){const o=T(t,"labels","logLoss"),i=T(n,"predictions","logLoss");let a=null;null!=e&&(a=T(e,"weights","logLoss")),cs(o.shape,i.shape,"Error in logLoss: ");const l=Fe(1),u=Fe(r),c=mn(V(o,hs(me(i,u)))),d=V($e(l,o),hs(me($e(l,i),u))),h=$e(c,d);return ui(h,a,s)}});const JC=M({squaredDifference_:function RY(t,n){let e=T(t,"a","squaredDifference"),r=T(n,"b","squaredDifference");return[e,r]=fn(e,r),bt(e.shape,r.shape),F.runKernel(eh,{a:e,b:r},{})}});M({meanSquaredError_:function $Y(t,n,e,r=Sr.SUM_BY_NONZERO_WEIGHTS){const s=T(t,"labels","meanSquaredError"),o=T(n,"predictions","meanSquaredError");let i=null;null!=e&&(i=T(e,"weights","meanSquaredError")),cs(s.shape,o.shape,"Error in meanSquaredError: ");const a=JC(s,o);return ui(a,i,r)}});const eI=M({log1p_:function OY(t){const e={x:T(t,"x","log1p")};return F.runKernel(Md,e)}});M({sigmoidCrossEntropy_:function PY(t,n,e,r=0,s=Sr.SUM_BY_NONZERO_WEIGHTS){let o=T(t,"multiClassLabels","sigmoidCrossEntropy");const i=T(n,"logits","sigmoidCrossEntropy");let a=null;if(null!=e&&(a=T(e,"weights","sigmoidCrossEntropy")),cs(o.shape,i.shape,"Error in sigmoidCrossEntropy: "),r>0){const u=Fe(r),c=Fe(1),d=Fe(.5);o=me(V(o,$e(c,u)),V(d,u))}const l=function MY(t,n){const e=T(t,"labels","sigmoidCrossEntropyWithLogits"),r=T(n,"logits","sigmoidCrossEntropyWithLogits");cs(e.shape,r.shape,"Error in sigmoidCrossEntropyWithLogits: ");const s=ai(r),o=V(r,e),i=eI(Rs(mn(Yn(r))));return me($e(s,o),i)}(o,i);return ui(l,a,s)}});const f2=M({logSumExp_:function BY(t,n=null,e=!1){const r=T(t,"x","logSumExp"),s=ft(n,r.shape),o=$s(r,s,!0),i=$e(r,o),a=Rs(i),l=Oe(a,s),u=hs(l),c=me(H(o,u.shape),u);if(e){const d=vn(c.shape,s);return H(c,d)}return c}});M({softmaxCrossEntropy_:function VY(t,n,e,r=0,s=Sr.SUM_BY_NONZERO_WEIGHTS){let o=T(t,"onehotLabels","softmaxCrossEntropy");const i=T(n,"logits","softmaxCrossEntropy");let a=null;if(null!=e&&(a=T(e,"weights","softmaxCrossEntropy")),cs(o.shape,i.shape,"Error in softmaxCrossEntropy: "),r>0){const u=Fe(r),c=Fe(1),d=Fe(o.shape[1]);o=me(V(o,$e(c,u)),Me(u,d))}const l=function zY(t,n,e=-1){if(-1===e&&(e=n.rank-1),e!==n.rank-1)throw Error(`Softmax cross entropy along a non-last dimension is not yet supported. Labels / logits was rank ${n.rank} and dim was ${e}`);return ni((s,o,i)=>{const l=f2(o,[e],!0),u=$e(Ae(o,"float32"),l);i([s,u]);const c=mn(V(u,s));return{value:Oe(c,[e]),gradFunc:(f,p)=>{const[m,g]=p,y=vn(f.shape,[e]);return[V(H(f,y),$e(Ae(m,"float32"),Rs(g))),V(H(f,y),$e(Rs(g),Ae(m,"float32")))]}}})(t,n)}(o,i);return ui(l,a,s)}});const Wa={flipLeftRight:V9,resizeNearestNeighbor:c2,resizeBilinear:u2,rotateWithOffset:W9,cropAndResize:B9,nonMaxSuppression:G9,nonMaxSuppressionAsync:function Q9(t,n,e){return KC.apply(this,arguments)},nonMaxSuppressionWithScore:tY,nonMaxSuppressionWithScoreAsync:function nY(t,n,e){return XC.apply(this,arguments)},nonMaxSuppressionPadded:oY,nonMaxSuppressionPaddedAsync:function iY(t,n,e){return YC.apply(this,arguments)},transform:dY},WY={bandPart:pY,gramSchmidt:bY,qr:xY};let tI=(()=>{class t extends Li{constructor(e,r,s=null){super(),this.learningRate=e,this.rho=r,this.epsilon=s,this.accumulatedGrads=[],this.accumulatedUpdates=[],null==s&&(this.epsilon=F.backend.epsilon())}applyGradients(e){(Array.isArray(e)?e.map(s=>s.name):Object.keys(e)).forEach((s,o)=>{const i=F.registeredVariables[s];null==this.accumulatedGrads[o]&&(this.accumulatedGrads[o]={originalName:`${s}/accum_grad`,variable:U(()=>Ct(i).variable(!1))}),null==this.accumulatedUpdates[o]&&(this.accumulatedUpdates[o]={originalName:`${s}/accum_var`,variable:U(()=>Ct(i).variable(!1))});const l=Array.isArray(e)?e[o].tensor:e[s];if(null==l)return;const u=this.accumulatedGrads[o].variable,c=this.accumulatedUpdates[o].variable;U(()=>{const d=me(V(u,this.rho),V(zt(l),1-this.rho)),h=V(Me(yr(me(c,this.epsilon)),yr(me(u,this.epsilon))),l),f=me(V(c,this.rho),V(zt(h),1-this.rho));u.assign(d),c.assign(f);const p=me(V(h,-this.learningRate),i);i.assign(p)})}),this.incrementIterations()}dispose(){null!=this.accumulatedUpdates&&(it(this.accumulatedGrads.map(e=>e.variable)),it(this.accumulatedUpdates.map(e=>e.variable)))}getWeights(){var e=this;return J(function*(){const r=[...e.accumulatedGrads,...e.accumulatedUpdates];return[yield e.saveIterations()].concat(r.map(s=>({name:s.originalName,tensor:s.variable})))})()}setWeights(e){var r=this;return J(function*(){const s=(e=yield r.extractIterations(e)).length/2;r.accumulatedGrads=e.slice(0,s).map(i=>({originalName:i.name,variable:i.tensor.variable(!1)})),r.accumulatedUpdates=e.slice(s,2*s).map(i=>({originalName:i.name,variable:i.tensor.variable(!1)}))})()}getConfig(){return{learningRate:this.learningRate,rho:this.rho,epsilon:this.epsilon}}static fromConfig(e,r){return new e(r.learningRate,r.rho,r.epsilon)}}return t.className="Adadelta",t})();le(tI);let nI=(()=>{class t extends Li{constructor(e,r=.1){super(),this.learningRate=e,this.initialAccumulatorValue=r,this.accumulatedGrads=[]}applyGradients(e){(Array.isArray(e)?e.map(s=>s.name):Object.keys(e)).forEach((s,o)=>{const i=F.registeredVariables[s];null==this.accumulatedGrads[o]&&(this.accumulatedGrads[o]={originalName:`${s}/accumulator`,variable:U(()=>Ig(i.shape,this.initialAccumulatorValue).variable(!1))});const a=Array.isArray(e)?e[o].tensor:e[s];if(null==a)return;const l=this.accumulatedGrads[o].variable;U(()=>{const u=me(l,zt(a));l.assign(u);const c=me(V(Me(a,yr(me(u,F.backend.epsilon()))),-this.learningRate),i);i.assign(c)})}),this.incrementIterations()}dispose(){null!=this.accumulatedGrads&&it(this.accumulatedGrads.map(e=>e.variable))}getWeights(){var e=this;return J(function*(){return[yield e.saveIterations()].concat(e.accumulatedGrads.map(r=>({name:r.originalName,tensor:r.variable})))})()}setWeights(e){var r=this;return J(function*(){e=yield r.extractIterations(e),r.accumulatedGrads=e.map(o=>({originalName:o.name,variable:o.tensor.variable(!1)}))})()}getConfig(){return{learningRate:this.learningRate,initialAccumulatorValue:this.initialAccumulatorValue}}static fromConfig(e,r){return new e(r.learningRate,r.initialAccumulatorValue)}}return t.className="Adagrad",t})();le(nI);let rI=(()=>{class t extends Li{constructor(e,r,s,o=null){super(),this.learningRate=e,this.beta1=r,this.beta2=s,this.epsilon=o,this.accumulatedFirstMoment=[],this.accumulatedSecondMoment=[],U(()=>{this.accBeta1=Fe(r).variable(),this.accBeta2=Fe(s).variable()}),null==o&&(this.epsilon=F.backend.epsilon())}applyGradients(e){const r=Array.isArray(e)?e.map(s=>s.name):Object.keys(e);U(()=>{const s=$e(1,this.accBeta1),o=$e(1,this.accBeta2);r.forEach((i,a)=>{const l=F.registeredVariables[i];null==this.accumulatedFirstMoment[a]&&(this.accumulatedFirstMoment[a]={originalName:`${i}/m`,variable:U(()=>Ct(l).variable(!1))}),null==this.accumulatedSecondMoment[a]&&(this.accumulatedSecondMoment[a]={originalName:`${i}/v`,variable:U(()=>Ct(l).variable(!1))});const c=Array.isArray(e)?e[a].tensor:e[i];if(null==c)return;const d=this.accumulatedFirstMoment[a].variable,h=this.accumulatedSecondMoment[a].variable,f=me(V(d,this.beta1),V(c,1-this.beta1)),p=me(V(h,this.beta2),V(zt(c),1-this.beta2)),m=Me(f,s),g=Me(p,o);d.assign(f),h.assign(p);const y=me(V(Me(m,me(yr(g),this.epsilon)),-this.learningRate),l);l.assign(y)}),this.accBeta1.assign(V(this.accBeta1,this.beta1)),this.accBeta2.assign(V(this.accBeta2,this.beta2))}),this.incrementIterations()}dispose(){this.accBeta1.dispose(),this.accBeta2.dispose(),null!=this.accumulatedFirstMoment&&it(this.accumulatedFirstMoment.map(e=>e.variable)),null!=this.accumulatedSecondMoment&&it(this.accumulatedSecondMoment.map(e=>e.variable))}getWeights(){var e=this;return J(function*(){const r=[...e.accumulatedFirstMoment,...e.accumulatedSecondMoment];return[yield e.saveIterations()].concat(r.map(s=>({name:s.originalName,tensor:s.variable})))})()}setWeights(e){var r=this;return J(function*(){e=yield r.extractIterations(e),U(()=>{r.accBeta1.assign(Ua(r.beta1,r.iterations_+1)),r.accBeta2.assign(Ua(r.beta2,r.iterations_+1))});const s=e.length/2;r.accumulatedFirstMoment=e.slice(0,s).map(i=>({originalName:i.name,variable:i.tensor.variable(!1)})),r.accumulatedSecondMoment=e.slice(s,2*s).map(i=>({originalName:i.name,variable:i.tensor.variable(!1)}))})()}getConfig(){return{learningRate:this.learningRate,beta1:this.beta1,beta2:this.beta2,epsilon:this.epsilon}}static fromConfig(e,r){return new e(r.learningRate,r.beta1,r.beta2,r.epsilon)}}return t.className="Adam",t})();le(rI);let sI=(()=>{class t extends Li{constructor(e,r,s,o=null,i=0){super(),this.learningRate=e,this.beta1=r,this.beta2=s,this.epsilon=o,this.decay=i,this.accumulatedFirstMoment=[],this.accumulatedWeightedInfNorm=[],U(()=>{this.iteration=Fe(0).variable(),this.accBeta1=Fe(r).variable()}),null==o&&(this.epsilon=F.backend.epsilon())}applyGradients(e){const r=Array.isArray(e)?e.map(s=>s.name):Object.keys(e);U(()=>{const s=$e(1,this.accBeta1),o=Me(-this.learningRate,me(V(this.iteration,this.decay),1));r.forEach((i,a)=>{const l=F.registeredVariables[i];null==this.accumulatedFirstMoment[a]&&(this.accumulatedFirstMoment[a]={originalName:`${i}/m`,variable:Ct(l).variable(!1)}),null==this.accumulatedWeightedInfNorm[a]&&(this.accumulatedWeightedInfNorm[a]={originalName:`${i}/v`,variable:Ct(l).variable(!1)});const c=Array.isArray(e)?e[a].tensor:e[i];if(null==c)return;const d=this.accumulatedFirstMoment[a].variable,h=this.accumulatedWeightedInfNorm[a].variable,f=me(V(d,this.beta1),V(c,1-this.beta1)),p=V(h,this.beta2),m=Yn(c),g=oi(p,m);d.assign(f),h.assign(g);const y=me(V(Me(o,s),Me(f,me(g,this.epsilon))),l);l.assign(y)}),this.iteration.assign(me(this.iteration,1)),this.accBeta1.assign(V(this.accBeta1,this.beta1))}),this.incrementIterations()}dispose(){this.accBeta1.dispose(),this.iteration.dispose(),null!=this.accumulatedFirstMoment&&it(this.accumulatedFirstMoment.map(e=>e.variable)),null!=this.accumulatedWeightedInfNorm&&it(this.accumulatedWeightedInfNorm.map(e=>e.variable))}getWeights(){return J(function*(){throw new Error("getWeights() is not implemented for Adamax yet.")})()}setWeights(e){return J(function*(){throw new Error("setWeights() is not implemented for Adamax yet.")})()}getConfig(){return{learningRate:this.learningRate,beta1:this.beta1,beta2:this.beta2,epsilon:this.epsilon,decay:this.decay}}static fromConfig(e,r){return new e(r.learningRate,r.beta1,r.beta2,r.epsilon,r.decay)}}return t.className="Adamax",t})();le(sI);let Lg=(()=>{class t extends Li{constructor(e){super(),this.learningRate=e,this.setLearningRate(e)}applyGradients(e){(Array.isArray(e)?e.map(s=>s.name):Object.keys(e)).forEach((s,o)=>{const i=Array.isArray(e)?e[o].tensor:e[s];if(null==i)return;const a=F.registeredVariables[s];U(()=>{const l=me(V(this.c,i),a);a.assign(l)})}),this.incrementIterations()}setLearningRate(e){this.learningRate=e,null!=this.c&&this.c.dispose(),this.c=ir(Fe(-e))}dispose(){this.c.dispose()}getWeights(){var e=this;return J(function*(){return[yield e.saveIterations()]})()}setWeights(e){var r=this;return J(function*(){if(0!==(e=yield r.extractIterations(e)).length)throw new Error("SGD optimizer does not have settable weights.")})()}getConfig(){return{learningRate:this.learningRate}}static fromConfig(e,r){return new e(r.learningRate)}}return t.className="SGD",t})();le(Lg);let oI=(()=>{class t extends Lg{constructor(e,r,s=!1){super(e),this.learningRate=e,this.momentum=r,this.useNesterov=s,this.accumulations=[],this.m=Fe(this.momentum)}applyGradients(e){(Array.isArray(e)?e.map(s=>s.name):Object.keys(e)).forEach((s,o)=>{const i=F.registeredVariables[s];null==this.accumulations[o]&&(this.accumulations[o]={originalName:`${s}/momentum`,variable:U(()=>Ct(i).variable(!1))});const a=this.accumulations[o].variable,l=Array.isArray(e)?e[o].tensor:e[s];null!=l&&U(()=>{let u;const c=me(V(this.m,a),l);u=me(V(this.c,this.useNesterov?me(l,V(c,this.m)):c),i),a.assign(c),i.assign(u)})}),this.incrementIterations()}dispose(){this.m.dispose(),null!=this.accumulations&&it(this.accumulations.map(e=>e.variable))}setMomentum(e){this.momentum=e}getWeights(){var e=this;return J(function*(){return[yield e.saveIterations()].concat(e.accumulations.map(r=>({name:r.originalName,tensor:r.variable})))})()}setWeights(e){var r=this;return J(function*(){e=yield r.extractIterations(e),r.accumulations=e.map(o=>({originalName:o.name,variable:o.tensor.variable(!1)}))})()}getConfig(){return{learningRate:this.learningRate,momentum:this.momentum,useNesterov:this.useNesterov}}static fromConfig(e,r){return new e(r.learningRate,r.momentum,r.useNesterov)}}return t.className="Momentum",t})();le(oI);let iI=(()=>{class t extends Li{constructor(e,r=.9,s=0,o=null,i=!1){if(super(),this.learningRate=e,this.decay=r,this.momentum=s,this.epsilon=o,this.accumulatedMeanSquares=[],this.accumulatedMoments=[],this.accumulatedMeanGrads=[],this.centered=i,null==o&&(this.epsilon=F.backend.epsilon()),null==e)throw new Error("learningRate for RMSPropOptimizer must be defined.")}applyGradients(e){(Array.isArray(e)?e.map(s=>s.name):Object.keys(e)).forEach((s,o)=>{const i=F.registeredVariables[s],a=!1;null==this.accumulatedMeanSquares[o]&&(this.accumulatedMeanSquares[o]={originalName:`${s}/rms`,variable:U(()=>Ct(i).variable(a))}),null==this.accumulatedMoments[o]&&(this.accumulatedMoments[o]={originalName:`${s}/momentum`,variable:U(()=>Ct(i).variable(a))}),null==this.accumulatedMeanGrads[o]&&this.centered&&(this.accumulatedMeanGrads[o]={originalName:`${s}/mg`,variable:U(()=>Ct(i).variable(a))});const l=Array.isArray(e)?e[o].tensor:e[s];if(null==l)return;const u=this.accumulatedMeanSquares[o].variable,c=this.accumulatedMoments[o].variable;U(()=>{const d=me(V(u,this.decay),V(zt(l),1-this.decay));if(this.centered){const h=this.accumulatedMeanGrads[o].variable,f=me(V(h,this.decay),V(l,1-this.decay)),p=Me(V(l,this.learningRate),yr($e(d,me(zt(f),this.epsilon)))),m=me(V(c,this.momentum),p);u.assign(d),h.assign(f),c.assign(m);const g=$e(i,m);i.assign(g)}else{const h=me(V(u,this.decay),V(zt(l),1-this.decay)),f=me(V(c,this.momentum),Me(V(l,this.learningRate),yr(me(h,this.epsilon))));u.assign(h),c.assign(f);const p=$e(i,f);i.assign(p)}})}),this.incrementIterations()}dispose(){null!=this.accumulatedMeanSquares&&it(this.accumulatedMeanSquares.map(e=>e.variable)),null!=this.accumulatedMeanGrads&&this.centered&&it(this.accumulatedMeanGrads.map(e=>e.variable)),null!=this.accumulatedMoments&&it(this.accumulatedMoments.map(e=>e.variable))}getWeights(){var e=this;return J(function*(){const r=[...e.accumulatedMeanSquares,...e.accumulatedMoments];return e.centered&&r.push(...e.accumulatedMeanGrads),[yield e.saveIterations()].concat(r.map(s=>({name:s.originalName,tensor:s.variable})))})()}setWeights(e){var r=this;return J(function*(){e=yield r.extractIterations(e);const s=r.centered?e.length/3:e.length/2,o=!1;r.accumulatedMeanSquares=e.slice(0,s).map(i=>({originalName:i.name,variable:i.tensor.variable(o)})),r.accumulatedMoments=e.slice(s,2*s).map(i=>({originalName:i.name,variable:i.tensor.variable(o)})),r.centered&&(r.accumulatedMeanGrads=e.slice(2*s,3*s).map(i=>({originalName:i.name,variable:i.tensor.variable(o)})))})()}getConfig(){return{learningRate:this.learningRate,decay:this.decay,momentum:this.momentum,epsilon:this.epsilon,centered:this.centered}}static fromConfig(e,r){return new e(r.learningRate,r.decay,r.momentum,r.epsilon,r.centered)}}return t.className="RMSProp",t})();le(iI);class Ha{static sgd(n){return new Lg(n)}static momentum(n,e,r=!1){return new oI(n,e,r)}static rmsprop(n,e=.9,r=0,s=null,o=!1){return new iI(n,e,r,s,o)}static adam(n=.001,e=.9,r=.999,s=null){return new rI(n,e,r,s)}static adadelta(n=.001,e=.95,r=null){return new tI(n,e,r)}static adamax(n=.002,e=.9,r=.999,s=null,o=0){return new sI(n,e,r,s,o)}static adagrad(n,e=.1){return new nI(n,e)}}const Cu={sgd:Ha.sgd,momentum:Ha.momentum,adadelta:Ha.adadelta,adagrad:Ha.adagrad,rmsprop:Ha.rmsprop,adamax:Ha.adamax,adam:Ha.adam},HY=typeof requestAnimationFrame<"u"?requestAnimationFrame:typeof setImmediate<"u"?setImmediate:t=>t();function aI(){return new Promise(t=>HY(()=>t()))}function lI(t,n){const e=t[0].length;t.forEach((s,o)=>{S(s.length===e,()=>`Error in concat${e}D: rank of tensors[${o}] must be the same as the rank of the rest (${e})`)}),S(n>=0&&n<e,()=>`Error in concat${e}D: axis must be between 0 and ${e-1}.`);const r=t[0];t.forEach((s,o)=>{for(let i=0;i<e;i++)S(i===n||s[i]===r[i],()=>`Error in concat${e}D: Shape of tensors[${o}] (${s}) does not match the shape of the rest (${r}) along the non-concatenated axis ${o}.`)})}function ci(t,n){const e=t[0].slice();for(let r=1;r<t.length;r++)e[n]+=t[r][n];return e}const uI=30;function Bg(t){return t<=uI?t:X0(t,Math.floor(Math.sqrt(t)))}function cI(t,n,e){return[e*("number"==typeof t?t:t[0]),n*("number"==typeof t?t:t[1])]}function Sh(t,n,e,r=!0){let s=[];if(r)s=s.concat(n.slice(0)),s.push(t[0]/e),s=s.concat(t.slice(1));else{s=s.concat(t[0]);const o=n.length;for(let i=0;i<o;++i)s=s.concat([t[i+1]/n[i],n[i]]);s=s.concat(t.slice(o+1))}return s}function Eh(t,n,e=!0){const r=[];if(e){r.push(n);for(let s=n+1;s<t;++s)s<=2*n?(r.push(s),r.push(s-(n+1))):r.push(s)}else{const s=[],o=[];for(let i=1;i<t;++i)i>=2*n+1||i%2==1?o.push(i):s.push(i);r.push(...s),r.push(0),r.push(...o)}return r}function Nh(t,n,e,r=!0){const s=[];s.push(r?t[0]/e:t[0]*e);for(let o=1;o<t.length;++o)s.push(o<=n.length?r?n[o-1]*t[o]:t[o]/n[o-1]:t[o]);return s}function dI(t,n){const e=[0];for(let r=0;r<n;++r)e.push(t[r][0]);return e}function hI(t,n,e){const r=t.slice(0,1);for(let s=0;s<e;++s)r.push(t[s+1]-n[s][0]-n[s][1]);return r}function fI(t,n){const e=t.shape.length,r=n.shape.length;if(e<1)throw new Error(`tf.gatherND() expects the input to be rank 1 or higher, but the rank was ${e}.`);if(r<1)throw new Error(`tf.gatherND() expects the indices to be rank 1 or higher, but the rank was ${r}.`);if("int32"!==n.dtype)throw new Error(`tf.gatherND() expects the indices to be int32 type, but the dtype was ${n.dtype}.`);if(n.shape[r-1]>e)throw new Error(`index innermost dimension length must be <= tensor rank; saw: ${n.shape[r-1]} vs. ${e}`);if(0===te(t.shape))throw new Error(`Requested more than 0 entries, but input is empty. Input shape: ${t.shape}.`);const s=n.shape,o=s[s.length-1];let i=1;for(let d=0;d<s.length-1;++d)i*=s[d];const a=t.shape,l=s.slice();l.pop();let u=1;for(let d=o;d<e;++d)u*=a[d],l.push(a[d]);const c=[...Le(t.shape).map(d=>d/u),1].slice(0,o);return[l,i,u,c]}function p2(t,n,e){const r=n.rank>1?n.shape[n.rank-1]:1,s=n.rank>1?n.rank-1:1,o=`Must have updates.shape = indices.shape[:batchDim] + shape[sliceDim:], got updates.shape: ${e.shape}, indices.shape: ${n.shape}, shape: ${t}, sliceDim: ${r}, and batchDim: ${s}.`;if(e.rank<s)throw new Error(o+` update.rank < ${s}. `);if(t.length<r+(e.rank-s))throw new Error(o+` Output shape length < ${r+(e.rank-s)}`);if(e.rank!==s+t.length-r)throw new Error(o+" update.rank != "+(s+t.length-r));for(let i=0;i<s;++i)if(e.shape[i]!==n.shape[i])throw new Error(o+` updates.shape[${i}] (${e.shape[i]}) != indices.shape[${i}] (${n.shape[i]}).`);for(let i=0;i<e.rank-s;++i)if(e.shape[i+s]!==t[i+r])throw new Error(o+` updates.shape[${i+s}] (${e.shape[i+s]}) != shape[${i+s}] (${t[i+s]})`)}function m2(t,n,e){if(n.rank<1)throw new Error(`tf.scatterND() expects the indices to be rank 1 or higher, but the rank was ${n.rank}.`);if(t.rank<1)throw new Error(`tf.scatterND() expects the updates to be rank 1 or higher, but the rank was ${t.rank}.`);if("int32"!==n.dtype)throw new Error(`The dtype of 'indices' should be int32, but got dtype: ${n.dtype}`);if(e.length<1)throw new Error(`Output rank must be greater or equal to 1, but got shape: ${e}`);if(0===e.length){if(0===n.size)throw new Error(`Indices specified for empty output. indices shape: ${n.shape}`);if(0===t.size)throw new Error(`Updates specified for empty output. updates shape: ${t.shape}`)}p2(e,n,t)}function Th(t,n,e){const r=n.shape.length,s=r>1?n.shape[r-1]:1,o=e.length;let i=1;for(let d=s;d<o;++d)i*=e[d];const a=s<1?1:s;return{sliceRank:s,numUpdates:te(n.shape)/a,sliceSize:i,strides:[...Le(e.slice(0,s)),1],outputSize:te(e)}}const zg=1.7580993408473768,Vg=1.0507009873554805,pI=.3275911,mI=.254829592,gI=-.284496736,yI=1.421413741,bI=-1.453152027,vI=1.061405429;function Iu(...t){ne().getBool("IS_TEST")||console.warn(...t)}function GY(...t){ne().getBool("IS_TEST")||console.log(...t)}function di(t,n){if(t.length!==n.length)throw new Error(`Cannot merge real and imag arrays of different lengths. real:${t.length}, imag: ${n.length}.`);const e=new Float32Array(2*t.length);for(let r=0;r<e.length;r+=2)e[r]=t[r/2],e[r+1]=n[r/2];return e}function g2(t){const n=new Float32Array(t.length/2),e=new Float32Array(t.length/2);for(let r=0;r<t.length;r+=2)n[r/2]=t[r],e[r/2]=t[r+1];return{real:n,imag:e}}function y2(t){const n=Math.ceil(t.length/4),e=new Float32Array(n),r=new Float32Array(n);for(let s=0;s<t.length;s+=4)e[Math.floor(s/4)]=t[s],r[Math.floor(s/4)]=t[s+1];return{real:e,imag:r}}function b2(t){const n=Math.floor(t.length/4),e=new Float32Array(n),r=new Float32Array(n);for(let s=2;s<t.length;s+=4)e[Math.floor(s/4)]=t[s],r[Math.floor(s/4)]=t[s+1];return{real:e,imag:r}}function xI(t,n){return{real:t[2*n],imag:t[2*n+1]}}function v2(t,n,e,r){t[2*r]=n,t[2*r+1]=e}function x2(t,n){const e=new Float32Array(t/2),r=new Float32Array(t/2);for(let s=0;s<Math.ceil(t/2);s++){const o=(n?2:-2)*Math.PI*(s/t);e[s]=Math.cos(o),r[s]=Math.sin(o)}return{real:e,imag:r}}function w2(t,n,e){const r=(e?2:-2)*Math.PI*(t/n);return{real:Math.cos(r),imag:Math.sin(r)}}function wI(t,n,e=0){let r=[];if("number"==typeof n)S(t.shape[e]%n==0,()=>"Number of splits must evenly divide the axis."),r=new Array(n).fill(t.shape[e]/n);else{S(n.reduce((i,a)=>(-1===a&&(i+=1),i),0)<=1,()=>"There should be only one negative value in split array.");const o=n.indexOf(-1);if(-1!==o){const i=n.reduce((a,l)=>l>0?a+l:a);n[o]=t.shape[e]-i}S(t.shape[e]===n.reduce((i,a)=>i+a),()=>"The sum of sizes must match the size of the axis dimension."),r=n}return r}function C2(t,n){let r,e=!1;for(t<=uI?(r=t,e=!0):r=X0(t,Math.floor(Math.sqrt(t)));!e;)r>n||r===t?e=!0:r=X0(t,r+1);return r}function I2(t,n,e){const r=[],s=t.length;for(let o=0;o<s;o++)r.push(o!==n?t[o]:e);return r}function CI(t,n,e,r){const s=n.shape.length,o=t.shape.length;if(0!==r&&(r<-s||r>s))throw new Error(`Expect batchDims in the range of [-${s}, ${s}], but got ${r}`);if(r<0&&(r+=s),r>o)throw new Error(`batchDims (${r}) must be less than rank(x) (\n    ${o}).`);if(e<r)throw new Error(`batchDims (${r}) must be less than or equal to axis (${e}).`);for(let d=0;d<r;++d)if(t.shape[d]!==n.shape[d])throw new Error(`x.shape[${d}]: ${t.shape[d]} should be equal to indices.shape[${d}]: ${n.shape[d]}.`);const i=t.shape[e],a=[];let l=1,u=1,c=1;for(let d=0;d<r;++d)a.push(t.shape[d]),l*=t.shape[d];for(let d=r;d<e;d++)a.push(t.shape[d]),u*=t.shape[d];for(let d=r;d<s;d++)a.push(n.shape[d]);for(let d=e+1;d<o;d++)a.push(t.shape[d]),c*=t.shape[d];return{batchSize:l,sliceSize:c,outerSize:u,dimSize:i,outputShape:a}}function II(t){try{return t.map(n=>iu(n))}catch(n){throw new Error(`Failed to decode encoded string bytes into utf-8, error: ${n}`)}}function D2(t){return t.map(n=>ah(n))}function DI(t,n){const e=[];for(let o=0;o<n.length;o++)n[o]&&e.push(o);const r=yt(t,"int32"),s=yt([e.length,t.length],"int32");for(let o=0;o<e.length;o++){const i=r.indexToLoc(e[o]);s.values.set(i,o*t.length)}return s.toTensor()}const _2={kernelName:nm,inputsToSave:["x"],gradFunc:(t,n)=>{const[e]=n;return{x:()=>V(t,_h(Ae(e,"float32"),-1))}}},jY={kernelName:dd,inputsToSave:["x"],gradFunc:(t,n)=>{const[e]=n;return{x:()=>{const r=zt(Ae(e,"float32")),s=yr($e(Fe(1),r));return mn(Me(t,s))}}}},qY={kernelName:hd,inputsToSave:["x"],gradFunc:(t,n)=>{const[e]=n;return{x:()=>{const r=yr($e(zt(Ae(e,"float32")),1));return Me(t,r)}}}},KY={kernelName:su,inputsToSave:["a","b"],gradFunc:(t,n)=>{const[e,r]=n,s=bt(e.shape,r.shape);return{a:()=>{let a=t;const l=Ln(e.shape,s);return l.length>0&&(a=Oe(a,l)),H(a,e.shape)},b:()=>{let a=t;const l=Ln(r.shape,s);return l.length>0&&(a=Oe(a,l)),H(a,r.shape)}}}},XY={kernelName:rm,saveAllInputs:!0,gradFunc:(t,n)=>{const e={};return n.forEach((r,s)=>{e[s]=()=>t.clone()}),e}},YY={kernelName:sm,inputsToSave:["x"],gradFunc:(t,n)=>{const[e]=n;return{x:()=>Ct(e)}}},ZY={kernelName:om,inputsToSave:["x"],gradFunc:(t,n)=>{const[e]=n;return{x:()=>Ct(e)}}},QY={kernelName:fd,inputsToSave:["x"],gradFunc:(t,n)=>{const[e]=n;return{x:()=>Me(t,yr($e(Fe(1),zt(Ae(e,"float32")))))}}},JY={kernelName:pd,inputsToSave:["x"],gradFunc:(t,n)=>{const[e]=n;return{x:()=>{const r=yr(me(Fe(1),zt(Ae(e,"float32"))));return Me(t,r)}}}},eZ={kernelName:yd,inputsToSave:["a","b"],gradFunc:(t,n)=>{const[e,r]=n,s=bt(e.shape,r.shape);return{a:()=>{const a=me(zt(e),zt(r));let l=V(t,Me(r,a));const u=Ln(e.shape,s);return u.length>0&&(l=Oe(l,u)),H(l,e.shape)},b:()=>{const a=me(zt(e),zt(r));let l=mn(V(t,Me(e,a)));const u=Ln(r.shape,s);return u.length>0&&(l=Oe(l,u)),H(l,r.shape)}}}},tZ={kernelName:md,inputsToSave:["x"],gradFunc:(t,n)=>{const[e]=n;return{x:()=>Me(t,me(zt(Ae(e,"float32")),1))}}},nZ={kernelName:gd,inputsToSave:["x"],gradFunc:(t,n)=>{const[e]=n;return{x:()=>Me(t,$e(Fe(1),zt(Ae(e,"float32"))))}}},sZ=M({avgPool3dGrad_:function rZ(t,n,e,r,s,o){const i=T(t,"dy","avgPool3dGrad"),a=T(n,"input","avgPool3dGrad");let l=i,u=a,c=!1;4===a.rank&&(c=!0,l=H(i,[1,i.shape[0],i.shape[1],i.shape[2],i.shape[3]]),u=H(a,[1,a.shape[0],a.shape[1],a.shape[2],a.shape[3]])),S(5===l.rank,()=>`Error in avgPool3dGrad: dy must be rank 5 but got rank ${l.rank}.`),S(5===u.rank,()=>`Error in avgPool3dGrad: input must be rank 5 but got rank ${u.rank}.`),null!=o&&S(Kn(s),()=>`Error in avgPool3dGrad: pad must be an integer when using, dimRoundingMode ${o} but got pad ${s}.`);const f=F.runKernel(tw,{dy:l,input:u},{filterSize:e,strides:r,pad:s,dimRoundingMode:o});return c?H(f,[f.shape[1],f.shape[2],f.shape[3],f.shape[4]]):f}}),oZ={kernelName:am,inputsToSave:["x"],gradFunc:(t,n,e)=>{const[r]=n,{filterSize:s,strides:o,pad:i,dimRoundingMode:a}=e;return{x:()=>sZ(t,r,s,o,i,a)}}},aZ=M({avgPoolGrad_:function iZ(t,n,e,r,s){const o=T(t,"dy","avgPoolGrad"),i=T(n,"input","avgPoolGrad");S(i.rank===o.rank,()=>`Rank of input (${i.rank}) does not match rank of dy (${o.rank})`);let a=i,l=o,u=!1;3===i.rank&&(u=!0,a=H(i,[1,i.shape[0],i.shape[1],i.shape[2]]),l=H(o,[1,o.shape[0],o.shape[1],o.shape[2]])),S(4===l.rank,()=>`Error in avgPoolGrad: dy must be rank 4 but got rank ${l.rank}.`),S(4===a.rank,()=>`Error in avgPoolGrad: input must be rank 4 but got rank ${a.rank}.`);const h=F.runKernel(ew,{dy:l,input:a},{filterSize:e,strides:r,pad:s});return u?H(h,[h.shape[1],h.shape[2],h.shape[3]]):h}}),lZ={kernelName:im,inputsToSave:["x"],gradFunc:(t,n,e)=>{const[r]=n,{filterSize:s,strides:o,pad:i}=e;return{x:()=>aZ(t,r,s,o,i)}}},uZ={kernelName:lm,inputsToSave:["a","b"],gradFunc:(t,n,e)=>{const[r,s]=n,{transposeA:o,transposeB:i}=e;return o||i?!o&&i?{a:()=>Nt(t,s,!1,!1),b:()=>Nt(t,r,!0,!1)}:o&&!i?{a:()=>Nt(s,t,!1,!0),b:()=>Nt(r,t,!1,!1)}:{a:()=>Nt(s,t,!0,!0),b:()=>Nt(t,r,!0,!0)}:{a:()=>Nt(t,s,!1,!0),b:()=>Nt(r,t,!0,!1)}}},Ug=M({spaceToBatchND_:function cZ(t,n,e){const r=T(t,"x","spaceToBatchND");return S(r.rank>=1+n.length,()=>`input rank ${r.rank} should be > than [blockShape] ${n.length}`),S(e.length===n.length,()=>`paddings.shape[0] ${e.length} must be equal to [blockShape] ${n.length}`),S(r.shape.reduce((i,a,l)=>l>0&&l<=n.length?i&&(a+e[l-1][0]+e[l-1][1])%n[l-1]==0:i,!0),()=>`input spatial dimensions ${r.shape.slice(1)} with paddings ${e.toString()} must be divisible by blockShapes ${n.toString()}`),F.runKernel(Ym,{x:r},{blockShape:n,paddings:e})}}),dZ={kernelName:um,gradFunc:(t,n,e)=>{const{blockShape:r,crops:s}=e;return{x:()=>Ug(t,r,s)}}},hZ={kernelName:"BroadcastTo",gradFunc:(t,n,e)=>{const s=e.inputShape,o=e.shape,i=Array.from(o);for(let l=s.length-1;l>=0;l--)if(s[l]===o[l])i[l]=1;else if(1!==s[l])throw new Error(`broadcastTo(): [${s}] cannot be broadcast to [${o}].`);const a=[];for(let l=0;l<i.length;l++)i[l]>1&&a.push(l);return{x:()=>Oe(t,a,!0)}}},fZ={kernelName:bd,gradFunc:t=>({x:()=>t.clone()})},pZ={kernelName:vd,gradFunc:t=>({x:()=>Ct(t)})},mZ={kernelName:xd,inputsToSave:["x"],gradFunc:(t,n,e)=>{const[r]=n,{clipValueMin:s,clipValueMax:o}=e;return{x:()=>ms(No(Va(r,s),wu(r,o)),t,Ct(t))}}},gZ={kernelName:cm,inputsToSave:["x"],gradFunc:_2.gradFunc},yZ={kernelName:dm,saveAllInputs:!0,gradFunc:(t,n,e)=>{const r=n.map(l=>l.shape),{axis:s}=e,o=ft(s,n[0].shape)[0],i=r.map(l=>l[o]);return ps(t,i,o).map(l=>()=>l)}},bZ={kernelName:hm,inputsToSave:["x","filter"],gradFunc:(t,n,e)=>{const[r,s]=n,{dilations:o,strides:i,pad:a,dataFormat:l}=e;return S(zi(o),()=>`Error in gradient of conv2D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '${o}'`),{x:()=>_C(r.shape,t,s,i,a,l),filter:()=>VC(r,t,s.shape,i,a,l)}}},vZ={kernelName:fm,inputsToSave:["dy","filter"],gradFunc:(t,n,e)=>{const[r,s]=n,{strides:o,pad:i,dataFormat:a,dimRoundingMode:l}=e;return{dy:()=>Vi(t,s,o,i,a,1,l),filter:()=>VC(t,r,s.shape,o,i,a,l)}}},wZ=M({conv3DBackpropFilter_:function xZ(t,n,e,r,s){let o=t;4===t.rank&&(o=H(t,[1,t.shape[0],t.shape[1],t.shape[2],t.shape[3]]));let i=n;return 4===i.rank&&(i=H(n,[1,n.shape[0],n.shape[1],n.shape[2],n.shape[3]])),S(5===o.rank,()=>`Error in conv3dDerFilter: input must be rank 5, but got shape ${o.shape}.`),S(5===i.rank,()=>`Error in conv3dDerFilter: dy must be rank 5, but got shape ${i.shape}.`),S(5===e.length,()=>`Error in conv3dDerFilter: filterShape must be length 5, but got ${e}.`),S(o.shape[4]===e[3],()=>`Error in conv3dDerFilter: depth of input ${o.shape[4]}) must match input depth in filter (${e[3]}.`),S(i.shape[4]===e[4],()=>`Error in conv3dDerFilter: depth of dy (${i.shape[4]}) must match output depth for filter (${e[4]}).`),F.runKernel(ow,{x:o,dy:i},{strides:r,pad:s,filterShape:e})}}),IZ=M({conv3DBackpropInput_:function CZ(t,n,e,r,s){S(t.length===n.rank,()=>`Length of inShape (${t.length}) and rank of dy (${n.rank}) must match`);let o=t,i=n,a=!1;4===n.rank&&(a=!0,i=H(n,[1,n.shape[0],n.shape[1],n.shape[2],n.shape[3]]),o=[1,t[0],t[1],t[2],t[3]]);const l=o[4],u=i.shape[4];S(5===o.length,()=>`Error in conv3dDerInput: inShape must be length 5, but got length ${o.length}.`),S(5===i.rank,()=>`Error in conv3dDerInput: dy must be rank 5, but got rank ${i.rank}`),S(5===e.rank,()=>`Error in conv3dDerInput: filter must be rank 5, but got rank ${e.rank}`),S(l===e.shape[3],()=>`Error in conv3dDerInput: depth of input (${l}) must match input depth for filter ${e.shape[3]}.`),S(u===e.shape[4],()=>`Error in conv3dDerInput: depth of output (${u}) must match output depth for filter ${e.shape[4]}.`);const h=F.runKernel(iw,{dy:i,filter:e},{pad:s,strides:r,inputShape:o});return a?H(h,[h.shape[1],h.shape[2],h.shape[3],h.shape[4]]):h}}),DZ={kernelName:pm,inputsToSave:["x","filter"],gradFunc:(t,n,e)=>{const{dilations:r,strides:s,pad:o}=e;S(zi(r),()=>`Error in gradient of conv3D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '${r}'`);const[i,a]=n;return{x:()=>IZ(i.shape,t,a,s,o),filter:()=>wZ(i,t,a.shape,s,o)}}},_I=M({sin_:function _Z(t){const e={x:T(t,"x","sin")};return F.runKernel(Kd,e)}}),SZ={kernelName:wd,inputsToSave:["x"],gradFunc:(t,n)=>{const[e]=n;return{x:()=>V(mn(_I(Ae(e,"float32"))),t)}}},SI=M({sinh_:function EZ(t){const e={x:T(t,"x","sinh")};return F.runKernel(Xd,e)}}),NZ={kernelName:Cd,inputsToSave:["x"],gradFunc:(t,n)=>{const[e]=n;return{x:()=>V(SI(Ae(e,"float32")),t)}}},EI=M({cumsum_:function TZ(t,n=0,e=!1,r=!1){const o={x:T(t,"x","cumsum")};return F.runKernel(mm,o,{axis:n,exclusive:e,reverse:r})}}),kZ={kernelName:mm,inputsToSave:["x"],gradFunc:(t,n,e)=>{const[r]=n,{axis:s,exclusive:o,reverse:i}=e;return{x:()=>{const a=xn([s],r.rank);let l=EI(t,s,o,!i);return null!=a&&(l=Bt(l,a)),l}}}},AZ={kernelName:gm,inputsToSave:["x","filter"],gradFunc:(t,n,e)=>{const{dilations:r,strides:s,pad:o,dimRoundingMode:i}=e,a=r??[1,1];S(zi(a),()=>`Error in gradient of depthwiseConv2dNative: dilation rates greater than 1 are not yet supported. Got dilations '${a}'`);const[l,u]=n;return S(4===l.rank,()=>`Error in gradient of depthwiseConv2dNative: input must be rank 4, but got rank ${l.rank}.`),S(4===u.rank,()=>`Error in gradient of depthwiseConv2dNative: filter must be rank 4, but got rank ${u.rank}.`),S(l.shape[3]===u.shape[2],()=>`Error in gradient of depthwiseConv2d: number of input channels (${l.shape[3]}) must match the inChannels dimension in filter ${u.shape[2]}.`),S(ar(s,a),()=>`Error in gradient of depthwiseConv2d: Either strides or dilations must be  1. Got strides ${s} and dilations '${a}'.`),null!=i&&S(Kn(o),()=>`Error in depthwiseConv2d: pad must be an integer when using, dimRoundingMode ${i} but got pad ${o}.`),{x:()=>s2(l.shape,t,u,s,o,r,i),filter:()=>r2(l,t,u.shape,s,o,r,i)}}},RZ={kernelName:ym,inputsToSave:["x","filter"],gradFunc:(t,n,e)=>{const[r,s]=n,o={x:r,filter:s,dy:t},i={x:r,filter:s,dy:t};return{x:()=>F.runKernel(hw,o,e),filter:()=>F.runKernel(fw,i,e)}}},$Z={kernelName:Dd,outputsToSave:[!0],gradFunc:(t,n)=>{const[e]=n,r={dy:t,y:e};return{x:()=>F.runKernel(pw,r)}}},FZ={kernelName:_d,inputsToSave:["x"],gradFunc:(t,n)=>{const[e]=n,r=V(Rs(mn(zt(e))),2/Math.sqrt(Math.PI));return{x:()=>V(t,r)}}},OZ={kernelName:Sd,outputsToSave:[!0],gradFunc:(t,n)=>{const[e]=n;return{x:()=>V(t,e)}}},MZ={kernelName:vm,inputsToSave:["input"],gradFunc:(t,n)=>{const[e]=n;return{input:()=>H(t,e.shape)}}},PZ={kernelName:Ed,inputsToSave:["x"],gradFunc:(t,n)=>{const[e]=n;return{x:()=>V(t,Rs(e))}}},LZ={kernelName:Nd,gradFunc:t=>({x:()=>Ct(t)})},BZ={kernelName:Td,inputsToSave:["a","b"],gradFunc:(t,n)=>{const[e,r]=n,s=bt(e.shape,r.shape);return{a:()=>{const a=Me(t,Ae(r,"float32")),l=Ln(e.shape,s);return l.length>0?H(Oe(a,l),e.shape):a},b:()=>{let a=V(t,Ae(e,"float32"));const l=Ln(r.shape,s);l.length>0&&(a=H(Oe(a,l),r.shape));const u=zt(r);return mn(Me(a,Ae(u,"float32")))}}}},NI=M({rsqrt_:function zZ(t){const e={x:T(t,"x","rsqrt")};return F.runKernel(jd,e)}}),VZ={kernelName:xm,inputsToSave:["x","mean","variance","scale"],gradFunc:(t,n,e)=>{const{varianceEpsilon:r}=e,[s,o,i,a]=n,l=a??Fe(1),u=Ln(o.shape,s.shape),c=[];if(1===o.rank){for(let x=0;x<s.shape.length-1;++x)c.push(s.shape[x]);c.push(1)}const d=$e(s,o),h=V(t,l),f=NI(me(i,Fe(r))),p=V(V(V(f,f),f),Fe(-.5));return{x:()=>H(V(V(t,1===o.rank?za(H(f,[1,1,1,o.shape[0]]),c):f),l),s.shape),mean:()=>{let x=V(V(f,Fe(-1)),h);return 1===o.rank&&(x=Oe(x,u)),H(x,o.shape)},variance:()=>{let x=V(V(p,d),h);return 1===o.rank&&(x=Oe(x,u)),H(x,o.shape)},scale:()=>{const x=V(d,f);let w=V(t,x);return 1===o.rank&&(w=Oe(w,u)),H(w,o.shape)},offset:()=>{let x=t;return 1===o.rank&&(x=Oe(x,u)),H(x,o.shape)}}}},S2=M({unsortedSegmentSum_:function UZ(t,n,e){const r=T(t,"x","unsortedSegmentSum"),s=T(n,"segmentIds","unsortedSegmentSum","int32");return S(Kn(e),()=>"numSegments must be of dtype int"),F.runKernel(tg,{x:r,segmentIds:s},{numSegments:e})}}),WZ={kernelName:wm,inputsToSave:["x","indices"],gradFunc:(t,n,e)=>{const[r,s]=n,{axis:o}=e,i=ft(o,r.shape)[0];return{x:()=>{const l=r.shape,u=s.size,c=l.slice(0,i),d=c.length,h=l.slice(o,l.length).slice(1),f=h.length,p=E2(0,d),m=E2(d+1,d+1+f),g=N2([c,[u],h]),y=H(t,g),b=H(s,[u]),v=N2([[d],p,m]),x=Bt(y,v);let w=S2(x,b,r.shape[i]);const _=gu(v);return w=Bt(w,_),w},indices:()=>s}}};function E2(t,n){const e=[];for(let r=t;r<n;++r)e.push(r);return e}function N2(t){const n=[];for(let e=0;e<t.length;++e)for(let r=0;r<t[e].length;++r)n.push(t[e][r]);return n}const HZ={kernelName:kd,inputsToSave:["a","b"],gradFunc:(t,n)=>{const[e,r]=n;return{a:()=>Ct(e),b:()=>Ct(r)}}},GZ={kernelName:Ad,gradFunc:t=>({x:()=>Ae(t,"float32")})},jZ={kernelName:Rd,gradFunc:t=>({x:()=>Ct(t)})},qZ={kernelName:$d,gradFunc:t=>({x:()=>Ct(t)})},KZ={kernelName:Fd,gradFunc:t=>({x:()=>Ct(t)})},XZ={kernelName:Im,inputsToSave:["x"],gradFunc:(t,n,e)=>{const[r]=n,{alpha:s}=e,o=Eo(r,0);return{x:()=>ms(o,t,V(t,s))}}},YZ={kernelName:Md,inputsToSave:["x"],gradFunc:(t,n)=>{const[e]=n;return{x:()=>Me(t,me(e,1))}}},ZZ={kernelName:Od,inputsToSave:["x"],gradFunc:(t,n)=>{const[e]=n;return{x:()=>Me(t,Ae(e,"float32"))}}},QZ={kernelName:"LogSoftmax",inputsToSave:[],outputsToSave:[!0],gradFunc:(t,n,e)=>{const[r]=n,{axis:s}=e;return{logits:()=>{const i=Rs(r);return $e(t,V(Oe(t,s,!0),i))}}}},eQ=M({localResponseNormalizationBackprop_:function JZ(t,n,e,r=5,s=1,o=1,i=.5){return F.runKernel(Cw,{x:t,y:n,dy:e},{depthRadius:r,bias:s,alpha:o,beta:i})}}),tQ={kernelName:Tm,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(t,n,e)=>{const[r,s]=n,{depthRadius:o,bias:i,alpha:a,beta:l}=e;return{x:()=>eQ(r,s,t,o,i,a,l)}}};function T2(t,n,e,r){return n.rank<e.rank&&(n=H(n,vn(n.shape,r))),t.rank<e.rank&&(t=H(t,vn(t.shape,r))),{x:()=>V(t,Ae(Ba(e,n),t.dtype))}}const k2={kernelName:km,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(t,n,e)=>{const r=e,{reductionIndices:s}=r,o=n[0],l=T2(t,n[1],o,ft(s,o.shape));return{x:()=>l.x()}}},TI=M({less_:function nQ(t,n){let e=T(t,"a","less"),r=T(n,"b","less");return[e,r]=fn(e,r),bt(e.shape,r.shape),F.runKernel(Dm,{a:e,b:r})}}),rQ={kernelName:Pd,inputsToSave:["a","b"],gradFunc:(t,n)=>{const[e,r]=n;return{a:()=>V(t,Ae(Va(e,r),"float32")),b:()=>V(t,Ae(TI(e,r),"float32"))}}},oQ=M({maxPool3dGrad_:function sQ(t,n,e,r,s,o,i){const a=T(t,"dy","maxPool3dGrad"),l=T(n,"input","maxPool3dGrad"),u=T(e,"output","maxPool3dGrad");let c=a,d=l,h=u,f=!1;4===l.rank&&(f=!0,c=H(a,[1,a.shape[0],a.shape[1],a.shape[2],a.shape[3]]),d=H(l,[1,l.shape[0],l.shape[1],l.shape[2],l.shape[3]]),h=H(u,[1,u.shape[0],u.shape[1],u.shape[2],u.shape[3]])),S(5===c.rank,()=>`Error in maxPool3dGrad: dy must be rank 5 but got rank ${c.rank}.`),S(5===d.rank,()=>`Error in maxPool3dGrad: input must be rank 5 but got rank ${d.rank}.`),S(5===h.rank,()=>`Error in maxPool3dGrad: output must be rank 5 but got rank ${h.rank}.`),null!=i&&S(Kn(o),()=>`Error in maxPool3dGrad: pad must be an integer when using, dimRoundingMode ${i} but got pad ${o}.`);const g=F.runKernel(Dw,{dy:c,input:d,output:h},{filterSize:r,strides:s,pad:o,dimRoundingMode:i});return f?H(g,[g.shape[1],g.shape[2],g.shape[3],g.shape[4]]):g}}),iQ={kernelName:Rm,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(t,n,e)=>{const[r,s]=n,{filterSize:o,strides:i,pad:a,dimRoundingMode:l}=e;return{x:()=>oQ(t,r,s,o,i,a,l)}}},lQ=M({maxPoolGrad_:function aQ(t,n,e,r,s,o,i){const a=T(t,"dy","maxPoolGrad"),l=T(n,"input","maxPoolGrad"),u=T(e,"output","maxPoolGrad");return S(l.rank===a.rank,()=>`Rank of input (${l.rank}) does not match rank of dy (${a.rank})`),S(4===a.rank,()=>`Error in maxPoolGrad: dy must be rank 4 but got rank ${a.rank}.`),S(4===l.rank,()=>`Error in maxPoolGrad: input must be rank 4 but got rank ${l.rank}.`),null!=i&&S(Kn(o),()=>`Error in maxPoolGrad: pad must be an integer when using, dimRoundingMode ${i} but got pad ${o}.`),F.runKernel(Iw,{dy:a,input:l,output:u},{filterSize:r,strides:s,pad:o,dimRoundingMode:i})}}),uQ={kernelName:Am,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(t,n,e)=>{const[r,s]=n,{filterSize:o,strides:i,pad:a}=e;return{x:()=>lQ(t,r,s,o,i,a)}}},cQ={kernelName:$m,inputsToSave:["x"],gradFunc:(t,n,e)=>{const[r]=n,{axis:s}=e,o=ft(s,r.shape),l=te(Qn(r.shape,o)[1]);return{x:()=>{const c=r.shape.slice();o.forEach(f=>{c[f]=1});const d=H(t,c);return Me(V(d,ii(r.shape,"float32")),l)}}}},dQ={kernelName:Fm,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(t,n,e)=>{const r=e,{axis:s}=r,[o,i]=n,l=T2(t,i,o,ft(s,o.shape));return{x:()=>l.x()}}},hQ={kernelName:Ld,inputsToSave:["a","b"],gradFunc:(t,n)=>{const[e,r]=n;return{a:()=>V(t,Ae(wu(e,r),"float32")),b:()=>V(t,Ae(Eo(e,r),"float32"))}}},fQ={kernelName:Om,inputsToSave:["x"],gradFunc:(t,n,e)=>{const r=n[0],{paddings:s}=e,o=s.map(i=>i[0]);return{x:()=>At(t,o,r.shape)}}},pQ={kernelName:Bd,inputsToSave:["a","b"],gradFunc:(t,n)=>{const[e,r]=n,s=bt(e.shape,r.shape);return{a:()=>{const a=Ln(e.shape,s);return a.length>0?H(Oe(t,a),e.shape):t},b:()=>{const a=V(t,mn(yh(Me(e,r)))),l=Ln(r.shape,s);return l.length>0?H(Oe(a,l),r.shape):a}}}},mQ={kernelName:zd,inputsToSave:["a","b"],gradFunc:(t,n)=>{const[e,r]=n,s=bt(e.shape,r.shape);return{a:()=>{const a=V(t,Ae(r,"float32")),l=Ln(e.shape,s);return l.length>0?H(Oe(a,l),e.shape):a},b:()=>{const a=V(t,Ae(e,"float32")),l=Ln(r.shape,s);return l.length>0?H(Oe(a,l),r.shape):a}}}},gQ={kernelName:Mm,gradFunc:t=>({x:()=>mn(t)})},yQ={kernelName:Bm,inputsToSave:["indices"],gradFunc:(t,n)=>{const e=n[0];return{indices:()=>Nn(e.shape,"float32")}}},bQ={kernelName:Lm,gradFunc:t=>({x:()=>Ct(t)})},vQ={kernelName:zm,saveAllInputs:!0,gradFunc:(t,n,e)=>{const{axis:r}=e;return oo(t,r).map(o=>()=>o)}},A2={kernelName:Vm,inputsToSave:["x"],gradFunc:(t,n,e)=>{const r=n[0],{paddings:s}=e,o=s.map(i=>i[0]);return{x:()=>At(t,o,r.shape)}}},xQ={kernelName:Vd,inputsToSave:["a","b"],outputsToSave:[!0],gradFunc:(t,n)=>{const[e,r,s]=n,o=e,i=r,a=bt(o.shape,i.shape);return{a:()=>{const c=Ae(i,"float32");let d=V(t,V(c,Ua(o,$e(c,Fe(1)))));const h=Ln(o.shape,a);return h.length>0&&(d=Oe(d,h)),H(d,o.shape)},b:()=>{const c=Eo(o,0),d=ms(c,hs(o),Ct(o));let h=V(t,V(s,d));const f=Ln(i.shape,a);return f.length>0&&(h=Oe(h,f)),H(h,i.shape)}}}},wQ={kernelName:Um,inputsToSave:["x","alpha"],gradFunc:(t,n)=>{const[e,r]=n,s=Eo(e,0);return{x:()=>ms(s,t,V(t,r)),alpha:()=>{let o=ms(s,Ct(t),V(t,e));const i=Ln(r.shape,t.shape);return i.length>0&&(o=Oe(o,i)),H(o,r.shape)}}}},CQ={kernelName:Id,inputsToSave:["a","b"],gradFunc:(t,n)=>{const[e,r]=n,s=bt(e.shape,r.shape);return{a:()=>{const a=Me(t,Ae(r,"float32")),l=Ln(e.shape,s);return l.length>0?H(Oe(a,l),e.shape):a},b:()=>{let a=V(t,Ae(e,"float32"));const l=Ln(r.shape,s);l.length>0&&(a=H(Oe(a,l),r.shape));const u=zt(r);return mn(Me(a,Ae(u,"float32")))}}}},IQ={kernelName:Ud,inputsToSave:["x"],gradFunc:(t,n)=>{const[e]=n;return{x:()=>Me(t,mn(zt(e)))}}},DQ={kernelName:Hd,inputsToSave:["x"],gradFunc:(t,n)=>{const[e]=n,r=V(wu(e,6),_h(e));return{x:()=>V(t,Ae(r,"float32"))}}},_Q={kernelName:Wd,inputsToSave:["x"],gradFunc:(t,n)=>{const[e]=n;return{x:()=>V(t,Ae(_h(e),"float32"))}}},SQ={kernelName:Wm,inputsToSave:["x"],gradFunc:(t,n)=>{const[e]=n;return{x:()=>H(t,e.shape)}}},EQ={kernelName:Gm,inputsToSave:["images"],gradFunc:(t,n,e)=>{const[r]=n,s={dy:t,images:r};return{images:()=>F.runKernel(Fw,s,e)}}},NQ={kernelName:Hm,inputsToSave:["images"],gradFunc:(t,n,e)=>{const[r]=n,s={dy:t,images:r};return{images:()=>F.runKernel($w,s,e)}}},TQ={kernelName:jm,gradFunc:(t,n,e)=>{const{dims:r}=e,s=ft(r,t.shape);return{x:()=>li(t,s)}}},kQ={kernelName:Gd,gradFunc:t=>({x:()=>Ct(t)})},AQ={kernelName:jd,inputsToSave:["x"],gradFunc:(t,n)=>{const[e]=n;return{x:()=>mn(Me(t,V(Ua(e,1.5),2)))}}},Wg=M({logicalNot_:function RQ(t){const e={x:T(t,"x","logicalNot","bool")};return F.runKernel(Em,e)}}),$Q={kernelName:qm,inputsToSave:["condition"],gradFunc:(t,n)=>{const[e]=n;return{condition:()=>Ae(Ct(e),"float32"),t:()=>V(t,Ae(e,t.dtype)),e:()=>V(t,Ae(Wg(e),t.dtype))}}},FQ={kernelName:qd,inputsToSave:["x"],gradFunc:(t,n)=>{const[e]=n;return{x:()=>{const r=Eo(e,Fe(0)),s=Fe(zg),o=Fe(Vg),i=V(t,o),a=V(V(t,s),Rs(Ae(e,"float32")));return ms(r,i,a)}}}},OQ={kernelName:Zd,outputsToSave:[!0],gradFunc:(t,n)=>{const[e]=n;return{x:()=>V(t,V(e,$e(Fe(1),e)))}}},MQ={kernelName:Yd,gradFunc:t=>({x:()=>Ct(t)})},Hg=M({cos_:function PQ(t){const e={x:T(t,"x","cos")};return F.runKernel(wd,e)}}),LQ={kernelName:Kd,inputsToSave:["x"],gradFunc:(t,n)=>{const[e]=n;return{x:()=>V(Hg(Ae(e,"float32")),t)}}},kI=M({cosh_:function BQ(t){const e={x:T(t,"x","cosh")};return F.runKernel(Cd,e)}}),zQ={kernelName:Xd,inputsToSave:["x"],gradFunc:(t,n)=>{const[e]=n;return{x:()=>V(kI(Ae(e,"float32")),t)}}},VQ={kernelName:Km,inputsToSave:["x"],gradFunc:(t,n,e)=>{const[r]=n,{begin:s,size:o}=e,i=r.shape,[a,l]=yg(r,s,o),u=[];for(let c=0;c<t.rank;c++)u.push([a[c],i[c]-a[c]-l[c]]);return{x:()=>Sg(t,u)}}},UQ={kernelName:Qm,outputsToSave:[!0],gradFunc:(t,n,e)=>{const[r]=n,{dim:s}=e,i=V(t,r);return{logits:()=>$e(i,V(Oe(i,[s],!0),r))}}},WQ={kernelName:Qd,inputsToSave:["x"],gradFunc:(t,n)=>{const[e]=n;return{x:()=>V(t,bu(e))}}},Gg=M({batchToSpaceND_:function HQ(t,n,e){const r=T(t,"x","batchToSpaceND"),s=n.reduce((a,l)=>a*l);return S(r.rank>=1+n.length,()=>`input rank is ${r.rank} but should be > than blockShape.length ${n.length}`),S(e.length===n.length,()=>`crops.length is ${e.length} but should be equal to blockShape.length  ${n.length}`),S(r.shape[0]%s==0,()=>`input tensor batch is ${r.shape[0]} but is not divisible by the product of the elements of blockShape ${n.join(" * ")} === ${s}`),F.runKernel(um,{x:r},{blockShape:n,crops:e})}}),R2={kernelName:Ym,gradFunc:(t,n,e)=>{const{blockShape:r,paddings:s}=e;return{x:()=>Gg(t,r,s)}}},$2={kernelName:Zm,gradFunc:(t,n,e)=>{const{axis:r}=e;return{x:()=>Sn(t,r)}}},oJ=[_2,jY,qY,KY,XY,YY,ZY,QY,JY,eZ,tZ,nZ,oZ,lZ,uZ,dZ,hZ,fZ,pZ,mZ,gZ,yZ,vZ,bZ,DZ,SZ,NZ,kZ,AZ,RZ,CQ,$Z,FZ,OZ,MZ,PZ,BZ,LZ,VZ,WZ,HZ,GZ,jZ,qZ,KZ,XZ,YZ,ZZ,QZ,tQ,k2,k2,rQ,iQ,uQ,cQ,dQ,hQ,fQ,pQ,mQ,gQ,yQ,bQ,vQ,A2,A2,xQ,wQ,IQ,DQ,_Q,SQ,EQ,NQ,TQ,kQ,AQ,$Q,FQ,OQ,MQ,LQ,zQ,VQ,UQ,WQ,R2,R2,$2,$2,{kernelName:Jd,inputsToSave:["x"],gradFunc:(t,n)=>{const[e]=n;return{x:()=>Me(t,V(yr(Ae(e,"float32")),2))}}},{kernelName:eh,inputsToSave:["a","b"],gradFunc:(t,n)=>{const[e,r]=n,s=Fe(2);return{a:()=>V(t,V(s,$e(e,r))),b:()=>V(t,V(s,$e(r,e)))}}},{kernelName:Mw,inputsToSave:["x"],gradFunc:(t,n)=>{const[e]=n;return{x:()=>V(t,V(Ae(e,"float32"),2))}}},{kernelName:oh,gradFunc:t=>({x:()=>Ct(t)})},{kernelName:th,inputsToSave:["a","b"],gradFunc:(t,n)=>{const[e,r]=n,s=bt(e.shape,r.shape);return{a:()=>{let a=t;const l=Ln(e.shape,s);return l.length>0&&(a=Oe(a,l)),H(a,e.shape)},b:()=>{let a=t;const l=Ln(r.shape,s);return l.length>0&&(a=Oe(a,l)),H(mn(a),r.shape)}}}},{kernelName:Xm,inputsToSave:["x"],gradFunc:(t,n,e)=>{const[r]=n,s=r.shape.slice(),{axis:o}=e;ft(o,r.shape).forEach(u=>{s[u]=1});const a=H(t,s),l=V(a,ii(r.shape,"float32"));return{x:()=>l}}},{kernelName:nh,inputsToSave:["x"],gradFunc:(t,n)=>{const[e]=n;return{x:()=>Me(t,zt(Hg(e)))}}},{kernelName:rh,outputsToSave:[!0],gradFunc:(t,n)=>{const[e]=n;return{x:()=>V($e(Fe(1),zt(e)),t)}}},{kernelName:sh,inputsToSave:["x"],gradFunc:(t,n,e)=>{const[r]=n,{reps:s}=e;return{x:()=>{let i=Ct(r);if(1===r.rank)for(let a=0;a<s[0];++a)i=me(i,At(t,[a*r.shape[0]],[r.shape[0]]));else if(2===r.rank)for(let a=0;a<s[0];++a)for(let l=0;l<s[1];++l)i=me(i,At(t,[a*r.shape[0],l*r.shape[1]],[r.shape[0],r.shape[1]]));else if(3===r.rank)for(let a=0;a<s[0];++a)for(let l=0;l<s[1];++l)for(let u=0;u<s[2];++u)i=me(i,At(t,[a*r.shape[0],l*r.shape[1],u*r.shape[2]],[r.shape[0],r.shape[1],r.shape[2]]));else{if(4!==r.rank)throw new Error(`Gradient for tile operation is not implemented for rank-${r.rank} tensors yet.`);for(let a=0;a<s[0];++a)for(let l=0;l<s[1];++l)for(let u=0;u<s[2];++u)for(let c=0;c<s[3];++c)i=me(i,At(t,[a*r.shape[0],l*r.shape[1],u*r.shape[2],c*r.shape[3]],[r.shape[0],r.shape[1],r.shape[2],r.shape[3]]))}return i}}}},{kernelName:Jm,gradFunc:(t,n,e)=>{const r=e,{perm:s}=r,o=gu(s);return{x:()=>Bt(t,o)}}},{kernelName:eg,gradFunc:(t,n,e)=>{const r=e,{axis:s}=r;return{value:()=>Fs(t,s)}}},{kernelName:tg,inputsToSave:["segmentIds"],gradFunc:(t,n)=>{const[e]=n;return{x:()=>function rJ(t,n){const e=oi(n,Ct(n)),r=bh(t,e);let s=Va(n,Fe(0,"int32"));const o=r.rank-s.rank;for(let a=0;a<o;++a)s=As(s,a+1);s=No(s,ii(r.shape,"bool"));const i=Ct(r);return ms(s,r,i)}(t,e)}}},{kernelName:ng,gradFunc:t=>({x:()=>Ct(t)})}];for(const t of oJ)aK(t);Z().prototype.abs=function(){return this.throwIfDisposed(),Yn(this)};const F2=M({acos_:function iJ(t){const e={x:T(t,"x","acos")};return F.runKernel(dd,e)}});Z().prototype.acos=function(){return this.throwIfDisposed(),F2(this)};const O2=M({acosh_:function aJ(t){const e={x:T(t,"x","acosh")};return F.runKernel(hd,e)}});Z().prototype.acosh=function(){return this.throwIfDisposed(),O2(this)},Z().prototype.add=function(t){return this.throwIfDisposed(),me(this,t)},Z().prototype.all=function(t,n){return this.throwIfDisposed(),wC(this,t,n)},Z().prototype.any=function(t,n){return this.throwIfDisposed(),vg(this,t,n)},Z().prototype.argMax=function(t){return this.throwIfDisposed(),xg(this,t)};const M2=M({argMin_:function lJ(t,n=0){const r={x:T(t,"x","argMin")};return F.runKernel(om,r,{axis:n})}});Z().prototype.argMin=function(t){return this.throwIfDisposed(),M2(this,t)},Z().prototype.asScalar=function(){return this.throwIfDisposed(),S(1===this.size,()=>"The array must have only 1 element."),H(this,[])},Z().prototype.asType=function(t){return this.throwIfDisposed(),Ae(this,t)},Z().prototype.as1D=function(){return this.throwIfDisposed(),H(this,[this.size])},Z().prototype.as2D=function(t,n){return this.throwIfDisposed(),H(this,[t,n])},Z().prototype.as3D=function(t,n,e){return this.throwIfDisposed(),H(this,[t,n,e])},Z().prototype.as4D=function(t,n,e,r){return this.throwIfDisposed(),H(this,[t,n,e,r])},Z().prototype.as5D=function(t,n,e,r,s){return this.throwIfDisposed(),H(this,[t,n,e,r,s])};const P2=M({asin_:function uJ(t){const e={x:T(t,"x","asin")};return F.runKernel(fd,e)}});Z().prototype.asin=function(){return this.throwIfDisposed(),P2(this)};const L2=M({asinh_:function cJ(t){const e={x:T(t,"x","asinh")};return F.runKernel(pd,e)}});Z().prototype.asinh=function(){return this.throwIfDisposed(),L2(this)};const B2=M({atan_:function dJ(t){const e={x:T(t,"x","atan")};return F.runKernel(md,e)}});Z().prototype.atan=function(){return this.throwIfDisposed(),B2(this)};const z2=M({atan2_:function hJ(t,n){let e=T(t,"a","atan2"),r=T(n,"b","atan2");return[e,r]=fn(e,r),F.runKernel(yd,{a:e,b:r})}});Z().prototype.atan2=function(t){return this.throwIfDisposed(),z2(this,t)};const V2=M({atanh_:function fJ(t){const e={x:T(t,"x","atanh")};return F.runKernel(gd,e)}});Z().prototype.atanh=function(){return this.throwIfDisposed(),V2(this)},Z().prototype.avgPool=function(t,n,e,r){return this.throwIfDisposed(),Cg(this,t,n,e,r)},Z().prototype.batchToSpaceND=function(t,n){return this.throwIfDisposed(),Gg(this,t,n)},Z().prototype.batchNorm=function(t,n,e,r,s){return this.throwIfDisposed(),mu(this,t,n,e,r,s)},Z().prototype.broadcastTo=function(t){return this.throwIfDisposed(),kg(this,t)},Z().prototype.cast=function(t){return this.throwIfDisposed(),Ae(this,t)};const U2=M({ceil_:function pJ(t){const e={x:T(t,"x","ceil")};return F.runKernel(vd,e)}});Z().prototype.ceil=function(){return this.throwIfDisposed(),U2(this)},Z().prototype.clipByValue=function(t,n){return this.throwIfDisposed(),Kr(this,t,n)},Z().prototype.concat=function(t,n){return this.throwIfDisposed(),t instanceof an&&(t=[t]),Sn([this,...t],n)},Z().prototype.conv1d=function(t,n,e,r,s,o){return this.throwIfDisposed(),DC(this,t,n,e,r,s,o)},Z().prototype.conv2dTranspose=function(t,n,e,r,s){return this.throwIfDisposed(),SC(this,t,n,e,r,s)},Z().prototype.conv2d=function(t,n,e,r,s,o){return this.throwIfDisposed(),Vi(this,t,n,e,r,s,o)},Z().prototype.cos=function(){return this.throwIfDisposed(),Hg(this)},Z().prototype.cosh=function(){return this.throwIfDisposed(),kI(this)},Z().prototype.cumsum=function(t,n,e){return this.throwIfDisposed(),EI(this,t,n,e)};const W2=M({depthToSpace_:function mJ(t,n,e="NHWC"){const r=T(t,"x","depthToSpace"),s="NHWC"===e?r.shape[1]:r.shape[2],o="NHWC"===e?r.shape[2]:r.shape[3],i="NHWC"===e?r.shape[3]:r.shape[1];return S(s*n>=0,()=>`Negative dimension size caused by overflow when multiplying\n    ${s} and ${n}  for depthToSpace with input shape\n    ${r.shape}`),S(o*n>=0,()=>`Negative dimension size caused by overflow when multiplying\n    ${o} and ${n} for depthToSpace with input shape\n        ${r.shape}`),S(i%(n*n)==0,()=>`Dimension size must be evenly divisible by ${n*n} but is ${i} for depthToSpace with input shape ${r.shape}`),F.runKernel(uw,{x:r},{blockSize:n,dataFormat:e})}});Z().prototype.depthToSpace=function(t,n){return this.throwIfDisposed(),W2(this,t,n)},Z().prototype.depthwiseConv2d=function(t,n,e,r,s,o){return this.throwIfDisposed(),ph(this,t,n,e,r,s,o)};const H2=M({dilation2d_:function gJ(t,n,e,r,s=[1,1],o="NHWC"){const i=T(t,"x","dilation2d"),a=T(n,"filter","dilation2d");S(3===i.rank||4===i.rank,()=>`Error in dilation2d: input must be rank 3 or 4, but got rank ${i.rank}.`),S(3===a.rank,()=>`Error in dilation2d: filter must be rank 3, but got rank ${a.rank}.`),S("NHWC"===o,()=>`Error in dilation2d: Only NHWC is currently supported, but got dataFormat of ${o}`);let l=i,u=!1;3===i.rank&&(l=H(i,[1,i.shape[0],i.shape[1],i.shape[2]]),u=!0);const h=F.runKernel(ym,{x:l,filter:a},{strides:e,pad:r,dilations:s});return u?H(h,[h.shape[1],h.shape[2],h.shape[3]]):h}});Z().prototype.dilation2d=function(t,n,e,r,s){return this.throwIfDisposed(),H2(this,t,n,e,r,s)};const G2=M({divNoNan_:function yJ(t,n){let e=T(t,"a","div"),r=T(n,"b","div");[e,r]=fn(e,r);const s=Me(e,r),o=Ct(s),i=Ba(r,o);return ms(i,o,s)}});Z().prototype.divNoNan=function(t){return this.throwIfDisposed(),G2(this,t)},Z().prototype.div=function(t){return this.throwIfDisposed(),Me(this,t)};const vJ=M({dot_:function bJ(t,n){const e=T(t,"t1","dot"),r=T(n,"t2","dot");S(!(1!==e.rank&&2!==e.rank||1!==r.rank&&2!==r.rank),()=>`Error in dot: inputs must all be rank 1 or 2, but got ranks ${e.rank} and ${r.rank}.`);const s=1===e.rank?e.size:e.shape[1],o=1===r.rank?r.size:r.shape[0];if(S(s===o,()=>`Error in dot: inner dimensions of inputs must match, but got ${s} and ${o}.`),1===e.rank&&1===r.rank){const i=H(e,[1,-1]),a=H(r,[-1,1]),l=Nt(i,a);return H(l,[])}if(1===e.rank&&2===r.rank){const i=H(e,[1,-1]),a=H(r,[r.shape[0],r.shape[1]]),l=Nt(i,a);return H(l,[l.size])}if(2===e.rank&&1===r.rank){const i=H(r,[-1,1]),a=Nt(e,i);return H(a,[a.size])}{const i=H(r,[r.shape[0],r.shape[1]]);return Nt(e,i)}}});Z().prototype.dot=function(t){return this.throwIfDisposed(),vJ(this,t)},Z().prototype.elu=function(){return this.throwIfDisposed(),mh(this)},Z().prototype.equal=function(t){return this.throwIfDisposed(),Ba(this,t)};const j2=M({erf_:function xJ(t){let n=T(t,"x","erf");return S("int32"===n.dtype||"float32"===n.dtype,()=>"Input dtype must be `int32` or `float32`."),"int32"===n.dtype&&(n=Ae(n,"float32")),F.runKernel(_d,{x:n})}});Z().prototype.erf=function(){return this.throwIfDisposed(),j2(this)},Z().prototype.exp=function(){return this.throwIfDisposed(),Rs(this)},Z().prototype.expandDims=function(t){return this.throwIfDisposed(),As(this,t)};const q2=M({expm1_:function wJ(t){const e={x:T(t,"x","expm1")};return F.runKernel(Ed,e)}});Z().prototype.expm1=function(){return this.throwIfDisposed(),q2(this)},Z().prototype.fft=function(){return this.throwIfDisposed(),Rg(this)},Z().prototype.flatten=function(){return this.throwIfDisposed(),H(this,[this.size])},Z().prototype.floor=function(){return this.throwIfDisposed(),yh(this)},Z().prototype.floorDiv=function(t){return this.throwIfDisposed(),EC(this,t)},Z().prototype.gather=function(t,n){return this.throwIfDisposed(),bh(this,t,n)},Z().prototype.greaterEqual=function(t){return this.throwIfDisposed(),Va(this,t)},Z().prototype.greater=function(t){return this.throwIfDisposed(),Eo(this,t)},Z().prototype.ifft=function(){return this.throwIfDisposed(),Dh(this)},Z().prototype.irfft=function(){return this.throwIfDisposed(),zC(this)};const IJ=M({isFinite_:function CJ(t){const e={x:T(t,"x","isFinite")};return F.runKernel(Rd,e)}});Z().prototype.isFinite=function(){return this.throwIfDisposed(),IJ(this)};const _J=M({isInf_:function DJ(t){const e={x:T(t,"x","isInf")};return F.runKernel($d,e)}});Z().prototype.isInf=function(){return this.throwIfDisposed(),_J(this)};const EJ=M({isNaN_:function SJ(t){const e={x:T(t,"x","isNaN")};return F.runKernel(Fd,e)}});Z().prototype.isNaN=function(){return this.throwIfDisposed(),EJ(this)},Z().prototype.leakyRelu=function(t){return this.throwIfDisposed(),Dg(this,t)},Z().prototype.lessEqual=function(t){return this.throwIfDisposed(),wu(this,t)},Z().prototype.less=function(t){return this.throwIfDisposed(),TI(this,t)};const K2=M({localResponseNormalization_:function NJ(t,n=5,e=1,r=1,s=.5){const o=T(t,"x","localResponseNormalization");S(4===o.rank||3===o.rank,()=>`Error in localResponseNormalization: x must be rank 3 or 4 but got\n               rank ${o.rank}.`),S(Kn(n),()=>`Error in localResponseNormalization: depthRadius must be an integer but got depthRadius ${n}.`);let i=o,a=!1;3===o.rank&&(a=!0,i=H(o,[1,o.shape[0],o.shape[1],o.shape[2]]));const c=F.runKernel(Tm,{x:i},{depthRadius:n,bias:e,alpha:r,beta:s});return a?H(c,[c.shape[1],c.shape[2],c.shape[3]]):c}});Z().prototype.localResponseNormalization=function(t,n,e,r){return this.throwIfDisposed(),K2(this,t,n,e,r)};const kJ=M({logSigmoid_:function TJ(t){const n=T(t,"x","logSigmoid");return ni(r=>({value:mn(Ch(mn(r))),gradFunc:i=>V(i,bu(mn(r)))}))(n)}});Z().prototype.logSigmoid=function(){return this.throwIfDisposed(),kJ(this)},Z().prototype.logSoftmax=function(t){return this.throwIfDisposed(),NC(this,t)},Z().prototype.logSumExp=function(t,n){return this.throwIfDisposed(),f2(this,t,n)},Z().prototype.log=function(){return this.throwIfDisposed(),hs(this)},Z().prototype.log1p=function(){return this.throwIfDisposed(),eI(this)},Z().prototype.logicalAnd=function(t){return this.throwIfDisposed(),No(this,t)},Z().prototype.logicalNot=function(){return this.throwIfDisposed(),Wg(this)};const AI=M({logicalOr_:function AJ(t,n){const e=T(t,"a","logicalOr","bool"),r=T(n,"b","logicalOr","bool");return bt(e.shape,r.shape),F.runKernel(Nm,{a:e,b:r})}});Z().prototype.logicalOr=function(t){return this.throwIfDisposed(),AI(this,t)};const $J=M({logicalXor_:function RJ(t,n){const e=T(t,"a","logicalXor","bool"),r=T(n,"b","logicalXor","bool");return bt(e.shape,r.shape),No(AI(t,n),Wg(No(t,n)))}});Z().prototype.logicalXor=function(t){return this.throwIfDisposed(),$J(this,t)},Z().prototype.matMul=function(t,n,e){return this.throwIfDisposed(),Nt(this,t,n,e)},Z().prototype.maxPool=function(t,n,e,r){return this.throwIfDisposed(),_g(this,t,n,e,r)},Z().prototype.max=function(t,n){return this.throwIfDisposed(),$s(this,t,n)},Z().prototype.maximum=function(t){return this.throwIfDisposed(),oi(this,t)},Z().prototype.mean=function(t,n){return this.throwIfDisposed(),pn(this,t,n)},Z().prototype.min=function(t,n){return this.throwIfDisposed(),vh(this,t,n)},Z().prototype.minimum=function(t){return this.throwIfDisposed(),xh(this,t)};const X2=M({mirrorPad_:function FJ(t,n,e){S("reflect"===e||"symmetric"===e,()=>`Invalid mode. Mode must be either reflect or symmetric. Got ${e}.`);const r=T(t,"x","mirrorPad");if(0===r.rank)throw new Error("mirrorPad(scalar) is not defined. Pass non-scalar to mirrorPad");S(n.length===r.rank,()=>`Padding doesn't match input. Must be ${r.rank}. Got ${n.length}.`);const s="reflect"===e?1:0;for(let a=0;a<r.rank;a++)S(2===n[a].length,()=>"Invalid number of paddings. Must be length of 2 each."),S(n[a][0]>=0&&n[a][0]<=r.shape[a]-s&&n[a][1]>=0&&n[a][1]<=r.shape[a]-s,()=>`Padding in dimension ${a} cannot be greater than or equal to ${r.shape[a]-s} or less than 0 for input of shape ${r.shape}`);return F.runKernel(Om,{x:r},{paddings:n,mode:e})}});Z().prototype.mirrorPad=function(t,n){return this.throwIfDisposed(),X2(this,t,n)};const Y2=M({mod_:function OJ(t,n){let e=T(t,"a","mod"),r=T(n,"b","mod");return[e,r]=fn(e,r),F.runKernel(Bd,{a:e,b:r})}});Z().prototype.mod=function(t){return this.throwIfDisposed(),Y2(this,t)},Z().prototype.mul=function(t){return this.throwIfDisposed(),V(this,t)},Z().prototype.neg=function(){return this.throwIfDisposed(),mn(this)},Z().prototype.norm=function(t,n,e){return this.throwIfDisposed(),QC(this,t,n,e)},Z().prototype.notEqual=function(t){return this.throwIfDisposed(),yu(this,t)},Z().prototype.oneHot=function(t,n=1,e=0){return this.throwIfDisposed(),AC(this,t,n,e)},Z().prototype.onesLike=function(){return this.throwIfDisposed(),fs(this)},Z().prototype.pad=function(t,n){return this.throwIfDisposed(),Sg(this,t,n)};const BJ=M({pool_:function MJ(t,n,e,r,s,o){null==s&&(s=[1,1]),null==o&&(o=1),0===r&&(r="valid");const i=T(t,"x","maxPool");let a=i,l=!1;3===i.rank&&(l=!0,a=H(i,[1,i.shape[0],i.shape[1],i.shape[2]])),S(ar(o,s),()=>`Error in pool: Either strides or dilations must be 1. Got strides ${o} and dilations '${s}'`);const u=ks(a.shape,n,o,s,r),c=[u.dilationHeight,u.dilationWidth];let d;d="same"===r?function LJ(t,n){const r=t.map((i,a)=>i+(i-1)*(n[a]-1)).map(i=>i-1),s=r.map(i=>Math.floor(i/2)),o=r.map((i,a)=>i-s[a]);return r.map((i,a)=>[s[a],o[a]])}([u.filterHeight,u.filterWidth],c):[[0,0],[0,0]];const h=1===c[0]&&1===c[1],[f,p]=function PJ(t,n,e){const r=e.map(c=>c[0]),s=e.map(c=>c[1]),o=t.concat(r,s),i=n.map((c,d)=>(c-o[d]%c)%c),a=s.map((c,d)=>c+i[d]),l=n.map((c,d)=>[r[d],a[d]]),u=n.map((c,d)=>[0,i[d]]);return[l,u]}([u.inHeight,u.inWidth],c,d),m=h?r:"valid",g=h?a:Ug(a,c,f),b=("avg"===e?()=>Cg(g,n,o,m):()=>_g(g,n,o,m))(),v=h?b:Gg(b,c,p);return l?H(v,[v.shape[1],v.shape[2],v.shape[3]]):v}});Z().prototype.pool=function(t,n,e,r,s){return this.throwIfDisposed(),BJ(this,t,n,e,r,s)},Z().prototype.pow=function(t){return this.throwIfDisposed(),Ua(this,t)},Z().prototype.prelu=function(t){return this.throwIfDisposed(),Eg(this,t)};const RI=M({prod_:function zJ(t,n=null,e=!1){let r=T(t,"x","prod");return"bool"===r.dtype&&(r=Ae(r,"int32")),F.runKernel(kw,{x:r},{axis:n,keepDims:e})}});Z().prototype.prod=function(t,n){return this.throwIfDisposed(),RI(this,t,n)};const Z2=M({reciprocal_:function VJ(t){const e={x:T(t,"x","reciprocal")};return F.runKernel(Ud,e)}});Z().prototype.reciprocal=function(){return this.throwIfDisposed(),Z2(this)},Z().prototype.relu=function(){return this.throwIfDisposed(),ai(this)},Z().prototype.relu6=function(){return this.throwIfDisposed(),UC(this)},Z().prototype.reshapeAs=function(t){return this.throwIfDisposed(),H(this,t.shape)},Z().prototype.reshape=function(t){return this.throwIfDisposed(),H(this,t)},Z().prototype.resizeBilinear=function(t,n,e){return this.throwIfDisposed(),u2(this,t,n,e)},Z().prototype.resizeNearestNeighbor=function(t,n,e){return this.throwIfDisposed(),c2(this,t,n,e)},Z().prototype.reverse=function(t){return this.throwIfDisposed(),li(this,t)},Z().prototype.rfft=function(){return this.throwIfDisposed(),$g(this)};const Q2=M({round_:function UJ(t){const e={x:T(t,"x","round")};return F.runKernel(Gd,e)}});Z().prototype.round=function(){return this.throwIfDisposed(),Q2(this)},Z().prototype.rsqrt=function(){return this.throwIfDisposed(),NI(this)},Z().prototype.selu=function(){return this.throwIfDisposed(),FC(this)},Z().prototype.separableConv2d=function(t,n,e,r,s,o){return this.throwIfDisposed(),e2(this,t,n,e,r,s,o)},Z().prototype.sigmoid=function(){return this.throwIfDisposed(),bu(this)};const J2=M({sign_:function WJ(t){const e={x:T(t,"x","sign")};return F.runKernel(Yd,e)}});Z().prototype.sign=function(){return this.throwIfDisposed(),J2(this)},Z().prototype.sin=function(){return this.throwIfDisposed(),_I(this)},Z().prototype.sinh=function(){return this.throwIfDisposed(),SI(this)},Z().prototype.slice=function(t,n){return this.throwIfDisposed(),At(this,t,n)},Z().prototype.softmax=function(t){return this.throwIfDisposed(),Tg(this,t)},Z().prototype.softplus=function(){return this.throwIfDisposed(),Ch(this)},Z().prototype.spaceToBatchND=function(t,n){return this.throwIfDisposed(),Ug(this,t,n)},Z().prototype.split=function(t,n){return this.throwIfDisposed(),ps(this,t,n)},Z().prototype.sqrt=function(){return this.throwIfDisposed(),yr(this)},Z().prototype.square=function(){return this.throwIfDisposed(),zt(this)},Z().prototype.squaredDifference=function(t){return this.throwIfDisposed(),JC(this,t)},Z().prototype.squeeze=function(t){return this.throwIfDisposed(),vu(this,t)},Z().prototype.stack=function(t,n){this.throwIfDisposed();const e=t instanceof an?[this,t]:[this,...t];return Fs(e,n)},Z().prototype.step=function(t){return this.throwIfDisposed(),_h(this,t)};const eF=M({stridedSlice_:function HJ(t,n,e,r,s=0,o=0,i=0,a=0,l=0){const c={x:T(t,"x","stridedSlice")};return F.runKernel(Lw,c,{begin:n,end:e,strides:r,beginMask:s,endMask:o,ellipsisMask:i,newAxisMask:a,shrinkAxisMask:l})}});Z().prototype.stridedSlice=function(t,n,e,r,s,o,i,a){return this.throwIfDisposed(),eF(this,t,n,e,r,s,o,i,a)},Z().prototype.sub=function(t){return this.throwIfDisposed(),$e(this,t)},Z().prototype.sum=function(t,n){return this.throwIfDisposed(),Oe(this,t,n)};const tF=M({tan_:function GJ(t){const e={x:T(t,"x","tan")};return F.runKernel(nh,e)}});Z().prototype.tan=function(){return this.throwIfDisposed(),tF(this)},Z().prototype.tanh=function(){return this.throwIfDisposed(),PC(this)},Z().prototype.tile=function(t){return this.throwIfDisposed(),za(this,t)},Z().prototype.toBool=function(){return this.throwIfDisposed(),Ae(this,"bool")},Z().prototype.toFloat=function(){return this.throwIfDisposed(),Ae(this,"float32")},Z().prototype.toInt=function(){return this.throwIfDisposed(),Ae(this,"int32")};const nF=M({topk_:function jJ(t,n=1,e=!0){const r=T(t,"x","topk");if(0===r.rank)throw new Error("topk() expects the input to be of rank 1 or higher");const s=r.shape[r.shape.length-1];if(n>s)throw new Error(`'k' passed to topk() must be <= the last dimension (${s}) but got ${n}`);const o={x:r},i={k:n,sorted:e},[a,l]=F.runKernel(Bw,o,i);return{values:a,indices:l}}});Z().prototype.topk=function(t,n){return this.throwIfDisposed(),nF(this,t,n)},Z().prototype.transpose=function(t){return this.throwIfDisposed(),Bt(this,t)};const $I=M({unique_:function qJ(t,n=0){const e=T(t,"x","unique","string_or_numeric");S(e.rank>0,()=>"The input tensor must be at least 1D");const r={x:e},s={axis:n},[o,i]=F.runKernel(Vw,r,s);return{values:o,indices:i}}});let jg;function Bn(){return null==jg&&(jg=function yX(){return F.backend}().epsilon()),jg}Z().prototype.unique=function(t){return this.throwIfDisposed(),$I(this,t)},Z().prototype.unsortedSegmentSum=function(t,n){return this.throwIfDisposed(),S2(this,t,n)},Z().prototype.unstack=function(t){return this.throwIfDisposed(),oo(this,t)},Z().prototype.where=function(t,n){return this.throwIfDisposed(),ms(t,this,n)},Z().prototype.zerosLike=function(){return this.throwIfDisposed(),Ct(this)};class To extends Error{constructor(n){super(n),Object.setPrototypeOf(this,To.prototype)}}class Ms extends Error{constructor(n){super(n),Object.setPrototypeOf(this,Ms.prototype)}}class L extends Error{constructor(n){super(n),Object.setPrototypeOf(this,L.prototype)}}class et extends Error{constructor(n){super(n),Object.setPrototypeOf(this,et.prototype)}}class FI extends Error{constructor(n){super(n),Object.setPrototypeOf(this,FI.prototype)}}class rF extends Error{constructor(n){super(n),Object.setPrototypeOf(this,rF.prototype)}}function Ga(t,n){if(Array.isArray(t)){let e=[];for(let r=0;r<n;r++)e=e.concat(t);return e}{const e=new Array(n);return e.fill(t),e}}function gs(t,n){if(!t)throw new FI(n)}function sF(t,n){let e=0;for(const r of t)r===n&&e++;return e}function Lr(t){return 1===t.length?t[0]:t}function qt(t){return Array.isArray(t)?t:[t]}function hi(t){const e=t.replace(/(.)([A-Z][a-z0-9]+)/g,"$1_$2").replace(/([a-z])([A-Z])/g,"$1_$2").toLowerCase();return"_"!==e[0]?e:"private"+e}function ja(t){return t.length<=1||-1===t.indexOf("_")?t:t.replace(/[_]+(\w|$)/g,(n,e)=>e.toUpperCase())}let Ps={};function OI(t){if(null==t)return null;const n={};return n.className=t.getClassName(),n.config=t.getConfig(),n}function MI(t){if(null!=t&&"object"==typeof t)if(Array.isArray(t))t.forEach(n=>MI(n));else{const n=Object.keys(t);for(const e of n){const r=t[e];null!=r&&"object"==typeof r&&(Array.isArray(r)||"ndarray"!==r.type||"number"!=typeof r.value?MI(r):t[e]=r.value)}}}function kh(t,n={},e={},r="object",s=!1){if("string"==typeof t){const o=t;let i;if(o in e)i=e[o];else if(o in Ps)i=Ps[o];else if(i=n[o],null==i)throw new L(`Unknown ${r}: ${t}. This may be due to one of the following reasons:\n1. The ${r} is defined in Python, in which case it needs to be ported to TensorFlow.js or your JavaScript code.\n2. The custom ${r} is defined in JavaScript, but is not registered properly with tf.serialization.registerClass().`);return i}{const o=t;if(null==o.className||null==o.config)throw new L(`${r}: Improper config format: ${JSON.stringify(o)}.\n'className' and 'config' must set.`);const i=o.className;let a,l;if(i in e?[a,l]=e[i]:i in Ps?[a,l]=Ps.className:i in n&&([a,l]=n[i]),null==a)throw new L(`Unknown ${r}: ${i}. This may be due to one of the following reasons:\n1. The ${r} is defined in Python, in which case it needs to be ported to TensorFlow.js or your JavaScript code.\n2. The custom ${r} is defined in JavaScript, but is not registered properly with tf.serialization.registerClass().`);if(null!=l){const u={};for(const f of Object.keys(Ps))u[f]=Ps[f];for(const f of Object.keys(e))u[f]=e[f];o.config.customObjects=u;const d=Object.assign({},Ps);for(const f of Object.keys(e))Ps[f]=e[f];MI(o.config);const h=l(a,o.config,e,s);return Ps=Object.assign({},d),h}{const u=Object.assign({},Ps);for(const d of Object.keys(e))Ps[d]=e[d];const c=new a(o.config);return Ps=Object.assign({},u),c}}}function qg(t,n){return-1*function KJ(t,n){return t<n?-1:t>n?1:0}(t,n)}function Ui(t){if(null==t)return t;const n=[];for(const e of t)-1===n.indexOf(e)&&n.push(e);return n}function XJ(t){if(null==t)throw new L(`Invalid value in obj: ${JSON.stringify(t)}`);for(const n in t)if(t.hasOwnProperty(n))return!1;return!0}function qa(t,n,e){if(null!=e&&t.indexOf(e)<0)throw new L(`${e} is not a valid ${n}.  Valid values are ${t} or null/undefined.`)}function PI(t,n,e=0,r=1/0){return gs(e>=0),gs(r>=e),Array.isArray(t)&&t.length>=e&&t.length<=r&&t.every(s=>typeof s===n)}function Jn(t,n){Array.isArray(t)?(S(t.length>0,()=>`${n} is unexpectedly an empty array.`),t.forEach((e,r)=>Jn(e,`element ${r+1} of ${n}`))):S(Number.isInteger(t)&&t>0,()=>`Expected ${n} to be a positive integer, but got ${oF(t)}.`)}function oF(t){return null===t?"null":Array.isArray(t)?"["+t.map(n=>oF(n)).join(",")+"]":"string"==typeof t?`"${t}"`:`${t}`}function iF(t){return"relu"===t?"relu":"linear"===t?"linear":"elu"===t?"elu":null}function LI(t,n){return U(()=>yr(Oe(V(t,t),n,!0)))}class Ah extends fu{getConfig(){return{}}}le((()=>{class t extends Ah{constructor(e){super(),this.defaultMaxValue=2,this.defaultAxis=0,this.maxValue=null!=e.maxValue?e.maxValue:this.defaultMaxValue,this.axis=null!=e.axis?e.axis:this.defaultAxis}apply(e){return U(()=>{const r=LI(e,this.axis),s=Kr(r,0,this.maxValue);return V(e,Me(s,me(Bn(),r)))})}getConfig(){return{maxValue:this.maxValue,axis:this.axis}}}return t.className="MaxNorm",t})()),le((()=>{class t extends Ah{constructor(e){super(),this.defaultAxis=0,this.axis=null!=e.axis?e.axis:this.defaultAxis}apply(e){return U(()=>Me(e,me(Bn(),LI(e,this.axis))))}getConfig(){return{axis:this.axis}}}return t.className="UnitNorm",t})()),le((()=>{class t extends Ah{apply(e){return ai(e)}}return t.className="NonNeg",t})()),le((()=>{class t extends Ah{constructor(e){super(),this.defaultMinValue=0,this.defaultMaxValue=1,this.defaultRate=1,this.defaultAxis=0,this.minValue=null!=e.minValue?e.minValue:this.defaultMinValue,this.maxValue=null!=e.maxValue?e.maxValue:this.defaultMaxValue,this.rate=null!=e.rate?e.rate:this.defaultRate,this.axis=null!=e.axis?e.axis:this.defaultAxis}apply(e){return U(()=>{const r=LI(e,this.axis),s=me(V(this.rate,Kr(r,this.minValue,this.maxValue)),V(1-this.rate,r));return V(e,Me(s,me(Bn(),r)))})}getConfig(){return{minValue:this.minValue,maxValue:this.maxValue,rate:this.rate,axis:this.axis}}}return t.className="MinMaxNorm",t})());const aF={maxNorm:"MaxNorm",minMaxNorm:"MinMaxNorm",nonNeg:"NonNeg",unitNorm:"UnitNorm"};function zn(t){return OI(t)}function lF(t,n={}){return kh(t,Ts.getMap().classNameMap,n,"constraint")}function Vn(t){return null==t?null:"string"==typeof t?lF({className:t in aF?aF[t]:t,config:{}}):t instanceof Ah?t:lF(t)}const ZJ=["channelsFirst","channelsLast"],QJ=["nearest","bilinear"],JJ=["valid","same","causal"],eee=["max","avg"],tee=["sum","mul","concat","ave"],Du=new Map;function wn(t){qa(ZJ,"DataFormat",t)}function ys(t){qa(JJ,"PaddingMode",t)}function uF(t){qa(eee,"PoolMode",t)}const Rh=[];function Ka(t,n){Rh.push(t);try{const e=n();return Rh.pop(),e}catch(e){throw Rh.pop(),e}}function dF(t){if(!fF(t))throw new Error("Not a valid tensor name: '"+t+"'");return function ree(){return 0===Rh.length?"":Rh.join("/")+"/"}()+t}function hF(t){if(!fF(t))throw new Error("Not a valid tensor name: '"+t+"'");Du.has(t)||Du.set(t,0);const n=Du.get(t);if(Du.set(t,Du.get(t)+1),n>0){const e=`${t}_${n}`;return Du.set(e,1),e}return t}const see=new RegExp(/^[A-Za-z0-9][-A-Za-z0-9\._\/]*$/);function fF(t){return!!t.match(see)}function oee(t){return t===parseInt(t.toString(),10)}function Wi(t,n,e){null==n&&(n=0),null==e&&(e=t.length);let r=1;for(let s=n;s<e;++s)r*=t[s];return r}function Kg(t){return Os(t=Array.isArray(t)?new Float32Array(t):t)}function _u(t){return vh(Kg(t)).dataSync()[0]}function Hi(t){return $s(Kg(t)).dataSync()[0]}function lo(t,n){if(n<t)throw new L(`end (${n}) < begin (${t}) is forbidden.`);const e=[];for(let r=t;r<n;++r)e.push(r);return e}function $h(t,n){return t.asType(n)}function Fh(t,n=-1){const e=t.shape.slice();return n<0&&(n=e.length+n+1),e.splice(n,0,1),t.reshape(e)}function Xa(t,n,e){return U(()=>{switch(t.rank){case 1:return OC(t,n,e);case 2:return t2(t,[n,0],[e,t.shape[1]]);case 3:return MC(t,[n,0,0],[e,t.shape[1],t.shape[2]]);case 4:return Ng(t,[n,0,0,0],[e,t.shape[1],t.shape[2],t.shape[3]]);case 5:return At(t,[n,0,0,0,0],[e,t.shape[1],t.shape[2],t.shape[3],t.shape[4]]);case 6:return At(t,[n,0,0,0,0,0],[e,t.shape[1],t.shape[2],t.shape[3],t.shape[4],t.shape[5]]);default:throw new L(`sliceAlongFirstAxis() received an unsupported tensor rank: ${t.rank}`)}})}function BI(t,n,e){return U(()=>{switch(t.rank){case 1:return OC(t,n,e);case 2:return t2(t,[0,n],[t.shape[0],e]);case 3:return MC(t,[0,0,n],[t.shape[0],t.shape[1],e]);case 4:return Ng(t,[0,0,0,n],[t.shape[0],t.shape[1],t.shape[2],e]);default:throw new L(`sliceAlongLastAxis() received an unsupported tensor rank: ${t.rank}`)}})}function Xg(t,n,e,r){return U(()=>{switch(t.rank){case 1:return OC(t,n,e);case 2:switch(r){case 1:return Xa(t,n,e);case 2:return BI(t,n,e);default:throw new L(`The axis is not within the rank of the tensor ${r}`)}case 3:switch(r){case 1:return Xa(t,n,e);case 2:return MC(t,[0,n,0],[t.shape[0],e,t.shape[2]]);case 3:return BI(t,n,e);default:throw new L(`The axis is not within the rank of the tensor ${r}`)}case 4:switch(r){case 1:return Xa(t,n,e);case 2:return Ng(t,[0,n,0,0],[t.shape[0],e,t.shape[2],t.shape[3]]);case 3:return Ng(t,[0,0,n,0],[t.shape[0],t.shape[1],e,t.shape[3]]);case 4:return BI(t,n,e);default:throw new L(`The axis is not within the rank of the tensor ${r}`)}default:throw new L(`sliceAlongLastAxis() received an unsupported tensor rank: ${t.rank}`)}})}function zI(t,n=-1){let e;return n<0&&(e=t[0].rank,n=0!==e?e:0),n===t[0].rank&&(n=-1),Sn(t,n)}function mF(t,n){switch(t.rank){case 1:return UX([t,n]);case 2:return HX([t,n],0);case 3:return jX([t,n],0);case 4:return KX([t,n],0);default:throw new L(`concatAlongFirstAxis() received an unsupported tensor rank: ${t.rank}`)}}function VI(t,n){if(Array.isArray(n)||(n=[n]),t.rank!==n.length)throw new L(`The length of input n (${n.length}) does not match the number of dimensions in input x (${t.rank})`);return za(t,n)}function Yg(t,n=0,e=1,r,s){return z7(t,n,e,r,s)}function ko(t,n,e,r){if(t.rank<2||n.rank<2)throw new et(`dot requires both inputs to be rank >= 2 but got x shape = ${t.shape} and y shape = ${n.shape}`);if(n.rank>=3&&t.shape.slice(-1)[0]!==n.shape.slice(-2)[0])throw new et(`If rank y >= 3, then the second last dim of y must equal the last dim of x but got x shape = ${t.shape} and  y shape = ${n.shape}`);if(2===t.rank&&2===n.rank)return WC({a:t,b:n,transposeA:!1,transposeB:!1,bias:r?UI(t.rank,r,"channelsLast"):null,activation:e});{const s=t.shape.slice(),o=s.pop();t=t.reshape([-1,o]);const i=n.shape.slice(),a=i.pop(),l=i.pop(),u=[...i,a],c=Array.from({length:n.rank},(p,m)=>0===m?n.rank-2:m<=n.rank-2?m-1:m);n=n.transpose(c).reshape([l,-1]);const d=[...s,...u];return WC({a:t,b:n,transposeA:!1,transposeB:!1,bias:r?UI(t.rank,r,"channelsLast"):null,activation:e}).reshape(d)}}function gF(t,n,e){return U(()=>(n=Array.isArray(n)?Os(n,"int32"):n.toInt(),bh(t,n,e)))}function Oh(t){return V(t,t)}function UI(t,n,e){const r=n.shape;if(1!==n.rank&&n.rank!==t)throw new L(`Unexpected bias dimensions: ${n.rank}; expected it to be 1 or ${t}`);if(5===t){if("channelsFirst"===e)return n.reshape(1===r.length?[1,r[0],1,1,1]:[1,r[3],r[0],r[1],r[2]]);if("channelsLast"===e)return n.reshape(1===r.length?[1,1,1,1,r[0]]:[1].concat(r))}else if(4===t){if("channelsFirst"===e)return n.reshape(1===r.length?[1,r[0],1,1]:[1,r[2],r[0],r[1]]);if("channelsLast"===e)return n.reshape(1===r.length?[1,1,1,r[0]]:[1].concat(r))}else if(3===t){if("channelsFirst"===e)return n.reshape(1===r.length?[1,r[0],1]:[1,r[1],r[0]]);if("channelsLast"===e)return n.reshape(1===r.length?[1,1,r[0]]:[1].concat(r))}else if(t<3)return n;throw new L(`Unsupported input rank by biasAdd: ${n.rank}`)}function Ao(t,n,e){return U(()=>(null==e&&(e="channelsLast"),wn(e),t.add(UI(t.rank,n,e))))}function yF(t,n,e,r){return U(()=>p9(t,n,e,r))}function Mh(t,n,e=!1){return e?t():n()}const pee=["fanIn","fanOut","fanAvg"],mee=["normal","uniform","truncatedNormal"];class Ls extends fu{fromConfigUsesCustomObjects(){return!1}getConfig(){return{}}}le((()=>{class t extends Ls{apply(e,r){return Nn(e,r)}}return t.className="Zeros",t})());let bF=(()=>{class t extends Ls{apply(e,r){return ii(e,r)}}return t.className="Ones",t})();le(bF),le((()=>{class t extends Ls{constructor(e){if(super(),"object"!=typeof e)throw new L(`Expected argument of type ConstantConfig but got ${e}`);if(void 0===e.value)throw new L(`config must have value set but got ${e}`);this.value=e.value}apply(e,r){return U(()=>V(Fe(this.value),ii(e,r)))}getConfig(){return{value:this.value}}}return t.className="Constant",t})()),le((()=>{class t extends Ls{constructor(e){super(),this.DEFAULT_MINVAL=-.05,this.DEFAULT_MAXVAL=.05,this.minval=e.minval||this.DEFAULT_MINVAL,this.maxval=e.maxval||this.DEFAULT_MAXVAL,this.seed=e.seed}apply(e,r){return wh(e,this.minval,this.maxval,r)}getConfig(){return{minval:this.minval,maxval:this.maxval,seed:this.seed}}}return t.className="RandomUniform",t})()),le((()=>{class t extends Ls{constructor(e){super(),this.DEFAULT_MEAN=0,this.DEFAULT_STDDEV=.05,this.mean=e.mean||this.DEFAULT_MEAN,this.stddev=e.stddev||this.DEFAULT_STDDEV,this.seed=e.seed}apply(e,r){if("float32"!==(r=r||"float32")&&"int32"!==r)throw new et(`randomNormal does not support dType ${r}.`);return Yg(e,this.mean,this.stddev,r,this.seed)}getConfig(){return{mean:this.mean,stddev:this.stddev,seed:this.seed}}}return t.className="RandomNormal",t})()),le((()=>{class t extends Ls{constructor(e){super(),this.DEFAULT_MEAN=0,this.DEFAULT_STDDEV=.05,this.mean=e.mean||this.DEFAULT_MEAN,this.stddev=e.stddev||this.DEFAULT_STDDEV,this.seed=e.seed}apply(e,r){if("float32"!==(r=r||"float32")&&"int32"!==r)throw new et(`truncatedNormal does not support dType ${r}.`);return LC(e,this.mean,this.stddev,r,this.seed)}getConfig(){return{mean:this.mean,stddev:this.stddev,seed:this.seed}}}return t.className="TruncatedNormal",t})()),le((()=>{class t extends Ls{constructor(e){super(),this.gain=null!=e.gain?e.gain:1}apply(e,r){return U(()=>{if(2!==e.length||e[0]!==e[1])throw new L("Identity matrix initializer can only be used for 2D square matrices.");return V(this.gain,Y$(e[0]))})}getConfig(){return{gain:this.gain}}}return t.className="Identity",t})());let bs=(()=>{class t extends Ls{constructor(e){if(super(),e.scale<0)throw new L(`scale must be a positive float. Got: ${e.scale}`);this.scale=e.scale??1,this.mode=e.mode??"fanIn",function gee(t){qa(pee,"FanMode",t)}(this.mode),this.distribution=e.distribution??"normal",function yee(t){qa(mee,"Distribution",t)}(this.distribution),this.seed=e.seed}apply(e,r){const s=function bee(t,n="channelsLast"){let e,r;if(wn(n),2===t.length)e=t[0],r=t[1];else if(-1!==[3,4,5].indexOf(t.length)){if("channelsFirst"===n){const s=Wi(t,2);e=t[1]*s,r=t[0]*s}else if("channelsLast"===n){const s=Wi(t,0,t.length-2);e=t[t.length-2]*s,r=t[t.length-1]*s}}else{const s=Wi(t);e=Math.sqrt(s),r=Math.sqrt(s)}return[e,r]}(e),o=s[0],i=s[1];let a=this.scale;if(a/="fanIn"===this.mode?Math.max(1,o):"fanOut"===this.mode?Math.max(1,i):Math.max(1,(o+i)/2),"normal"===this.distribution){const l=Math.sqrt(a);if("float32"!==(r=r||"float32")&&"int32"!==r)throw new et(`${this.getClassName()} does not support dType ${r}.`);return LC(e,0,l,r,this.seed)}{const l=Math.sqrt(3*a);return wh(e,-l,l,r)}}getConfig(){return{scale:this.scale,mode:this.mode,distribution:this.distribution,seed:this.seed}}}return t.className="VarianceScaling",t})();le(bs);let vF=(()=>{class t extends bs{constructor(e){super({scale:1,mode:"fanAvg",distribution:"uniform",seed:null==e?null:e.seed})}getClassName(){return bs.className}}return t.className="GlorotUniform",t})();le(vF);let xF=(()=>{class t extends bs{constructor(e){super({scale:1,mode:"fanAvg",distribution:"normal",seed:null==e?null:e.seed})}getClassName(){return bs.className}}return t.className="GlorotNormal",t})();le(xF);let wF=(()=>{class t extends bs{constructor(e){super({scale:2,mode:"fanIn",distribution:"normal",seed:null==e?null:e.seed})}getClassName(){return bs.className}}return t.className="HeNormal",t})();le(wF);let CF=(()=>{class t extends bs{constructor(e){super({scale:2,mode:"fanIn",distribution:"uniform",seed:null==e?null:e.seed})}getClassName(){return bs.className}}return t.className="HeUniform",t})();le(CF);let IF=(()=>{class t extends bs{constructor(e){super({scale:1,mode:"fanIn",distribution:"normal",seed:null==e?null:e.seed})}getClassName(){return bs.className}}return t.className="LeCunNormal",t})();le(IF);let DF=(()=>{class t extends bs{constructor(e){super({scale:1,mode:"fanIn",distribution:"uniform",seed:null==e?null:e.seed})}getClassName(){return bs.className}}return t.className="LeCunNormal",t})();le(DF),le((()=>{class t extends Ls{constructor(e){if(super(),this.DEFAULT_GAIN=1,this.gain=e.gain??this.DEFAULT_GAIN,this.seed=e.seed,null!=this.seed)throw new et("Random seed is not implemented for Orthogonal Initializer yet.")}apply(e,r){return U(()=>{if(e.length<2)throw new et("Shape must be at least 2D.");e[0]*e[1]>2e3&&console.warn(`Orthogonal initializer is being called on a matrix with more than 2000 (${e[0]*e[1]}) elements: Slowness may result.`);const o=Yg(e[0]>e[1]?[e[1],e[0]]:e,0,1,"float32");let i=WY.gramSchmidt(o);return e[0]>e[1]&&(i=i.transpose()),V(this.gain,i)})}getConfig(){return{gain:this.gain,seed:this.seed}}}return t.className="Orthogonal",t})());const _F={constant:"Constant",glorotNormal:"GlorotNormal",glorotUniform:"GlorotUniform",heNormal:"HeNormal",heUniform:"HeUniform",identity:"Identity",leCunNormal:"LeCunNormal",leCunUniform:"LeCunUniform",ones:"Ones",orthogonal:"Orthogonal",randomNormal:"RandomNormal",randomUniform:"RandomUniform",truncatedNormal:"TruncatedNormal",varianceScaling:"VarianceScaling",zeros:"Zeros"};function SF(t,n={}){return kh(t,Ts.getMap().classNameMap,n,"initializer")}function un(t){return OI(t)}function nn(t){if("string"==typeof t){const n=t in _F?_F[t]:t;if("GlorotNormal"===n)return new xF;if("GlorotUniform"===n)return new vF;if("HeNormal"===n)return new wF;if("HeUniform"===n)return new CF;if("LeCunNormal"===n)return new IF;if("LeCunUniform"===n)return new DF;{const e={};return e.className=n,e.config={},SF(e)}}return t instanceof Ls?t:SF(t)}let vee=0;function EF(){return vee++}const Zg={};function Qg(t=""){return t in Zg||(Zg[t]=0),Zg[t]+=1,t+Zg[t].toString()}function WI(t){return Array.isArray(t)&&Array.isArray(t[0])}function Jg(t){return 0===t.length?[]:Array.isArray(t[0])?t:[t]}function at(t){let n;if(Array.isArray(t)){if(1!==t.length)throw new L(`Expected Tensor length to be 1; got ${t.length}`);n=t[0]}else n=t;return n}function Vt(t){if(Array.isArray(t)&&Array.isArray(t[0])){if(1===t.length)return t[0];throw new L(`Expected exactly 1 Shape; got ${t.length}`)}return t}function ey(t){let n=0;for(const e of t)n+=0===e.shape.length?1:e.shape.reduce((r,s)=>r*s);return n}const NF="Variable";class Ro{constructor(n,e="float32",r=NF,s=!0,o=null){this.dtype=e??"float32",this.shape=n.shape,this.id=EF(),this.originalName=dF(r=r??NF),this.name=hF(this.originalName),this.trainable_=s,this.constraint=o,this.val=function a9(t,n=!0,e,r){return F.makeVariable(t,n,e,r)}(n,this.trainable_,this.name,this.dtype)}read(){return this.assertNotDisposed(),this.val}write(n){return this.assertNotDisposed(),function xee(t,n){if(t.shape.toString()!==n.shape.toString())throw new Error("Shape mismatch: "+JSON.stringify(t.shape)+" vs. "+JSON.stringify(n.shape))}(this.val,n),this.val.id!==n.id&&(this.val.assign(n),null!=this.constraint&&this.val.assign(this.constraint.apply(this.val))),this}dispose(){this.assertNotDisposed(),this.val.dispose()}assertNotDisposed(){if(this.val.isDisposed)throw new Error(`LayersVariable ${this.name} is already disposed.`)}get trainable(){return this.trainable_}set trainable(n){this.trainable_=n,this.val.trainable=n}}function HI(t){return t.map(n=>n.read())}function GI(t){t.forEach(n=>{n[0].write(n[1])})}class ur{constructor(n){this.dtype=n.dtype,this.shape=n.shape,this.ndim=null!=n.shape?n.shape.length:n.ndim,this.maxNDim=n.maxNDim,this.minNDim=n.minNDim,this.axes=n.axes||{}}}class $o{constructor(n,e,r,s,o,i,a){this.dtype=n,this.shape=e,this.sourceLayer=r,this.inputs=s,this.callArgs=o,this.outputTensorIndex=a,this.id=EF(),null!=i&&(this.originalName=dF(i),this.name=hF(this.originalName)),this.rank=e.length}}let wee=0;class ty{constructor(n,e){this.callArgs=e,this.id=wee++,this.outboundLayer=n.outboundLayer,this.inboundLayers=n.inboundLayers,this.nodeIndices=n.nodeIndices,this.tensorIndices=n.tensorIndices,this.inputTensors=n.inputTensors,this.outputTensors=n.outputTensors,this.inputMasks=n.inputMasks,this.outputMasks=n.outputMasks,this.inputShapes=n.inputShapes,this.outputShapes=n.outputShapes;for(const r of n.inboundLayers)r?.outboundNodes.push(this);n.outboundLayer.inboundNodes.push(this)}getConfig(){const n=[];for(const e of this.inboundLayers)n.push(null!=e?e.name:null);return{outboundLayer:this.outboundLayer?this.outboundLayer.name:null,inboundLayers:n,nodeIndices:this.nodeIndices,tensorIndices:this.tensorIndices}}}let Cee=0;class Dt extends fu{constructor(n={}){super(),this._callHook=null,this._addedWeightNames=[],this._stateful=!1,this.id=Cee++,this.activityRegularizer=null,this.inputSpec=null,this.supportsMasking=!1,this._trainableWeights=[],this._nonTrainableWeights=[],this._losses=[],this._updates=[],this._built=!1,this.inboundNodes=[],this.outboundNodes=[];let e=n.name;if(!e){const r=this.getClassName();e=hi(r)+"_"+Qg(r)}if(this.name=e,this.trainable_=n.trainable??!0,null!=n.inputShape||null!=n.batchInputShape){let r;if(null!=n.batchInputShape)r=n.batchInputShape;else if(null!=n.inputShape){let o=null;null!=n.batchSize&&(o=n.batchSize),r=[o].concat(n.inputShape)}this.batchInputShape=r;let s=n.dtype;null==s&&(s=n.inputDType),null==s&&(s="float32"),this.dtype=s}this.initialWeights=null!=n.weights?n.weights:null,this._refCount=null,this.fastWeightInitDuringBuild=!1}static nodeKey(n,e){return n.name+"_ib-"+e.toString()}getNodeAtIndex(n,e){if(0===this.inboundNodes.length)throw new Ms(`The layer has never been called and thus has no defined ${e}.`);if(this.inboundNodes.length<=n)throw new L(`Asked to get ${e} at node ${n}, but the layer has only ${this.inboundNodes.length} inbound nodes.`);return this.inboundNodes[n]}getInputAt(n){return Lr(this.getNodeAtIndex(n,"input").inputTensors)}getOutputAt(n){return Lr(this.getNodeAtIndex(n,"output").outputTensors)}get input(){if(this.inboundNodes.length>1)throw new To(`Layer ${this.name} has multiple inbound nodes, hence the notion of "layer input" is ill-defined. Use \`getInputAt(nodeIndex)\` instead.`);if(0===this.inboundNodes.length)throw new To(`Layer ${this.name} is not connected, no input to return.`);return Lr(this.getNodeAtIndex(0,"input").inputTensors)}get output(){if(0===this.inboundNodes.length)throw new To(`Layer ${this.name} has no inbound nodes.`);if(this.inboundNodes.length>1)throw new To(`Layer ${this.name} has multiple inbound nodes, hence the notion of "layer output" is ill-defined. Use \`getOutputAt(nodeIndex)\` instead.`);return Lr(this.getNodeAtIndex(0,"output").outputTensors)}get losses(){return this._losses}calculateLosses(){return this.losses.map(n=>n())}get updates(){return this._updates}get built(){return this._built}set built(n){this._built=n}get trainable(){return this.trainable_}set trainable(n){this._trainableWeights.forEach(e=>e.trainable=n),this.trainable_=n}get trainableWeights(){return this.trainable_?this._trainableWeights.filter(n=>n.trainable):[]}set trainableWeights(n){this._trainableWeights=n}get nonTrainableWeights(){return this.trainable?this._trainableWeights.filter(n=>!n.trainable).concat(this._nonTrainableWeights):this._trainableWeights.concat(this._nonTrainableWeights)}set nonTrainableWeights(n){this._nonTrainableWeights=n}get weights(){return this.trainableWeights.concat(this.nonTrainableWeights)}get stateful(){return this._stateful}resetStates(){if(!this.stateful)throw new Error("Cannot call the resetStates() method of a non-stateful Layer object.")}assertInputCompatibility(n){if(n=qt(n),null==this.inputSpec||0===this.inputSpec.length)return;const e=qt(this.inputSpec);if(n.length!==e.length)throw new L(`Layer ${this.name} expects ${e.length} inputs, but it received ${n.length} input tensors. Input received: ${n}`);for(let r=0;r<n.length;r++){const s=n[r],o=e[r];if(null==o)continue;const i=s.rank;if(null!=o.ndim&&i!==o.ndim)throw new L(`Input ${r} is incompatible with layer ${this.name}: expected ndim=${o.ndim}, found ndim=${i}`);if(null!=o.maxNDim&&i>o.maxNDim)throw new L(`Input ${r} is incompatible with layer ${this.name}: expected max_ndim=${o.maxNDim}, found ndim=${i}`);if(null!=o.minNDim&&i<o.minNDim)throw new L(`Input ${r} is incompatible with layer ${this.name}: expected min_ndim=${o.minNDim}, found ndim=${i}.`);if(null!=o.dtype&&s.dtype!==o.dtype)throw new L(`Input ${r} is incompatible with layer ${this.name} : expected dtype=${o.dtype}, found dtype=${s.dtype}.`);if(o.axes){const a=s.shape;for(const l in o.axes){const u=Number(l),c=o.axes[l],d=u>=0?a[u]:a[a.length+u];if(null!=c&&-1===[c,null].indexOf(d))throw new L(`Input ${r} is incompatible with layer ${this.name}: expected axis ${u} of input shape to have value ${c} but got shape ${a}.`)}}if(null!=o.shape)for(let a=0;a<o.shape.length;++a){const l=o.shape[a],u=s.shape[a];if(null!=l&&null!=u&&l!==u)throw new L(`Input ${r} is incompatible with layer ${this.name}: expected shape=${o.shape}, found shape=${s.shape}.`)}}}call(n,e){return n}invokeCallHook(n,e){null!=this._callHook&&this._callHook(n,e)}setCallHook(n){this._callHook=n}clearCallHook(){this._callHook=null}apply(n,e){e=e||{},this.assertNotDisposed();const r=qt(n);let s=!0;for(const i of r)if(!(i instanceof $o)){s=!1;break}let o=!0;for(const i of r)if(i instanceof $o){o=!1;break}if(s===o)throw new L("Arguments to apply() must be all SymbolicTensors or all Tensors");return Ka(this.name,()=>{if(!this.built){this.assertInputCompatibility(n);const i=[];for(const a of qt(n))i.push(a.shape);this.build(Lr(i)),this.built=!0,this.initialWeights&&this.setWeights(this.initialWeights),null===this._refCount&&o&&(this._refCount=1)}if(this.assertInputCompatibility(n),o){let i=this.call(n,e);const a=qt(i),l=[];for(let u of a)-1!==r.indexOf(u)&&(u=u.clone()),l.push(u);if(i=Lr(l),null!=this.activityRegularizer)throw new et("Layer invocation in the presence of activity regularizer(s) is not supported yet.");return i}{const i=function Iee(t){t=qt(t);const n=[];for(const e of t)n.push(e.shape);return Lr(n)}(n),a=this.computeOutputShape(i);let l;const u="float32";if(this.warnOnIncompatibleInputShape(Array.isArray(n)?i[0]:i),l=null!=a&&a.length>0&&Array.isArray(a[0])?a.map((c,d)=>new $o(u,c,this,qt(n),e,this.name,d)):new $o(u,a,this,qt(n),e,this.name),this.addInboundNode(n,l,null,null,i,a,e),this._refCount++,null!=this.activityRegularizer)throw new et("Layer invocation in the presence of activity regularizer(s) is not supported yet.");return l}})}warnOnIncompatibleInputShape(n){if(null!=this.batchInputShape)if(n.length!==this.batchInputShape.length)console.warn(`The rank of the input tensor provided (shape: ${JSON.stringify(n)}) does not match that of the batchInputShape (${JSON.stringify(this.batchInputShape)}) of the layer ${this.name}`);else{let e=!1;this.batchInputShape.forEach((r,s)=>{null!=r&&null!=n[s]&&n[s]!==r&&(e=!0)}),e&&console.warn(`The shape of the input tensor (${JSON.stringify(n)}) does not match the expectation of layer ${this.name}: ${JSON.stringify(this.batchInputShape)}`)}}get outputShape(){if(null==this.inboundNodes||0===this.inboundNodes.length)throw new To(`The layer ${this.name} has never been called and thus has no defined output shape.`);const n=[];for(const e of this.inboundNodes){const r=JSON.stringify(e.outputShapes);-1===n.indexOf(r)&&n.push(r)}if(1===n.length){const e=this.inboundNodes[0].outputShapes;return Array.isArray(e)&&Array.isArray(e[0])&&1===e.length?e[0]:e}throw new To(`The layer ${this.name} has multiple inbound nodes with different output shapes. Hence the notion of "output shape" is ill-defined for the layer.`)}countParams(){if(!this.built)throw new Ms(`You tried to call countParams() on ${this.name}, but the layer is not built yet. Build it first by calling build(batchInputShape).`);return ey(this.weights)}build(n){this.built=!0}getWeights(n=!1){return HI(n?this.trainableWeights:this.weights)}setWeights(n){U(()=>{const e=this.weights;if(e.length!==n.length)throw new L(`You called setWeights(weights) on layer "${this.name}" with a weight list of length ${n.length}, but the layer was expecting ${e.length} weights. Provided weights: ${n}...`);if(0===e.length)return;const r=[],s=HI(e);for(let o=0;o<s.length;++o){const i=s[o],a=e[o],l=n[o];if(!Mt(i.shape,l.shape))throw new L(`Layer weight shape ${i.shape} not compatible with provided weight shape ${l.shape}`);r.push([a,l])}GI(r)})}addWeight(n,e,r,s,o,i,a){if(-1!==this._addedWeightNames.indexOf(n))throw new L(`Duplicate weight name ${n} for layer ${this.name}`);this._addedWeightNames.push(n),null==r&&(r="float32"),this.fastWeightInitDuringBuild&&(s=nn("zeros"));const l=s.apply(e,r),u=new Ro(l,r,n,i,a);return l.dispose(),null!=o&&this.addLoss(()=>o.apply(u.read())),null==i&&(i=!0),i?this._trainableWeights.push(u):this._nonTrainableWeights.push(u),u}setFastWeightInitDuringBuild(n){this.fastWeightInitDuringBuild=n}addLoss(n){null==n||Array.isArray(n)&&0===n.length||(n=qt(n),null!=this._losses&&this.losses.push(...n))}computeOutputShape(n){return n}computeMask(n,e){if(!this.supportsMasking){if(null!=e){if(!Array.isArray(e))throw new TypeError(`Layer ${this.name} does not support masking, but was passed an inputMask.`);e.forEach(r=>{if(null!=r)throw new TypeError(`Layer ${this.name} does not support masking, but was passed an inputMask.`)})}return null}return e}addInboundNode(n,e,r,s,o,i,a=null){const l=qt(n);e=qt(e),r=qt(r),s=qt(s),o=Jg(o),i=Jg(i);const u=[],c=[],d=[];for(const h of l)u.push(h.sourceLayer),c.push(h.nodeIndex),d.push(h.tensorIndex);new ty({outboundLayer:this,inboundLayers:u,nodeIndices:c,tensorIndices:d,inputTensors:l,outputTensors:e,inputMasks:r,outputMasks:s,inputShapes:o,outputShapes:i},a);for(let h=0;h<e.length;h++)e[h].sourceLayer=this,e[h].nodeIndex=this.inboundNodes.length-1,e[h].tensorIndex=h}getConfig(){const n={name:this.name,trainable:this.trainable};return null!=this.batchInputShape&&(n.batchInputShape=this.batchInputShape),null!=this.dtype&&(n.dtype=this.dtype),n}disposeWeights(){return this.weights.forEach(n=>n.dispose()),this.weights.length}assertNotDisposed(){if(0===this._refCount)throw new Error(`Layer '${this.name}' is already disposed.`)}dispose(){if(!this.built)throw new Error(`Cannot dispose Layer ${this.name} because it has not been built yet.`);if(null===this._refCount)throw new Error(`Cannot dispose Layer ${this.name} because it has not been used yet.`);this.assertNotDisposed();let n=0;return 0==--this._refCount&&(n=this.disposeWeights()),{refCountAfterDispose:this._refCount,numDisposedVariables:n}}}function TF(t,n,e){if((null==n||null!=e&&e>0)&&(n=t.sourceLayer,e=t.nodeIndex),0===n.inboundNodes.length)return[t];{const r=n.inboundNodes[e];if(0===r.inboundLayers.length)return r.inputTensors;{const s=[];for(let o=0;o<r.inboundLayers.length;o++){const u=TF(r.inputTensors[o],r.inboundLayers[o],r.nodeIndices[o]);for(const c of u)-1===s.indexOf(c)&&s.push(c)}return s}}}let ny=(()=>{class t extends Dt{constructor(e){if(super({dtype:e.dtype,name:null!=e.name?e.name:Qg("input").toString()}),null==e.batchSize&&(e.batchSize=null),null==e.sparse&&(e.sparse=!1),this.trainable=!1,this.built=!0,this.sparse=e.sparse,null!=e.inputShape&&null!=e.batchInputShape)throw new L("Only provide the inputShape OR batchInputShape argument to inputLayer, not both at the same time.");let r=e.batchInputShape;if(null==r){if(null==e.inputShape)throw new L("An InputLayer should be passed either a `batchInputShape` or an `inputShape`.");r=[e.batchSize].concat(e.inputShape)}else if(null!=e.batchSize)throw new L("Cannot specify batchSize if batchInputShape is specified when creating an InputLayer.");const s=e.dtype||"float32";this.batchInputShape=r,this.dtype=s,this.inputSpec=[{shape:r}];const o=new $o(this.dtype,this.batchInputShape,this,[],{},this.name);o.nodeIndex=0,o.tensorIndex=0,new ty({outboundLayer:this,inboundLayers:[],nodeIndices:[],tensorIndices:[],inputTensors:[o],outputTensors:[o],inputMasks:[null],outputMasks:[null],inputShapes:[r],outputShapes:[r]})}apply(e,r){throw new L(`Cannot pass any input to an InputLayer's apply() method. InputLayer name: ${this.name}`)}dispose(){return{refCountAfterDispose:this._refCount,numDisposedVariables:0}}getConfig(){return{batchInputShape:this.batchInputShape,dtype:this.dtype,sparse:this.sparse,name:this.name}}}return t.className="InputLayer",t})();function Gi(t){return jI.apply(this,arguments)}function jI(){return(jI=J(function*(t){if(null==t)return;const n=[],e=[],r=[];for(const s in t){const o=t[s];if("number"!=typeof o){const i=o;n.push(i.data()),e.push(s),r.push(i)}}if(n.length>0){const s=yield Promise.all(n);for(let o=0;o<s.length;++o)t[e[o]]=s[o][0];it(r)}})).apply(this,arguments)}function kF(t){if(null!=t)for(const n in t){const e=t[n];"number"!=typeof e&&e.dispose()}}le(ny);class Su{constructor(){this.validationData=null}setParams(n){this.params=n}onEpochBegin(n,e){return J(function*(){})()}onEpochEnd(n,e){return J(function*(){})()}onBatchBegin(n,e){return J(function*(){})()}onBatchEnd(n,e){return J(function*(){})()}onTrainBegin(n){return J(function*(){})()}onTrainEnd(n){return J(function*(){})()}setModel(n){}}class Eee{constructor(n,e=10){null==n&&(n=[]),this.callbacks=n,this.queueLength=e}append(n){this.callbacks.push(n)}setParams(n){for(const e of this.callbacks)e.setParams(n)}setModel(n){for(const e of this.callbacks)e.setModel(n)}onEpochBegin(n,e){var r=this;return J(function*(){null==e&&(e={});for(const s of r.callbacks)yield s.onEpochBegin(n,e)})()}onEpochEnd(n,e){var r=this;return J(function*(){null==e&&(e={});for(const s of r.callbacks)yield s.onEpochEnd(n,e)})()}onBatchBegin(n,e){var r=this;return J(function*(){null==e&&(e={});for(const s of r.callbacks)yield s.onBatchBegin(n,e)})()}onBatchEnd(n,e){var r=this;return J(function*(){null==e&&(e={});for(const s of r.callbacks)yield s.onBatchEnd(n,e)})()}onTrainBegin(n){var e=this;return J(function*(){null==n&&(n={});for(const r of e.callbacks)yield r.onTrainBegin(n)})()}onTrainEnd(n){var e=this;return J(function*(){null==n&&(n={});for(const r of e.callbacks)yield r.onTrainEnd(n)})()}}class Nee extends Su{constructor(){super()}onEpochBegin(n){var e=this;return J(function*(){e.seen=0,e.totals={}})()}onBatchEnd(n,e){var r=this;return J(function*(){null==e&&(e={});const s=e.size??0;r.seen+=s;for(const o in e){const i=e[o];if("number"==typeof i)r.totals.hasOwnProperty(o)||(r.totals[o]=0),r.totals[o]=r.totals[o]+i*s;else{let a;o in r.totals?a=r.totals[o]:r.totals[o]=0;const l=U(()=>me(r.totals[o],V(i,s)));r.totals[o]=l,a?.dispose()}}})()}onEpochEnd(n,e){var r=this;return J(function*(){if(null!=e)for(const s of r.params.metrics)null!=r.totals[s]&&("number"==typeof r.totals[s]?e[s]=r.totals[s]/r.seen:U(()=>{const o=V(Me(1,r.seen),r.totals[s]);e[s]=o,r.totals[s].dispose(),ir(e[s])}))})()}}class Tee extends Su{onTrainBegin(n){var e=this;return J(function*(){e.epoch=[],e.history={}})()}onEpochEnd(n,e){var r=this;return J(function*(){null==e&&(e={}),r.epoch.push(n);for(const s in e)null==r.history[s]&&(r.history[s]=[]),r.history[s].push(e[s])})()}syncData(){var n=this;return J(function*(){const e=[],r=[],s=[];for(const i in n.history){const a=n.history[i];for(let l=0;l<a.length;++l)"number"!=typeof a[l]&&(e.push(a[l].data()),r.push(i),s.push(l))}const o=yield Promise.all(e);for(let i=0;i<o.length;++i)n.history[r[i]][s[i]].dispose(),n.history[r[i]][s[i]]=o[i][0]})()}}class kee extends Su{constructor(n,e){if(super(),this.currentEpoch=0,this.yieldEvery=e||"auto","auto"===this.yieldEvery&&(this.yieldEvery=125),"never"===this.yieldEvery&&null!=n.onYield)throw new Error("yieldEvery is `never` but you provided an `onYield` callback. Either change `yieldEvery` or remove the callback");q0(this.yieldEvery)&&(this.maybeWait=function YJ(t,n){let r,e=Pr();return(...o)=>{const i=Pr();return i-e<n||(e=i,r=t(...o)),r}}(this.maybeWait.bind(this),this.yieldEvery)),this.trainBegin=n.onTrainBegin,this.trainEnd=n.onTrainEnd,this.epochBegin=n.onEpochBegin,this.epochEnd=n.onEpochEnd,this.batchBegin=n.onBatchBegin,this.batchEnd=n.onBatchEnd,this.yield=n.onYield}maybeWait(n,e,r){var s=this;return J(function*(){const o=[];null!=s.yield&&(yield Gi(r),o.push(s.yield(n,e,r))),o.push(aI()),yield Promise.all(o)})()}onEpochBegin(n,e){var r=this;return J(function*(){r.currentEpoch=n,null!=r.epochBegin&&(yield Gi(e),yield r.epochBegin(n,e))})()}onEpochEnd(n,e){var r=this;return J(function*(){const s=[];null!=r.epochEnd&&(yield Gi(e),s.push(r.epochEnd(n,e))),"epoch"===r.yieldEvery&&s.push(aI()),yield Promise.all(s)})()}onBatchBegin(n,e){var r=this;return J(function*(){null!=r.batchBegin&&(yield Gi(e),yield r.batchBegin(n,e))})()}onBatchEnd(n,e){var r=this;return J(function*(){const s=[];null!=r.batchEnd&&(yield Gi(e),s.push(r.batchEnd(n,e))),"batch"===r.yieldEvery?s.push(aI()):q0(r.yieldEvery)&&s.push(r.maybeWait(r.currentEpoch,n,e)),yield Promise.all(s)})()}onTrainBegin(n){var e=this;return J(function*(){null!=e.trainBegin&&(yield Gi(n),yield e.trainBegin(n))})()}onTrainEnd(n){var e=this;return J(function*(){null!=e.trainEnd&&(yield Gi(n),yield e.trainEnd(n))})()}}function AF(t,n){return null==t&&(t={}),t instanceof Su?[t]:Array.isArray(t)&&t[0]instanceof Su?t:qt(t).map(r=>new kee(r,n))}let Aee=(()=>{class t{constructor(){}static registerCallbackConstructor(e,r){S(e>=0&&Number.isInteger(e),()=>`Verbosity level is expected to be an integer >= 0, but got ${e}`),t.checkForDuplicate(r),null==t.constructors[e]&&(t.constructors[e]=[]),t.constructors[e].push(r)}static checkForDuplicate(e){for(const r in t.constructors)t.constructors[+r].forEach(o=>{if(o===e)throw new L("Duplicate callback constructor.")})}static clear(){t.constructors={}}static createCallbacks(e){const r=[];for(const s in t.constructors){const o=+s;e>=o&&r.push(...t.constructors[o])}return r.map(s=>new s)}}return t.constructors={},t})();function RF(t,n,e,r,s,o,i,a,l){const u=new Tee,c=[new Nee,...Aee.createCallbacks(n)];null!=t&&c.push(...t),c.push(u);const d=new Eee(c);return d.setParams({epochs:e,initialEpoch:r,samples:s,steps:o,batchSize:i,verbose:n,doValidation:a,metrics:l}),{callbackList:d,history:u}}function fi(t,n={},e=!1){return kh(t,Ts.getMap().classNameMap,n,"layer",e)}function ry(t,n){return U(()=>{"float32"!==t.dtype&&(t=t.asType("float32"));const e=Oe(Oh(t),n,!0),r=Ig(e.shape,Bn()),s=yr(oi(e,r));return Me(t,s)})}function sy(t,n){return U(()=>pn(Oh($e(n,t)),-1))}function qI(t,n){return U(()=>pn(Yn($e(n,t)),-1))}function KI(t,n){return U(()=>{const e=$e(t,n),r=Kr(Yn(t),Bn(),Number.MAX_VALUE),s=Yn(Me(e,r));return V(100,pn(s,-1))})}function Ph(t,n,e=!1){return U(()=>{if(e)n=Tg(n);else{const r=Oe(n,n.shape.length-1,!0);n=Me(n,r)}return n=Kr(n,Bn(),1-Bn()),mn(Oe(V(t.toFloat(),hs(n)),n.shape.length-1))})}function oy(t,n,e=!1){return U(()=>{const r=yh(function uee(t){const n=[Wi(t.shape)];return t.reshape(n)}(t)).toInt(),s=(n=Kr(n,Bn(),1-Bn())).shape;return Ph(AC(r,s[s.length-1]).reshape(s),n,e)})}function iy(t,n){return U(()=>{let e;return e=Kr(n,Bn(),1-Bn()),e=hs(Me(e,$e(1,e))),pn(function Pee(t,n){if(!Mt(t.shape,n.shape))throw new L(`logits and labels must have the same shape, but got shapes ${JSON.stringify(t.shape)} and ${JSON.stringify(n.shape)}`);return U(()=>{const e=n.relu(),r=n.abs().neg();return e.sub(n.mul(t)).add(r.exp().log1p())})}(t,e),-1)})}function $F(t,n){return U(()=>{const e=ry(t,-1),r=ry(n,-1),s=V(e,r);return mn(Oe(s,-1))})}const ay={meanSquaredError:sy,meanAbsoluteError:qI,meanAbsolutePercentageError:KI,meanSquaredLogarithmicError:function Ree(t,n){return U(()=>{const e=Kr(n,Bn(),Number.MAX_VALUE),r=hs(me(1,e)),s=Kr(t,Bn(),Number.MAX_VALUE),o=hs(me(1,s));return pn(Oh($e(r,o)),-1)})},squaredHinge:function $ee(t,n){return U(()=>{const e=oi(0,$e(1,V(t,n)));return pn(Oh(e),-1)})},hinge:function Fee(t,n){return U(()=>{const e=oi(0,$e(1,V(t,n)));return pn(e,-1)})},categoricalHinge:function Oee(t,n){return U(()=>{const e=Oe(V(t,n),-1),r=$s(V($e(1,t),n),-1);return oi(0,me(1,$e(r,e)))})},logcosh:function Mee(t,n){return U(()=>{const e=Math.log(2),r=$e(n,t),s=$e(me(r,Ch(V(-2,r))),e);return pn(s,-1)})},categoricalCrossentropy:Ph,sparseCategoricalCrossentropy:oy,binaryCrossentropy:iy,kullbackLeiblerDivergence:function Lee(t,n){return U(()=>{const e=Kr(t,Bn(),1),r=Kr(n,Bn(),1);return Oe(V(t,hs(Me(e,r))),-1)})},poisson:function Bee(t,n){return U(()=>{const e=hs(me(Bn(),n));return pn($e(n,V(t,e)),-1)})},cosineProximity:$F};function XI(t){if("string"==typeof t){if(t in ay)return ay[t];let n=`Unknown loss ${t}`;throw t.toLowerCase().includes("softmaxcrossentropy")&&(n=`Unknown loss ${t}. Use "categoricalCrossentropy" as the string name for tf.losses.softmaxCrossEntropy`),new L(n)}return t}function FF(t,n){return U(()=>{const e=V(.5,fs(n)),r=$h(Eo(n,e),t.dtype);return pn(Ba(t,r),-1)})}function OF(t,n){return U(()=>$h(Ba(xg(t,-1),xg(n,-1)),"float32"))}function Wee(t,n){return iy(t,n)}function Hee(t,n){return t.rank===n.rank&&(t=t.squeeze([t.rank-1])),(n=n.argMax(-1)).dtype!==t.dtype&&(n=n.asType(t.dtype)),Ba(t,n).asType("float32")}const PF=Ph,LF=oy,ly={binaryAccuracy:FF,categoricalAccuracy:OF,precision:function Uee(t,n){return U(()=>{const e=function MF(t,n){return U(()=>No(t.equal(1),n.equal(1)).sum().cast("float32"))}(t,n),r=function Vee(t,n){return U(()=>No(t.equal(0),n.equal(1)).sum().cast("float32"))}(t,n),s=e.add(r);return ms(Eo(s,0),e.div(s),0).cast("float32")})},categoricalCrossentropy:PF,sparseCategoricalCrossentropy:LF,mse:sy,MSE:sy,mae:qI,MAE:qI,mape:KI,MAPE:KI,cosine:$F};function Qee(t){if("string"==typeof t&&t in ly)return ly[t];if("string"!=typeof t&&null!=t)return t;throw new L(`Unknown metric ${t}`)}function uy(t){if(gs(null!==t,`Unknown LossOrMetricFn ${t}`),"string"==typeof t)return t;{let n;for(const e of Object.keys(ay))if(ay[e]===t){n=e;break}if(void 0!==n)return n;for(const e of Object.keys(ly))if(ly[e]===t){n=e;break}return void 0!==n?n:t.name}}function zF(t,n,e=!1){if(null==t||"object"!=typeof t||Object.getPrototypeOf(t)!==Object.prototype||!YI(t))throw new Error("User-defined metadata is expected to be a JSON object, but is not.");if(e){const r=JSON.stringify(t);r.length>1048576&&console.warn(`User-defined metadata of model "${n}" is too large in size (length=${r.length} when serialized). It is not recommended to store such large objects in user-defined metadata. Please make sure its serialized length is <= 1048576.`)}}function YI(t){if(null===t)return!0;if("object"==typeof t){if(Object.getPrototypeOf(t)===Object.prototype){const n=Object.keys(t);for(const e of n)if("string"!=typeof e||!YI(t[e]))return!1;return!0}if(Array.isArray(t)){for(const n of t)if(!YI(n))return!1;return!0}return!1}{const n=typeof t;return"string"===n||"number"===n||"boolean"===n}}function cy(t,n,e=console.log){let r="";for(let s=0;s<t.length;++s)s>0&&(r=r.slice(0,r.length-1)+" "),r+=t[s],r=r.slice(0,n[s]),r+=" ".repeat(n[s]-r.length);e(r)}function rte(t,n,e){let r;try{r=JSON.stringify(t.outputShape)}catch{r="multiple"}cy([`${t.name} (${t.getClassName()})`,r,t.countParams().toString()],n,e)}function ste(t,n,e,r){let s;try{s=JSON.stringify(t.outputShape)}catch{s="multiple"}const o=[];for(const c of t.inboundNodes)if(!(null!=e&&e.length>0&&-1===e.indexOf(c)))for(let d=0;d<c.inboundLayers.length;++d)o.push(`${c.inboundLayers[d].name}[${c.nodeIndices[d]}][${c.tensorIndices[d]}]`);const i=t.name,a=t.getClassName(),l=0===o.length?"":o[0];cy([`${i} (${a})`,s,t.countParams().toString(),l],n,r);for(let c=1;c<o.length;++c)cy(["","","",o[c]],n,r)}function VF(t,n,e){return("inboundNodes"===t||"outputLayers"===t||"inputLayers"===t)&&0===n&&"string"==typeof e}function ZI(t,n){if(null===t)return null;if("string"==typeof t)return ja(t);if("number"==typeof t||"boolean"==typeof t)return t;if(t instanceof Array){const e=[],r=t.length;for(let s=0;s<r;++s){const o=t[s];VF(n,s,o)?e.push(o):e.push(ZI(o,n))}return e}{const e={};for(const r of Object.keys(t)){const s=t[r];if("name"===r&&"string"==typeof s)e[r]=s;else{const o=ja(r);e[o]=ZI(s,o)}}return e}}function QI(t,n){if(null==t)return null;if("string"==typeof t)return hi(t);if("number"==typeof t||"boolean"==typeof t)return t;if(t instanceof Array){const e=[],r=t.length;for(let s=0;s<r;++s){const o=t[s];VF(n,s,o)?e.push(o):e.push(QI(o,n))}return e}{const e={};for(const r of Object.keys(t)){const s=t[r];e[hi(r)]="name"!==r&&"className"!==r||"string"!=typeof s?QI(s,r):s}return e}}class ji{constructor(n){if(this.id2Value={},this.id2Mask={},this.name2Id={},n instanceof ji)for(const e in n.id2Value)this.id2Value[e]=n.id2Value[e],e in n.id2Mask&&(this.id2Mask[e]=n.id2Mask[e]);else{if(null==n)return;for(const e of n)this.add(e.key,e.value)}}add(n,e,r){if(null!=this.id2Value[n.id])throw new L(`Duplicate key: name=${n.name}, id=${n.id}`);return this.id2Value[n.id]=function ote(t,n){if(null==t.dtype||t.dtype===n.dtype)return n;try{return Ae(n,t.dtype)}catch{throw new L(`The dtype of the feed (${n.dtype}) can not be cast to the dtype of the key '${t.name}' (${t.dtype}).`)}}(n,e),this.name2Id[n.name]=n.id,null!=r&&(this.id2Mask[n.id]=r),this}addFeed(n){this.add(n.key,n.value)}hasKey(n){return null!=this.id2Value[n.id]}names(){return Object.keys(this.name2Id)}getValue(n){if(n instanceof $o){if(null==this.id2Value[n.id])throw new L(`Nonexistent key: ${n.name}`);return this.id2Value[n.id]}{const e=this.name2Id[n];if(null==e)throw new L(`Feed dict has no SymbolicTensor name: ${n}`);return this.id2Value[e]}}getMask(n){if(n instanceof $o){if(null==this.id2Value[n.id])throw new L(`Nonexistent key: ${n.name}`);return this.id2Mask[n.id]}{const e=this.name2Id[n];if(null==e)throw new L(`Feed dict has no SymbolicTensor name: ${n}`);return this.id2Mask[e]}}disposeMasks(){null!=this.id2Mask&&it(this.id2Mask)}}const eD={},UF={};function Lh(t,n,e,r){const s=null!=e&&e.training,o=Array.isArray(t),i=o?t:[t],a=i.map(p=>p.name),l=[],u=n.names();for(const p of a)-1!==u.indexOf(p)?l.push(n.getValue(p)):l.push(null);null!=r&&(r.maxNumTensors=-1/0,r.minNumTensors=1/0);const c=a.join(",")+"|"+n.names().join(",");let d,h;if(null==eD[c]){const p=function ite(t,n){S(null!=t&&t.length>0,()=>"Expected at least one fetch, got none");let e=[],r={};if(1===t.length){const s=WF(t[0],n);e=s.sorted,r=s.recipientMap}else{const s=new Set;for(const o of t){const{sorted:i,recipientMap:a}=WF(o,n);for(const l of i)s.has(l.name)||(e.push(l),s.add(l.name));for(const l in a)null==r[l]&&(r[l]=new Set),a[l].forEach(u=>r[l].add(u))}}return{sorted:e,recipientCounts:ate(r)}}(i,n);d=p.sorted,h=p.recipientCounts,eD[c]=d,UF[c]=h}d=eD[c],h={},s||Object.assign(h,UF[c]);const f=new ji(n);for(let p=0;p<d.length;++p){if(null!=r){const R=xC().numTensors;R>r.maxNumTensors&&(r.maxNumTensors=R),R<r.minNumTensors&&(r.minNumTensors=R)}const m=d[p],g=m.sourceLayer;if(g instanceof ny)continue;const y=[],b=[],v=[];let x=!1;for(const R of m.inputs){const O=f.getValue(R),G=f.getMask(R);y.push(O),b.push(G),null!=G&&(x=!0),s||(h[R.name]--,0===h[R.name]&&!n.hasKey(R)&&-1===a.indexOf(R.name)&&!O.isDisposed&&!0!==R.sourceLayer.stateful&&v.push(O))}x&&((e=e||{}).mask=b[0]);const w=qt(g.apply(y,e));let _=null;g.supportsMasking&&(_=g.computeMask(y,b));const D=lte(m),A=Array.isArray(D)?D:[D];for(let R=0;R<A.length;++R){f.hasKey(A[R])||f.add(A[R],w[R],Array.isArray(_)?_[0]:_);const O=a.indexOf(A[R].name);-1!==O&&(l[O]=w[R])}s||it(v)}return f.disposeMasks(),o?l:l[0]}function ate(t){const n={};for(const e in t)n[e]=t[e].size;return n}function WF(t,n){const e=new Set,r=[],s={};for(const a of n.names())e.add(a);const o=[],i=[];for(o.push(t);o.length>0;){const a=o[o.length-1];if(e.has(a.name)){o.pop();continue}const l=i[i.length-1]===o.length-1;if(0===a.inputs.length||l)o.pop(),r.push(a),e.add(a.name),l&&i.pop();else{i.push(o.length-1);for(const u of a.inputs)null==s[u.name]&&(s[u.name]=new Set),s[u.name].add(a.name),!e.has(u.name)&&o.push(u)}}return{sorted:r,recipientMap:s}}function lte(t){let n;if(1===t.sourceLayer.inboundNodes.length)n=t.sourceLayer.output;else{let e=null;for(let r=0;r<t.sourceLayer.inboundNodes.length;++r)for(const s of t.sourceLayer.inboundNodes[r].outputTensors)if(s.id===t.id){e=r;break}n=t.sourceLayer.getOutputAt(e)}return n}class uo extends Dt{constructor(n){if(super({}),this.containerNodes=new Set,this.name=n.name,null==this.name){const b=this.getClassName().toLowerCase();this.name=Qg(b)}if(this.supportsMasking=!1,this.trainable_=!0,this.inputs=Array.isArray(n.inputs)?n.inputs.slice():[n.inputs],this.outputs=Array.isArray(n.outputs)?n.outputs.slice():[n.outputs],Ui(this.inputs).length!==this.inputs.length)throw new L(`The list of inputs passed to the model is redundant. All inputs should only appear once. Found: ${this.inputs.map(b=>b.name)}`);Ui(this.outputs).length!==this.outputs.length&&console.warn(`The list of outputs passed to the model is redundant. All outputs should only appear once. Found: ${this.outputs.map(b=>b.name)}`),this.inputLayers=[],this.inputLayersNodeIndices=[],this.inputLayersTensorIndices=[],this.outputLayers=[],this.outputLayersNodeIndices=[],this.outputLayersTensorIndices=[],this.layers=[],this.internalContainerRefs=[];for(const b of this.outputs){const x=b.nodeIndex,w=b.tensorIndex;this.outputLayers.push(b.sourceLayer),this.outputLayersNodeIndices.push(x),this.outputLayersTensorIndices.push(w)}for(const b of this.inputs){const v=b.sourceLayer,x=b.nodeIndex,w=b.tensorIndex;gs(0===x,"input layer has >1 nodes"),gs(0===w,"input layer has >1 tensors"),this.inputLayers.push(v),this.inputLayersNodeIndices.push(x),this.inputLayersTensorIndices.push(w)}this.inputNames=[],this.outputNames=[],this.feedInputShapes=[],this.feedInputNames=[],this.feedOutputNames=[];for(let b=0;b<this.inputLayers.length;b++){const v=this.inputLayers[b];if(!(v instanceof ny))throw new TypeError(`Input layers to a LayersModel must be InputLayer objects. Received inputs: ${n.inputs}. Input ${b} (0-based) originates from layer type ${v.getClassName()}.`);this.inputNames.push(v.name),this.feedInputShapes.push(v.batchInputShape),this.feedInputNames.push(v.name)}for(const b of this.outputLayers)this.outputNames.push(b.name);this.internalInputShapes=this.inputs.map(b=>b.shape),this.internalOutputShapes=this.outputs.map(b=>b.shape);const e={},r={},s={},o={},i={},a=[],l=(b,v,x,w,_,D)=>{(null==w||null==_||null==D)&&(w=b.sourceLayer,_=b.nodeIndex,D=b.tensorIndex);const A=w.inboundNodes[_];if(-1!==x.indexOf(A))throw new Ms(`The tensor ${b.name} at layer "${w.name}" is part of a cycle.`);if(-1!==v.indexOf(A))return;this.containerNodes.add(uo.nodeKey(w,_)),w.id in i||(i[w.id]=Object.keys(i).length),-1===x.indexOf(A)&&x.push(A);const R=A.inboundLayers.length;for(let O=0;O<R;O++)l(A.inputTensors[O],v,x,A.inboundLayers[O],A.nodeIndices[O],A.tensorIndices[O]);for(v.push(A);x.indexOf(A)>=0;)x.splice(x.indexOf(A),1);a.push(A)},u=[],c=[];for(const b of this.outputs)l(b,u,c);const d=a.slice().reverse();for(const b of d){r[b.id]=b,b.id in e||(e[b.id]=0);let v=e[b.id];v=Math.max(v,s[b.outboundLayer.id]??0),s[b.outboundLayer.id]=v,o[b.outboundLayer.id]=b.outboundLayer,e[b.id]=v;for(let w=0;w<b.inboundLayers.length;w++){const A=b.inboundLayers[w].inboundNodes[b.nodeIndices[w]];e[A.id]=Math.max(v+1,e[A.id]??0),r[A.id]=A}}const h={};for(const b in e){const v=e[b];v in h||(h[v]=[]),h[v].push(r[b])}const f={};for(const b in s){const v=s[b];v in f||(f[v]=[]),f[v].push(o[b])}let p=Object.keys(f).map(b=>parseInt(b,10)).sort(qg);this.layers=[];for(const b of p){const v=f[b];v.sort((x,w)=>{const _=i[x.id],D=i[w.id];return _<D?-1:_>D?1:0});for(const x of v)x instanceof uo&&this.internalContainerRefs.push(x),this.layers.push(x)}this.layersByDepth=f,p=Object.keys(h).map(b=>parseInt(b,10)).sort(qg);const m=this.inputs.slice(),g=[];for(const b of p)for(const v of h[b]){const x=v.outboundLayer;if(null!=x){for(const w of v.inputTensors)if(-1===m.indexOf(w))throw new Ms(`Graph disconnected: cannot obtain value for tensor ${w} at layer "${x.name}". The following previous layers were accessed without issue: ${g}`);for(const w of v.outputTensors)m.push(w);g.push(x.name)}}this.nodesByDepth=h;const y=this.layers.map(b=>b.name);for(const b of y){const v=y.filter(x=>x===b).length;if(1!==v)throw new Ms(`The name "${b}" is used ${v} times in the model. All layer names should be unique. Layer names: `+JSON.stringify(y))}this.outboundNodes=[],this.inboundNodes=[],new ty({outboundLayer:this,inboundLayers:[],nodeIndices:[],tensorIndices:[],inputTensors:this.inputs,outputTensors:this.outputs,inputMasks:this.inputs.map(b=>null),outputMasks:this.outputs.map(b=>null),inputShapes:this.inputs.map(b=>b.shape),outputShapes:this.outputs.map(b=>b.shape)}),this.built=!0,this._refCount=1}assertNotDisposed(){if(0===this._refCount)throw new Error(`Container '${this.name}' is already disposed.`)}dispose(){this.assertNotDisposed();const n={refCountAfterDispose:null,numDisposedVariables:0};if(0==--this._refCount){for(const e of this.layers)n.numDisposedVariables+=e.dispose().numDisposedVariables;for(const e of this.internalContainerRefs)n.numDisposedVariables+=e.dispose().numDisposedVariables}return n.refCountAfterDispose=this._refCount,n}get trainable(){return this.trainable_}set trainable(n){this.layers.forEach(e=>{e._trainableWeights.forEach(r=>r.trainable=n)}),this.trainable_=n}get trainableWeights(){if(this._trainableWeights.length>0)throw new L("Container instance unexpectedly contains _trainableWeights.The trainable weights of a Container are a union of the trainable weights of its consituent Layers. Its own _trainableWeights must remain an empty Array.");if(!this.trainable)return[];let n=[];for(const e of this.layers)n=n.concat(e.trainableWeights);return n}get nonTrainableWeights(){const n=[];for(const e of this.layers)n.push(...e.nonTrainableWeights);if(!this.trainable){const e=[];for(const r of this.layers)e.push(...r.trainableWeights);return e.concat(n)}return n}get weights(){return this.trainableWeights.concat(this.nonTrainableWeights)}loadWeights(n,e=!0){const r={};let s=0;for(const i of this.layers)for(const a of i.weights){if(null!=r[a.originalName])throw new L(`Duplicate weight name: ${a.originalName}`);r[a.originalName]=a,s++}const o=[];for(const i in n){let a=i;if(null==r[i]){const l=i.split("/");a=l.slice(0,-2).concat([l[l.length-1]]).join("/")}if(null!=r[a])o.push([r[a],n[i]]);else if(e)throw new L(`Provided weight data has no target variable: ${i}`);delete r[a]}if(e){const i=[];for(const a in r)i.push(a);if(i.length>0)throw new L(`${i.length} of ${s} weights are not set: ${i}`)}GI(o)}updatedConfig(){const n=this.getConfig(),e={};return e.className=this.getClassName(),e.config=n,e.kerasVersion="tfjs-layers 3.3.0",e.backend="TensorFlow.js",e}toJSON(n,e=!0){const r=QI(this.updatedConfig());return e?JSON.stringify(r):r}call(n,e){return U(()=>{n=qt(n);const r=new ji;for(let s=0;s<this.inputs.length;++s)r.add(this.inputs[s],n[s]);return Lh(this.outputs,r,e)})}computeMask(n,e){return U(()=>{let r;return n=qt(n),r=null==e?Ga(null,n.length):qt(e),this.runInternalGraph(n,r)[1]})}computeOutputShape(n){const e=Jg(n);if(e.length!==this.inputLayers.length)throw new L(`Invalid inputShape argument ${n}: model has ${this.inputLayers.length} tensor inputs.`);const r={};for(let a=0;a<e.length;a++)r[this.inputLayers[a].name+"_0_0"]=e[a];const s=Object.keys(this.nodesByDepth).map(a=>parseInt(a,10)).sort(qg);if(s.length>1)for(const a of s){const l=this.nodesByDepth[a];for(const u of l){const c=u.outboundLayer;if(-1!==this.inputLayers.map(m=>m.id).indexOf(c.id))continue;const d=[];for(let m=0;m<u.inboundLayers.length;m++)d.push(r[`${u.inboundLayers[m].name}_${u.nodeIndices[m]}_${u.tensorIndices[m]}`]);const f=Jg(c.computeOutputShape(Lr(d))),p=c.inboundNodes.indexOf(u);for(let m=0;m<f.length;m++)r[`${c.name}_${p}_${m}`]=f[m]}}const o=[],i=[];for(let a=0;a<this.outputLayers.length;a++)i.push(`${this.outputLayers[a].name}_${this.outputLayersNodeIndices[a]}_${this.outputLayersTensorIndices[a]}`);for(let a=0;a<i.length;a++){const l=i[a];gs(l in r),o.push(r[l])}return Lr(o)}runInternalGraph(n,e){null==e&&(e=Ga(null,n.length));const r={};for(let l=0;l<this.inputs.length;++l)r[this.inputs[l].id]=[n[l],e[l]];const s=Object.keys(this.nodesByDepth).map(l=>parseInt(l,10)).sort(qg);for(const l of s){const u=this.nodesByDepth[l];for(const c of u){const d=c.outboundLayer,h=c.inputTensors,f=c.outputTensors,p=new Array;for(const m of h)m.id in r&&p.push(r[m.id]);if(p.length===h.length){let g,y,b,v,m={};if(null!=c.callArgs&&(m=c.callArgs),1===p.length){const[x,w]=p[0];null==m.mask&&(m.mask=w),b=qt(d.call(x,m)),v=qt(d.computeMask(x,w)),g=[x],y=[w]}else g=p.map(x=>x[0]),y=p.map(x=>x[1]),null==m.mask&&(m.mask=y),b=qt(d.call(g,m)),v=qt(d.computeMask(g,y));if(d.activityRegularizer)throw new et("LayersModel invocation with concrete Tensor value(s) in the presence of activity regularizer(s) is not supported yet.");for(let x=0;x<f.length;++x)r[f[x].id]=[b[x],v[x]]}}}const o=[],i=[],a=[];for(const l of this.outputs){gs(l.id in r,`Could not compute output ${l.name} : ${l.id}`);const[u,c]=r[l.id];a.push(u.shape),o.push(u),i.push(c)}return[o,i,a]}buildNodeConversionMap(n){const e={};let r;for(const s of this.layers){r=s instanceof uo?1:0;for(let o=0;o<s.inboundNodes.length;o++){const i=uo.nodeKey(s,o);this.containerNodes.has(i)&&(e[i]=r,r+=1)}}return e}getLayer(n,e){if(null!=e){if(this.layers.length<=e)throw new L(`Was asked to retrieve layer at index ${e}, but model only has ${this.layers.length} layer(s).`);return this.layers[e]}if(null==n)throw new L("Provide either a layer name or layer index");for(const r of this.layers)if(r.name===n)return r;throw new L(`No such layer: ${n}`)}calculateLosses(){return U(()=>{const n=[];for(const e of this.layers)for(let r=0;r<e.inboundNodes.length;++r){const s=uo.nodeKey(e,r);this.containerNodes.has(s)&&n.push(...e.calculateLosses())}return n})}getConfig(){const n={name:this.name},e=this.buildNodeConversionMap(this.layers),r=[];for(const i of this.layers){const a=i.getClassName(),l=i.getConfig(),u=[];for(let d=0;d<i.inboundNodes.length;d++){const h=i.inboundNodes[d],f=uo.nodeKey(i,d);let p={};if(this.containerNodes.has(f)){if(h.callArgs)try{JSON.stringify(h.callArgs),p=h.callArgs}catch{console.warn(`Layer ${i.name} was passed non-serializable keyword arguments: ${h.callArgs}. They will not be included in the serialized model (and thus will be missing at deserialization time).`),p={}}if(h.inboundLayers.length>0){const m=[];for(let g=0;g<h.inboundLayers.length;g++){const y=h.inboundLayers[g],v=h.tensorIndices[g];let w=e[uo.nodeKey(y,h.nodeIndices[g])];null==w&&(w=0),m.push([y.name,w,v,p])}u.push(m)}}}const c={};c.name=i.name,c.className=a,c.config=l,c.inboundNodes=u,r.push(c)}n.layers=r;const s=[];for(let i=0;i<this.inputLayers.length;i++){const a=this.inputLayers[i],u=uo.nodeKey(a,this.inputLayersNodeIndices[i]);if(!this.containerNodes.has(u))continue;let c=e[u];null==c&&(c=0),s.push([a.name,c,this.inputLayersTensorIndices[i]])}n.inputLayers=s;const o=[];for(let i=0;i<this.outputLayers.length;i++){const a=this.outputLayers[i],u=uo.nodeKey(a,this.outputLayersNodeIndices[i]);if(!this.containerNodes.has(u))continue;let c=e[u];null==c&&(c=0),o.push([a.name,c,this.outputLayersTensorIndices[i]])}return n.outputLayers=o,n}static fromConfig(n,e,r={},s=!1){const o={},i={};function a(g,y){g.name in i?i[g.name].push(y):i[g.name]=[y]}function l(g,y){const b=[];let v;for(const x of y){const w=x[0],_=x[1],D=x[2];if(v=x[3]??{},!(w in o))return void a(g,y);const A=o[w];if(A.inboundNodes.length<=_)return void a(g,y);b.push(A.inboundNodes[_].outputTensors[D])}b.length>0&&g.apply(Lr(b),v)}function u(g){const y=g.name,b=fi(g,null!=e.customObjects?e.customObjects:{});b.setFastWeightInitDuringBuild(s),o[y]=b,g.inboundNodes.forEach(x=>{if(!(x instanceof Array))throw new L(`Corrupted configuration, expected array for nodeData: ${x}`);a(b,x)})}const c=e.name,d=e.layers;for(const g of d)u(g);for(;!XJ(i);)for(const g of d){const y=o[g.name];if(y.name in i){const b=i[y.name];delete i[y.name];for(const v of b)l(y,v)}}const h=[],f=[],p=e.inputLayers;for(const g of p){const y=g[0],b=g[1],v=g[2];gs(y in o),h.push(o[y].inboundNodes[b].outputTensors[v])}const m=e.outputLayers;for(const g of m){const y=g[0],b=g[1],v=g[2];gs(y in o),f.push(o[y].inboundNodes[b].outputTensors[v])}return new n({inputs:h,outputs:f,name:c})}get stateful(){if(this._stateful)throw new L("Container instance unexpectedly has _stateful = true. The statefulness of a Container is determined by the Layers it contains. Its _stateful property must remain the default false.");for(const n of this.layers)if(n.stateful)return!0;return!1}resetStates(){U(()=>{this.layers.forEach(n=>{n.stateful&&n.resetStates()})})}}function GF(t,n){return function HF(t,n,e){const r=n.length;if(null==t||Array.isArray(t)&&0===t.length)return n.map(s=>null);if(1===r)return Array.isArray(t)&&1===t.length?t:"object"==typeof t&&n[0]in t?[t[n[0]]]:[t];if(Array.isArray(t)){if(t.length!==r)throw new Error(`Provided ${e} is an array of ${t.length} element(s), but the model has ${r} outputs. Make sure a set of weights is provided for each model output.`);return t}if("object"==typeof t&&Object.keys(t).length>0&&"object"==typeof t[Object.keys(t)[0]]){const s=[];return n.forEach(o=>{s.push(o in t?t[o]:null)}),s}throw new Error(`The model has multiple (${r}) outputs, so ${e} must be either an array with ${r} elements or an object with ${n} keys. Provided ${e} not understood: ${JSON.stringify(t)}`)}(t,n,"classWeight")}function jF(t,n,e,r){return tD.apply(this,arguments)}function tD(){return(tD=J(function*(t,n,e,r){if(null!=n||null!=r)throw new Error("Support sampleWeight is not implemented yet");if(null!=e){const s=U(()=>{if(1===t.shape.length)return t.clone();if(2===t.shape.length){if(t.shape[1]>1)return t.argMax(1);if(1===t.shape[1])return t.reshape([t.shape[0]]);throw new Error(`Encountered unexpected last-dimension size (${t.shape[1]}) during handling of class weights. The size is expected to be >= 1.`)}throw new Error(`Unexpected rank of target (y) tensor (${t.rank}) during handling of class weights. The rank is expected to be 1 or 2.`)}),o=Array.from(yield s.data());it(s);const i=[];return o.forEach(a=>{if(null==e[a])throw new Error(`classWeight must contain all classes in the training data. The class ${a} exists in the data but not in classWeight`);i.push(e[a])}),Os(i,"float32")}return null})).apply(this,arguments)}function ute(t,n){return V(t,n)}function qF(t,n){let e,r;e=n.xs,r=n.ys,S(null!=e&&null!=r,()=>`A Dataset iterator for fitDataset() is expected to generate objects of the form \`{xs: xVal, ys: yVal}\`, where the two values may be \`tf.Tensor\`, an array of Tensors, or a map of string to Tensor.  The provided Dataset instead generates ${n}`);const o=KF("input",t.inputNames,e),i=KF("output",t.outputNames,r),a=o[0].shape[0];S(o.length===t.inputs.length,()=>`LayersModel has ${t.inputs.length} inputs, but the dataset provides ${o.length} inputs.  (Expected input keys: ${JSON.stringify(t.inputNames)})`),S(i.length===t.outputs.length,()=>`LayersModel has ${t.outputs.length} outputs, but the dataset provides ${i.length} outputs.  (Expected output keys: ${JSON.stringify(t.outputNames)})`);for(let l=0;l<o.length;l++)S(o[l].shape[0]===a,()=>`Batch size mismatch: input ${t.inputNames[l]} has ${o[l].shape[0]}; expected  ${a} based on input ${t.inputNames[0]}.`);for(let l=0;l<i.length;l++)S(i[l].shape[0]===a,()=>`Batch size mismatch: output ${t.outputNames[l]} has ${i[l].shape[0]}; expected  ${a} based on input ${t.inputNames[0]}.`);return{xs:o,ys:i}}function KF(t,n,e){if(e instanceof an)return[e];if(Array.isArray(e))return S(e.length===n.length,()=>`Received an array of ${e.length} Tensors, but expected ${n.length} to match the ${t} keys ${n}.`),e;{const r=[];for(const s of n){if(null==e[s])throw new L(`The feature data generated by the dataset lacks the required ${t} key '${s}'.`);r.push(e[s])}return r}}function dte(t){if(3===t.length)throw new et("Validation with sample weights is not implemented yet.");return{xs:t[0],ys:t[1]}}function nD(){return(nD=J(function*(t,n,e){const r=null!=e.batchesPerEpoch;if(S(null!=t.optimizer,()=>"You must compile a model before training/testing. Use LayersModel.compile(modelCompileConfig)."),S(null!=e,()=>"For fitDataset(), the 2nd argument (config) is required, but it is not provided in this call."),S(null!=e.epochs&&e.epochs>0&&Number.isInteger(e.epochs),()=>`For fitDataset(), config.epochs is expected to be a positive integer, but got ${e.epochs}`),S(!r||e.batchesPerEpoch>0&&Number.isInteger(e.batchesPerEpoch),()=>`For fitDataset(), config.batchesPerEpoch is expected to be a positive integer if specified, but got ${e.batchesPerEpoch}`),S(null==e.validationSplit,()=>"`validationSplit` is not supported by `fitDataset()`. Use validationData instead."),t.isTraining)throw new Error("Cannot start training because another fit() call is ongoing.");t.isTraining=!0;try{const s=null!=e.validationData;let o,i;if(s)if(XF(e.validationData))S(null==e.validationBatches||e.validationBatches>0&&Number.isInteger(e.validationBatches),()=>`For fitDataset() with dataset-based validation, config.validationBatches is expected not to be provided, or to be a positive integer, but got ${e.validationBatches}`);else{const g=dte(e.validationData);o=g.xs,i=g.ys}const a=t.makeTrainFunction(),l=t.getDedupedMetricsNames();let u;u=s?l.slice().concat(l.map(g=>"val_"+g)):l.slice();const c=AF(e.callbacks,e.yieldEvery),d=e.verbose??1,{callbackList:h,history:f}=RF(c,d,e.epochs,null,null,fte(n,e),null,s,u);h.setModel(t),t.history=f,yield h.onTrainBegin(),t.stopTraining_=!1;let p=e.initialEpoch??0,m=yield n.iterator();for(;p<e.epochs;){const g={};yield h.onEpochBegin(p);let y=0,b=0;for(r||(m=yield n.iterator());!r||y<e.batchesPerEpoch;){const v=yield m.next();if(r&&v.done){console.warn(`You provided \`batchesPerEpoch\` as ${e.batchesPerEpoch}, but your dataset iterator ran out of data after ${y} batches; interrupting training. Make sure that your dataset can generate at least \`batchesPerEpoch * epochs\` batches (in this case, ${e.batchesPerEpoch*e.epochs} batches). You may need to use the repeat() function when building your dataset.`);break}if(null!=v.value){const{xs:x,ys:w}=qF(t,v.value),_={};_.batch=b,_.size=x[0].shape[0],yield h.onBatchBegin(b,_);const D=[];if(null!=e.classWeight){const O=GF(e.classWeight,t.outputNames);for(let G=0;G<O.length;++G)D.push(yield jF(w[G],null,O[G]))}const A=x.concat(w).concat(D),R=a(A);it(A);for(let O=0;O<l.length;++O){const K=R[O];_[l[O]]=K,ir(K)}yield h.onBatchEnd(b,_),kF(_),b++,y++}if(r?y>=e.batchesPerEpoch:v.done){if(s){let x;x=XF(e.validationData)?qt(yield t.evaluateDataset(e.validationData,{batches:e.validationBatches})):qt(t.evaluate(o,i,{batchSize:e.validationBatchSize??32,verbose:0}));for(let w=0;w<t.metricsNames.length;++w)g[`val_${t.metricsNames[w]}`]=x[w]}break}if(t.stopTraining_)break}if(yield h.onEpochEnd(p,g),p++,t.stopTraining_)break}return yield h.onTrainEnd(),yield t.history.syncData(),t.history}finally{t.isTraining=!1}})).apply(this,arguments)}function fte(t,n){let e=null;return null!=n.batchesPerEpoch?e=n.batchesPerEpoch:Number.isFinite(t.size)&&(e=t.size),e}function XF(t){return"function"==typeof t.iterator}function pte(t){return"function"==typeof t.next}function rD(){return(rD=J(function*(t,n,e){const r=null!=(e=e||{}).batches,s=t.testFunction;let o=[];if(e.verbose>0)throw new et("Verbose mode is not implemented yet.");S(!r||e.batches>0&&Number.isInteger(e.batches),()=>`Test loop expects \`batches\` to be a positive integer, but received ${JSON.stringify(e.batches)}`);const i=pte(n)?n:yield n.iterator();let a=0,l=0;for(;!r||l<e.batches;){const u=yield i.next();if(o=U(()=>{if(u.value){const{xs:c,ys:d}=qF(t,u.value),h=c.concat(d),f=U(()=>s(h));if(it(h),0===l)for(let m=0;m<f.length;++m)o.push(Fe(0));const p=h[0].shape[0];for(let m=0;m<f.length;++m){const g=f[m],y=o[m];o[m]=U(()=>me(o[m],V(p,g))),l>0&&it(y)}it(f),a+=p,++l}return o}),u.done){r&&console.warn(`Your dataset iterator ran out of data during evaluateDataset(). Interrupting evalution. Make sure that your dataset can generate at least \`batches\` batches (in this case, ${e.batches} batches). You may need to use the repeat() function when building your dataset.`);break}}for(let u=0;u<o.length;++u){const c=o[u];o[u]=Me(o[u],a),it(c)}return Lr(o)})).apply(this,arguments)}function sD(t){S(t>0&&Number.isInteger(t),()=>`batchSize is required to be a positive integer, but got ${t}`)}function Bh(t,n,e){return null==t?[null]:Array.isArray(t)?t.map(r=>Xa(r,n,e-n)):Xa(t,n,e-n)}function oD(t,n){return U(()=>null==t?null:Array.isArray(t)?t.map(e=>oD(e,n)):gF(t,"int32"===n.dtype?n:n.toInt()))}function iD(t,n){const e=[];let r=0,s=null;for(;r<t;)s=r+n,s>=t&&(s=t),e.push([r,s]),r=s;return e}function gte(t,n,e,r,s,o,i,a,l,u,c,d,h,f,p){return aD.apply(this,arguments)}function aD(){return(aD=J(function*(t,n,e,r,s,o,i,a,l,u,c,d,h,f,p){null==s&&(s=32),null==o&&(o=1),null==c&&(c=!0),null==h&&(h=0);let m=!1;if(null!=l&&null!=u&&(m=!0),null!=p&&(m=!0,null==f))throw new L("Can only use `validationSteps` when doing step-wise training, i.e., `stepsPerEpoch` must be set.");const g=t.checkNumSamples(e,s,f,"steps_per_epoch");let y;null!=g&&(y=lo(0,g)),null==i&&(i=1);const{callbackList:b,history:v}=RF(a,i,o,h,g,f,s,m,d);b.setModel(t),t.history=v,yield b.onTrainBegin(),t.stopTraining_=!1;for(let x=h;x<o;++x){yield b.onEpochBegin(x);const w={};if(null!=f)throw new et("stepsPerEpoch mode is not implemented yet.");{if("batch"===c)throw new et("batch shuffling is not implemneted yet");c&&HR(y);const _=Os(y),D=iD(g,s);for(let A=0;A<D.length;++A){const R={};if(yield b.onBatchBegin(A,R),U(()=>{const O=D[A][0],G=D[A][1],K=Xa(_,O,G-O);R.batch=A,R.size=G-O;const j=oD(e,K),Q=n(j);for(let q=0;q<r.length;++q){const re=Q[q];R[r[q]]=re,ir(re)}if(A===D.length-1&&m){const q=t.testLoop(l,u,s);for(let Y=0;Y<r.length;++Y){const re=r[Y],ee=q[Y];ir(ee),w["val_"+re]=ee}}}),yield b.onBatchEnd(A,R),kF(R),t.stopTraining_)break}_.dispose()}if(yield b.onEpochEnd(x,w),t.stopTraining_)break}return yield b.onTrainEnd(),yield t.history.syncData(),t.history})).apply(this,arguments)}function lD(){return(lD=J(function*(t,n,e,r={}){if(t.isTraining)throw new Error("Cannot start training because another fit() call is ongoing.");let s,o,i,a,l,u,c;t.isTraining=!0;try{const d=r.batchSize??32;sD(d);const h=!1,f=yield t.standardizeUserData(n,e,r.sampleWeight,r.classWeight,h,d);s=f[0],o=f[1],c=f[2];let m,p=!1;if(null!=r.validationData&&r.validationData.length>0){if(p=!0,2!==r.validationData.length)throw 3===r.validationData.length?new et("validationData including sample weights is not supported yet."):new L(`When passing validation data, it must contain 2 (valX, valY) or 3 (valX, valY, valSampleWeight) items; ${r.validationData} is invalid.`);i=r.validationData[0],a=r.validationData[1];const D=!0,A=yield t.standardizeUserData(i,a,null,null,D,d);l=A[0],u=A[1],m=l.concat(u)}else if(null!=r.validationSplit&&r.validationSplit>0&&r.validationSplit<1){p=!0;const D=Math.floor(s[0].shape[0]*(1-r.validationSplit)),A=s[0].shape[0];l=Bh(s,D,A),s=Bh(s,0,D),u=Bh(o,D,A),o=Bh(o,0,D),m=l.concat(u)}else null!=r.validationSteps&&(p=!0);const g=s.concat(o).concat(c);t.checkTrainableWeightsConsistency();const y=t.makeTrainFunction(),b=t.getDedupedMetricsNames();let v,x;p?(t.makeTestFunction(),v=t.testFunction,x=b.slice().concat(b.map(D=>"val_"+D))):(v=null,m=[],x=b.slice());const w=AF(r.callbacks,r.yieldEvery);return yield gte(t,y,g,b,d,r.epochs,r.verbose,w,v,m,r.shuffle,x,r.initialEpoch,null,null)}finally{t.isTraining=!1,Ya(s,n),Ya(o,e),Ya(l,i),Ya(u,a),null!=c&&it(c)}})).apply(this,arguments)}function YF(t){const n=[];t instanceof an&&(t=[t]);for(let e=0;e<t.length;++e){const r=t[e];if(1===r.rank)n.push(Fh(r,1));else{if(0===r.rank)throw new Error("Expected tensor to be at least 1D, but received a 0D tensor (scalar).");n.push(r)}}return n}function Ya(t,n){if(null==t)return;const e=[];if(n instanceof an)e.push(n.id);else if(Array.isArray(n))n.forEach(s=>e.push(s.id));else if(null!=n)for(const s in n)e.push(n[s].id);const r=[];if(t instanceof an)-1===e.indexOf(t.id)&&r.push(t);else if(Array.isArray(t))t.forEach(s=>{-1===e.indexOf(s.id)&&r.push(s)});else if(null!=t)for(const s in t){const o=t[s];-1===e.indexOf(o.id)&&r.push(o)}r.forEach(s=>{s.isDisposed||s.dispose()})}function uD(t){return Array.isArray(t)}function ZF(t){return!function bte(t){return t instanceof an}(t)&&!uD(t)}function QF(t,n,e,r=!0,s=""){if(null==n||0===n.length){if(null!=t){let i=!1;if(uD(t)&&t.length>0)i=!0;else if(ZF(t)){for(const a in t)if(t.hasOwnProperty(a)){i=!0;break}}else i=!0;if(i)throw new L(`Error when checking model ${s} expected no data, but got ${t}`)}return[]}if(null==t)return n.map(i=>null);let o;if(ZF(t)){o=[];for(const i of n){if(null==t[i])throw new L(`No data provided for "${i}". Need data for each key in: ${n}`);o.push(t[i])}}else if(uD(t)){if(t.length!==n.length)throw new L(`Error when checking model ${s}: the Array of Tensors that you are passing to your model is not the size the model expected. Expected to see ${n.length} Tensor(s), but instead got the following list of Tensor(s): ${t}`);o=t}else{if(n.length>1)throw new L(`The model ${s} expects ${n.length} Tensor(s), but only received one Tensor. Found: Tensor with shape ${t.shape}`);o=[t]}if(o=YF(o),null!=e)for(let i=0;i<n.length;++i){if(null==e[i])continue;const a=o[i];if(a.shape.length!==e[i].length)throw new L(`Error when checking ${s}: expected ${n[i]} to have ${e[i].length} dimension(s). but got array with shape ${a.shape}`);for(let l=0;l<e[i].length;++l){if(0===l&&!r)continue;const u=a.shape[l],c=e[i][l];if(null!=c&&c>=0&&u!==c)throw new L(`Error when checking ${s}: expected ${n[i]} to have shape [${e[i]}], but got array with shape [${a.shape}].`)}}return o}function JF(t,n,e,r=!0,s=""){let o;if(Array.isArray(t)){if(t.length!==n.length)throw new L(`Error when checking model ${s}: the Array of Tensors that you are passing to your model is not the size the the model expected. Expected to see ${n.length} Tensor(s), but instead got ${t.length} Tensors(s).`);o=t}else{if(n.length>1)throw new L(`The model expects ${n.length} ${s} Tensors, but only received one Tensor. Found: array with shape ${JSON.stringify(t.shape)}.`);o=[t]}if(null!=e)for(let i=0;i<n.length;++i){if(null==e[i])continue;const a=o[i];if(a.shape.length!==e[i].length)throw new L(`Error when checking ${s}: expected ${n[i]} to have ${e[i].length} dimension(s), but got array with shape ${JSON.stringify(a.shape)}`);for(let l=0;l<e[i].length;++l){if(0===l&&!r)continue;const u=a.shape[l],c=e[i][l];if(null!=c&&c!==u)throw new L(`Error when checking ${s}: expected ${n[i]} to have shape ${JSON.stringify(e[i])} but got array with shape ${JSON.stringify(a.shape)}.`)}}}let Eu=(()=>{class t extends uo{constructor(e){super(e),this.isTraining=!1}summary(e,r,s=console.log){if(!this.built)throw new L("This model has never been called, thus its weights have not been created yet. So no summary can be displayed. Build the model first (e.g., by calling it on some test data).");!function ete(t,n,e,r=console.log){const s=function nte(t){let n=!0;const e=[],r=[];for(const s in t.nodesByDepth)e.push(t.nodesByDepth[s]);for(const s of e){if(s.length>1||1===s.length&&s[0].inboundLayers.length>1){n=!1;break}r.push(...s)}if(n)for(const s of t.layers){let o=!1;for(const i of s.inboundNodes)if(-1!==r.indexOf(i)){if(o){n=!1;break}o=!0}if(!n)break}return n}(t),o=["Layer (type)","Output shape","Param #"];let i;if(s?(n=n||65,e=e||[.45,.85,1]):(n=n||98,e=e||[.33,.55,.67,1]),e[e.length-1]<=1&&(e=e.map(c=>Math.floor(n*c))),!s){o.push("Receives inputs"),i=[];for(const c in t.nodesByDepth)i.push(...t.nodesByDepth[c])}r("_".repeat(n)),cy(o,e,r),r("=".repeat(n));const a=t.layers;for(let c=0;c<a.length;++c)s?rte(a[c],e,r):ste(a[c],e,i,r),r((c===a.length-1?"=":"_").repeat(n));t.checkTrainableWeightsConsistency();const l=function tte(t){let n;return n=ey(null!=t.collectedTrainableWeights?t.collectedTrainableWeights:t.trainableWeights),n}(t),u=ey(t.nonTrainableWeights);r(`Total params: ${l+u}`),r(`Trainable params: ${l}`),r(`Non-trainable params: ${u}`),r("_".repeat(n))}(this,e,r,s)}compile(e){if(null==e.loss&&(e.loss=[]),this.loss=e.loss,"string"==typeof e.optimizer)this.optimizer_=function Jee(t){const n={Adagrad:()=>Cu.adagrad(.01),Adadelta:()=>Cu.adadelta(1,.95,Bn()),Adam:()=>Cu.adam(.001,.9,.999,Bn()),Adamax:()=>Cu.adamax(.002,.9,.999,Bn(),0),RMSProp:()=>Cu.rmsprop(.001,.9,0,Bn()),SGD:()=>Cu.sgd(.01)};if(n.adagrad=n.Adagrad,n.adadelta=n.Adadelta,n.adam=n.Adam,n.adamax=n.Adamax,n.rmsprop=n.RMSProp,n.sgd=n.SGD,t in n)return n[t]();throw new L(`Unknown Optimizer ${t}`)}(e.optimizer),this.isOptimizerOwned=!0;else{if(!(e.optimizer instanceof Li))throw new L("User-defined optimizer must be an instance of tf.Optimizer.");this.optimizer_=e.optimizer,this.isOptimizerOwned=!1}let r=[];if(Array.isArray(e.loss)||"string"==typeof e.loss||"function"==typeof e.loss)if(Array.isArray(e.loss)){if(e.loss.length!==this.outputs.length)throw new L(`When passing an Array as loss, it should have one entry per model output. The model has ${this.outputs.length} output(s), but you passed loss=${e.loss}.`);r=e.loss.map(l=>XI(l))}else{const a=XI(e.loss);this.outputs.forEach(l=>{r.push(a)})}else{e.loss=e.loss;for(const a in e.loss)if(-1===this.outputNames.indexOf(a))throw new L(`Unknown entry in loss dictionary: "${a}". Only expected the following keys: ${this.outputNames}`);for(const a of this.outputNames)null==e.loss[a]&&console.warn(`Output "${a}" is missing from loss dictionary. We assume this was done on purpose, and we will not be expecting data to be passed to ${a} during training`),r.push(XI(e.loss[a]))}this.lossFunctions=r,this.feedOutputNames=[],this.feedOutputShapes=[],this.feedLossFns=[];for(let a=0;a<this.outputs.length;++a){const l=this.internalOutputShapes[a];this.feedOutputNames.push(this.outputNames[a]),this.feedOutputShapes.push(l),this.feedLossFns.push(this.lossFunctions[a])}const s=[];this.metrics=e.metrics,this.metricsNames=["loss"],this.metricsTensors=[],Ka("loss",()=>{for(let a=0;a<this.outputs.length;++a){if(-1!==s.indexOf(a))continue;const l=this.lossFunctions[a];this.outputs.length>1&&(this.metricsTensors.push([l,a]),this.metricsNames.push(this.outputNames[a]+"_loss"))}});const o=function wte(t,n){if(null==t||Array.isArray(t)&&0===t.length)return n.map(r=>[]);let e;if("string"==typeof t||"function"==typeof t)e=[t];else{if(!Array.isArray(t)&&"object"!=typeof t)throw new TypeError(`Type of metrics argument not understood. Expected an string,function, Array, or Object, found: ${t}`);e=t}if(Array.isArray(e))return n.map(r=>e);{const r=[];for(const s of n){let o=e.hasOwnProperty(s)?e[s]:[];Array.isArray(o)||(o=[o]),r.push(o)}return r}}(e.metrics,this.outputNames),i=(a,l,u)=>{this.outputNames.length>1&&(l=this.outputNames[a]+"_"+l),this.metricsNames.push(l),this.metricsTensors.push([u,a])};Ka("metric",()=>{for(let a=0;a<this.outputs.length;++a)-1===s.indexOf(a)&&(c=>{let h,f,p;for(const m of c){if("string"==typeof m&&-1!==["accuracy","acc","crossentropy","ce"].indexOf(m)){const y=this.internalOutputShapes[a];let b;1===y[y.length-1]||this.lossFunctions[a]===iy?-1!==["accuracy","acc"].indexOf(m)?f=FF:-1!==["crossentropy","ce"].indexOf(m)&&(f=Wee):this.lossFunctions[a]===oy?-1!==["accuracy","acc"].indexOf(m)?f=Hee:-1!==["crossentropy","ce"].indexOf(m)&&(f=LF):-1!==["accuracy","acc"].indexOf(m)?f=OF:-1!==["crossentropy","ce"].indexOf(m)&&(f=PF),-1!==["accuracy","acc"].indexOf(m)?b="acc":-1!==["crossentropy","ce"].indexOf(m)&&(b="ce"),p=f,h=""+b}else p=Qee(m),h=""+uy(m);let g;Ka(h,()=>{g=p}),i(a,h,g)}})(o[a])}),this.collectedTrainableWeights=this.trainableWeights}checkTrainableWeightsConsistency(){null!=this.collectedTrainableWeights&&this.trainableWeights.length!==this.collectedTrainableWeights.length&&console.warn("Discrepancy between trainableweights and collected trainable weights. Did you set `model.trainable` without calling `model.compile()` afterwards?")}evaluate(e,r,s={}){const o=s.batchSize??32;sD(o);const a=this.standardizeUserDataXY(e,r,!0,o);try{const l=a[0].concat(a[1]);return this.makeTestFunction(),Lr(this.testLoop(this.testFunction,l,o,s.verbose,s.steps))}finally{Ya(a[0],e),Ya(a[1],r)}}evaluateDataset(e,r){var s=this;return J(function*(){return s.makeTestFunction(),function mte(t,n,e){return rD.apply(this,arguments)}(s,e,r)})()}checkNumSamples(e,r,s,o="steps"){let i;if(null!=s){if(i=null,null!=r)throw new L(`If ${o} is set, batchSize must be null or undefined.Got batchSize = ${r}`)}else{if(null==e)throw new L(`Either the input data should have a defined shape, or ${o} shoud be specified.`);i=Array.isArray(e)?e[0].shape[0]:e.shape[0]}return i}execute(e,r){if(Array.isArray(r)&&0===r.length)throw new L("`outputs` is an empty Array, which is not allowed.");const s=Array.isArray(r),i=this.retrieveSymbolicTensors(s?r:[r]),a=new ji;if(e instanceof an&&(e=[e]),Array.isArray(e)){if(e.length!==this.inputs.length)throw new L(`The number of inputs provided (${e.length}) does not match the number of inputs of this model (${this.inputs.length}).`);for(let u=0;u<this.inputs.length;++u)a.add(this.inputs[u],e[u])}else for(const u of this.inputs){const c=e[u.name];if(null==c)throw new L(`No value is provided for the model's input ${u.name}`);a.add(u,c)}const l=Lh(i,a);return s?l:l[0]}retrieveSymbolicTensors(e){const r=Ga(null,e.length);let s=e.length;for(const o of this.layers){const i=Array.isArray(o.output)?o.output:[o.output],a=i.map(l=>l.name);for(let l=0;l<e.length;++l){const u=a.indexOf(e[l]);if(-1!==u&&(r[l]=i[u],s--),0===s)break}if(0===s)break}if(s>0){const o=[];throw r.forEach((i,a)=>{null==i&&o.push(e[a])}),new L(`Cannot find SymbolicTensors for output name(s): ${JSON.stringify(o)}`)}return r}predictLoop(e,r=32,s=!1){return U(()=>{const o=this.checkNumSamples(e);if(s)throw new et("Verbose predictLoop() is not implemented yet.");const i=iD(o,r),a=this.outputs.map(l=>[]);for(let l=0;l<i.length;++l)U(()=>{const h=Bh(e,i[l][0],i[l][1]),f=[];if(Array.isArray(h))for(let m=0;m<h.length;++m)f.push({key:this.inputs[m],value:h[m]});else f.push({key:this.inputs[0],value:h});const p=new ji(f);return Lh(this.outputs,p)}).forEach((c,d)=>a[d].push(c));return Lr(a.map(l=>Sn(l,0)))})}predict(e,r={}){const s=YF(e);JF(s,this.inputNames,this.feedInputShapes,!1);try{const o=r.batchSize??32;return sD(o),this.predictLoop(s,o)}finally{Ya(s,e)}}predictOnBatch(e){JF(e,this.inputNames,this.feedInputShapes,!0);const r=(Array.isArray(e)?e[0]:e).shape[0];return this.predictLoop(e,r)}standardizeUserDataXY(e,r,s=!0,o){if(null==this.optimizer_)throw new Ms("You must compile a model before training/testing. Use LayersModel.compile(modelCompileArgs).");const i=[];for(let a=0;a<this.feedOutputShapes.length;++a){const l=this.feedOutputShapes[a];i.push(this.feedLossFns[a]===oy?l.slice(0,l.length-1).concat([1]):l)}if(function vte(t,n,e){const r=Ui(t.map(o=>o.shape[0]));r.sort();const s=Ui(n.map(o=>o.shape[0]));if(s.sort(),r.length>1)throw new L(`All input Tensors (x) should have the same number of samples. Got array shapes: ${JSON.stringify(t.map(o=>o.shape))}`);if(s.length>1)throw new L(`All target Tensors (y) should have the same number of samples. Got array shapes: ${JSON.stringify(n.map(o=>o.shape))}`);if(r.length>0&&s.length>0&&!Mt(r,s))throw new L(`Input Tensors should have the same number of samples as target Tensors. Found ${r[0]} input sample(s) and ${s[0]} target sample(s).`)}(e=QF(e,this.feedInputNames,this.feedInputShapes,!1,"input"),r=QF(r,this.feedOutputNames,i,!1,"target")),function xte(t,n,e){const r=[sy,iy,Ph];for(let s=0;s<t.length;++s){const o=t[s],i=n[s],a=e[s];if(null!=i){if(i===Ph&&1===o.shape[o.shape.length-1])throw new L(`You are passing a target array of shape ${o.shape} while using a loss 'categorical_crossentropy'. 'categorical_crossentropy'expects targets to be binary matrices (1s and 0s) of shape [samples, classes].`);if(-1!==r.indexOf(i)){const l=o.shape.slice(1),u=a.slice(1);for(let c=0;c<l.length;++c){const d=l[c],h=u[c];if(null!=h&&d!==h)throw new L(`A target Tensor with shape ${o.shape} was passed for an output of shape ${a}, while using a loss function that expects targets to have the same shape as the output.`)}}}}}(r,this.feedLossFns,this.feedOutputShapes),this.stateful&&null!=o&&o>0&&e[0].shape[0]%o!=0)throw new L(`In a stateful network, you should only pass inputs with a number of samples that is divisible by the batch size ${o}. Found: ${e[0].shape[0]} sample(s).`);return[e,r]}standardizeUserData(e,r,s,o,i=!0,a){var l=this;return J(function*(){const[u,c]=l.standardizeUserDataXY(e,r,i,a);if(null!=s)throw new Error("sample weight is not supported yet.");let d=null;if(null!=o){const h=GF(o,l.outputNames);d=[];for(let f=0;f<h.length;++f)d.push(yield jF(c[f],null,h[f]))}return[u,c,d]})()}testLoop(e,r,s,o=0,i){return U(()=>{const a=this.checkNumSamples(r,s,i,"steps"),l=[];if(o>0)throw new et("Verbose mode is not implemented yet.");if(null!=i)throw new et("steps mode in testLoop() is not implemented yet");{const u=iD(a,s),c=Os(lo(0,a));for(let d=0;d<u.length;++d){const h=u[d][0],f=u[d][1],p=Xa(c,h,f-h),m=oD(r,p),g=e(m);if(0===d)for(let y=0;y<g.length;++y)l.push(Fe(0));for(let y=0;y<g.length;++y)l[y]=me(l[y],V(f-h,g[y]))}for(let d=0;d<l.length;++d)l[d]=Me(l[d],a)}return l})}getDedupedMetricsNames(){const e=this.metricsNames,r=[];for(let s=0;s<e.length;++s){const o=e[s];let i=o;sF(e,o)>1&&(i+=`_${sF(e.slice(0,s),o)}`),r.push(i)}return r}makeTrainFunction(){return e=>{const r=[],s=e.slice(0,this.inputs.length),o=e.slice(this.inputs.length,this.inputs.length+this.outputs.length),i=e.slice(this.inputs.length+this.outputs.length,this.inputs.length+2*this.outputs.length),a=[],u=this.collectedTrainableWeights.map(h=>h.read());return[this.optimizer_.minimize(()=>{const h=[];for(let g=0;g<this.inputs.length;++g)h.push({key:this.inputs[g],value:s[g]});const f=new ji(h),p=Lh(this.outputs,f,{training:!0});let m;for(let g=0;g<this.lossFunctions.length;++g){let b=(0,this.lossFunctions[g])(o[g],p[g]);null!=i[g]&&(b=ute(b,i[g]));const v=pn(b);r.push(v),m=0===g?b:me(m,b)}for(let g=0;g<this.metricsTensors.length;++g){let y;if(this.outputs.length>1&&g<this.outputs.length)y=r[g];else{const v=this.metricsTensors[g][1];y=pn((0,this.metricsTensors[g][0])(o[v],p[v]))}ir(y),a.push(y)}return m=pn(m),this.calculateLosses().forEach(g=>{m=me(m,g)}),m},!0,u)].concat(a)}}makeTestFunction(){this.testFunction=e=>U(()=>{const r=[];let s;const o=e.slice(0,this.inputs.length),i=e.slice(this.inputs.length,this.inputs.length+this.outputs.length),a=[];for(let c=0;c<this.inputs.length;++c)a.push({key:this.inputs[c],value:o[c]});const l=new ji(a),u=Lh(this.outputs,l);for(let c=0;c<this.lossFunctions.length;++c){const h=pn((0,this.lossFunctions[c])(i[c],u[c]));s=0===c?h:me(s,h),r.push(s)}for(let c=0;c<this.metricsTensors.length;++c){const h=this.metricsTensors[c][1],f=pn((0,this.metricsTensors[c][0])(i[h],u[h]));r.push(f)}return r})}fit(e,r,s={}){var o=this;return J(function*(){return function yte(t,n,e){return lD.apply(this,arguments)}(o,e,r,s)})()}fitDataset(e,r){var s=this;return J(function*(){return function hte(t,n,e){return nD.apply(this,arguments)}(s,e,r)})()}trainOnBatch(e,r){var s=this;return J(function*(){const o=yield s.standardizeUserData(e,r),i=o[0],a=o[1],u=s.makeTrainFunction()(i.concat(a)),c=[];for(const d of u){const h=yield d.data();c.push(h[0])}return it(u),Lr(c)})()}getNamedWeights(e){const r=[],s=null!=e&&e.trainableOnly,o=s?this.trainableWeights:this.weights,i=this.getWeights(s);for(let a=0;a<o.length;++a)s&&!o[a].trainable||r.push({name:o[a].originalName,tensor:i[a]});return r}set stopTraining(e){this.stopTraining_=e}get stopTraining(){return this.stopTraining_}get optimizer(){return this.optimizer_}set optimizer(e){this.optimizer_!==e&&(this.optimizer_=e,this.isOptimizerOwned=!1)}dispose(){const e=super.dispose();if(0===e.refCountAfterDispose&&null!=this.optimizer&&this.isOptimizerOwned){const r=xC().numTensors;this.optimizer_.dispose(),e.numDisposedVariables+=r-xC().numTensors}return e}getLossIdentifiers(){let e;if("string"==typeof this.loss)e=hi(this.loss);else if(Array.isArray(this.loss)){for(const r of this.loss)if("string"!=typeof r)throw new Error("Serialization of non-string loss is not supported.");e=this.loss.map(r=>hi(r))}else{const r=Object.keys(this.loss);e={};const s=this.loss;for(const o of r){if("string"!=typeof s[o])throw new Error("Serialization of non-string loss is not supported.");e[o]=hi(s[o])}}return e}getMetricIdentifiers(){if("string"==typeof this.metrics||"function"==typeof this.metrics)return[hi(uy(this.metrics))];if(Array.isArray(this.metrics))return this.metrics.map(e=>hi(uy(e)));{const e={};for(const r in this.metrics)e[r]=hi(uy(this.metrics[r]));return e}}getTrainingConfig(){return{loss:this.getLossIdentifiers(),metrics:this.getMetricIdentifiers(),optimizer_config:{class_name:this.optimizer.getClassName(),config:this.optimizer.getConfig()}}}loadTrainingConfig(e){if(null!=e.weighted_metrics)throw new Error("Loading weight_metrics is not supported yet.");if(null!=e.loss_weights)throw new Error("Loading loss_weights is not supported yet.");if(null!=e.sample_weight_mode)throw new Error("Loading sample_weight_mode is not supported yet.");const s=fi(ZI(e.optimizer_config));let o,i;if("string"==typeof e.loss)o=ja(e.loss);else if(Array.isArray(e.loss))o=e.loss.map(a=>ja(a));else if(null!=e.loss){o={};for(const a in e.loss)o[a]=ja(e.loss[a])}if(Array.isArray(e.metrics))i=e.metrics.map(a=>ja(a));else if(null!=e.metrics){i={};for(const a in e.metrics)i[a]=ja(e.metrics[a])}this.compile({loss:o,metrics:i,optimizer:s})}save(e,r){var s=this;return J(function*(){if("string"==typeof e){const d=x$(e);if(0===d.length)throw new L(`Cannot find any save handlers for URL '${e}'`);if(d.length>1)throw new L(`Found more than one (${d.length}) save handlers for URL '${e}'`);e=d[0]}if(null==e.save)throw new L("LayersModel.save() cannot proceed because the IOHandler provided does not have the `save` attribute defined.");const o=yield g$(s.getNamedWeights(r)),u={modelTopology:s.toJSON(null,!1),format:"layers-model",generatedBy:"TensorFlow.js tfjs-layers v3.3.0",convertedBy:null};if(null!=r&&r.includeOptimizer&&null!=s.optimizer){u.trainingConfig=s.getTrainingConfig();const d="optimizer",{data:h,specs:f}=yield g$(yield s.optimizer.getWeights(),d);o.specs.push(...f),o.data=eC([o.data,h])}return null!=s.userDefinedMetadata&&(zF(s.userDefinedMetadata,s.name,!0),u.userDefinedMetadata=s.userDefinedMetadata),u.weightData=o.data,u.weightSpecs=o.specs,e.save(u)})()}setUserDefinedMetadata(e){zF(e,this.name),this.userDefinedMetadata=e}getUserDefinedMetadata(){return this.userDefinedMetadata}}return t.className="Model",t})();le(Eu),le((()=>{class t extends Eu{}return t.className="Functional",t})()),le((()=>{class t extends Eu{constructor(e){if(super({inputs:[],outputs:[]}),e=e||{},this.trainable=!0,this.built=!1,this.name=null!=e.name?e.name:Qg("sequential_"),null!=e.layers)for(const r of e.layers)this.add(r)}checkShape(e){if(e.inboundNodes[0].outputTensors[0].shape.some(s=>s<0))throw new L(`Negative dimension size caused by adding layer ${e.name} with input shape [${e.inboundNodes[0].inputTensors[0].shape}]`)}add(e){const r=e instanceof t||e instanceof Eu;let s;if(r){if(s=e,1!==s.outputs.length)throw new L("All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.");if(1!==s.inputs.length)throw new L("All layers in a Sequential model should have a single input tensor. For multi-input layers, use the functional API.")}if(0===this.outputs.length){if(0===e.inboundNodes.length){if(null==e.batchInputShape)throw new L("The first layer in a Sequential model must get an `inputShape` or `batchInputShape` argument.");const o=function _ee(t){if(null==t.batchShape&&null==t.shape)throw new Error("Please provide to Input either a `shape` or a `batchShape` argument. Note that `shape` does not include the batch dimension.");if(null!=t.batchShape&&null!=t.shape)throw new L("Please provide either a `shape` or `batchShape` argument to Input, but not both.");let n=t.batchShape;null!=t.shape&&null==n&&(n=[null].concat(t.shape));let e=t.dtype;return null==e&&(e="float32"),new ny({batchInputShape:n,name:t.name,dtype:e,sparse:t.sparse}).inboundNodes[0].outputTensors[0]}({batchShape:e.batchInputShape,dtype:e.dtype,name:e.name+"_input"});e.apply(o)}if(r)this.outputs=s.outputs,this.inputs=s.inputs;else{if(1!==e.inboundNodes.length)throw new L(`A layer added to a Sequential model must not already be connected somewhere else. LayersModel received layer ${e.name} which has ${e.inboundNodes.length} pre-existing inbound connections.`);if(1!==e.inboundNodes[0].outputTensors.length)throw new L("All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.");this.checkShape(e),this.outputs=[e.inboundNodes[0].outputTensors[0]],this.inputs=TF(this.outputs[0])}this.inboundNodes=[],new ty({outboundLayer:this,inboundLayers:[],nodeIndices:[],tensorIndices:[],inputTensors:this.inputs,outputTensors:this.outputs,inputMasks:Ga(null,this.inputs.length),outputMasks:[null],inputShapes:this.inputs.map(o=>o.shape),outputShapes:this.outputs[0].shape})}else{const o=e.apply(this.outputs[0]);if(Array.isArray(o))throw new TypeError("All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.");this.checkShape(e),this.outputs=[o],this.inboundNodes[0].outputTensors=this.outputs,this.inboundNodes[0].outputShapes=[this.outputs[0].shape]}this.layers.push(e),this.built=!1}pop(){if(0===this.layers.length)throw new TypeError("There are no layers in the model.");if(this.layers.pop(),0===this.layers.length)this.outputs=[],this.inboundNodes=[],this.outboundNodes=[];else{const e=this.layers.length-1;this.layers[e].outboundNodes=[],this.outputs=[this.layers[e].output],this.inboundNodes[0].outputTensors=this.outputs,this.inboundNodes[0].outputShapes=[this.outputs[0].shape]}}call(e,r){return null==this.model&&this.build(),this.model.call(e,r)}build(e){if(Vt(e),0===this.inputs.length||0===this.outputs.length)throw new TypeError("Sequential model cannot be built: model is empty. Add some layers first.");this.model=new Eu({inputs:this.inputs,outputs:this.outputs[0],name:this.name+"_model"}),this.model.trainable=this.trainable,this.supportsMasking=this.model.supportsMasking,this.inputLayers=this.model.inputLayers,this.inputLayersNodeIndices=this.model.inputLayersNodeIndices,this.inputLayersTensorIndices=this.model.inputLayersTensorIndices,this.outputLayers=this.model.outputLayers,this.outputLayersNodeIndices=this.model.outputLayersNodeIndices,this.outputLayersTensorIndices=this.model.outputLayersTensorIndices,this.nodesByDepth=this.model.nodesByDepth,this.containerNodes=this.model.containerNodes,this.outputNames=this.model.outputNames,this.inputNames=this.model.inputNames,this.built=!0}countParams(){return this.built||this.build(),super.countParams()}summary(e,r,s=console.log){this.built||this.build(),super.summary(e,r,s)}setWeights(e){null==this.model&&this.build(),this.model.setWeights(e)}evaluate(e,r,s={}){if(!this.built)throw new Ms("The model needs to be compiled before being used.");return this.model.evaluate(e,r,s)}evaluateDataset(e,r){var s=this;return J(function*(){if(!s.built)throw new Ms("The model needs to be compiled before being used.");return s.model.evaluateDataset(e,r)})()}predict(e,r={}){return null==this.model&&this.build(),this.model.predict(e,r)}predictOnBatch(e){return null==this.model&&this.build(),this.model.predictOnBatch(e)}compile(e){this.build(),this.model.compile(e),this.optimizer_=this.model.optimizer,this.isOptimizerOwned=this.model.isOptimizerOwned,this.loss=this.model.loss,this.metrics=this.model.metrics,this.metricsTensors=this.model.metricsTensors,this.metricsNames=this.model.metricsNames}get optimizer(){return null==this.model?void 0:this.model.optimizer}set optimizer(e){this.model.optimizer=e}fit(e,r,s={}){var o=this;return J(function*(){if(!o.built)throw new Ms("The model needs to be compiled before being used.");return o.model.fit(e,r,s)})()}fitDataset(e,r){var s=this;return J(function*(){if(!s.built)throw new Ms("The model needs to be compiled before being used.");return s.model.fitDataset(e,r)})()}trainOnBatch(e,r){var s=this;return J(function*(){return s.model.trainOnBatch(e,r)})()}static fromConfig(e,r,s={},o=!1){let i,a={};if(r instanceof Array){if(null==r[0].className||"Merge"===r[0].className)throw new L("Legacy serialization format not supported yet.");i=r}else S(null!=r.layers,()=>"When the config data for a Sequential model is not an Array, it must be an Object that contains the 'layers' field."),i=r.layers,delete r.layers,a=r;const l=new e(a);if(!(l instanceof t))throw new et(`Sequential.fromConfig called on non-Sequential input: ${l}`);for(const u of i){const d=fi(u,void 0,o);o&&d.setFastWeightInitDuringBuild(!0),l.add(d)}return l}set stopTraining(e){if(null==this.model)throw new L("Cannot set the stopTraining property of a sequential model before it is compiled.");this.model.stopTraining=e}get stopTraining(){if(null==this.model)throw new L("Cannot get the stopTraining property of a sequential model before it is compiled.");return this.model.stopTraining}getConfig(){const e=[];for(const r of this.layers){const s={};s.className=r.getClassName(),s.config=r.getConfig(),e.push(s)}return{name:this.name,layers:e}}}return t.className="Sequential",t})());class Xr extends fu{getConfig(){return{}}}le((()=>{class t extends Xr{apply(e,r=1){return function dee(t,n=1){if(1!==n)throw new et(`Support for alpha values other than 1 (${n}) is not implemented yet.`);return mh(t)}(e,r)}}return t.className="elu",t})()),le((()=>{class t extends Xr{apply(e){return FC(e)}}return t.className="selu",t})()),le((()=>{class t extends Xr{apply(e){return ai(e)}}return t.className="relu",t})()),le((()=>{class t extends Xr{apply(e){return U(()=>xh(6,ai(e)))}}return t.className="relu6",t})()),le((()=>{class t extends Xr{apply(e){return e}}return t.className="linear",t})()),le((()=>{class t extends Xr{apply(e){return bu(e)}}return t.className="sigmoid",t})()),le((()=>{class t extends Xr{apply(e){return function fee(t){return U(()=>{const n=me(.5,V(.2,t));return Kr(n,0,1)})}(e)}}return t.className="hardSigmoid",t})()),le((()=>{class t extends Xr{apply(e){return Ch(e)}}return t.className="softplus",t})()),le((()=>{class t extends Xr{apply(e){return function hee(t){return U(()=>Me(t,Yn(t).add(1)))}(e)}}return t.className="softsign",t})()),le((()=>{class t extends Xr{apply(e){return PC(e)}}return t.className="tanh",t})());let eO=(()=>{class t extends Xr{apply(e,r=-1){return Tg(e,r)}}return t.className="softmax",t})();function qi(t){return t.getClassName()}function fD(t,n={}){return kh(t,Ts.getMap().classNameMap,n,"activation")}function Ki(t){if(null==t){return fD({className:"linear",config:{}})}if("string"==typeof t){const n={};return n.className=t,n.config={},fD(n)}return t instanceof Xr?t:fD(t)}le(eO),le((()=>{class t extends Xr{apply(e,r=-1){return NC(e,r)}}return t.className="logSoftmax",t})()),le((()=>{class t extends Xr{apply(e,r=1){return U(()=>bu(e.mul(r)).mul(e))}}return t.className="swish",t})());class tO extends fu{}le((()=>{class t extends tO{constructor(e){super(),function pD(t){if(null!=t&&"object"!=typeof t)throw new Error(`Argument to L1L2 regularizer's constructor is expected to be an object, but received: ${t}`)}(e),this.l1=null==e||null==e.l1?.01:e.l1,this.l2=null==e||null==e.l2?.01:e.l2,this.hasL1=0!==this.l1,this.hasL2=0!==this.l2}apply(e){return U(()=>{let r=Nn([1]);return this.hasL1&&(r=me(r,Oe(V(this.l1,Yn(e))))),this.hasL2&&(r=me(r,Oe(V(this.l2,Oh(e))))),r.asScalar()})}getConfig(){return{l1:this.l1,l2:this.l2}}static fromConfig(e,r){return new e({l1:r.l1,l2:r.l2})}}return t.className="L1L2",t})());const nO={l1l2:"L1L2"};function Ut(t){return OI(t)}function rO(t,n={}){return kh(t,Ts.getMap().classNameMap,n,"regularizer")}function rn(t){return null==t?null:"string"==typeof t?rO({className:t in nO?nO[t]:t,config:{}}):t instanceof tO?t:rO(t)}function Nu(t,n,e){if("number"==typeof t)return Ga(t,n);if(t.length!==n)throw new L(`The ${e} argument must be an integer or tuple of ${n} integers. Received: ${t.length} elements.`);for(let r=0;r<n;++r){const s=t[r];if(!oee(s))throw new L(`The ${e} argument must be an integer or tuple of ${n} integers. Received: ${JSON.stringify(t)} including a non-integer number ${s}`)}return t}function co(t,n,e,r,s=1){if(null==t)return t;let i;return i="same"===e?t:t-(n+(n-1)*(s-1))+1,Math.floor((i+r-1)/r)}function dy(t,n,e,r){if(null==t)return null;if("valid"===r)t=t*n+Hi([e-n,0]);else{if("same"!==r)throw new L(`Unsupport padding mode: ${r}.`);t*=n}return t}function gD(t,n){return U(()=>(wn(n),"channelsFirst"===n?Bt(t,[0,2,3,1]):t))}function sO(t,n){return U(()=>(wn(n),"channelsFirst"===n?Bt(t,[0,2,3,4,1]):t))}function yD(t,n,e,r=[1,1],s="valid",o,i,a=null){return U(()=>{if(null==o&&(o="channelsLast"),wn(o),3!==t.rank&&4!==t.rank)throw new L(`conv2dWithBiasActivation expects input to be of rank 3 or 4, but received ${t.rank}.`);if(3!==n.rank&&4!==n.rank)throw new L(`conv2dWithBiasActivation expects kernel to be of rank 3 or 4, but received ${t.rank}.`);let l=gD(t,o);if("causal"===s)throw new et("The support for CAUSAL padding mode in conv1dWithBias is not implemented yet.");return l=n2({x:l,filter:n,strides:r,pad:"same"===s?"same":"valid",dilations:i,dataFormat:"NHWC",bias:e,activation:a}),"channelsFirst"===o&&(l=Bt(l,[0,3,1,2])),l})}le((()=>{class t extends Dt{constructor(e){super(e??{}),this.supportsMasking=!0,null!=e&&(this.maxValue=e.maxValue)}call(e,r){e=at(e);let s=ai(e);return null!=this.maxValue&&(s=Kr(s,0,this.maxValue)),s}computeOutputShape(e){return e}getConfig(){const e={maxValue:this.maxValue},r=super.getConfig();return Object.assign(e,r),e}}return t.className="ReLU",t})()),le((()=>{class t extends Dt{constructor(e){super(e??{}),this.DEFAULT_ALPHA=.3,null==e&&(e={}),this.alpha=e.alpha??this.DEFAULT_ALPHA}call(e,r){const s=at(e);return Dg(s,this.alpha)}computeOutputShape(e){return e}getConfig(){const e={alpha:this.alpha},r=super.getConfig();return Object.assign(e,r),e}}return t.className="LeakyReLU",t})()),le((()=>{class t extends Dt{constructor(e){if(super(e??{}),this.DEFAULT_ALPHA_INITIALIZER="zeros",null==e&&(e={}),this.supportsMasking=!0,this.alphaInitializer=nn(e.alphaInitializer||this.DEFAULT_ALPHA_INITIALIZER),this.alphaRegularizer=rn(e.alphaRegularizer),this.alphaConstraint=Vn(e.alphaConstraint),null==e.sharedAxes)this.sharedAxes=null;else if(Array.isArray(e.sharedAxes))this.sharedAxes=e.sharedAxes;else{if("number"!=typeof e.sharedAxes)throw new L(`Expected sharedAxes to be a number or an array of numbers, but got ${e.sharedAxes}`);this.sharedAxes=[e.sharedAxes]}}build(e){const r=(e=Vt(e)).slice(1);if(null!=this.sharedAxes)for(const o of this.sharedAxes)r[o-1]=1;this.alpha=this.addWeight("alpha",r,"float32",this.alphaInitializer,this.alphaRegularizer,!0,this.alphaConstraint);const s={};if(null!=this.sharedAxes)for(let o=1;o<e.length;++o)s[o]=e[o];this.inputSpec=[new ur({ndim:e.length,axes:s})],this.built=!0}call(e,r){return e=at(e),Eg(e,this.alpha.read())}getConfig(){const e={alphaInitializer:un(this.alphaInitializer),alphaRegularizer:Ut(this.alphaRegularizer),alphaConstraint:zn(this.alphaConstraint),sharedAxes:this.sharedAxes},r=super.getConfig();return Object.assign(e,r),e}}return t.className="PReLU",t})()),le((()=>{class t extends Dt{constructor(e){if(super(e??{}),this.DEFAULT_ALPHA=1,null==e&&(e={}),null!=e.alpha&&e.alpha!==this.DEFAULT_ALPHA)throw new et(`Non-default alpha value (${e.alpha}) is not supported by the ELU layer yet.`);this.alpha=e.alpha??this.DEFAULT_ALPHA}call(e,r){const s=at(e);return mh(s)}computeOutputShape(e){return e}getConfig(){const e={alpha:this.alpha},r=super.getConfig();return Object.assign(e,r),e}}return t.className="ELU",t})()),le((()=>{class t extends Dt{constructor(e){super(e??{}),this.DEFAULT_THETA=1,null==e&&(e={}),this.theta=e.theta??this.DEFAULT_THETA}call(e,r){const s=at(e);return s.mul($h(s.greater(this.theta),"float32"))}computeOutputShape(e){return e}getConfig(){const e={theta:this.theta},r=super.getConfig();return Object.assign(e,r),e}}return t.className="ThresholdedReLU",t})()),le((()=>{class t extends Dt{constructor(e){super(e??{}),this.DEFAULT_AXIS=1,null==e&&(e={}),this.softmax=(new eO).apply,this.axis=e.axis??this.DEFAULT_AXIS}call(e,r){const s=at(e);return this.softmax(s,this.axis)}computeOutputShape(e){return e}getConfig(){const e={axis:this.axis},r=super.getConfig();return Object.assign(e,r),e}}return t.className="Softmax",t})());class hy extends Dt{constructor(n,e){if(super(e),this.bias=null,this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_BIAS_INITIALIZER="zeros",hy.verifyArgs(e),this.rank=n,Jn(this.rank,"rank"),1!==this.rank&&2!==this.rank&&3!==this.rank)throw new et(`Convolution layer for rank other than 1, 2, or 3 (${this.rank}) is not implemented yet.`);if(this.kernelSize=Nu(e.kernelSize,n,"kernelSize"),this.strides=Nu(e.strides??1,n,"strides"),this.padding=e.padding??"valid",ys(this.padding),this.dataFormat=e.dataFormat??"channelsLast",wn(this.dataFormat),this.activation=Ki(e.activation),this.useBias=e.useBias??!0,this.biasInitializer=nn(e.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.biasConstraint=Vn(e.biasConstraint),this.biasRegularizer=rn(e.biasRegularizer),this.activityRegularizer=rn(e.activityRegularizer),this.dilationRate=Nu(e.dilationRate??1,n,"dilationRate"),1===this.rank&&Array.isArray(this.dilationRate)&&1!==this.dilationRate.length)throw new L(`dilationRate must be a number or an array of a single number for 1D convolution, but received ${JSON.stringify(this.dilationRate)}`);if(2===this.rank){if("number"==typeof this.dilationRate)this.dilationRate=[this.dilationRate,this.dilationRate];else if(2!==this.dilationRate.length)throw new L(`dilationRate must be a number or array of two numbers for 2D convolution, but received ${JSON.stringify(this.dilationRate)}`)}else if(3===this.rank)if("number"==typeof this.dilationRate)this.dilationRate=[this.dilationRate,this.dilationRate,this.dilationRate];else if(3!==this.dilationRate.length)throw new L(`dilationRate must be a number or array of three numbers for 3D convolution, but received ${JSON.stringify(this.dilationRate)}`)}static verifyArgs(n){if(gs("kernelSize"in n,"required key 'kernelSize' not in config"),"number"!=typeof n.kernelSize&&!PI(n.kernelSize,"number",1,3))throw new L(`BaseConv expects config.kernelSize to be number or number[] with length 1, 2, or 3, but received ${JSON.stringify(n.kernelSize)}.`)}getConfig(){const n={kernelSize:this.kernelSize,strides:this.strides,padding:this.padding,dataFormat:this.dataFormat,dilationRate:this.dilationRate,activation:qi(this.activation),useBias:this.useBias,biasInitializer:un(this.biasInitializer),biasRegularizer:Ut(this.biasRegularizer),activityRegularizer:Ut(this.activityRegularizer),biasConstraint:zn(this.biasConstraint)},e=super.getConfig();return Object.assign(n,e),n}}class Tu extends hy{constructor(n,e){super(n,e),this.kernel=null,Tu.verifyArgs(e),this.filters=e.filters,Jn(this.filters,"filters"),this.kernelInitializer=nn(e.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.kernelConstraint=Vn(e.kernelConstraint),this.kernelRegularizer=rn(e.kernelRegularizer)}build(n){n=Vt(n);const e="channelsFirst"===this.dataFormat?1:n.length-1;if(null==n[e])throw new L(`The channel dimension of the input should be defined. Found ${n[e]}`);const r=n[e],s=this.kernelSize.concat([r,this.filters]);this.kernel=this.addWeight("kernel",s,null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.filters],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint)),this.inputSpec=[{ndim:this.rank+2,axes:{[e]:r}}],this.built=!0}call(n,e){return U(()=>{let r;n=at(n);const s=null==this.bias?null:this.bias.read(),o=iF(this.activation.getClassName());if(null!=o&&2===this.rank)r=yD(n,this.kernel.read(),s,this.strides,this.padding,this.dataFormat,this.dilationRate,o);else{if(1===this.rank)r=function oO(t,n,e,r=1,s="valid",o,i=1){return U(()=>{if(null==o&&(o="channelsLast"),wn(o),3!==t.shape.length)throw new L(`The input of a conv1dWithBias operation should be 3, but is ${t.shape.length} instead.`);if(3!==n.shape.length)throw new L(`The kernel for a conv1dWithBias operation should be 3, but is ${n.shape.length} instead`);if(null!=e&&1!==e.shape.length)throw new L(`The bias for a conv1dWithBias operation should be 1, but is ${n.shape.length} instead`);if("channelsFirst"===o&&(t=Bt(t,[0,2,1])),"causal"===s)throw new et("The support for CAUSAL padding mode in conv1dWithBias is not implemented yet.");let a=DC(t,n,r,"same"===s?"same":"valid","NWC",i);return null!=e&&(a=Ao(a,e)),a})}(n,this.kernel.read(),s,this.strides[0],this.padding,this.dataFormat,this.dilationRate[0]);else if(2===this.rank)r=yD(n,this.kernel.read(),s,this.strides,this.padding,this.dataFormat,this.dilationRate);else{if(3!==this.rank)throw new et("convolutions greater than 3D are not implemented yet.");r=function iO(t,n,e,r=[1,1,1],s="valid",o,i){return U(()=>{if(null==o&&(o="channelsLast"),wn(o),4!==t.rank&&5!==t.rank)throw new L(`conv3dWithBias expects input to be of rank 4 or 5, but received ${t.rank}.`);if(4!==n.rank&&5!==n.rank)throw new L(`conv3dWithBias expects kernel to be of rank 4 or 5, but received ${t.rank}.`);let a=sO(t,o);if("causal"===s)throw new et("The support for CAUSAL padding mode in conv3dWithBias is not implemented yet.");return a=X$(a,n,r,"same"===s?"same":"valid","NDHWC",i),null!=e&&(a=Ao(a,e)),"channelsFirst"===o&&(a=Bt(a,[0,4,1,2,3])),a})}(n,this.kernel.read(),s,this.strides,this.padding,this.dataFormat,this.dilationRate)}null!=this.activation&&(r=this.activation.apply(r))}return r})}computeOutputShape(n){n=Vt(n);const e=[],r="channelsLast"===this.dataFormat?n.slice(1,n.length-1):n.slice(2);for(let o=0;o<r.length;++o){const i=co(r[o],this.kernelSize[o],this.padding,this.strides[o],"number"==typeof this.dilationRate?this.dilationRate:this.dilationRate[o]);e.push(i)}let s=[n[0]];return"channelsLast"===this.dataFormat?(s=s.concat(e),s.push(this.filters)):(s.push(this.filters),s=s.concat(e)),s}getConfig(){const n={filters:this.filters,kernelInitializer:un(this.kernelInitializer),kernelRegularizer:Ut(this.kernelRegularizer),kernelConstraint:zn(this.kernelConstraint)},e=super.getConfig();return Object.assign(n,e),n}static verifyArgs(n){if(!("filters"in n)||"number"!=typeof n.filters||n.filters<1)throw new L(`Convolution layer expected config.filters to be a 'number' > 0 but got ${JSON.stringify(n.filters)}`)}}let aO=(()=>{class t extends Tu{constructor(e){super(2,e),t.verifyArgs(e)}getConfig(){const e=super.getConfig();return delete e.rank,e}static verifyArgs(e){if("number"!=typeof e.kernelSize&&!PI(e.kernelSize,"number",1,2))throw new L(`Conv2D expects config.kernelSize to be number or number[] with length 1 or 2, but received ${JSON.stringify(e.kernelSize)}.`)}}return t.className="Conv2D",t})();le(aO),le((()=>{class t extends Tu{constructor(e){super(3,e),t.verifyArgs(e)}getConfig(){const e=super.getConfig();return delete e.rank,e}static verifyArgs(e){if("number"!=typeof e.kernelSize&&(!Array.isArray(e.kernelSize)||1!==e.kernelSize.length&&3!==e.kernelSize.length))throw new L(`Conv3D expects config.kernelSize to be number or [number, number, number], but received ${JSON.stringify(e.kernelSize)}.`)}}return t.className="Conv3D",t})()),le((()=>{class t extends aO{constructor(e){if(super(e),this.inputSpec=[new ur({ndim:4})],"same"!==this.padding&&"valid"!==this.padding)throw new L(`Conv2DTranspose currently supports only padding modes 'same' and 'valid', but received padding mode ${this.padding}`)}build(e){if(4!==(e=Vt(e)).length)throw new L("Input should have rank 4; Received input shape: "+JSON.stringify(e));const r="channelsFirst"===this.dataFormat?1:e.length-1;if(null==e[r])throw new L("The channel dimension of the inputs should be defined. Found `None`.");const s=e[r],o=this.kernelSize.concat([this.filters,s]);this.kernel=this.addWeight("kernel",o,"float32",this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.filters],"float32",this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint)),this.inputSpec=[new ur({ndim:4,axes:{[r]:s}})],this.built=!0}call(e,r){return U(()=>{let s=at(e);if(4!==s.shape.length)throw new L(`Conv2DTranspose.call() expects input tensor to be rank-4, but received a tensor of rank-${s.shape.length}`);const o=s.shape;let a,l;"channelsFirst"===this.dataFormat?(a=2,l=3):(a=1,l=2);const c=o[l],h=this.kernelSize[1],p=this.strides[1],y=[o[0],dy(o[a],this.strides[0],this.kernelSize[0],this.padding),dy(c,p,h,this.padding),this.filters];"channelsLast"!==this.dataFormat&&(s=Bt(s,[0,2,3,1]));let b=SC(s,this.kernel.read(),y,this.strides,this.padding);return"channelsLast"!==this.dataFormat&&(b=Bt(b,[0,3,1,2])),null!=this.bias&&(b=Ao(b,this.bias.read(),this.dataFormat)),null!=this.activation&&(b=this.activation.apply(b)),b})}computeOutputShape(e){const r=(e=Vt(e)).slice();let s,o,i;"channelsFirst"===this.dataFormat?(s=1,o=2,i=3):(s=3,o=1,i=2);const a=this.kernelSize[0],l=this.kernelSize[1],u=this.strides[0],c=this.strides[1];return r[s]=this.filters,r[o]=dy(r[o],u,a,this.padding),r[i]=dy(r[i],c,l,this.padding),r}getConfig(){const e=super.getConfig();return delete e.dilationRate,e}}return t.className="Conv2DTranspose",t})());let _te=(()=>{class t extends Tu{constructor(e,r){if(super(e,r),this.DEFAULT_DEPTHWISE_INITIALIZER="glorotUniform",this.DEFAULT_POINTWISE_INITIALIZER="glorotUniform",this.depthwiseKernel=null,this.pointwiseKernel=null,null==r.filters)throw new L("The `filters` configuration field is required by SeparableConv, but is unspecified.");if(null!=r.kernelInitializer||null!=r.kernelRegularizer||null!=r.kernelConstraint)throw new L("Fields kernelInitializer, kernelRegularizer and kernelConstraint are invalid for SeparableConv2D. Use depthwiseInitializer, depthwiseRegularizer, depthwiseConstraint, pointwiseInitializer, pointwiseRegularizer and pointwiseConstraint instead.");if(null!=r.padding&&"same"!==r.padding&&"valid"!==r.padding)throw new L(`SeparableConv${this.rank}D supports only padding modes: 'same' and 'valid', but received ${JSON.stringify(r.padding)}`);this.depthMultiplier=r.depthMultiplier??1,this.depthwiseInitializer=nn(r.depthwiseInitializer||this.DEFAULT_DEPTHWISE_INITIALIZER),this.depthwiseRegularizer=rn(r.depthwiseRegularizer),this.depthwiseConstraint=Vn(r.depthwiseConstraint),this.pointwiseInitializer=nn(r.depthwiseInitializer||this.DEFAULT_POINTWISE_INITIALIZER),this.pointwiseRegularizer=rn(r.pointwiseRegularizer),this.pointwiseConstraint=Vn(r.pointwiseConstraint)}build(e){if((e=Vt(e)).length<this.rank+2)throw new L(`Inputs to SeparableConv${this.rank}D should have rank ${this.rank+2}, but received input shape: ${JSON.stringify(e)}`);const r="channelsFirst"===this.dataFormat?1:e.length-1;if(null==e[r]||e[r]<0)throw new L(`The channel dimension of the inputs should be defined, but found ${JSON.stringify(e[r])}`);const s=e[r],o=this.kernelSize.concat([s,this.depthMultiplier]),i=[];for(let l=0;l<this.rank;++l)i.push(1);i.push(s*this.depthMultiplier,this.filters);const a=!0;this.depthwiseKernel=this.addWeight("depthwise_kernel",o,"float32",this.depthwiseInitializer,this.depthwiseRegularizer,a,this.depthwiseConstraint),this.pointwiseKernel=this.addWeight("pointwise_kernel",i,"float32",this.pointwiseInitializer,this.pointwiseRegularizer,a,this.pointwiseConstraint),this.bias=this.useBias?this.addWeight("bias",[this.filters],"float32",this.biasInitializer,this.biasRegularizer,a,this.biasConstraint):null,this.inputSpec=[new ur({ndim:this.rank+2,axes:{[r]:s}})],this.built=!0}call(e,r){return U(()=>{let s;if(e=at(e),1===this.rank)throw new et("1D separable convolution is not implemented yet.");return 2===this.rank&&("channelsFirst"===this.dataFormat&&(e=Bt(e,[0,2,3,1])),s=e2(e,this.depthwiseKernel.read(),this.pointwiseKernel.read(),this.strides,this.padding,this.dilationRate,"NHWC")),this.useBias&&(s=Ao(s,this.bias.read(),this.dataFormat)),null!=this.activation&&(s=this.activation.apply(s)),"channelsFirst"===this.dataFormat&&(s=Bt(s,[0,3,1,2])),s})}getConfig(){const e=super.getConfig();return delete e.rank,delete e.kernelInitializer,delete e.kernelRegularizer,delete e.kernelConstraint,e.depthwiseInitializer=un(this.depthwiseInitializer),e.pointwiseInitializer=un(this.pointwiseInitializer),e.depthwiseRegularizer=Ut(this.depthwiseRegularizer),e.pointwiseRegularizer=Ut(this.pointwiseRegularizer),e.depthwiseConstraint=zn(this.depthwiseConstraint),e.pointwiseConstraint=zn(this.pointwiseConstraint),e}}return t.className="SeparableConv",t})();function lO(t,n,e,r){if(Array.isArray(t)){if(null!=n||null!=e)throw new L("When inputs is an array, neither initialState or constants should be provided");null!=r&&(e=t.slice(t.length-r,t.length),t=t.slice(0,t.length-r)),t.length>1&&(n=t.slice(1,t.length)),t=t[0]}function s(o){return null==o||Array.isArray(o)?o:[o]}return{inputs:t,initialState:n=s(n),constants:e=s(e)}}function uO(t,n,e,r=!1,s,o,i=!1,a=!1){return U(()=>{const l=n.shape.length;if(l<3)throw new L(`Input should be at least 3D, but is ${l}D.`);const u=[1,0].concat(lo(2,l));if(n=Bt(n,u),null!=o)throw new et("The rnn() functoin of the deeplearn.js backend does not support constants yet.");i&&console.warn("Backend rnn(): the unroll = true option is not applicable to the imperative deeplearn.js backend."),null!=s&&((s=s.asType("bool").asType("float32")).rank===l-1&&(s=As(s,-1)),s=Bt(s,u)),r&&(n=li(n,0),null!=s&&(s=li(s,0)));const c=[];let d,h=e;const f=n.shape[0],p=oo(n);let m,g;null!=s&&(m=oo(s));for(let y=0;y<f;++y){const b=p[y],v=U(()=>t(b,h));if(null==s)d=v[0],h=v[1];else{const x=U(()=>{const w=m[y],_=fs(w).sub(w);return{output:v[0].mul(w).add(h[0].mul(_)),newStates:h.map((R,O)=>v[1][O].mul(w).add(R.mul(_)))}});d=x.output,h=x.newStates}a&&c.push(d)}return a&&(g=Fs(c,1)),[d,g,h]})}le((()=>{class t extends _te{constructor(e){super(2,e)}}return t.className="SeparableConv2D",t})()),le((()=>{class t extends Tu{constructor(e){super(1,e),t.verifyArgs(e),this.inputSpec=[{ndim:3}]}getConfig(){const e=super.getConfig();return delete e.rank,delete e.dataFormat,e}static verifyArgs(e){if("number"!=typeof e.kernelSize&&!PI(e.kernelSize,"number",1,1))throw new L(`Conv1D expects config.kernelSize to be number or number[] with length 1, but received ${JSON.stringify(e.kernelSize)}.`)}}return t.className="Conv1D",t})()),le((()=>{class t extends Dt{constructor(e){super(e),this.cropping="number"==typeof e.cropping?[[e.cropping,e.cropping],[e.cropping,e.cropping]]:"number"==typeof e.cropping[0]?[[e.cropping[0],e.cropping[0]],[e.cropping[1],e.cropping[1]]]:e.cropping,this.dataFormat=void 0===e.dataFormat?"channelsLast":e.dataFormat,this.inputSpec=[{ndim:4}]}computeOutputShape(e){return"channelsFirst"===this.dataFormat?[e[0],e[1],e[2]-this.cropping[0][0]-this.cropping[0][1],e[3]-this.cropping[1][0]-this.cropping[1][1]]:[e[0],e[1]-this.cropping[0][0]-this.cropping[0][1],e[2]-this.cropping[1][0]-this.cropping[1][1],e[3]]}call(e,r){return U(()=>{if(e=at(e),"channelsLast"===this.dataFormat){const s=Xg(e,this.cropping[0][0],e.shape[1]-this.cropping[0][0]-this.cropping[0][1],2);return Xg(s,this.cropping[1][0],e.shape[2]-this.cropping[1][1]-this.cropping[1][0],3)}{const s=Xg(e,this.cropping[0][0],e.shape[2]-this.cropping[0][0]-this.cropping[0][1],3);return Xg(s,this.cropping[1][0],e.shape[3]-this.cropping[1][1]-this.cropping[1][0],4)}})}getConfig(){const e={cropping:this.cropping,dataFormat:this.dataFormat},r=super.getConfig();return Object.assign(e,r),e}}return t.className="Cropping2D",t})()),le((()=>{class t extends Dt{constructor(e){super(e),this.DEFAULT_SIZE=[2,2],this.inputSpec=[{ndim:4}],this.size=e.size??this.DEFAULT_SIZE,this.dataFormat=e.dataFormat??"channelsLast",wn(this.dataFormat),this.interpolation=e.interpolation??"nearest",function nee(t){qa(QJ,"InterpolationFormat",t)}(this.interpolation)}computeOutputShape(e){return"channelsFirst"===this.dataFormat?[e[0],e[1],null==e[2]?null:this.size[0]*e[2],null==e[3]?null:this.size[1]*e[3]]:[e[0],null==e[1]?null:this.size[0]*e[1],null==e[2]?null:this.size[1]*e[2],e[3]]}call(e,r){return U(()=>{let s=at(e);const o=s.shape;if("channelsFirst"===this.dataFormat){s=Bt(s,[0,2,3,1]);const i=this.size[0]*o[2],a=this.size[1]*o[3],l="nearest"===this.interpolation?s.resizeNearestNeighbor([i,a]):s.resizeBilinear([i,a]);return Bt(l,[0,3,1,2])}{const i=this.size[0]*o[1],a=this.size[1]*o[2];return"nearest"===this.interpolation?s.resizeNearestNeighbor([i,a]):s.resizeBilinear([i,a])}})}getConfig(){const e={size:this.size,dataFormat:this.dataFormat},r=super.getConfig();return Object.assign(e,r),e}}return t.className="UpSampling2D",t})()),le((()=>{class t extends hy{constructor(e){super(2,e),this.depthwiseKernel=null,this.depthMultiplier=e.depthMultiplier??1,this.depthwiseInitializer=nn(e.depthwiseInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.depthwiseConstraint=Vn(e.depthwiseConstraint),this.depthwiseRegularizer=rn(e.depthwiseRegularizer)}build(e){if((e=Vt(e)).length<4)throw new L(`Inputs to DepthwiseConv2D should have rank 4. Received input shape: ${JSON.stringify(e)}.`);const r="channelsFirst"===this.dataFormat?1:3;if(null==e[r]||e[r]<0)throw new L(`The channel dimension of the inputs to DepthwiseConv2D should be defined, but is not (${e[r]}).`);const s=e[r];this.depthwiseKernel=this.addWeight("depthwise_kernel",[this.kernelSize[0],this.kernelSize[1],s,this.depthMultiplier],null,this.depthwiseInitializer,this.depthwiseRegularizer,!0,this.depthwiseConstraint),this.bias=this.useBias?this.addWeight("bias",[s*this.depthMultiplier],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint):null,this.built=!0}call(e,r){return U(()=>{let s=function Ste(t,n,e=[1,1],r="valid",s,o){return U(()=>{null==s&&(s="channelsLast"),wn(s);let i=gD(t,s);if(4!==t.rank)throw new L(`Input for depthwiseConv2d is required to be 4-D, but is instead ${t.rank}-D`);if(4!==n.rank)throw new L(`depthwiseKernel is required to be 4-D, but is instead ${n.rank}-D`);return i=ph(i,n,e,"same"===r?"same":"valid","NHWC",o),"channelsFirst"===s&&(i=Bt(i,[0,3,1,2])),i})}(e=at(e),this.depthwiseKernel.read(),this.strides,this.padding,this.dataFormat,null);return this.useBias&&(s=Ao(s,this.bias.read(),this.dataFormat)),null!=this.activation&&(s=this.activation.apply(s)),s})}computeOutputShape(e){e=Vt(e);const s="channelsFirst"===this.dataFormat?e[3]:e[2],o="channelsFirst"===this.dataFormat?e[1]*this.depthMultiplier:e[3]*this.depthMultiplier,i=co("channelsFirst"===this.dataFormat?e[2]:e[1],this.kernelSize[0],this.padding,this.strides[0]),a=co(s,this.kernelSize[1],this.padding,this.strides[1]);return"channelsFirst"===this.dataFormat?[e[0],o,i,a]:[e[0],i,a,o]}getConfig(){const e=super.getConfig();return e.depthMultiplier=this.depthMultiplier,e.depthwiseInitializer=un(this.depthwiseInitializer),e.depthwiseRegularizer=Ut(this.depthwiseRegularizer),e.depthwiseConstraint=zn(this.depthwiseRegularizer),e}}return t.className="DepthwiseConv2D",t})());let zh=(()=>{class t extends Dt{constructor(e){let r;if(super(e),null==e.cell)throw new L("cell property is missing for the constructor of RNN.");if(r=Array.isArray(e.cell)?new hO({cells:e.cell}):e.cell,null==r.stateSize)throw new L("The RNN cell should have an attribute `stateSize` (tuple of integers, one integer per RNN state).");this.cell=r,this.returnSequences=e.returnSequences??!1,this.returnState=e.returnState??!1,this.goBackwards=e.goBackwards??!1,this._stateful=e.stateful??!1,this.unroll=e.unroll??!1,this.supportsMasking=!0,this.inputSpec=[new ur({ndim:3})],this.stateSpec=null,this.states_=null,this.numConstants=null,this.keptStates=[]}getStates(){return this.states_??lo(0,Array.isArray(this.cell.stateSize)?this.cell.stateSize.length:1).map(r=>null)}setStates(e){this.states_=e}computeOutputShape(e){WI(e)&&(e=e[0]);let r=this.cell.stateSize;Array.isArray(r)||(r=[r]);const s=r[0];let o;if(o=this.returnSequences?[e[0],e[1],s]:[e[0],s],this.returnState){const i=[];for(const a of r)i.push([e[0],a]);return[o].concat(i)}return o}computeMask(e,r){return U(()=>{Array.isArray(r)&&(r=r[0]);const s=this.returnSequences?r:null;if(this.returnState){const o=this.states.map(i=>null);return[s].concat(o)}return s})}get states(){if(null==this.states_){const e=Array.isArray(this.cell.stateSize)?this.cell.stateSize.length:1,r=[];for(let s=0;s<e;++s)r.push(null);return r}return this.states_}set states(e){this.states_=e}build(e){if(null!=this.numConstants)throw new et("Constants support is not implemented in RNN yet.");WI(e)&&(e=e[0]);const s=this.stateful?e[0]:null,o=e.slice(2);this.inputSpec[0]=new ur({shape:[s,null,...o]});const i=[e[0]].concat(e.slice(2));let a;if(this.cell.build(i),a=Array.isArray(this.cell.stateSize)?this.cell.stateSize:[this.cell.stateSize],null!=this.stateSpec){if(!Mt(this.stateSpec.map(l=>l.shape[l.shape.length-1]),a))throw new L(`An initialState was passed that is not compatible with cell.stateSize. Received stateSpec=${this.stateSpec}; However cell.stateSize is ${this.cell.stateSize}`)}else this.stateSpec=a.map(l=>new ur({shape:[null,l]}));this.stateful&&this.resetStates()}resetStates(e,r=!1){U(()=>{if(!this.stateful)throw new To("Cannot call resetStates() on an RNN Layer that is not stateful.");const s=this.inputSpec[0].shape[0];if(null==s)throw new L("If an RNN is stateful, it needs to know its batch size. Specify the batch size of your input tensors: \n- If using a Sequential model, specify the batch size by passing a `batchInputShape` option to your first layer.\n- If using the functional API, specify the batch size by passing a `batchShape` option to your Input layer.");if(null==this.states_)this.states_=Array.isArray(this.cell.stateSize)?this.cell.stateSize.map(o=>Nn([s,o])):[Nn([s,this.cell.stateSize])];else if(null==e)it(this.states_),null!=this.keptStates&&(it(this.keptStates),this.keptStates=[]),Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map(o=>Nn([s,o])):this.states_[0]=Nn([s,this.cell.stateSize]);else{if(Array.isArray(e)||(e=[e]),e.length!==this.states_.length)throw new L(`Layer ${this.name} expects ${this.states_.length} state(s), but it received ${e.length} state value(s). Input received: ${e}`);!0===r?this.keptStates.push(this.states_.slice()):it(this.states_);for(let o=0;o<this.states_.length;++o){const i=e[o],a=Array.isArray(this.cell.stateSize)?this.cell.stateSize[o]:this.cell.stateSize,l=[s,a];if(!Mt(i.shape,l))throw new L(`State ${o} is incompatible with layer ${this.name}: expected shape=${l}, received shape=${i.shape}`);this.states_[o]=i}}this.states_=this.states_.map(o=>ir(o.clone()))})}apply(e,r){let s=null==r?null:r.initialState,o=null==r?null:r.constants;null==r&&(r={});const i=lO(e,s,o,this.numConstants);e=i.inputs,s=i.initialState,o=i.constants;let a=[],l=[];if(null!=s){r.initialState=s,a=a.concat(s),this.stateSpec=[];for(const c of s)this.stateSpec.push(new ur({shape:c.shape}));l=l.concat(this.stateSpec)}if(null!=o&&(r.constants=o,a=a.concat(o),this.numConstants=o.length),a[0]instanceof $o){const c=[e].concat(a),d=this.inputSpec.concat(l),h=this.inputSpec;this.inputSpec=d;const f=super.apply(c,r);return this.inputSpec=h,f}return super.apply(e,r)}call(e,r){return U(()=>{const s=null==r?null:r.mask,o=null==r?null:r.training;let i=null==r?null:r.initialState;e=at(e),null==i&&(i=this.stateful?this.states_:this.getInitialState(e));const a=Array.isArray(this.cell.stateSize)?this.cell.stateSize.length:1;if(i.length!==a)throw new L(`RNN Layer has ${a} state(s) but was passed ${i.length} initial state(s).`);this.unroll&&console.warn("Ignoring unroll = true for RNN layer, due to imperative backend.");const l={training:o},c=uO((m,g)=>{const y=this.cell.call([m].concat(g),l);return[y[0],y.slice(1)]},e,i,this.goBackwards,s,null,this.unroll,this.returnSequences),d=c[0],h=c[1],f=c[2];this.stateful&&this.resetStates(f,o);const p=this.returnSequences?h:d;return this.returnState?[p].concat(f):p})}getInitialState(e){return U(()=>{let r=Nn(e.shape);return r=Oe(r,[1,2]),r=Fh(r),Array.isArray(this.cell.stateSize)?this.cell.stateSize.map(s=>s>1?VI(r,[1,s]):r):this.cell.stateSize>1?[VI(r,[1,this.cell.stateSize])]:[r]})}get trainableWeights(){return this.trainable?this.cell.trainableWeights:[]}get nonTrainableWeights(){return this.trainable?this.cell.nonTrainableWeights:this.cell.weights}setFastWeightInitDuringBuild(e){super.setFastWeightInitDuringBuild(e),null!=this.cell&&this.cell.setFastWeightInitDuringBuild(e)}getConfig(){const e=super.getConfig(),r={returnSequences:this.returnSequences,returnState:this.returnState,goBackwards:this.goBackwards,stateful:this.stateful,unroll:this.unroll};null!=this.numConstants&&(r.numConstants=this.numConstants);const s=this.cell.getConfig();return this.getClassName()===t.className&&(r.cell={className:this.cell.getClassName(),config:s}),Object.assign({},s,e,r)}static fromConfig(e,r,s={}){const i=fi(r.cell,s);return new e(Object.assign(r,{cell:i}))}}return t.className="RNN",t})();le(zh);class fy extends Dt{}let cO=(()=>{class t extends fy{constructor(e){super(e),this.DEFAULT_ACTIVATION="tanh",this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_RECURRENT_INITIALIZER="orthogonal",this.DEFAULT_BIAS_INITIALIZER="zeros",this.units=e.units,Jn(this.units,"units"),this.activation=Ki(e.activation??this.DEFAULT_ACTIVATION),this.useBias=e.useBias??!0,this.kernelInitializer=nn(e.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.recurrentInitializer=nn(e.recurrentInitializer||this.DEFAULT_RECURRENT_INITIALIZER),this.biasInitializer=nn(e.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.kernelRegularizer=rn(e.kernelRegularizer),this.recurrentRegularizer=rn(e.recurrentRegularizer),this.biasRegularizer=rn(e.biasRegularizer),this.kernelConstraint=Vn(e.kernelConstraint),this.recurrentConstraint=Vn(e.recurrentConstraint),this.biasConstraint=Vn(e.biasConstraint),this.dropout=_u([1,Hi([0,e.dropout??0])]),this.recurrentDropout=_u([1,Hi([0,e.recurrentDropout??0])]),this.stateSize=this.units,this.dropoutMask=null,this.recurrentDropoutMask=null}build(e){e=Vt(e),this.kernel=this.addWeight("kernel",[e[e.length-1],this.units],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.recurrentKernel=this.addWeight("recurrent_kernel",[this.units,this.units],null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.bias=this.useBias?this.addWeight("bias",[this.units],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint):null,this.built=!0}call(e,r){return U(()=>{if(2!==e.length)throw new L(`SimpleRNNCell expects 2 input Tensors, got ${e.length}.`);let s=e[1];e=e[0];const o=r.training??!1;let i;0<this.dropout&&this.dropout<1&&null==this.dropoutMask&&(this.dropoutMask=Xi({ones:()=>fs(e),rate:this.dropout,training:o})),0<this.recurrentDropout&&this.recurrentDropout<1&&null==this.recurrentDropoutMask&&(this.recurrentDropoutMask=Xi({ones:()=>fs(s),rate:this.recurrentDropout,training:o}));const a=this.dropoutMask,l=this.recurrentDropoutMask;i=ko(null!=a?V(e,a):e,this.kernel.read()),null!=this.bias&&(i=Ao(i,this.bias.read())),null!=l&&(s=V(s,l));let u=me(i,ko(s,this.recurrentKernel.read()));return null!=this.activation&&(u=this.activation.apply(u)),[u,u]})}getConfig(){const e=super.getConfig(),r={units:this.units,activation:qi(this.activation),useBias:this.useBias,kernelInitializer:un(this.kernelInitializer),recurrentInitializer:un(this.recurrentInitializer),biasInitializer:un(this.biasInitializer),kernelRegularizer:Ut(this.kernelRegularizer),recurrentRegularizer:Ut(this.recurrentRegularizer),biasRegularizer:Ut(this.biasRegularizer),activityRegularizer:Ut(this.activityRegularizer),kernelConstraint:zn(this.kernelConstraint),recurrentConstraint:zn(this.recurrentConstraint),biasConstraint:zn(this.biasConstraint),dropout:this.dropout,recurrentDropout:this.recurrentDropout};return Object.assign({},e,r)}}return t.className="SimpleRNNCell",t})();le(cO),le((()=>{class t extends zh{constructor(e){e.cell=new cO(e),super(e)}call(e,r){return U(()=>(null!=this.cell.dropoutMask&&(it(this.cell.dropoutMask),this.cell.dropoutMask=null),null!=this.cell.recurrentDropoutMask&&(it(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null),super.call(e,{mask:null==r?null:r.mask,training:null==r?null:r.training,initialState:null==r?null:r.initialState})))}static fromConfig(e,r){return new e(r)}}return t.className="SimpleRNN",t})());let dO=(()=>{class t extends fy{constructor(e){if(super(e),this.DEFAULT_ACTIVATION="tanh",this.DEFAULT_RECURRENT_ACTIVATION="hardSigmoid",this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_RECURRENT_INITIALIZER="orthogonal",this.DEFAULT_BIAS_INITIALIZER="zeros",e.resetAfter)throw new L("GRUCell does not support reset_after parameter set to true.");this.units=e.units,Jn(this.units,"units"),this.activation=Ki(void 0===e.activation?this.DEFAULT_ACTIVATION:e.activation),this.recurrentActivation=Ki(void 0===e.recurrentActivation?this.DEFAULT_RECURRENT_ACTIVATION:e.recurrentActivation),this.useBias=e.useBias??!0,this.kernelInitializer=nn(e.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.recurrentInitializer=nn(e.recurrentInitializer||this.DEFAULT_RECURRENT_INITIALIZER),this.biasInitializer=nn(e.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.kernelRegularizer=rn(e.kernelRegularizer),this.recurrentRegularizer=rn(e.recurrentRegularizer),this.biasRegularizer=rn(e.biasRegularizer),this.kernelConstraint=Vn(e.kernelConstraint),this.recurrentConstraint=Vn(e.recurrentConstraint),this.biasConstraint=Vn(e.biasConstraint),this.dropout=_u([1,Hi([0,e.dropout??0])]),this.recurrentDropout=_u([1,Hi([0,e.recurrentDropout??0])]),this.implementation=e.implementation,this.stateSize=this.units,this.dropoutMask=null,this.recurrentDropoutMask=null}build(e){e=Vt(e),this.kernel=this.addWeight("kernel",[e[e.length-1],3*this.units],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.recurrentKernel=this.addWeight("recurrent_kernel",[this.units,3*this.units],null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.bias=this.useBias?this.addWeight("bias",[3*this.units],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint):null,this.built=!0}call(e,r){return U(()=>{if(2!==e.length)throw new L(`GRUCell expects 2 input Tensors (inputs, h, c), got ${e.length}.`);const s=r.training??!1;let o=e[1];e=e[0],0<this.dropout&&this.dropout<1&&null==this.dropoutMask&&(this.dropoutMask=Xi({ones:()=>fs(e),rate:this.dropout,training:s,count:3})),0<this.recurrentDropout&&this.recurrentDropout<1&&null==this.recurrentDropoutMask&&(this.recurrentDropoutMask=Xi({ones:()=>fs(o),rate:this.recurrentDropout,training:s,count:3}));const a=this.recurrentDropoutMask;let l,u,c;0<this.dropout&&this.dropout<1&&(e=V(e,this.dropoutMask[0]));let d=ko(e,this.kernel.read());this.useBias&&(d=Ao(d,this.bias.read())),0<this.recurrentDropout&&this.recurrentDropout<1&&(o=V(o,a[0]));const h=this.recurrentKernel.read(),[f,p]=ps(h,[2*this.units,this.units],h.rank-1),m=ko(o,f),[g,y,b]=ps(d,3,d.rank-1),[v,x]=ps(m,2,m.rank-1);l=this.recurrentActivation.apply(me(g,v)),u=this.recurrentActivation.apply(me(y,x));const w=ko(V(u,o),p);c=this.activation.apply(me(b,w));const _=me(V(l,o),V(me(1,mn(l)),c));return[_,_]})}getConfig(){const e=super.getConfig(),r={units:this.units,activation:qi(this.activation),recurrentActivation:qi(this.recurrentActivation),useBias:this.useBias,kernelInitializer:un(this.kernelInitializer),recurrentInitializer:un(this.recurrentInitializer),biasInitializer:un(this.biasInitializer),kernelRegularizer:Ut(this.kernelRegularizer),recurrentRegularizer:Ut(this.recurrentRegularizer),biasRegularizer:Ut(this.biasRegularizer),activityRegularizer:Ut(this.activityRegularizer),kernelConstraint:zn(this.kernelConstraint),recurrentConstraint:zn(this.recurrentConstraint),biasConstraint:zn(this.biasConstraint),dropout:this.dropout,recurrentDropout:this.recurrentDropout,implementation:this.implementation,resetAfter:!1};return Object.assign({},e,r)}}return t.className="GRUCell",t})();le(dO),le((()=>{class t extends zh{constructor(e){0===e.implementation&&console.warn("`implementation=0` has been deprecated, and now defaults to `implementation=1`. Please update your layer call."),e.cell=new dO(e),super(e)}call(e,r){return U(()=>(null!=this.cell.dropoutMask&&(it(this.cell.dropoutMask),this.cell.dropoutMask=null),null!=this.cell.recurrentDropoutMask&&(it(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null),super.call(e,{mask:null==r?null:r.mask,training:null==r?null:r.training,initialState:null==r?null:r.initialState})))}static fromConfig(e,r){return 0===r.implmentation&&(r.implementation=1),new e(r)}}return t.className="GRU",t})());let bD=(()=>{class t extends fy{constructor(e){super(e),this.DEFAULT_ACTIVATION="tanh",this.DEFAULT_RECURRENT_ACTIVATION="hardSigmoid",this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_RECURRENT_INITIALIZER="orthogonal",this.DEFAULT_BIAS_INITIALIZER="zeros",this.units=e.units,Jn(this.units,"units"),this.activation=Ki(void 0===e.activation?this.DEFAULT_ACTIVATION:e.activation),this.recurrentActivation=Ki(void 0===e.recurrentActivation?this.DEFAULT_RECURRENT_ACTIVATION:e.recurrentActivation),this.useBias=e.useBias??!0,this.kernelInitializer=nn(e.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.recurrentInitializer=nn(e.recurrentInitializer||this.DEFAULT_RECURRENT_INITIALIZER),this.biasInitializer=nn(e.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.unitForgetBias=e.unitForgetBias,this.kernelRegularizer=rn(e.kernelRegularizer),this.recurrentRegularizer=rn(e.recurrentRegularizer),this.biasRegularizer=rn(e.biasRegularizer),this.kernelConstraint=Vn(e.kernelConstraint),this.recurrentConstraint=Vn(e.recurrentConstraint),this.biasConstraint=Vn(e.biasConstraint),this.dropout=_u([1,Hi([0,e.dropout??0])]),this.recurrentDropout=_u([1,Hi([0,e.recurrentDropout??0])]),this.implementation=e.implementation,this.stateSize=[this.units,this.units],this.dropoutMask=null,this.recurrentDropoutMask=null}build(e){var r;let o;if(e=Vt(e),this.kernel=this.addWeight("kernel",[e[e.length-1],4*this.units],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.recurrentKernel=this.addWeight("recurrent_kernel",[this.units,4*this.units],null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.useBias){if(this.unitForgetBias){const i=this.biasInitializer,a=this.units;o=new((r=class extends Ls{apply(u,c){const d=i.apply([a]),h=(new bF).apply([a]),f=i.apply([2*a]);return mF(mF(d,h),f)}}).className="CustomInit",r)}else o=this.biasInitializer;this.bias=this.addWeight("bias",[4*this.units],null,o,this.biasRegularizer,!0,this.biasConstraint)}else this.bias=null;this.built=!0}call(e,r){return U(()=>{const s=r.training??!1;if(3!==e.length)throw new L(`LSTMCell expects 3 input Tensors (inputs, h, c), got ${e.length}.`);let o=e[1];const i=e[2];e=e[0],0<this.dropout&&this.dropout<1&&null==this.dropoutMask&&(this.dropoutMask=Xi({ones:()=>fs(e),rate:this.dropout,training:s,count:4})),0<this.recurrentDropout&&this.recurrentDropout<1&&null==this.recurrentDropoutMask&&(this.recurrentDropoutMask=Xi({ones:()=>fs(o),rate:this.recurrentDropout,training:s,count:4}));const l=this.recurrentDropoutMask;let u,c,d,h;0<this.dropout&&this.dropout<1&&(e=V(e,this.dropoutMask[0]));let f=ko(e,this.kernel.read());0<this.recurrentDropout&&this.recurrentDropout<1&&(o=V(o,l[0])),f=me(f,ko(o,this.recurrentKernel.read())),this.useBias&&(f=Ao(f,this.bias.read()));const[p,m,g,y]=ps(f,4,f.rank-1);u=this.recurrentActivation.apply(p),c=this.recurrentActivation.apply(m),d=me(V(c,i),V(u,this.activation.apply(g))),h=this.recurrentActivation.apply(y);const b=V(h,this.activation.apply(d));return[b,b,d]})}getConfig(){const e=super.getConfig(),r={units:this.units,activation:qi(this.activation),recurrentActivation:qi(this.recurrentActivation),useBias:this.useBias,kernelInitializer:un(this.kernelInitializer),recurrentInitializer:un(this.recurrentInitializer),biasInitializer:un(this.biasInitializer),unitForgetBias:this.unitForgetBias,kernelRegularizer:Ut(this.kernelRegularizer),recurrentRegularizer:Ut(this.recurrentRegularizer),biasRegularizer:Ut(this.biasRegularizer),activityRegularizer:Ut(this.activityRegularizer),kernelConstraint:zn(this.kernelConstraint),recurrentConstraint:zn(this.recurrentConstraint),biasConstraint:zn(this.biasConstraint),dropout:this.dropout,recurrentDropout:this.recurrentDropout,implementation:this.implementation};return Object.assign({},e,r)}}return t.className="LSTMCell",t})();le(bD),le((()=>{class t extends zh{constructor(e){0===e.implementation&&console.warn("`implementation=0` has been deprecated, and now defaults to `implementation=1`. Please update your layer call."),e.cell=new bD(e),super(e)}call(e,r){return U(()=>(null!=this.cell.dropoutMask&&(it(this.cell.dropoutMask),this.cell.dropoutMask=null),null!=this.cell.recurrentDropoutMask&&(it(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null),super.call(e,{mask:null==r?null:r.mask,training:null==r?null:r.training,initialState:null==r?null:r.initialState})))}static fromConfig(e,r){return 0===r.implmentation&&(r.implementation=1),new e(r)}}return t.className="LSTM",t})());let hO=(()=>{class t extends fy{constructor(e){super(e),this.cells=e.cells}get stateSize(){const e=[];for(const r of this.cells.slice().reverse())Array.isArray(r.stateSize)?e.push(...r.stateSize):e.push(r.stateSize);return e}call(e,r){return U(()=>{let s=e.slice(1);const o=[];for(const l of this.cells.slice().reverse())Array.isArray(l.stateSize)?o.push(s.splice(0,l.stateSize.length)):o.push(s.splice(0,1));o.reverse();const i=[];let a;for(let l=0;l<this.cells.length;++l){const u=this.cells[l];s=o[l],a=0===l?[e[0]].concat(s):[a[0]].concat(s),a=u.call(a,r),i.push(a.slice(1))}s=[];for(const l of i.slice().reverse())s.push(...l);return[a[0]].concat(s)})}build(e){let r;WI(e)&&(e=e[0]),this.cells.forEach((s,o)=>{Ka(`RNNCell_${o}`,()=>{s.build(e),r=Array.isArray(s.stateSize)?s.stateSize[0]:s.stateSize,e=[e[0],r]})}),this.built=!0}getConfig(){const e=super.getConfig(),o={cells:this.cells.map(i=>({className:i.getClassName(),config:i.getConfig()}))};return Object.assign({},e,o)}static fromConfig(e,r,s={}){const o=[];for(const i of r.cells)o.push(fi(i,s));return new e({cells:o})}get trainableWeights(){if(!this.trainable)return[];const e=[];for(const r of this.cells)e.push(...r.trainableWeights);return e}get nonTrainableWeights(){const e=[];for(const r of this.cells)e.push(...r.nonTrainableWeights);if(!this.trainable){const r=[];for(const s of this.cells)r.push(...s.trainableWeights);return r.concat(e)}return e}getWeights(){const e=[];for(const r of this.cells)e.push(...r.weights);return HI(e)}setWeights(e){const r=[];for(const s of this.cells){const i=e.splice(s.weights.length);for(let a=0;a<s.weights.length;++a)r.push([s.weights[a],i[a]])}GI(r)}}return t.className="StackedRNNCells",t})();function Xi(t){const{ones:n,rate:e,training:r=!1,count:s=1}=t,o=()=>yF(n(),e),i=()=>Mh(o,n,r);return!s||s<=1?ir(i().clone()):Array(s).fill(void 0).map(i).map(l=>ir(l.clone()))}le(hO);let Nte=(()=>{class t extends zh{constructor(e){if(e.unroll)throw new et("Unrolling is not possible with convolutional RNNs.");if(Array.isArray(e.cell))throw new et("It is not possible at the moment to stack convolutional cells.");super(e),this.inputSpec=[new ur({ndim:5})]}call(e,r){return U(()=>{if(null!=this.cell.dropoutMask&&(it(this.cell.dropoutMask),this.cell.dropoutMask=null),null!=this.cell.recurrentDropoutMask&&(it(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null),r&&r.constants)throw new L("ConvRNN2D cell does not support constants");return super.call(e,{mask:null==r?null:r.mask,training:null==r?null:r.training,initialState:null==r?null:r.initialState})})}computeOutputShape(e){let r=this.computeSingleOutputShape(e);return this.returnSequences||(r=[r[0],...r.slice(2)]),this.returnState&&(r=[r,...Array(2).fill([e[0],...r.slice(-3)])]),r}getInitialState(e){return U(()=>{const{stateSize:r}=this.cell,o=this.computeSingleOutputShape(e.shape),a=Nn([o[0],...o.slice(2)]);return Array.isArray(r)?Array(r.length).fill(a):[a]})}resetStates(e,r=!1){U(()=>{if(!this.stateful)throw new To("Cannot call resetStates() on an RNN Layer that is not stateful.");const s=this.inputSpec[0].shape,o=this.computeSingleOutputShape(s),i=[o[0],...o.slice(2)];if(null==s[0])throw new L("If an RNN is stateful, it needs to know its batch size. Specify the batch size of your input tensors: \n- If using a Sequential model, specify the batch size by passing a `batchInputShape` option to your first layer.\n- If using the functional API, specify the batch size by passing a `batchShape` option to your Input layer.");if(null==this.getStates())this.states_=Array.isArray(this.cell.stateSize)?this.cell.stateSize.map(()=>Nn(i)):[Nn(i)];else if(null==e)it(this.states_),null!=this.keptStates&&(it(this.keptStates),this.keptStates=[]),Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map(()=>Nn(i)):this.states_[0]=Nn(i);else{if(Array.isArray(e)||(e=[e]),e.length!==this.states_.length)throw new L(`Layer ${this.name} expects ${this.states_.length} state(s), but it received ${e.length} state value(s). Input received: ${e}`);r?this.keptStates.push(this.states_.slice()):it(this.states_);for(let l=0;l<this.states_.length;++l){const u=e[l],c=i;if(!Mt(u.shape,c))throw new L(`State ${l} is incompatible with layer ${this.name}: expected shape=${c}, received shape=${u.shape}`);this.states_[l]=u}}this.states_=this.states_.map(l=>ir(l.clone()))})}computeSingleOutputShape(e){const{dataFormat:r,filters:s,kernelSize:o,padding:i,strides:a,dilationRate:l}=this.cell,u="channelsFirst"===r,d=e[u?4:3],h=co(e[u?3:2],o[0],i,a[0],l[0]),f=co(d,o[1],i,a[1],l[1]);return[...e.slice(0,2),...u?[s,h,f]:[h,f,s]]}}return t.className="ConvRNN2D",t})(),fO=(()=>{class t extends bD{constructor(e){const{filters:r,kernelSize:s,strides:o,padding:i,dataFormat:a,dilationRate:l}=e;super(Object.assign({},e,{units:r})),this.filters=r,Jn(this.filters,"filters"),this.kernelSize=Nu(s,2,"kernelSize"),this.kernelSize.forEach(u=>Jn(u,"kernelSize")),this.strides=Nu(o||1,2,"strides"),this.strides.forEach(u=>Jn(u,"strides")),this.padding=i||"valid",ys(this.padding),this.dataFormat=a||"channelsLast",wn(this.dataFormat),this.dilationRate=Nu(l||1,2,"dilationRate"),this.dilationRate.forEach(u=>Jn(u,"dilationRate"))}build(e){var r;e=Vt(e);const s="channelsFirst"===this.dataFormat?1:e.length-1;if(null==e[s])throw new L(`The channel dimension of the input should be defined. Found ${e[s]}`);const a=this.kernelSize.concat([e[s],4*this.filters]);this.kernel=this.addWeight("kernel",a,null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint);const l=this.kernelSize.concat([this.filters,4*this.filters]);if(this.recurrentKernel=this.addWeight("recurrent_kernel",l,null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.useBias){let u;if(this.unitForgetBias){const c=this.biasInitializer,d=this.filters;u=new((r=class extends Ls{apply(f,p){return zI([c.apply([d]),ii([d]),c.apply([2*d])])}}).className="CustomInit",r)}else u=this.biasInitializer;this.bias=this.addWeight("bias",[4*this.filters],null,u,this.biasRegularizer,!0,this.biasConstraint)}this.built=!0}call(e,r){return U(()=>{if(3!==e.length)throw new L(`ConvLSTM2DCell expects 3 input Tensors (inputs, h, c), got ${e.length}.`);const s=r.training||!1,o=e[0],i=e[1],a=e[2];0<this.dropout&&this.dropout<1&&null==this.dropoutMask&&(this.dropoutMask=Xi({ones:()=>fs(o),rate:this.dropout,training:s,count:4}));const u=this.dropoutMask,c=(de,ge,pe)=>ge&&ge[pe]?V(ge[pe],de):de;let d=c(o,u,0),h=c(o,u,1),f=c(o,u,2),p=c(o,u,3);0<this.recurrentDropout&&this.recurrentDropout<1&&null==this.recurrentDropoutMask&&(this.recurrentDropoutMask=Xi({ones:()=>fs(i),rate:this.recurrentDropout,training:s,count:4}));const m=this.recurrentDropoutMask;let g=c(i,m,0),y=c(i,m,1),b=c(i,m,2),v=c(i,m,3);const[w,_,D,A]=ps(this.kernel.read(),4,3),[R,O,G,K]=this.useBias?ps(this.bias.read(),4):[null,null,null,null];d=this.inputConv(d,w,R,this.padding),h=this.inputConv(h,_,O,this.padding),f=this.inputConv(f,D,G,this.padding),p=this.inputConv(p,A,K,this.padding);const[j,Q,q,Y]=ps(this.recurrentKernel.read(),4,3);g=this.recurrentConv(g,j),y=this.recurrentConv(y,Q),b=this.recurrentConv(b,q),v=this.recurrentConv(v,Y);const re=this.recurrentActivation.apply(me(d,g)),ee=this.recurrentActivation.apply(me(h,y)),se=me(V(ee,a),V(re,this.activation.apply(me(f,b)))),ue=V(this.recurrentActivation.apply(me(p,v)),this.activation.apply(se));return[ue,ue,se]})}getConfig(){const s=function(t,n){var e={};for(var r in t)Object.prototype.hasOwnProperty.call(t,r)&&n.indexOf(r)<0&&(e[r]=t[r]);if(null!=t&&"function"==typeof Object.getOwnPropertySymbols){var s=0;for(r=Object.getOwnPropertySymbols(t);s<r.length;s++)n.indexOf(r[s])<0&&Object.prototype.propertyIsEnumerable.call(t,r[s])&&(e[r[s]]=t[r[s]])}return e}(super.getConfig(),["units"]);return Object.assign({},s,{filters:this.filters,kernelSize:this.kernelSize,padding:this.padding,dataFormat:this.dataFormat,dilationRate:this.dilationRate,strides:this.strides})}inputConv(e,r,s,o){const i=Vi(e,r,this.strides,o||"valid","channelsFirst"===this.dataFormat?"NCHW":"NHWC",this.dilationRate);return s?Ao(i,s,this.dataFormat):i}recurrentConv(e,r){return Vi(e,r,1,"same","channelsFirst"===this.dataFormat?"NCHW":"NHWC")}}return t.className="ConvLSTM2DCell",t})();le(fO),le((()=>{class t extends Nte{constructor(e){const r=new fO(e);super(Object.assign({},e,{cell:r}))}static fromConfig(e,r){return new e(r)}}return t.className="ConvLSTM2D",t})());let pO=(()=>{class t extends Dt{constructor(e){super(e),this.rate=Math.max(Math.min(e.rate,1),0),this.noiseShape=e.noiseShape,this.seed=e.seed,this.supportsMasking=!0}getNoiseShape(e){if(null==this.noiseShape)return this.noiseShape;const r=e.shape,s=[];for(let o=0;o<this.noiseShape.length;++o)s.push(this.noiseShape[o]??r[o]);return s}call(e,r){return U(()=>{this.invokeCallHook(e,r);const s=at(e);if(0<this.rate&&this.rate<1){const o=r.training??!1,i=this.getNoiseShape(s);return Mh(()=>yF(s,this.rate,i,this.seed),()=>s,o)}return e})}getConfig(){const e={rate:this.rate,noiseShape:this.noiseShape,seed:this.seed},r=super.getConfig();return Object.assign(e,r),e}dispose(){return super.dispose()}}return t.className="Dropout",t})();le(pO),le((()=>{class t extends pO{constructor(e){super(e),this.inputSpec=[{ndim:3}]}getNoiseShape(e){const r=e.shape;return[r[0],1,r[2]]}}return t.className="SpatialDropout1D",t})()),le((()=>{class t extends Dt{constructor(e){if(super(e),this.activation=null,this.useBias=!0,this.kernel=null,this.bias=null,this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_BIAS_INITIALIZER="zeros",null==e.batchInputShape&&null==e.inputShape&&null!=e.inputDim){let r=null;null!=e.batchSize&&(r=e.batchSize),this.batchInputShape=[r,e.inputDim]}this.units=e.units,Jn(this.units,"units"),this.activation=Ki(e.activation),null!=e.useBias&&(this.useBias=e.useBias),this.kernelInitializer=nn(e.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.biasInitializer=nn(e.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.kernelConstraint=Vn(e.kernelConstraint),this.biasConstraint=Vn(e.biasConstraint),this.kernelRegularizer=rn(e.kernelRegularizer),this.biasRegularizer=rn(e.biasRegularizer),this.activityRegularizer=rn(e.activityRegularizer),this.supportsMasking=!0,this.inputSpec=[{minNDim:2}]}build(e){const r=(e=Vt(e))[e.length-1];null==this.kernel&&(this.kernel=this.addWeight("kernel",[r,this.units],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.units],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint))),this.inputSpec=[{minNDim:2,axes:{[-1]:r}}],this.built=!0}computeOutputShape(e){const r=(e=Vt(e)).slice();return r[r.length-1]=this.units,r}call(e,r){return U(()=>{this.invokeCallHook(e,r);const s=at(e),o=iF(this.activation.getClassName());let i;return null!=o?i=ko(s,this.kernel.read(),o,this.bias?this.bias.read():null):(i=ko(s,this.kernel.read()),null!=this.bias&&(i=Ao(i,this.bias.read())),null!=this.activation&&(i=this.activation.apply(i))),i})}getConfig(){const e={units:this.units,activation:qi(this.activation),useBias:this.useBias,kernelInitializer:un(this.kernelInitializer),biasInitializer:un(this.biasInitializer),kernelRegularizer:Ut(this.kernelRegularizer),biasRegularizer:Ut(this.biasRegularizer),activityRegularizer:Ut(this.activityRegularizer),kernelConstraint:zn(this.kernelConstraint),biasConstraint:zn(this.biasConstraint)},r=super.getConfig();return Object.assign(e,r),e}}return t.className="Dense",t})()),le((()=>{class t extends Dt{constructor(e){super(e=e||{}),this.inputSpec=[{minNDim:3}],this.dataFormat=e.dataFormat}computeOutputShape(e){e=Vt(e);for(const r of e.slice(1))if(null==r)throw new L(`The shape of the input to "Flatten" is not fully defined (got ${e.slice(1)}). Make sure to pass a complete "input_shape" or "batch_input_shape" argument to the first layer in your model.`);return[e[0],Wi(e,1)]}call(e,r){return U(()=>{this.invokeCallHook(e,r);let s=at(e);if("channelsFirst"===this.dataFormat&&s.rank>1){const o=[0];for(let i=2;i<s.rank;++i)o.push(i);o.push(1),s=s.transpose(o)}return function cee(t){if(t.rank<=1)throw new L(`batchFlatten requires a minimum rank of 2. Got rank: ${t.rank}.`);const n=[t.shape[0],Wi(t.shape,1)];return t.reshape(n)}(s)})}getConfig(){const e={};null!=this.dataFormat&&(e.dataFormat=this.dataFormat);const r=super.getConfig();return Object.assign(e,r),e}}return t.className="Flatten",t})()),le((()=>{class t extends Dt{constructor(e){super(e),this.supportsMasking=!0,this.activation=Ki(e.activation)}call(e,r){return U(()=>{this.invokeCallHook(e,r);const s=at(e);return this.activation.apply(s)})}getConfig(){const e={activation:qi(this.activation)},r=super.getConfig();return Object.assign(e,r),e}}return t.className="Activation",t})()),le((()=>{class t extends Dt{constructor(e){super(e),this.n=e.n,this.inputSpec=[{ndim:2}]}computeOutputShape(e){return[e[0],this.n,e[1]]}call(e,r){return U(()=>function lee(t,n){return U(()=>{if(2!==t.shape.length)throw new L(`repeat() expects a rank-2 tensor, but received a rank-${t.shape.length} tensor.`);return VI(Fh(t,1),[1,n,1])})}(e=at(e),this.n))}getConfig(){const e={n:this.n},r=super.getConfig();return Object.assign(e,r),e}}return t.className="RepeatVector",t})()),le((()=>{class t extends Dt{constructor(e){super(e),this.targetShape=e.targetShape;for(let r=0;r<this.targetShape.length;++r)this.isUnknown(this.targetShape[r])&&(this.targetShape[r]=null)}isUnknown(e){return e<0||null==e}fixUnknownDimension(e,r){const s="Total size of new array must be unchanged.",o=r.slice();let i=1,a=null;for(let u=0;u<o.length;++u){const c=o[u];if(this.isUnknown(c)){if(null!==a)throw new L("Can only specifiy one unknown dimension.");a=u}else i*=c}const l=Wi(e);if(null!==a){if(0===i||l%i!=0)throw new L(s);o[a]=l/i}else if(l!==i)throw new L(s);return o}computeOutputShape(e){let r=!1;for(let s=0;s<e.length;++s)if(this.isUnknown(e[s])){r=!0;break}return r?e.slice(0,1).concat(this.targetShape):e.slice(0,1).concat(this.fixUnknownDimension(e.slice(1),this.targetShape))}call(e,r){return U(()=>{this.invokeCallHook(e,r);const s=at(e),o=s.shape,i=o.slice(0,1).concat(this.fixUnknownDimension(o.slice(1),this.targetShape));return s.reshape(i)})}getConfig(){const e={targetShape:this.targetShape},r=super.getConfig();return Object.assign(e,r),e}}return t.className="Reshape",t})()),le((()=>{class t extends Dt{constructor(e){if(super(e),null==e.dims)throw new Error("Required configuration field `dims` is missing during Permute constructor call.");if(!Array.isArray(e.dims))throw new Error(`Permute constructor requires \`dims\` to be an Array, but received ${e.dims} instead.`);const r=lo(1,e.dims.length+1);if(!Mt(e.dims.slice().sort(),r))throw new Error("Invalid permutation `dims`: "+JSON.stringify(e.dims)+" `dims` must contain consecutive integers starting from 1.");this.dims=e.dims,this.dimsIncludingBatch=[0].concat(this.dims),this.inputSpec=[new ur({ndim:this.dims.length+1})]}computeOutputShape(e){const r=(e=Vt(e)).slice();return this.dims.forEach((s,o)=>{r[o+1]=e[s]}),r}call(e,r){return Bt(at(e),this.dimsIncludingBatch)}getConfig(){const e={dims:this.dims},r=super.getConfig();return Object.assign(e,r),e}}return t.className="Permute",t})()),le((()=>{class t extends Dt{constructor(e){super(e??{}),this.supportsMasking=!0,this.maskValue=null!=e?e.maskValue??0:0}computeOutputShape(e){return e}getConfig(){const e=super.getConfig(),r={maskValue:this.maskValue};return Object.assign(r,e),r}computeMask(e,r){const s=at(e);return vg(yu(s,this.maskValue),-1)}call(e,r){return U(()=>{this.invokeCallHook(e,r);const s=at(e),a=vg(yu(s,this.maskValue),-1,!0);return s.mul(a.asType(s.dtype))})}}return t.className="Masking",t})()),le((()=>{class t extends Dt{constructor(e){if(super(e),this.embeddings=null,this.DEFAULT_EMBEDDINGS_INITIALIZER="randomUniform",null==e.batchInputShape&&null==e.inputShape){let r=null;null!=e.batchSize&&(r=e.batchSize),this.batchInputShape=null==e.inputLength?[r,null]:[r].concat(qt(e.inputLength))}this.inputDim=e.inputDim,Jn(this.inputDim,"inputDim"),this.outputDim=e.outputDim,Jn(this.outputDim,"outputDim"),this.embeddingsInitializer=nn(e.embeddingsInitializer||this.DEFAULT_EMBEDDINGS_INITIALIZER),this.embeddingsRegularizer=rn(e.embeddingsRegularizer),this.activityRegularizer=rn(e.activityRegularizer),this.embeddingsConstraint=Vn(e.embeddingsConstraint),this.maskZero=e.maskZero,this.supportsMasking=e.maskZero,this.inputLength=e.inputLength}build(e){this.embeddings=this.addWeight("embeddings",[this.inputDim,this.outputDim],this.dtype,this.embeddingsInitializer,this.embeddingsRegularizer,!0,this.embeddingsConstraint),this.built=!0}warnOnIncompatibleInputShape(e){}computeMask(e,r){return U(()=>this.maskZero?(e=at(e),yu(e,Ct(e))):null)}computeOutputShape(e){if(e=Vt(e),null==this.inputLength)return[...e,this.outputDim];const r=qt(this.inputLength);if(r.length!==e.length-1)throw new L(`"inputLength" is ${this.inputLength}, but received input shape has shape ${e}`);{let s=0;for(let o=0;o<r.length;++o){const i=r[o],a=e[o+1];if(null!=i&&null!=a&&i!==a)throw new L(`"inputLength" is ${this.inputLength}, but received input shape has shape ${e}`);null==i&&(r[s]=a),s++}}return[e[0],...r,this.outputDim]}call(e,r){return U(()=>{this.invokeCallHook(e,r);let s=at(e);return"int32"!==s.dtype&&(s=$h(s,"int32")),gF(this.embeddings.read(),s.as1D()).reshape(Vt(this.computeOutputShape(s.shape)))})}getConfig(){const e={inputDim:this.inputDim,outputDim:this.outputDim,embeddingsInitializer:un(this.embeddingsInitializer),embeddingsRegularizer:Ut(this.embeddingsRegularizer),activityRegularizer:Ut(this.activityRegularizer),embeddingsConstraint:zn(this.embeddingsConstraint),maskZero:this.maskZero,inputLength:this.inputLength},r=super.getConfig();return Object.assign(e,r),e}}return t.className="Embedding",t})());class Za extends Dt{constructor(n){super(n||{}),this.supportsMasking=!0}mergeFunction(n){throw new et}computeElementwiseOpOutputShape(n,e){if(null==n||null==e)return null;if(n.length<e.length)return this.computeElementwiseOpOutputShape(e,n);if(0===e.length)return n;const r=n.slice(0,n.length-e.length);for(let s=0;s<e.length;++s){const o=n[n.length-e.length+s],i=e[s];if(null==o||null==i||o<0||i<0)r.push(null);else if(1===o)r.push(i);else if(1===i)r.push(o);else{if(o!==i)throw new L("Operands could not be broadcast together with shapes "+JSON.stringify(n)+" "+JSON.stringify(e));r.push(o)}}return r}build(n){if(Array.isArray(n)&&!Array.isArray(n[0])&&(n=[Vt(n)]),n.length<2)throw new L(`A merge layer should be called on an Array of at least 2 inputs. Got ${n.length} input(s).`);let e=[];for(const o of n)null!=o&&null!==o[0]&&e.push(o[0]);if(e=Ui(e),e.length>1)throw new L(`Can not merge tensors with different batch sizes. Got tensors with shapes: ${JSON.stringify(n)}.`);let r=null==n[0]?null:n[0].slice(1);for(let o=1;o<n.length;++o){const i=null==n[o]?null:n[o].slice(1);r=this.computeElementwiseOpOutputShape(r,i)}const s=n.map(o=>o.length);this.reshapeRequired=-1!==n.indexOf(null)||1!==Ui(s).length}call(n,e){return U(()=>{if(this.reshapeRequired){const r=[],s=n.map(o=>o.rank);if(-1===s.indexOf(null)){const o=Hi(s);for(let i of n){const a=i.rank;for(let l=0;l<o-a;++l)i=Fh(i,1);r.push(i)}return this.mergeFunction(r)}{let o=!1;for(const l of n){const u=l.rank;if(null==u){const c=l.shape,d=c[0],h=c.slice(1).concat([d]);let f=l.reshape([d].concat(Wi(c.slice(1))));f=Bt(f,[1,0]),f=f.reshape(h),r.push(f),o=!0}else if(u>1){const c=lo(1,u).concat([0]);r.push(Bt(l,c)),o=!0}else r.push(l)}let i=this.mergeFunction(r);const a=i.rank;if(o)if(null==a){const l=i.shape,c=l[l.length-1],d=[c].concat(l.slice(0,l.length-1));i=Bt(i.reshape([-1,c]),[1,0]).reshape(d)}else if(a>1){const l=[a-1].concat(lo(0,a-1));i=Bt(i,l)}return i}}return this.mergeFunction(n)})}computeOutputShape(n){let e;e=null==n[0]?null:n[0].slice(1);for(let s=1;s<n.length;++s){const o=null==n[s]?null:n[s].slice(1);e=this.computeElementwiseOpOutputShape(e,o)}let r=[];for(const s of n)null!=s&&null!==s[0]&&r.push(s[0]);return r=Ui(r),e=1===r.length?r.concat(e):[null].concat(e),e}computeMask(n,e){return U(()=>{if(null==e)return null;if(!Array.isArray(e))throw new L("`mask` should be an Array");if(!Array.isArray(n))throw new L("`inputs` should be an Array");if(e.length!==n.length)throw new L(`The Array 'inputs' and 'mask' are expected to have the same length, but have different lengths (${n.length} vs ${e.length})`);if(e.every(s=>null==s))return null;let r=(e=e.map(s=>null==s?s:As(s,0)))[0];for(let s=1;s<e.length-1;++s)r=No(r,e[s]);return r})}}function Vh(t,n){for(;t<0;)t+=n;return t}function Uh(t,n,e,r,s,o=.001){let i;if(2===t.rank)i=FX(t,n,e,r,s,o);else if(3===t.rank)i=MX(t,n,e,r,s,o);else{if(4!==t.rank)throw new et(`batchNormalization is not implemented for array of rank ${t.rank} yet`);i=LX(t,n,e,r,s,o)}return i}function py(t,n,e,r,s,o){return U(()=>{let i;wn(s),uF(o),ys(r),null==e&&(e=[1,1]),null==r&&(r="valid"),null==s&&(s="channelsLast"),null==o&&(o="max"),t=gD(t,s);const a="same"===r?"same":"valid";return i="max"===o?_g(t,n,e,a):Cg(t,n,e,a),"channelsFirst"===s&&(i=Bt(i,[0,3,1,2])),i})}function mO(t,n,e,r,s,o){return U(()=>{let i;wn(s),uF(o),ys(r),null==e&&(e=[1,1,1]),null==r&&(r="valid"),null==s&&(s="channelsLast"),null==o&&(o="max"),t=sO(t,s);const a="same"===r?"same":"valid";return i="max"===o?Z$(t,n,e,a):K$(t,n,e,a),"channelsFirst"===s&&(i=Bt(i,[0,4,1,2,3])),i})}le((()=>{class t extends Za{constructor(e){super(e)}mergeFunction(e){return U(()=>{let r=e[0].clone();for(let s=1;s<e.length;++s)r=me(r,e[s]);return r})}}return t.className="Add",t})()),le((()=>{class t extends Za{constructor(e){super(e)}mergeFunction(e){return U(()=>{let r=e[0].clone();for(let s=1;s<e.length;++s)r=V(r,e[s]);return r})}}return t.className="Multiply",t})()),le((()=>{class t extends Za{constructor(e){super(e)}mergeFunction(e){return U(()=>{let r=e[0].clone();for(let s=1;s<e.length;++s)r=me(r,e[s]);return V(1/e.length,r)})}}return t.className="Average",t})()),le((()=>{class t extends Za{constructor(e){super(e)}mergeFunction(e){return U(()=>{let r=e[0];for(let s=1;s<e.length;++s)r=oi(r,e[s]);return r})}}return t.className="Maximum",t})()),le((()=>{class t extends Za{constructor(e){super(e)}mergeFunction(e){return U(()=>{let r=e[0];for(let s=1;s<e.length;++s)r=xh(r,e[s]);return r})}}return t.className="Minimum",t})()),le((()=>{class t extends Za{constructor(e){super(e),this.DEFAULT_AXIS=-1,null==e&&(e={}),this.axis=e.axis??this.DEFAULT_AXIS,this.supportsMasking=!0,this.reshapeRequired=!1}build(e){if(!Array.isArray(e)||!Array.isArray(e[0])||1===e.length)throw new L("A `Concatenate` layer should be called on a list of at least 2 inputs");let r=!0;for(const o of e)if(null!=o){r=!1;break}if(r)return;const s=[];for(let o=0;o<e.length;++o){const i=e[o].slice();i.splice(this.axis,1);let a=!1;for(const l of s)if(Mt(l,i)){a=!0;break}a||s.push(i)}if(s.length>1)throw new L("A `Concatenate` layer requires inputs with matching shapes except for the concat axis. Got input shapes: "+JSON.stringify(e))}mergeFunction(e){return U(()=>zI(e,this.axis))}computeOutputShape(e){if(!Array.isArray(e)||!Array.isArray(e[0]))throw new L("A `Concatenate` layer should be called on a list of inputs.");const r=e,s=r[0].slice(),o=this.axis<0?s.length+this.axis:this.axis;for(const i of r.slice(1)){if(null==s[o]||null==i[o]){s[o]=null;break}s[o]+=i[o]}return s}computeMask(e,r){if(null==r)return null;if(!Array.isArray(r))throw new L("`mask` should be an array for Concatenate");if(!Array.isArray(e))throw new L("`inputs` should be an array for Concatenate");if(r.length!==e.length)throw new L(`Mismatch in the length of mask (${r.length}) and the legnth of inputs (${e.length})`);return U(()=>{let s=!0;if(r.forEach(a=>{null==a||(s=!1)}),s)return null;const o=[];for(let a=0;a<e.length;++a)o.push(null==r[a]?fs(e[a]).asType("bool"):r[a].rank<e[a].rank?As(r[a],-1):r[a]);const i=Sn(o,this.axis);return wC(i,-1,!1)})}getConfig(){const e={axis:this.axis},r=super.getConfig();return Object.assign(e,r),e}}return t.className="Concatenate",t})()),le((()=>{class t extends Za{constructor(e){super(e),this.axes=e.axes,this.normalize=e.normalize??!1,this.supportsMasking=!0,this.reshapeRequired=!1}build(e){S(Array.isArray(e)&&2===e.length&&Array.isArray(e[0])&&Array.isArray(e[1]),()=>"A `Dot` layer should be called on a list of exactly 2 inputs.");const r=e[0],s=e[1];if(r.length>3||s.length>3)throw new et("Dot layer does not support tensors of 4D or higher rank yet.");const o=this.interpretAxes(r,s);if(r[o[0]]!==s[o[1]])throw new L(`Dimension incompatibility: ${r[o[0]]} !== ${s[o[1]]}`)}mergeFunction(e){if(2!==e.length)throw new L(`A \`Dot\` layer must be called on exactly 2 inputs, but received ${e.length} input(s).`);let o,r=e[0],s=e[1];return o=Array.isArray(this.axes)?this.axes.map((i,a)=>Vh(i,e[a].shape.length)):[Vh(this.axes,r.shape.length),Vh(this.axes,s.shape.length)],this.normalize&&(r=ry(r,o[0]),s=ry(s,o[1])),function Tte(t,n,e){if(t.shape.length>3||n.shape.length>3)throw new et("batchDot is not implemented for tensors of 4D or higher rank yet");if(S(t.shape.length>=2,()=>`batchDot requires the rank of x to be >= 2, but got ${t.shape.length}`),S(t.shape.length>=2,()=>`batchDot requires the rank of y to be >= 2, but got ${n.shape.length}`),"number"==typeof e&&(e=[e,e]),"complex64"===t.dtype||"complex64"===n.dtype)throw new et("batchDot is not implemented for complex64-type Tensors yet.");const r=t.shape.length,s=n.shape.length;null==e&&(e=[r-1,s-2]);const o=e;return U(()=>{let i,a;if(r>s){i=r-s;const l=[];for(let u=0;u<i;++u)l.push(1);n=n.reshape(n.shape.concat(l))}else if(s>r){i=s-r;const l=[];for(let u=0;u<i;++u)l.push(1);t=t.reshape(t.shape.concat(l))}else i=0;if(a=2===t.shape.length&&2===n.shape.length?o[0]===o[1]?t.mul(n).sum(o[0]):t.transpose([1,0]).mul(n).sum(o[1]):t.matMul(n,o[0]!==t.shape.length-1,o[1]===n.shape.length-1),i>0){let l;l=r>s?r+s-3:r-1;const u=[];for(let c=l;c<l+i;++c)u.push(c);a=a.squeeze(u)}return 1===a.shape.length&&(a=a.expandDims(1)),a})}(r,s,o)}interpretAxes(e,r){let s;return s=Array.isArray(this.axes)?this.axes:[Vh(this.axes,e.length),Vh(this.axes,r.length)],s}computeOutputShape(e){S(Array.isArray(e)&&2===e.length&&Array.isArray(e[0])&&Array.isArray(e[1]),()=>"A `Dot` layer should be called on a list of exactly 2 inputs.");const r=e[0].slice(),s=e[1].slice();if(r.length>3||s.length>3)throw new et("Dot layer does not support tensors of 4D or higher rank yet.");const o=this.interpretAxes(r,s);r.splice(o[0],1),s.splice(o[1],1),s.splice(0,1);const i=r.concat(s);return 1===i.length&&i.push(1),i}computeMask(e,r){return null}getConfig(){const e={axes:this.axes,normalize:this.normalize},r=super.getConfig();return Object.assign(e,r),e}}return t.className="Dot",t})()),le((()=>{class t extends Dt{constructor(e){super(e),this.supportsMasking=!0,this.stddev=e.stddev}computeOutputShape(e){return e}getConfig(){const e=super.getConfig(),r={stddev:this.stddev};return Object.assign(r,e),r}call(e,r){return U(()=>{this.invokeCallHook(e,r);const s=at(e);return Mh(()=>Yg(s.shape,0,this.stddev).add(s),()=>s,r.training||!1)})}}return t.className="GaussianNoise",t})()),le((()=>{class t extends Dt{constructor(e){super(e),this.supportsMasking=!0,this.rate=e.rate}computeOutputShape(e){return e}getConfig(){const e=super.getConfig(),r={rate:this.rate};return Object.assign(r,e),r}call(e,r){return U(()=>{this.invokeCallHook(e,r);const s=at(e);return this.rate>0&&this.rate<1?Mh(()=>{const i=Math.sqrt(this.rate/(1-this.rate));return s.mul(Yg(s.shape,1,i))},()=>s,r.training||!1):s})}}return t.className="GaussianDropout",t})()),le((()=>{class t extends Dt{constructor(e){super(e),this.supportsMasking=!0,this.rate=e.rate,this.noiseShape=e.noiseShape}_getNoiseShape(e){return this.noiseShape||at(e).shape}computeOutputShape(e){return e}getConfig(){const e=super.getConfig(),r={rate:this.rate};return Object.assign(r,e),r}call(e,r){return U(()=>{if(this.rate<1&&this.rate>0){const s=this._getNoiseShape(e);return Mh(()=>{const i=at(e),u=-1.7580993408473766;let c=Va(wh(s),this.rate);c=$h(c,"float32");const d=((1-this.rate)*(1+this.rate*u**2))**-.5,h=-d*u*this.rate;return i.mul(c).add(c.add(-1).mul(u)).mul(d).add(h)},()=>at(e),r.training||!1)}return e})}}return t.className="AlphaDropout",t})()),le((()=>{class t extends Dt{constructor(e){null==e&&(e={}),super(e),this.supportsMasking=!0,this.axis=e.axis??-1,this.momentum=e.momentum??.99,this.epsilon=e.epsilon??.001,this.center=e.center??!0,this.scale=e.scale??!0,this.betaInitializer=nn(e.betaInitializer||"zeros"),this.gammaInitializer=nn(e.gammaInitializer||"ones"),this.movingMeanInitializer=nn(e.movingMeanInitializer||"zeros"),this.movingVarianceInitializer=nn(e.movingVarianceInitializer||"ones"),this.betaConstraint=Vn(e.betaConstraint),this.gammaConstraint=Vn(e.gammaConstraint),this.betaRegularizer=rn(e.betaRegularizer),this.gammaRegularizer=rn(e.gammaRegularizer)}build(e){e=Vt(e);const r=this.axis>=0?this.axis:this.axis+e.length,s=e[r];if(null==s)throw new L(`Axis ${r} of input tensor should have a defined dimension but the layer received an input with shape ${JSON.stringify(e)}.`);this.inputSpec=[new ur({ndim:e.length,axes:{[r]:s}})];const o=[s];this.scale&&(this.gamma=this.addWeight("gamma",o,null,this.gammaInitializer,this.gammaRegularizer,!0,this.gammaConstraint)),this.center&&(this.beta=this.addWeight("beta",o,null,this.betaInitializer,this.betaRegularizer,!0,this.betaConstraint)),this.movingMean=this.addWeight("moving_mean",o,null,this.movingMeanInitializer,null,!1),this.movingVariance=this.addWeight("moving_variance",o,null,this.movingVarianceInitializer,null,!1),this.built=!0}call(e,r){return U(()=>{const s=r.training??!1,o=at(e),i=o.shape,a=i.length,l=lo(0,a),u=this.axis>=0?this.axis:this.axis+a;l.splice(u,1);const c=Ga(1,a);c[u]=i[u];const d=l.slice();d.sort();const h=!Mt(d,lo(0,a).slice(0,a-1));if(!s)return(()=>{if(h){const v=this.movingMean.read().reshape(c),x=this.movingVariance.read().reshape(c),w=this.center?this.beta.read().reshape(c):null,_=this.scale?this.gamma.read().reshape(c):null;return Uh(o,v,x,w,_,this.epsilon)}return Uh(o,this.movingMean.read(),this.movingVariance.read(),null==this.beta?null:this.beta.read(),null==this.gamma?null:this.gamma.read(),this.epsilon)})();const[p,m,g]=function Rte(t,n,e,r,s=.001){return Mt(r.slice().sort(),lo(0,t.rank-1))?function kte(t,n,e,r,s=.001){return U(()=>{const o=kC(t,r),i=o.mean,a=o.variance;return[Uh(t,i,a,e,n,s),i,a]})}(t,n,e,r,s):function Ate(t,n,e,r,s=.001){return U(()=>{const o=kC(t,r),i=o.mean,a=o.variance,l=[];for(const p of lo(0,t.rank))-1!==r.indexOf(p)?l.push(1):l.push(t.shape[p]);const u=i.reshape(l),c=a.reshape(l),d=null==n?null:n.reshape(l),h=null==e?null:e.reshape(l);return[Uh(t,u,c,h,d,s),i,a]})}(t,n,e,r,s)}(o,this.gamma.read(),this.beta.read(),l,this.epsilon),y=(v,x,w)=>{U(()=>{const _=1-w,D=v.read(),A=D.sub(x).mul(_);v.write(D.sub(A))})};return(()=>{y(this.movingMean,m,this.momentum),y(this.movingVariance,g,this.momentum)})(),p})}getConfig(){const e={axis:this.axis,momentum:this.momentum,epsilon:this.epsilon,center:this.center,scale:this.scale,betaInitializer:un(this.betaInitializer),gammaInitializer:un(this.gammaInitializer),movingMeanInitializer:un(this.movingMeanInitializer),movingVarianceInitializer:un(this.movingVarianceInitializer),betaRegularizer:Ut(this.betaRegularizer),gammaRegularizer:Ut(this.gammaRegularizer),betaConstraint:zn(this.betaConstraint),gammaConstraint:zn(this.gammaConstraint)},r=super.getConfig();return Object.assign(e,r),e}}return t.className="BatchNormalization",t})()),le((()=>{class t extends Dt{constructor(e){if(null==e&&(e={}),super(e),this.axis=e.axis??-1,"number"==typeof this.axis){if(!Number.isInteger(this.axis))throw new Error(`Expected axis to be an integer, but received ${this.axis}`)}else{if(!Array.isArray(this.axis))throw new Error(`Expected axis to be an integer or an array of integers, but received ${JSON.stringify(this.axis)}`);for(const r of this.axis)if(!Number.isInteger(r))throw new Error(`Expected axis to be an array of integers, but received ${JSON.stringify(this.axis)}`)}this.epsilon=e.epsilon??.001,this.center=e.center??!0,this.scale=e.scale??!0,this.betaInitializer=nn(e.betaInitializer||"zeros"),this.gammaInitializer=nn(e.gammaInitializer||"ones"),this.betaRegularizer=rn(e.betaRegularizer),this.gammaRegularizer=rn(e.gammaRegularizer),this.supportsMasking=!0}build(e){const r=(e=Vt(e)).length;"number"==typeof this.axis&&(this.axis=[this.axis]);for(let i=0;i<this.axis.length;++i)this.axis[i]<0&&(this.axis[i]+=r);for(const i of this.axis)if(i<0||i>=r)throw new Error(`Invalid axis: ${i}`);if(this.axis.length!==Ui(this.axis).length)throw new Error(`Found duplicate axes in: ${this.axis}`);const s=this.axis.map(i=>e[i]);this.gamma=this.scale?this.addWeight("gamma",s,"float32",this.gammaInitializer,this.gammaRegularizer,!0):null,this.beta=this.center?this.addWeight("beta",s,"float32",this.betaInitializer,this.betaRegularizer,!0):null,this.built=!0}call(e,r){const s=at(e),o=s.shape,i=o.length;return U(()=>{let{mean:l,variance:u}=kC(s,this.axis,!0);const c=Ga(1,i);for(const g of this.axis)c[g]=o[g];const d=g=>null!=g&&g.shape.length!==i&&this.axis!==[i-1]?g.reshape(c):g;let h=d(this.gamma.read()),f=d(this.beta.read());const p=[],m=[];for(let g=0;g<i;++g)-1!==this.axis.indexOf(g)?(p.push(o[g]),m.push(1)):(p.push(1),m.push(o[g]));return l=l.tile(p),u=u.tile(p),h=h.tile(m),f=f.tile(m),Uh(s,l,u,f,h,this.epsilon)})}getConfig(){const e={axis:this.axis,epsilon:this.epsilon,center:this.center,scale:this.scale,betaInitializer:un(this.betaInitializer),gammaInitializer:un(this.gammaInitializer),betaRegularizer:Ut(this.betaRegularizer),gammaRegularizer:Ut(this.gammaRegularizer)},r=super.getConfig();return Object.assign(e,r),e}}return t.className="LayerNormalization",t})()),le((()=>{class t extends Dt{constructor(e){if(null==e&&(e={}),super(e),this.dataFormat=e.dataFormat??"channelsLast",null==e.padding)this.padding=[[1,1],[1,1]];else if("number"==typeof e.padding)this.padding=[[e.padding,e.padding],[e.padding,e.padding]];else{if(e.padding=e.padding,2!==e.padding.length)throw new L(`ZeroPadding2D expects padding to be a length-2 array, but received a length-${e.padding.length} array.`);let r,s;if("number"==typeof e.padding[0])r=[e.padding[0],e.padding[0]],s=[e.padding[1],e.padding[1]];else{if(e.padding=e.padding,2!==e.padding[0].length)throw new L(`ZeroPadding2D expects height padding to be a length-2 array, but received a length-${e.padding[0].length} array.`);if(r=e.padding[0],2!==e.padding[1].length)throw new L(`ZeroPadding2D expects width padding to be a length-2 array, but received a length-${e.padding[1].length} array.`);s=e.padding[1]}this.padding=[r,s]}this.inputSpec=[new ur({ndim:4})]}computeOutputShape(e){let r,s;return e=Vt(e),"channelsFirst"===this.dataFormat?(r=null!=e[2]&&e[2]>=0?e[2]+this.padding[0][0]+this.padding[0][1]:null,s=null!=e[3]&&e[3]>=0?e[3]+this.padding[1][0]+this.padding[1][1]:null,[e[0],e[1],r,s]):(r=null!=e[1]&&e[1]>=0?e[1]+this.padding[0][0]+this.padding[0][1]:null,s=null!=e[2]&&e[2]>=0?e[2]+this.padding[1][0]+this.padding[1][1]:null,[e[0],r,s,e[3]])}call(e,r){return U(()=>function $te(t,n,e){return U(()=>{if(4!==t.rank)throw new L(`temporalPadding expects input tensor to be 4-D, but received a ${t.rank}-D tensor.`);if(null==n&&(n=[[1,1],[1,1]]),2!==n.length||2!==n[0].length||2!==n[1].length)throw new L("spatial2dPadding expects `padding` to be an Array of two Arrays, each of which is an Array of two integers.");if(null==e&&(e="channelsLast"),"channelsLast"!==e&&"channelsFirst"!==e)throw new L(`Unknown data format: ${e}. Supported data formats are 'channelsLast' and 'channelsFirst.`);let r;return r="channelsFirst"===e?[[0,0],[0,0],n[0],n[1]]:[[0,0],n[0],n[1],[0,0]],Sg(t,r)})}(at(e),this.padding,this.dataFormat))}getConfig(){const e={padding:this.padding,dataFormat:this.dataFormat},r=super.getConfig();return Object.assign(e,r),e}}return t.className="ZeroPadding2D",t})());class gO extends Dt{constructor(n){if(null==n.poolSize&&(n.poolSize=2),super(n),"number"==typeof n.poolSize)this.poolSize=[n.poolSize];else{if(!Array.isArray(n.poolSize)||1!==n.poolSize.length||"number"!=typeof n.poolSize[0])throw new L(`poolSize for 1D convolutional layer must be a number or an Array of a single number, but received ${JSON.stringify(n.poolSize)}`);this.poolSize=n.poolSize}if(Jn(this.poolSize,"poolSize"),null==n.strides)this.strides=this.poolSize;else if("number"==typeof n.strides)this.strides=[n.strides];else{if(!Array.isArray(n.strides)||1!==n.strides.length||"number"!=typeof n.strides[0])throw new L(`strides for 1D convolutional layer must be a number or an Array of a single number, but received ${JSON.stringify(n.strides)}`);this.strides=n.strides}Jn(this.strides,"strides"),this.padding=n.padding??"valid",ys(this.padding),this.inputSpec=[new ur({ndim:3})]}computeOutputShape(n){const e=co((n=Vt(n))[1],this.poolSize[0],this.padding,this.strides[0]);return[n[0],e,n[2]]}call(n,e){return U(()=>{this.invokeCallHook(n,e),n=Fh(at(n),2);const r=this.poolingFunction(at(n),[this.poolSize[0],1],[this.strides[0],1],this.padding,"channelsLast");return vu(r,[2])})}getConfig(){const n={poolSize:this.poolSize,padding:this.padding,strides:this.strides},e=super.getConfig();return Object.assign(n,e),n}}le((()=>{class t extends gO{constructor(e){super(e)}poolingFunction(e,r,s,o,i){return wn(i),ys(o),py(e,r,s,o,i,"max")}}return t.className="MaxPooling1D",t})()),le((()=>{class t extends gO{constructor(e){super(e)}poolingFunction(e,r,s,o,i){return wn(i),ys(o),py(e,r,s,o,i,"avg")}}return t.className="AveragePooling1D",t})());class yO extends Dt{constructor(n){if(null==n.poolSize&&(n.poolSize=[2,2]),super(n),this.poolSize=Array.isArray(n.poolSize)?n.poolSize:[n.poolSize,n.poolSize],null==n.strides)this.strides=this.poolSize;else if(Array.isArray(n.strides)){if(2!==n.strides.length)throw new L(`If the strides property of a 2D pooling layer is an Array, it is expected to have a length of 2, but received length ${n.strides.length}.`);this.strides=n.strides}else this.strides=[n.strides,n.strides];Jn(this.poolSize,"poolSize"),Jn(this.strides,"strides"),this.padding=n.padding??"valid",this.dataFormat=n.dataFormat??"channelsLast",wn(this.dataFormat),ys(this.padding),this.inputSpec=[new ur({ndim:4})]}computeOutputShape(n){n=Vt(n);let e="channelsFirst"===this.dataFormat?n[2]:n[1],r="channelsFirst"===this.dataFormat?n[3]:n[2];return e=co(e,this.poolSize[0],this.padding,this.strides[0]),r=co(r,this.poolSize[1],this.padding,this.strides[1]),"channelsFirst"===this.dataFormat?[n[0],n[1],e,r]:[n[0],e,r,n[3]]}call(n,e){return U(()=>(this.invokeCallHook(n,e),this.poolingFunction(at(n),this.poolSize,this.strides,this.padding,this.dataFormat)))}getConfig(){const n={poolSize:this.poolSize,padding:this.padding,strides:this.strides,dataFormat:this.dataFormat},e=super.getConfig();return Object.assign(n,e),n}}le((()=>{class t extends yO{constructor(e){super(e)}poolingFunction(e,r,s,o,i){return wn(i),ys(o),py(e,r,s,o,i,"max")}}return t.className="MaxPooling2D",t})()),le((()=>{class t extends yO{constructor(e){super(e)}poolingFunction(e,r,s,o,i){return wn(i),ys(o),py(e,r,s,o,i,"avg")}}return t.className="AveragePooling2D",t})());class bO extends Dt{constructor(n){if(null==n.poolSize&&(n.poolSize=[2,2,2]),super(n),this.poolSize=Array.isArray(n.poolSize)?n.poolSize:[n.poolSize,n.poolSize,n.poolSize],null==n.strides)this.strides=this.poolSize;else if(Array.isArray(n.strides)){if(3!==n.strides.length)throw new L(`If the strides property of a 3D pooling layer is an Array, it is expected to have a length of 3, but received length ${n.strides.length}.`);this.strides=n.strides}else this.strides=[n.strides,n.strides,n.strides];Jn(this.poolSize,"poolSize"),Jn(this.strides,"strides"),this.padding=n.padding??"valid",this.dataFormat=n.dataFormat??"channelsLast",wn(this.dataFormat),ys(this.padding),this.inputSpec=[new ur({ndim:5})]}computeOutputShape(n){n=Vt(n);let e="channelsFirst"===this.dataFormat?n[2]:n[1],r="channelsFirst"===this.dataFormat?n[3]:n[2],s="channelsFirst"===this.dataFormat?n[4]:n[3];return e=co(e,this.poolSize[0],this.padding,this.strides[0]),r=co(r,this.poolSize[1],this.padding,this.strides[1]),s=co(s,this.poolSize[2],this.padding,this.strides[2]),"channelsFirst"===this.dataFormat?[n[0],n[1],e,r,s]:[n[0],e,r,s,n[4]]}call(n,e){return U(()=>(this.invokeCallHook(n,e),this.poolingFunction(at(n),this.poolSize,this.strides,this.padding,this.dataFormat)))}getConfig(){const n={poolSize:this.poolSize,padding:this.padding,strides:this.strides,dataFormat:this.dataFormat},e=super.getConfig();return Object.assign(n,e),n}}le((()=>{class t extends bO{constructor(e){super(e)}poolingFunction(e,r,s,o,i){return wn(i),ys(o),mO(e,r,s,o,i,"max")}}return t.className="MaxPooling3D",t})()),le((()=>{class t extends bO{constructor(e){super(e)}poolingFunction(e,r,s,o,i){return wn(i),ys(o),mO(e,r,s,o,i,"avg")}}return t.className="AveragePooling3D",t})());class vO extends Dt{constructor(n){super(n),this.inputSpec=[new ur({ndim:3})]}computeOutputShape(n){return[n[0],n[2]]}call(n,e){throw new et}}le((()=>{class t extends vO{constructor(e){super(e||{})}call(e,r){return U(()=>{const s=at(e);return pn(s,1)})}}return t.className="GlobalAveragePooling1D",t})()),le((()=>{class t extends vO{constructor(e){super(e||{})}call(e,r){return U(()=>{const s=at(e);return $s(s,1)})}}return t.className="GlobalMaxPooling1D",t})());class xO extends Dt{constructor(n){super(n),this.dataFormat=n.dataFormat??"channelsLast",wn(this.dataFormat),this.inputSpec=[new ur({ndim:4})]}computeOutputShape(n){return"channelsLast"===this.dataFormat?[n[0],n[3]]:[n[0],n[1]]}call(n,e){throw new et}getConfig(){const n={dataFormat:this.dataFormat},e=super.getConfig();return Object.assign(n,e),n}}le((()=>{class t extends xO{call(e,r){return U(()=>{const s=at(e);return pn(s,"channelsLast"===this.dataFormat?[1,2]:[2,3])})}}return t.className="GlobalAveragePooling2D",t})()),le((()=>{class t extends xO{call(e,r){return U(()=>{const s=at(e);return $s(s,"channelsLast"===this.dataFormat?[1,2]:[2,3])})}}return t.className="GlobalMaxPooling2D",t})());class wO extends Dt{constructor(n){super(n),this.layer=n.layer}build(n){this.built=!0}get trainable(){return null!=this.layer&&this.layer.trainable}set trainable(n){null!=this.layer&&(this.layer.trainable=n)}get trainableWeights(){return this.layer.trainableWeights}get nonTrainableWeights(){return this.layer.nonTrainableWeights}get updates(){return this.layer._updates}get losses(){return this.layer.losses}getWeights(){return this.layer.getWeights()}setWeights(n){this.layer.setWeights(n)}getConfig(){const n={layer:{className:this.layer.getClassName(),config:this.layer.getConfig()}},e=super.getConfig();return Object.assign(n,e),n}setFastWeightInitDuringBuild(n){super.setFastWeightInitDuringBuild(n),null!=this.layer&&this.layer.setFastWeightInitDuringBuild(n)}static fromConfig(n,e,r={}){const o=fi(e.layer,r);delete e.layer;const i={layer:o};return Object.assign(i,e),new n(i)}}le((()=>{class t extends wO{constructor(e){super(e),this.supportsMasking=!0}build(e){if((e=Vt(e)).length<3)throw new L(`TimeDistributed layer expects an input shape >= 3D, but received input shape ${JSON.stringify(e)}`);this.inputSpec=[{shape:e}];const r=[e[0]].concat(e.slice(2));this.layer.built||(this.layer.build(r),this.layer.built=!0),super.build(e)}computeOutputShape(e){const r=[(e=Vt(e))[0]].concat(e.slice(2)),s=this.layer.computeOutputShape(r);return[s[0],e[1]].concat(s.slice(1))}call(e,r){return U(()=>uO((a,l)=>[at(this.layer.call(a,r)),[]],e=at(e),[],!1,null,null,!1,!0)[1])}}return t.className="TimeDistributed",t})()),le((()=>{class t extends wO{constructor(e){super(e);const r=e.layer.getConfig(),s={};s.className=e.layer.getClassName(),s.config=r,this.forwardLayer=fi(s),r.goBackwards=!0!==r.goBackwards;const o={};if(o.className=e.layer.getClassName(),o.config=r,this.backwardLayer=fi(o),this.forwardLayer.name="forward_"+this.forwardLayer.name,this.backwardLayer.name="backward_"+this.backwardLayer.name,this.mergeMode=void 0===e.mergeMode?"concat":e.mergeMode,function Fte(t){qa(tee,"BidirectionalMergeMode",t)}(this.mergeMode),e.weights)throw new et("weights support is not implemented for Bidirectional layer yet.");this._stateful=e.layer.stateful,this.returnSequences=e.layer.returnSequences,this.returnState=e.layer.returnState,this.supportsMasking=!0,this._trainable=!0,this.inputSpec=e.layer.inputSpec,this.numConstants=null}get trainable(){return this._trainable}set trainable(e){this._trainable=e,null!=this.forwardLayer&&(this.forwardLayer.trainable=e),null!=this.backwardLayer&&(this.backwardLayer.trainable=e)}getWeights(){return this.forwardLayer.getWeights().concat(this.backwardLayer.getWeights())}setWeights(e){const s=Math.floor(e.length/2);this.forwardLayer.setWeights(e.slice(0,s)),this.backwardLayer.setWeights(e.slice(s))}computeOutputShape(e){let s,o,i,r=this.forwardLayer.computeOutputShape(e);return Array.isArray(r)&&Array.isArray(r[0])||(r=[r]),this.returnState&&(i=r.slice(1)),s=r[0],"concat"===this.mergeMode?(s[s.length-1]*=2,o=[s]):o=null==this.mergeMode?[s,s.slice()]:[s],this.returnState?null==this.mergeMode?o.concat(i).concat(i.slice()):[s].concat(i).concat(i.slice()):Lr(o)}apply(e,r){let s=null==r?null:r.initialState,o=null==r?null:r.constants;null==r&&(r={});const i=lO(e,s,o,this.numConstants);if(e=i.inputs,s=i.initialState,o=i.constants,Array.isArray(e)&&(s=e.slice(1),e=e[0]),(null==s||0===s.length)&&null==o)return super.apply(e,r);const a=[],l=[];if(null!=s){const c=s.length;if(c%2>0)throw new L("When passing `initialState` to a Bidrectional RNN, the state should be an Array containing the states of the underlying RNNs.");r.initialState=s,a.push(...s);const d=s.map(h=>new ur({shape:h.shape}));this.forwardLayer.stateSpec=d.slice(0,c/2),this.backwardLayer.stateSpec=d.slice(c/2),l.push(...d)}if(null!=o)throw new et("Support for constants in Bidirectional layers is not implemented yet.");const u=a[0]instanceof $o;for(const c of a)if(c instanceof $o!==u)throw new L("The initial state of a Bidirectional layer cannot be specified as a mix of symbolic and non-symbolic tensors");if(u){const c=[e].concat(a),d=this.inputSpec.concat(l),h=this.inputSpec;this.inputSpec=d;const f=super.apply(c,r);return this.inputSpec=h,f}return super.apply(e,r)}call(e,r){return U(()=>{const s=r.initialState;let o,i,a,l;if(null==s)o=this.forwardLayer.call(e,r),i=this.backwardLayer.call(e,r);else{const u=s.slice(0,s.length/2),c=s.slice(s.length/2);o=this.forwardLayer.call(e,Object.assign(r,{initialState:u})),i=this.backwardLayer.call(e,Object.assign(r,{initialState:c}))}return this.returnState&&(Array.isArray(o)&&(a=o.slice(1).concat(i.slice(1))),o=o[0],i=i[0]),this.returnSequences&&(i=li(i,1)),"concat"===this.mergeMode?l=zI([o,i]):"sum"===this.mergeMode?l=me(o,i):"ave"===this.mergeMode?l=V(.5,me(o,i)):"mul"===this.mergeMode?l=V(o,i):null==this.mergeMode&&(l=[o,i]),this.returnState?null==this.mergeMode?l.concat(a):[l].concat(a):l})}resetStates(e){this.forwardLayer.resetStates(),this.backwardLayer.resetStates()}build(e){Ka(this.forwardLayer.name,()=>{this.forwardLayer.build(e)}),Ka(this.backwardLayer.name,()=>{this.backwardLayer.build(e)}),this.built=!0}computeMask(e,r){let s;if(Array.isArray(r)&&(r=r[0]),s=this.returnSequences?null==this.mergeMode?[r,r]:r:null==this.mergeMode?[null,null]:null,this.returnState){const i=this.forwardLayer.states.map(a=>null);return Array.isArray(s)?s.concat(i).concat(i):[s].concat(i).concat(i)}return s}get trainableWeights(){return this.forwardLayer.trainableWeights.concat(this.backwardLayer.trainableWeights)}get nonTrainableWeights(){return this.forwardLayer.nonTrainableWeights.concat(this.backwardLayer.nonTrainableWeights)}setFastWeightInitDuringBuild(e){super.setFastWeightInitDuringBuild(e),null!=this.forwardLayer&&this.forwardLayer.setFastWeightInitDuringBuild(e),null!=this.backwardLayer&&this.backwardLayer.setFastWeightInitDuringBuild(e)}getConfig(){const e={mergeMode:this.mergeMode},r=super.getConfig();return Object.assign(e,r),e}static fromConfig(e,r){const s=fi(r.layer);if(delete r.layer,null!=r.numConstants)throw new et("Deserialization of a Bidirectional layer with numConstants present is not supported yet.");const o=r;return o.layer=s,new e(o)}}return t.className="Bidirectional",t})());var SO,Bs=(()=>{return(t=Bs||(Bs={}))[t.DT_INVALID=0]="DT_INVALID",t[t.DT_FLOAT=1]="DT_FLOAT",t[t.DT_DOUBLE=2]="DT_DOUBLE",t[t.DT_INT32=3]="DT_INT32",t[t.DT_UINT8=4]="DT_UINT8",t[t.DT_INT16=5]="DT_INT16",t[t.DT_INT8=6]="DT_INT8",t[t.DT_STRING=7]="DT_STRING",t[t.DT_COMPLEX64=8]="DT_COMPLEX64",t[t.DT_INT64=9]="DT_INT64",t[t.DT_BOOL=10]="DT_BOOL",t[t.DT_QINT8=11]="DT_QINT8",t[t.DT_QUINT8=12]="DT_QUINT8",t[t.DT_QINT32=13]="DT_QINT32",t[t.DT_BFLOAT16=14]="DT_BFLOAT16",t[t.DT_FLOAT_REF=101]="DT_FLOAT_REF",t[t.DT_DOUBLE_REF=102]="DT_DOUBLE_REF",t[t.DT_INT32_REF=103]="DT_INT32_REF",t[t.DT_UINT8_REF=104]="DT_UINT8_REF",t[t.DT_INT16_REF=105]="DT_INT16_REF",t[t.DT_INT8_REF=106]="DT_INT8_REF",t[t.DT_STRING_REF=107]="DT_STRING_REF",t[t.DT_COMPLEX64_REF=108]="DT_COMPLEX64_REF",t[t.DT_INT64_REF=109]="DT_INT64_REF",t[t.DT_BOOL_REF=110]="DT_BOOL_REF",t[t.DT_QINT8_REF=111]="DT_QINT8_REF",t[t.DT_QUINT8_REF=112]="DT_QUINT8_REF",t[t.DT_QINT32_REF=113]="DT_QINT32_REF",t[t.DT_BFLOAT16_REF=114]="DT_BFLOAT16_REF",Bs;var t})();!function(t){let n;var e;(e=n=t.CheckpointFormatVersion||(t.CheckpointFormatVersion={}))[e.LEGACY=0]="LEGACY",e[e.V1=1]="V1",e[e.V2=2]="V2"}(SO||(SO={}));const _D={};function EO(t){return _D[t]}function C(t,n,e,r,s){const o=n.inputParams[t];if(o&&void 0!==o.inputIndexStart){const a=o.inputIndexStart,l=0===o.inputIndexEnd?void 0:void 0===o.inputIndexEnd?a+1:o.inputIndexEnd;if("tensor"===o.type)return Br(n.inputNames[o.inputIndexStart],e,r,s);if("tensors"===o.type)return n.inputNames.slice(a,l).map(h=>Br(h,e,r,s));const u=Br(n.inputNames.slice(a)[0],e,r,s),c=u.dataSync();return"number"===o.type?c[0]:Ns(u.shape,c)}const i=n.attrParams[t];return i&&i.value}function Br(t,n,e,r){const[s,o]=Yr(t);if(null!=r){const a=r.getHashTableHandleByName(s);if(null!=a)return a}const i=e.currentContextIds.find(a=>!!n[gy(s,a)]);return void 0!==i?n[gy(s,i)][o]:void 0}function pi(t,n){const[e,r]=Yr(t);return[gy(e,n&&n.currentContextId),r]}function gy(t,n){return n?`${t}-${n}`:t}function Yr(t){const n=t.split(":");return 1===n.length?[t,0]:[n[0],Number(n[n.length-1])]}function yy(t,n,e){let r=C("pad",t,n,e);if("explicit"===r){r=C("explicitPaddings",t,n,e);const s=[[0,0],[0,0],[0,0],[0,0]];for(let o=0;o<4;o++)s[o][0]=r[2*o],s[o][1]=r[2*o+1];return s}return r}function mi(t){return t.kept?t:Pa(t)}const zte=[{tfOpName:"Add",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"AddV2",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"AddN",category:"arithmetic",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}]},{tfOpName:"BiasAdd",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"Sub",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"RealDiv",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Div",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"DivNoNan",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"FloorDiv",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Mul",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Maximum",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Minimum",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Pow",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"SquaredDifference",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Mod",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"FloorMod",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}],Vte=[{tfOpName:"Abs",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Acos",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Asin",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Atan",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Atan2",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"y",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Ceil",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ClipByValue",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"clipValueMin",type:"number"},{start:2,name:"clipValueMax",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Complex",category:"basic_math",inputs:[{start:0,name:"real",type:"tensor"},{start:1,name:"imag",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ComplexAbs",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Cos",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Cosh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Elu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Exp",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Floor",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Log",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Imag",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"Tout",name:"outputType",type:"dtype",notSupported:!0}]},{tfOpName:"Neg",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Real",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"Tout",name:"outputType",type:"dtype",notSupported:!0}]},{tfOpName:"Prelu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"alpha",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Relu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Relu6",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Selu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sigmoid",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sin",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sinh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sqrt",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Rsqrt",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Square",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Tan",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Tanh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sign",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Round",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Expm1",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Log1p",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Reciprocal",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Softplus",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Asinh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Acosh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Atanh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Erf",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Prod",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axes",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool",notSupported:!0},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LeakyRelu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"alpha",name:"alpha",type:"number",defaultValue:.2},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}],Ute=[{tfOpName:"EmptyTensorList",category:"control",inputs:[{start:0,name:"elementShape",type:"shape"},{start:1,name:"maxNumElements",type:"number"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"LoopCond",category:"control",inputs:[{start:0,name:"pred",type:"tensor"}]},{tfOpName:"Switch",category:"control",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"pred",type:"tensor"}]},{tfOpName:"Merge",category:"control",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}]},{tfOpName:"Enter",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"frame_name",name:"frameName",type:"string"},{tfName:"is_constant",name:"isConstant",type:"bool"}]},{tfOpName:"Exit",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"NextIteration",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"TensorArrayV3",category:"control",inputs:[{start:0,name:"size",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"element_shape",name:"elementShape",type:"shape"},{tfName:"dynamic_size",name:"dynamicSize",type:"bool"},{tfName:"clear_after_read",name:"clearAfterRead",type:"bool"},{tfName:"identical_element_shapes",name:"identicalElementShapes",type:"bool"},{tfName:"tensor_array_name",name:"name",type:"string"}]},{tfOpName:"TensorArrayWriteV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"tensor",type:"tensor"},{start:3,name:"flowIn",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"TensorArrayReadV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"flowIn",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"TensorArrayGatherV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"flowIn",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"element_shape",name:"elementShape",type:"shape"}]},{tfOpName:"TensorArrayScatterV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"tensor",type:"tensor"},{start:3,name:"flowIn",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"TensorArrayConcatV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"flowIn",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"element_shape_except0",name:"elementShapeExcept0",type:"shape",notSupported:!0}]},{tfOpName:"TensorArraySplitV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"tensor",type:"tensor"},{start:2,name:"lengths",type:"number[]"},{start:3,name:"flowIn",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"TensorArraySizeV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"flowIn",type:"number"}]},{tfOpName:"TensorArrayCloseV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"}]},{tfOpName:"StatelessIf",category:"control",inputs:[{start:0,name:"cond",type:"tensor"},{start:1,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"then_branch",name:"thenBranch",type:"func"},{tfName:"else_branch",name:"elseBranch",type:"func"}]},{tfOpName:"If",category:"control",inputs:[{start:0,name:"cond",type:"tensor"},{start:1,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"then_branch",name:"thenBranch",type:"func"},{tfName:"else_branch",name:"elseBranch",type:"func"}]},{tfOpName:"StatelessWhile",category:"control",inputs:[{start:0,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"cond",name:"cond",type:"func"},{tfName:"body",name:"body",type:"func"}]},{tfOpName:"While",category:"control",inputs:[{start:0,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"cond",name:"cond",type:"func"},{tfName:"body",name:"body",type:"func"}]},{tfOpName:"TensorListScatter",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListScatterV2",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"elementShape",type:"shape"},{start:3,name:"numElements",type:"number"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListGather",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListGetItem",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListSetItem",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"tensor",type:"tensor"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListReserve",category:"control",inputs:[{start:0,name:"elementShape",type:"shape"},{start:1,name:"numElements",type:"number"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListFromTensor",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListStack",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"},{tfName:"num_elements",name:"numElements",type:"dtype"}]},{tfOpName:"TensorListSplit",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"elementShape",type:"shape"},{start:2,name:"lengths",type:"number[]"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListConcat",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"}],attrs:[{tfName:"element_shape",name:"elementShape",type:"shape"},{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListPopBack",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListPushBack",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"tensor",type:"tensor"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]}],Wte=[{tfOpName:"AvgPool",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MaxPool",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[],notSupported:!0},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MaxPoolWithArgmax",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"include_batch_in_index",name:"includeBatchInIndex",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"AvgPool3D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MaxPool3D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Conv1D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"stride",name:"stride",type:"number"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NWC"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"dilation",name:"dilation",type:"number",defaultValue:1}]},{tfOpName:"Conv2D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"useCudnnOnGpu",name:"useCudnnOnGpu",type:"bool"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"_FusedConv2D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"},{start:2,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"num_args",name:"numArgs",type:"number"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"use_cudnn_on_gpu",name:"useCudnnOnGpu",type:"bool",defaultValue:!0},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"dilations",name:"dilations",type:"number[]",defaultValue:[1,1,1,1]},{tfName:"fused_ops",name:"fusedOps",type:"string[]",defaultValue:[]},{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:1e-4},{tfName:"leakyrelu_alpha",name:"leakyreluAlpha",type:"number"}]},{tfOpName:"Conv2DBackpropInput",category:"convolution",inputs:[{start:2,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"},{start:0,name:"outputShape",type:"number[]"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]",notSupported:!0}]},{tfOpName:"DepthwiseConv2d",category:"convolution",inputs:[{start:0,name:"input",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"DepthwiseConv2dNative",category:"convolution",inputs:[{start:0,name:"input",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"FusedDepthwiseConv2dNative",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"},{start:2,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"num_args",name:"numArgs",type:"number"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"dilations",name:"dilations",type:"number[]",defaultValue:[1,1,1,1]},{tfName:"fused_ops",name:"fusedOps",type:"string[]",defaultValue:[]},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]}]},{tfOpName:"Conv3D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"Dilation2D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"rates",name:"dilations",type:"number[]"},{tfName:"padding",name:"pad",type:"string"}]}],Hte=[{tfOpName:"Fill",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"},{start:1,name:"value",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"LinSpace",category:"creation",inputs:[{start:0,name:"start",type:"number"},{start:1,name:"stop",type:"number"},{start:2,name:"num",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"OneHot",category:"creation",inputs:[{start:0,name:"indices",type:"tensor"},{start:1,name:"depth",type:"number"},{start:2,name:"onValue",type:"number",defaultValue:1},{start:3,name:"offValue",type:"number",defaultValue:0}],attrs:[{tfName:"axis",name:"axis",type:"number",notSupported:!0},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Ones",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"OnesLike",category:"creation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"}]},{tfOpName:"RandomUniform",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"minval",name:"minval",type:"number",defaultValue:0},{tfName:"maxval",name:"maxval",type:"number",defaultValue:1},{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"seed",name:"seed",type:"number",defaultValue:0},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0},{tfName:"T",name:"T",type:"number",notSupported:!0}]},{tfOpName:"Range",category:"creation",inputs:[{start:0,name:"start",type:"number"},{start:1,name:"stop",type:"number"},{start:2,name:"step",type:"number",defaultValue:0}],attrs:[{tfName:"Tidx",name:"dtype",type:"dtype"}]},{tfOpName:"TruncatedNormal",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"means",name:"mean",type:"number",defaultValue:0},{tfName:"stddev",name:"stdDev",type:"number",defaultValue:1},{tfName:"seed",name:"seed",type:"number"},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0},{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"T",name:"T",type:"number",notSupported:!0}]},{tfOpName:"Zeros",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"ZerosLike",category:"creation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"Multinomial",category:"creation",inputs:[{start:0,name:"logits",type:"tensor"},{start:1,name:"numSamples",type:"number"}],attrs:[{tfName:"seed",name:"seed",type:"number"},{tfName:"seed2",name:"seed2",type:"number"},{tfName:"T",name:"dtype",type:"dtype"},{tfName:"output_dtype",name:"output_dtype",type:"dtype"}]}],Gte=[{tfOpName:"NonMaxSuppressionV2",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"}]},{tfOpName:"NonMaxSuppressionV3",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"},{start:4,name:"scoreThreshold",type:"number"}]},{tfOpName:"NonMaxSuppressionV4",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"},{start:4,name:"scoreThreshold",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"T_threshold",name:"threshold",type:"dtype",notSupported:!0},{tfName:"pad_to_max_output_size",name:"padToMaxOutputSize",type:"bool"}]},{tfOpName:"NonMaxSuppressionV5",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"},{start:4,name:"scoreThreshold",type:"number"},{start:5,name:"softNmsSigma",type:"number"}]},{tfOpName:"Where",category:"dynamic",inputs:[{start:0,name:"condition",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ListDiff",category:"dynamic",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"y",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}],jte=[{tfOpName:"TopKV2",category:"evaluation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"k",type:"number"}],attrs:[{tfName:"sorted",name:"sorted",type:"bool"}]},{tfOpName:"Unique",category:"evaluation",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"UniqueV2",category:"evaluation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]}],qte=[{tfOpName:"PlaceholderWithDefault",category:"graph",inputs:[{start:0,name:"default",type:"tensor"}],attrs:[{tfName:"shape",name:"shape",type:"shape"},{tfName:"dtype",name:"dtype",type:"dtype"}]},{tfOpName:"Placeholder",category:"graph",attrs:[{tfName:"shape",name:"shape",type:"shape"},{tfName:"dtype",name:"dtype",type:"dtype"}]},{tfOpName:"Const",category:"graph"},{tfOpName:"Identity",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"IdentityN",category:"graph",inputs:[{start:0,end:0,name:"x",type:"tensors"}]},{tfOpName:"Snapshot",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"Rank",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"Size",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"Shape",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"ShapeN",category:"graph",inputs:[{start:0,end:0,name:"x",type:"tensors"}]},{tfOpName:"Print",category:"graph",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"data",type:"tensors"}],attrs:[{tfName:"message",name:"message",type:"string"},{tfName:"first_n",name:"firstN",type:"number",notSupported:!0},{tfName:"summarize",name:"summarize",type:"number",defaultValue:3}]},{tfOpName:"NoOp",category:"graph",inputs:[]},{tfOpName:"StopGradient",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"FakeQuantWithMinMaxVars",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"min",name:"min",type:"number"},{tfName:"max",name:"max",type:"number"}]}],Kte=[{tfOpName:"HashTable",category:"hash_table",inputs:[],attrs:[{tfName:"shared_name",name:"sharedName",type:"string"},{tfName:"use_node_name_sharing",name:"useNodeNameSharing",type:"bool"},{tfName:"key_dtype",name:"keyDType",type:"dtype"},{tfName:"value_dtype",name:"valueDType",type:"dtype"}]},{tfOpName:"HashTableV2",category:"hash_table",inputs:[],attrs:[{tfName:"shared_name",name:"sharedName",type:"string"},{tfName:"use_node_name_sharing",name:"useNodeNameSharing",type:"bool"},{tfName:"key_dtype",name:"keyDType",type:"dtype"},{tfName:"value_dtype",name:"valueDType",type:"dtype"}]},{tfOpName:"LookupTableImport",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableImportV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableFind",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableFindV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableSize",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"}]},{tfOpName:"LookupTableSizeV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"}]}],Xte=[{tfOpName:"ResizeBilinear",category:"image",inputs:[{start:0,name:"images",type:"tensor"},{start:1,name:"size",type:"number[]"}],attrs:[{tfName:"align_corners",name:"alignCorners",type:"bool"},{tfName:"half_pixel_centers",name:"halfPixelCenters",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ResizeNearestNeighbor",category:"image",inputs:[{start:0,name:"images",type:"tensor"},{start:1,name:"size",type:"number[]"}],attrs:[{tfName:"align_corners",name:"alignCorners",type:"bool"},{tfName:"half_pixel_centers",name:"halfPixelCenters",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"CropAndResize",category:"image",inputs:[{start:0,name:"image",type:"tensor"},{start:1,name:"boxes",type:"tensor"},{start:2,name:"boxInd",type:"tensor"},{start:3,name:"cropSize",type:"number[]"}],attrs:[{tfName:"method",name:"method",type:"string"},{tfName:"extrapolation_value",name:"extrapolationValue",type:"number"}]}],Yte=[{tfOpName:"Equal",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"NotEqual",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Greater",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"GreaterEqual",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Less",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LessEqual",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LogicalAnd",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LogicalNot",category:"logical",inputs:[{start:0,name:"a",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LogicalOr",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Select",category:"logical",inputs:[{start:0,name:"condition",type:"tensor"},{start:1,name:"a",type:"tensor"},{start:2,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"SelectV2",category:"logical",inputs:[{start:0,name:"condition",type:"tensor"},{start:1,name:"a",type:"tensor"},{start:2,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}],Zte=[{tfOpName:"_FusedMatMul",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"},{start:2,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"num_args",name:"numArgs",type:"number"},{tfName:"fused_ops",name:"fusedOps",type:"string[]",defaultValue:[]},{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:1e-4},{tfName:"transpose_a",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"transpose_b",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MatMul",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"transpose_a",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"transpose_b",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"BatchMatMul",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"adj_x",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"adj_y",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"BatchMatMulV2",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"adj_x",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"adj_y",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Transpose",category:"matrices",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"perm",type:"number[]"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}],Qte=[{tfOpName:"FusedBatchNorm",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"scale",type:"tensor"},{start:2,name:"offset",type:"tensor"},{start:3,name:"mean",type:"tensor"},{start:4,name:"variance",type:"tensor"}],attrs:[{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:.001},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"FusedBatchNormV2",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"scale",type:"tensor"},{start:2,name:"offset",type:"tensor"},{start:3,name:"mean",type:"tensor"},{start:4,name:"variance",type:"tensor"}],attrs:[{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:.001},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"FusedBatchNormV3",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"scale",type:"tensor"},{start:2,name:"offset",type:"tensor"},{start:3,name:"mean",type:"tensor"},{start:4,name:"variance",type:"tensor"}],attrs:[{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:.001},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"LRN",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"depth_radius",name:"radius",type:"number",defaultValue:5},{tfName:"bias",name:"bias",type:"number",defaultValue:1},{tfName:"alpha",name:"alpha",type:"number",defaultValue:1},{tfName:"beta",name:"beta",type:"number",defaultValue:.5}]},{tfOpName:"Softmax",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"LogSoftmax",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"SparseToDense",category:"normalization",inputs:[{start:0,name:"sparseIndices",type:"tensor"},{start:1,name:"outputShape",type:"number[]"},{start:2,name:"sparseValues",type:"tensor"},{start:3,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"validate_indices",name:"validateIndices",type:"bool",defaultValue:!0,notSupported:!0}]}],Jte=[{tfOpName:"Bincount",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"size",type:"number"},{start:2,name:"weights",type:"tensor"}]},{tfOpName:"DenseBincount",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"size",type:"number"},{start:2,name:"weights",type:"tensor"}],attrs:[{tfName:"binary_output",name:"binaryOutput",type:"bool"}]},{tfOpName:"Max",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Mean",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Min",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Sum",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"All",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Any",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"ArgMax",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]},{tfOpName:"ArgMin",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]},{tfOpName:"Prod",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Cumsum",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}],attrs:[{tfName:"exclusive",name:"exclusive",type:"bool"},{tfName:"reverse",name:"reverse",type:"bool"}]}],ene=[{tfOpName:"ConcatV2",category:"slice_join",inputs:[{start:0,end:-1,name:"tensors",type:"tensors"},{start:-1,name:"axis",type:"number"}],attrs:[{tfName:"N",name:"n",type:"number",defaultValue:2}]},{tfOpName:"Concat",category:"slice_join",inputs:[{start:1,end:0,name:"tensors",type:"tensors"},{start:0,name:"axis",type:"number"}],attrs:[{tfName:"N",name:"n",type:"number",defaultValue:2}]},{tfOpName:"GatherV2",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"axis",type:"number",defaultValue:0}],attrs:[{tfName:"batch_dims",name:"batchDims",type:"number",defaultValue:0}]},{tfOpName:"Gather",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"indices",type:"tensor"}],attrs:[{tfName:"validate_indices",name:"validateIndices",type:"bool",notSupported:!0}]},{tfOpName:"Reverse",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"dims",type:"bool[]"}]},{tfOpName:"ReverseV2",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}]},{tfOpName:"Slice",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"begin",type:"number[]"},{start:2,name:"size",type:"number[]"}]},{tfOpName:"StridedSlice",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"begin",type:"number[]"},{start:2,name:"end",type:"number[]"},{start:3,name:"strides",type:"number[]"}],attrs:[{tfName:"begin_mask",name:"beginMask",type:"number",defaultValue:0},{tfName:"end_mask",name:"endMask",type:"number",defaultValue:0},{tfName:"new_axis_mask",name:"newAxisMask",type:"number",defaultValue:0},{tfName:"ellipsis_mask",name:"ellipsisMask",type:"number",defaultValue:0},{tfName:"shrink_axis_mask",name:"shrinkAxisMask",type:"number",defaultValue:0}]},{tfOpName:"Pack",category:"slice_join",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}],attrs:[{tfName:"axis",name:"axis",type:"number",defaultValue:0}]},{tfOpName:"Unpack",category:"slice_join",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"axis",name:"axis",type:"number",defaultValue:0},{tfName:"num",name:"num",type:"number",defaultValue:0,notSupported:!0}]},{tfOpName:"Tile",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"reps",type:"number[]"}]},{tfOpName:"Split",category:"slice_join",inputs:[{start:0,name:"axis",type:"number",defaultValue:0},{start:1,name:"x",type:"tensor"}],attrs:[{tfName:"num_split",name:"numOrSizeSplits",type:"number",defaultValue:1}]},{tfOpName:"SplitV",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"numOrSizeSplits",type:"number[]"},{start:2,name:"axis",type:"number",defaultValue:0}]},{tfOpName:"ScatterNd",category:"slice_join",inputs:[{start:0,name:"indices",type:"tensor"},{start:1,name:"values",type:"tensor"},{start:2,name:"shape",type:"number[]"}]},{tfOpName:"GatherNd",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"indices",type:"tensor"}]},{tfOpName:"SparseToDense",category:"slice_join",inputs:[{start:0,name:"sparseIndices",type:"tensor"},{start:1,name:"outputShape",type:"number[]"},{start:2,name:"sparseValues",type:"tensor"},{start:3,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"validate_indices",name:"validateIndices",type:"bool",defaultValue:!1,notSupported:!0}]}],tne=[{tfOpName:"FFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"IFFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"RFFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"fft_length",type:"number",notSupported:!0}]},{tfOpName:"IRFFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"fft_length",type:"number",notSupported:!0}]}],nne=[{tfOpName:"Cast",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"SrcT",name:"sdtype",type:"dtype",notSupported:!0},{tfName:"DstT",name:"dtype",type:"dtype"}]},{tfOpName:"ExpandDims",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]},{tfOpName:"MirrorPad",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"padding",type:"number[]"}],attrs:[{tfName:"mode",name:"mode",type:"string"}]},{tfOpName:"Pad",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"padding",type:"number[]"}],attrs:[{tfName:"constant_value",name:"constantValue",type:"number",defaultValue:0}]},{tfOpName:"PadV2",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"padding",type:"number[]"},{start:2,name:"constantValue",type:"number",defaultValue:0}]},{tfOpName:"Reshape",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"shape",type:"number[]"}]},{tfOpName:"Squeeze",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"axis",tfDeprecatedName:"squeeze_dims",name:"axis",type:"number[]"}]},{tfOpName:"SpaceToBatchND",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"blockShape",type:"number[]"},{start:2,name:"paddings",type:"number[]"}]},{tfOpName:"BatchToSpaceND",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"blockShape",type:"number[]"},{start:2,name:"crops",type:"number[]"}]},{tfOpName:"DepthToSpace",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"block_size",name:"blockSize",type:"number"},{tfName:"data_format",name:"dataFormat",type:"string"}]},{tfOpName:"BroadcastTo",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"shape",type:"number[]"}],attrs:[]}];class NO{static get Instance(){return this._instance||(this._instance=new this)}constructor(){const e=[].concat(...[Ze,be,Ce,ie,P,I,k,z,N,$,W,Qe,Rt,wt,In,Dn,E].map(r=>r.json));this.opMappers=e.reduce((r,s)=>(r[s.tfOpName]=s,r),{})}transformGraph(n,e={}){const s=[],o=[],i=[],a=n.node.reduce((m,g)=>(m[g.name]=this.mapNode(g),g.op.startsWith("Placeholder")?s.push(m[g.name]):"Const"===g.op?o.push(m[g.name]):(null==g.input||0===g.input.length)&&i.push(m[g.name]),m),{});let l=[];const u=[];let c={},d={};null!=e&&(c=this.mapSignatureEntries(e.inputs),d=this.mapSignatureEntries(e.outputs));const h=Object.keys(a);h.forEach(m=>{const g=a[m];g.inputNames.forEach(y=>{const[b]=pi(y);g.inputs.push(a[b]),a[b].children.push(g)})}),0===Object.keys(d).length?h.forEach(m=>{const g=a[m];0===g.children.length&&u.push(g)}):Object.keys(d).forEach(m=>{const[g]=pi(m),y=a[g];null!=y&&(y.signatureKey=d[m],u.push(y))}),Object.keys(c).length>0?Object.keys(c).forEach(m=>{const[g]=pi(m),y=a[g];y&&(y.signatureKey=c[m],l.push(y))}):l=s;let f={};null!=n.library&&null!=n.library.function&&(f=n.library.function.reduce((m,g)=>(m[g.signature.name]=this.mapFunction(g),m),{}));const p={nodes:a,inputs:l,outputs:u,weights:o,placeholders:s,signature:e,functions:f};return i.length>0&&(p.initNodes=i),p}mapSignatureEntries(n){return Object.keys(n||{}).reduce((e,r)=>(e[n[r].name]=r,e),{})}mapNode(n){const e=EO(n.op)||this.opMappers[n.op]||{};null==n.attr&&(n.attr={});const r={name:n.name,op:n.op,category:e.category,inputNames:(n.input||[]).map(s=>s.startsWith("^")?s.substr(1):s),inputs:[],children:[],inputParams:{},attrParams:{},rawAttrs:n.attr};return null!=e.inputs&&(r.inputParams=e.inputs.reduce((s,o)=>(s[o.name]={type:o.type,inputIndexStart:o.start,inputIndexEnd:o.end},s),{})),null!=e.attrs&&(r.attrParams=e.attrs.reduce((s,o)=>{const i=o.type;let a;switch(o.type){case"string":a=SD(n.attr,o.tfName,o.defaultValue),void 0===a&&o.tfDeprecatedName&&(a=SD(n.attr,o.tfDeprecatedName,o.defaultValue));break;case"string[]":a=FD(n.attr,o.tfName,o.defaultValue),void 0===a&&o.tfDeprecatedName&&(a=FD(n.attr,o.tfDeprecatedName,o.defaultValue));break;case"number":a=ND(n.attr,o.tfName,o.defaultValue||0),void 0===a&&o.tfDeprecatedName&&(a=ND(n.attr,o.tfDeprecatedName,o.defaultValue));break;case"number[]":a=$D(n.attr,o.tfName,o.defaultValue),void 0===a&&o.tfDeprecatedName&&(a=$D(n.attr,o.tfDeprecatedName,o.defaultValue));break;case"bool":a=ED(n.attr,o.tfName,o.defaultValue),void 0===a&&o.tfDeprecatedName&&(a=ED(n.attr,o.tfDeprecatedName,o.defaultValue));break;case"bool[]":a=MD(n.attr,o.tfName,o.defaultValue),void 0===a&&o.tfDeprecatedName&&(a=MD(n.attr,o.tfDeprecatedName,o.defaultValue));break;case"shape":a=RD(n.attr,o.tfName,o.defaultValue),void 0===a&&o.tfDeprecatedName&&(a=RD(n.attr,o.tfDeprecatedName,o.defaultValue));break;case"shape[]":a=OD(n.attr,o.tfName,o.defaultValue),void 0===a&&o.tfDeprecatedName&&(a=OD(n.attr,o.tfDeprecatedName,o.defaultValue));break;case"dtype":a=kD(n.attr,o.tfName,o.defaultValue),void 0===a&&o.tfDeprecatedName&&(a=kD(n.attr,o.tfDeprecatedName,o.defaultValue));break;case"dtype[]":a=AD(n.attr,o.tfName,o.defaultValue),void 0===a&&o.tfDeprecatedName&&(a=AD(n.attr,o.tfDeprecatedName,o.defaultValue));break;case"func":a=kO(n.attr,o.tfName,o.defaultValue),void 0===a&&o.tfDeprecatedName&&(a=kO(n.attr,o.tfDeprecatedName,o.defaultValue));break;case"tensor":case"tensors":break;default:throw new Error(`Unsupported param type: ${o.type} for op: ${n.op}`)}return s[o.name]={value:a,type:i},s},{})),r}mapFunction(n){const e=n.nodeDef,s=[];let o={};null!=e&&(o=e.reduce((d,h)=>(d[h.name]=this.mapNode(h),"Const"===h.op&&s.push(d[h.name]),d),{}));const i=[],a=[];n.signature.inputArg.forEach(d=>{const[h]=pi(d.name),f={name:h,op:"Placeholder",inputs:[],inputNames:[],category:"graph",inputParams:{},attrParams:{dtype:{value:TD(d.type),type:"dtype"}},children:[]};f.signatureKey=d.name,i.push(f),o[h]=f}),Object.keys(o).forEach(d=>{const h=o[d];h.inputNames.forEach(f=>{const[p]=pi(f);h.inputs.push(o[p]),o[p].children.push(h)})});const u=n.ret;n.signature.outputArg.forEach(d=>{const[h,f]=pi(u[d.name]),p=o[h];null!=p&&(p.defaultOutput=f,a.push(p))});const c=this.mapArgsToSignature(n);return{nodes:o,inputs:i,outputs:a,weights:s,placeholders:[],signature:c}}mapArgsToSignature(n){return{methodName:n.signature.name,inputs:n.signature.inputArg.reduce((e,r)=>(e[r.name]=this.mapArgToTensorInfo(r),e),{}),outputs:n.signature.outputArg.reduce((e,r)=>(e[r.name]=this.mapArgToTensorInfo(r,n.ret),e),{})}}mapArgToTensorInfo(n,e){let r=n.name;return null!=e&&(r=e[r]),{name:r,dtype:n.type}}}function TO(t,n){const e=Array.isArray(t)?String.fromCharCode.apply(null,t):function rne(t){const n=ne().global;if(typeof n.atob<"u")return n.atob(t);if(typeof Buffer<"u")return new Buffer(t,"base64").toString();throw new Error("Unable to decode base64 in this environment. Missing built-in atob() or Buffer()")}(t);return n?e:e.toLowerCase()}function SD(t,n,e,r=!1){const s=t[n];return null!=s?TO(s.s,r):e}function ED(t,n,e){const r=t[n];return r?r.b:e}function ND(t,n,e){const r=t[n]||{},s=null!=r.i?r.i:null!=r.f?r.f:e;return"number"==typeof s?s:parseInt(s,10)}function TD(t){switch("string"==typeof t&&(t=Bs[t]),t){case Bs.DT_FLOAT:return"float32";case Bs.DT_INT32:case Bs.DT_INT64:case Bs.DT_INT8:case Bs.DT_UINT8:return"int32";case Bs.DT_BOOL:return"bool";case Bs.DT_DOUBLE:return"float32";case Bs.DT_STRING:return"string";default:return null}}function kO(t,n,e){const r=t[n];return r&&r.func?r.func.name:e}function kD(t,n,e){const r=t[n];return r&&r.type?TD(r.type):e}function AD(t,n,e){const r=t[n];return r&&r.list&&r.list.type?r.list.type.map(s=>TD(s)):e}function AO(t){if(!t.unknownRank)return null!=t.dim?t.dim.map(n=>"number"==typeof n.size?n.size:parseInt(n.size,10)):[]}function RD(t,n,e){const r=t[n];return r&&r.shape?AO(r.shape):e}function $D(t,n,e){const r=t[n];return r?((r.list.f&&r.list.f.length?r.list.f:r.list.i)||[]).map(s=>"number"==typeof s?s:parseInt(s,10)):e}function FD(t,n,e,r=!1){const s=t[n];return s&&s.list&&s.list.s?s.list.s.map(o=>TO(o,r)):e}function OD(t,n,e){const r=t[n];return r&&r.list&&r.list.shape?r.list.shape.map(s=>AO(s)):e}function MD(t,n,e){const r=t[n];return r&&r.list&&r.list.b?r.list.b:e}class sne{constructor(n,e,r){this.node=n,this.tensorMap=e,this.context=r,this.inputs=[],this.attrs={},this.inputs=n.inputNames.map(s=>this.getInput(s)),null!=n.rawAttrs&&(this.attrs=Object.keys(n.rawAttrs).reduce((s,o)=>(s[o]=this.getAttr(o),s),{}))}getInput(n){return Br(n,this.tensorMap,this.context)}getAttr(n,e){const r=this.node.rawAttrs[n];if(null!=r.tensor)return Br(n,this.tensorMap,this.context);if(null!=r.i||null!=r.f)return ND(this.node.rawAttrs,n,e);if(null!=r.s)return SD(this.node.rawAttrs,n,e);if(null!=r.b)return ED(this.node.rawAttrs,n,e);if(null!=r.shape)return RD(this.node.rawAttrs,n,e);if(null!=r.type)return kD(this.node.rawAttrs,n,e);if(null!=r.list){if(null!=r.list.i||null!=r.list.f)return $D(this.node.rawAttrs,n,e);if(null!=r.list.s)return FD(this.node.rawAttrs,n,e);if(null!=r.list.shape)return OD(this.node.rawAttrs,n,e);if(null!=r.list.b)return MD(this.node.rawAttrs,n,e);if(null!=r.list.type)return AD(this.node.rawAttrs,n,e)}return e}}const ine=M({addN_:function one(t){S(Array.isArray(t),()=>"The argument passed to tf.addN() must be a list of tensors"),S(t.length>=1,()=>`Must pass at least one tensor to tf.addN(), but got ${t.length}`);const n=t.map((s,o)=>T(s,`tensors${o}`,"addN")),e=n[0];return n.forEach(s=>{if(s.dtype!==e.dtype)throw new Error("All tensors passed to tf.addN() must have the same dtype")}),n.forEach(s=>{if(!Mt(s.shape,e.shape))throw new Error("All tensors passed to tf.addN() must have the same shape")}),F.runKernel(rm,n)}});function zs(t,n,e=""){if("number"!=typeof t&&"number"!=typeof n){S(t.length===n.length,()=>e+` Shapes ${t} and ${n} must match`);for(let r=0;r<t.length;r++){const s=t[r],o=n[r];S(s<0||o<0||s===o,()=>e+` Shapes ${t} and ${n} must match`)}}}function RO(t){return!("number"==typeof t||t.some(n=>n<0))}function Wh(t,n,e){let r=PD(t,e);const s=!RO(r);if(s&&0===n.length)throw new Error(`Tried to calculate elements of an empty list with non-fully-defined elementShape: ${r}`);if(s&&n.forEach(o=>{r=PD(o.shape,r)}),!RO(r))throw new Error(`Non-fully-defined elementShape: ${r}`);return r}function PD(t,n){if("number"==typeof t)return n;if("number"==typeof n)return t;if(t.length!==n.length)throw new Error(`Incompatible ranks during merge: ${t} vs. ${n}`);const e=[];for(let r=0;r<t.length;++r){const s=t[r],o=n[r];if(s>=0&&o>=0&&s!==o)throw new Error(`Incompatible shape during merge: ${t} vs. ${n}`);e[r]=s>=0?s:o}return e}class une{constructor(n,e,r,s,o,i,a){this.name=n,this.dtype=e,this.maxSize=r,this.elementShape=s,this.identicalElementShapes=o,this.dynamicSize=i,this.clearAfterRead=a,this.tensors=[],this.closed_=!1,this.idTensor=Fe(0),ir(this.idTensor)}get id(){return this.idTensor.id}get closed(){return this.closed_}clearAndClose(n){this.tensors.forEach(e=>{(null==n||!n.has(e.tensor.id))&&e.tensor.dispose()}),this.tensors=[],this.closed_=!0,this.idTensor.dispose()}size(){return this.tensors.length}read(n){if(this.closed_)throw new Error(`TensorArray ${this.name} has already been closed.`);if(n<0||n>=this.size())throw new Error(`Tried to read from index ${n}, but array size is: ${this.size()}`);const e=this.tensors[n];if(e.cleared)throw new Error(`TensorArray ${this.name}: Could not read index ${n} twice because it was cleared after a previous read (perhaps try setting clear_after_read = false?).`);return this.clearAfterRead&&(e.cleared=!0),e.read=!0,e.tensor}readMany(n){return n.map(e=>this.read(e))}write(n,e){if(this.closed_)throw new Error(`TensorArray ${this.name} has already been closed.`);if(n<0||!this.dynamicSize&&n>=this.maxSize)throw new Error(`Tried to write to index ${n}, but array is not resizeable and size is: ${this.maxSize}`);const r=this.tensors[n]||{};if(e.dtype!==this.dtype)throw new Error(`TensorArray ${this.name}: Could not write to TensorArray index ${n},\n          because the value dtype is ${e.dtype}, but TensorArray dtype is ${this.dtype}.`);if(0===this.size()&&(null==this.elementShape||0===this.elementShape.length)&&(this.elementShape=e.shape),zs(this.elementShape,e.shape,`TensorArray ${this.name}: Could not write to TensorArray index ${n}.`),r.read)throw new Error(`TensorArray ${this.name}: Could not write to TensorArray index ${n}, because it has already been read.`);if(r.written)throw new Error(`TensorArray ${this.name}: Could not write to TensorArray index ${n}, because it has already been written.`);r.tensor=e,ir(e),r.written=!0,this.tensors[n]=r}writeMany(n,e){if(n.length!==e.length)throw new Error(`TensorArray ${this.name}: could not write multiple tensors,because the index size: ${n.length} is not the same as tensors size: ${e.length}.`);n.forEach((r,s)=>this.write(r,e[s]))}gather(n,e){if(e&&e!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but gather requested dtype ${e}`);if(n)n=n.slice(0,this.size());else{n=[];for(let s=0;s<this.size();s++)n.push(s)}if(0===n.length)return Fa([],[0].concat(this.elementShape));const r=this.readMany(n);return zs(this.elementShape,r[0].shape,"TensorArray shape mismatch: "),Fs(r,0)}concat(n){if(n&&n!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but concat requested dtype ${n}`);if(0===this.size())return Fa([],[0].concat(this.elementShape));const e=[];for(let s=0;s<this.size();s++)e.push(s);const r=this.readMany(e);return zs(this.elementShape,r[0].shape,`TensorArray shape mismatch: tensor array shape (${this.elementShape}) vs first tensor shape (${r[0].shape})`),Sn(r,0)}scatter(n,e){if(e.dtype!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but tensor has dtype ${e.dtype}`);if(n.length!==e.shape[0])throw new Error(`Expected len(indices) == tensor.shape[0], but saw: ${n.length} vs. ${e.shape[0]}`);const r=Math.max(...n);if(!this.dynamicSize&&r>=this.maxSize)throw new Error(`Max index must be < array size (${r}  vs. ${this.maxSize})`);this.writeMany(n,oo(e,0))}split(n,e){if(e.dtype!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but tensor has dtype ${e.dtype}`);let r=0;const s=n.map(l=>(r+=l,r));if(r!==e.shape[0])throw new Error(`Expected sum of lengths to be equal to\n          tensor.shape[0], but sum of lengths is\n        ${r}, and tensor's shape is: ${e.shape}`);if(!this.dynamicSize&&n.length!==this.maxSize)throw new Error(`TensorArray's size is not equal to the size of lengths (${this.maxSize} vs. ${n.length}), and the TensorArray is not marked as dynamically resizeable`);const o=0===r?0:e.size/r,i=[];U(()=>{e=H(e,[1,r,o]);for(let l=0;l<n.length;++l)i[l]=H(At(e,[0,0===l?0:s[l-1],0],[1,n[l],o]),this.elementShape);return i});const a=[];for(let l=0;l<n.length;l++)a[l]=l;this.writeMany(a,i)}}class ku{constructor(n,e,r,s=-1){this.tensors=n,this.elementShape=e,this.elementDtype=r,n?.forEach(o=>{if(r!==o.dtype)throw new Error(`Invalid data types; op elements ${r}, but list elements ${o.dtype}`);zs(e,o.shape,"TensorList shape mismatch: "),ir(o)}),this.idTensor=Fe(0),this.maxNumElements=s,ir(this.idTensor)}get id(){return this.idTensor.id}copy(){return new ku([...this.tensors],this.elementShape,this.elementDtype)}clearAndClose(n){this.tensors.forEach(e=>{(null==n||!n.has(e.id))&&e.dispose()}),this.tensors.length=0,this.idTensor.dispose()}size(){return this.tensors.length}stack(n,e,r=-1){if(e!==this.elementDtype)throw new Error(`Invalid data types; op elements ${e}, but list elements ${this.elementDtype}`);if(-1!==r&&this.tensors.length!==r)throw new Error(`Operation expected a list with ${r} elements but got a list with ${this.tensors.length} elements.`);zs(n,this.elementShape,"TensorList shape mismatch: ");const s=Wh(this.elementShape,this.tensors,n);return U(()=>{const o=this.tensors.map(i=>H(i,s));return Fs(o,0)})}popBack(n,e){if(e!==this.elementDtype)throw new Error(`Invalid data types; op elements ${e}, but list elements ${this.elementDtype}`);if(0===this.size())throw new Error("Trying to pop from an empty list.");const r=Wh(this.elementShape,this.tensors,n),s=this.tensors.pop();return zs(s.shape,n,"TensorList shape mismatch: "),H(s,r)}pushBack(n){if(n.dtype!==this.elementDtype)throw new Error(`Invalid data types; op elements ${n.dtype}, but list elements ${this.elementDtype}`);if(zs(n.shape,this.elementShape,"TensorList shape mismatch: "),this.maxNumElements===this.size())throw new Error("Trying to push element into a full list.");ir(n),this.tensors.push(n)}resize(n){if(n<0)throw new Error(`TensorListResize expects size to be non-negative. Got: ${n}`);if(-1!==this.maxNumElements&&n>this.maxNumElements)throw new Error(`TensorListResize input size ${n} is greater maxNumElement ${this.maxNumElements}.`);this.tensors.length=n}getItem(n,e,r){if(r!==this.elementDtype)throw new Error(`Invalid data types; op elements ${r}, but list elements ${this.elementDtype}`);if(n<0||n>this.tensors.length)throw new Error(`Trying to access element ${n} in a list with ${this.tensors.length} elements.`);if(null==this.tensors[n])throw new Error(`element at index ${n} is null.`);zs(this.tensors[n].shape,e,"TensorList shape mismatch: ");const s=Wh(this.elementShape,this.tensors,e);return H(this.tensors[n],s)}setItem(n,e){if(e.dtype!==this.elementDtype)throw new Error(`Invalid data types; op elements ${e.dtype}, but list elements ${this.elementDtype}`);if(n<0||-1!==this.maxNumElements&&n>=this.maxNumElements)throw new Error(`Trying to set element ${n} in a list with max ${this.maxNumElements} elements.`);zs(this.elementShape,e.shape,"TensorList shape mismatch: "),ir(e),this.tensors[n]=e}gather(n,e,r){if(e!==this.elementDtype)throw new Error(`Invalid data types; op elements ${e}, but list elements ${this.elementDtype}`);zs(this.elementShape,r,"TensorList shape mismatch: "),n=n.slice(0,this.size());const s=Wh(this.elementShape,this.tensors,r);return 0===n.length?Fa([],[0].concat(s)):U(()=>{const o=n.map(i=>H(this.tensors[i],s));return Fs(o,0)})}concat(n,e){if(n&&n!==this.elementDtype)throw new Error(`TensorList dtype is ${this.elementDtype} but concat requested dtype ${n}`);zs(this.elementShape,e,"TensorList shape mismatch: ");const r=Wh(this.elementShape,this.tensors,e);return 0===this.size()?Fa([],[0].concat(r)):U(()=>{const s=this.tensors.map(o=>H(o,r));return Sn(s,0)})}}const pne=function(){var t=J(function*(n,e,r){switch(n.op){case"If":case"StatelessIf":{const s=C("thenBranch",n,e,r),o=C("elseBranch",n,e,r),i=C("cond",n,e,r),a=C("args",n,e,r);return(yield i.data())[0]?r.functionMap[s].executeFunctionAsync(a,r.tensorArrayMap,r.tensorListMap):r.functionMap[o].executeFunctionAsync(a,r.tensorArrayMap,r.tensorListMap)}case"While":case"StatelessWhile":{const s=C("body",n,e,r),o=C("cond",n,e,r),i=C("args",n,e,r),a=yield r.functionMap[o].executeFunctionAsync(i,r.tensorArrayMap,r.tensorListMap),l=i.map(d=>d.id);let u=yield a[0].data();a.forEach(d=>{!d.kept&&-1===l.indexOf(d.id)&&d.dispose()});let c=i;for(;u[0];){const d=c;c=yield r.functionMap[s].executeFunctionAsync(c,r.tensorArrayMap,r.tensorListMap);const h=c.map(p=>p.id);d.forEach(p=>{!p.kept&&-1===l.indexOf(p.id)&&-1===h.indexOf(p.id)&&p.dispose()});const f=yield r.functionMap[o].executeFunctionAsync(c,r.tensorArrayMap,r.tensorListMap);u=yield f[0].data(),f.forEach(p=>{!p.kept&&-1===l.indexOf(p.id)&&-1===h.indexOf(p.id)&&p.dispose()})}return c}case"LoopCond":return[mi(C("pred",n,e,r))];case"Switch":{const s=C("pred",n,e,r);let o=C("data",n,e,r);return o.kept||(o=mi(o)),(yield s.data())[0]?[void 0,o]:[o,void 0]}case"Merge":{const s=n.inputNames.find(o=>void 0!==Br(o,e,r));return s?[mi(Br(s,e,r))]:void 0}case"Enter":{const s=C("frameName",n,e,r),o=C("tensor",n,e,r);return r.enterFrame(s),[mi(o)]}case"Exit":{const s=C("tensor",n,e,r);return r.exitFrame(),[mi(s)]}case"NextIteration":{const s=C("tensor",n,e,r);return r.nextIteration(),[mi(s)]}case"TensorArrayV3":{const s=C("size",n,e,r),o=C("dtype",n,e,r),i=C("elementShape",n,e,r),a=C("dynamicSize",n,e,r),l=C("clearAfterRead",n,e,r),u=C("identicalElementShapes",n,e,r),c=C("name",n,e,r),d=new une(c,o,s,i,u,a,l);return r.addTensorArray(d),[d.idTensor,Fe(1)]}case"TensorArrayWriteV3":{const s=C("tensorArrayId",n,e,r),o=C("index",n,e,r),i=C("tensor",n,e,r),a=r.getTensorArray(s.id);return a.write(o,i),[a.idTensor]}case"TensorArrayReadV3":{const s=C("tensorArrayId",n,e,r),o=C("index",n,e,r);return[r.getTensorArray(s.id).read(o)]}case"TensorArrayGatherV3":{const s=C("tensorArrayId",n,e,r),o=C("indices",n,e,r),i=C("dtype",n,e,r);return[r.getTensorArray(s.id).gather(o,i)]}case"TensorArrayScatterV3":{const s=C("tensorArrayId",n,e,r),o=C("indices",n,e,r),i=C("tensor",n,e,r),a=r.getTensorArray(s.id);return a.scatter(o,i),[a.idTensor]}case"TensorArrayConcatV3":{const s=C("tensorArrayId",n,e,r),o=r.getTensorArray(s.id),i=C("dtype",n,e,r);return[o.concat(i)]}case"TensorArraySplitV3":{const s=C("tensorArrayId",n,e,r),o=C("tensor",n,e,r),i=C("lengths",n,e,r),a=r.getTensorArray(s.id);return a.split(i,o),[a.idTensor]}case"TensorArraySizeV3":{const s=C("tensorArrayId",n,e,r);return[Fe(r.getTensorArray(s.id).size(),"int32")]}case"TensorArrayCloseV3":{const s=C("tensorArrayId",n,e,r),o=r.getTensorArray(s.id);return o.clearAndClose(),[o.idTensor]}case"TensorListSetItem":{const s=C("tensorListId",n,e,r),o=C("index",n,e,r),i=C("tensor",n,e,r),a=r.getTensorList(s.id);return a.setItem(o,i),[a.idTensor]}case"TensorListGetItem":{const s=C("tensorListId",n,e,r),o=C("index",n,e,r),i=C("elementShape",n,e,r),a=C("elementDType",n,e,r);return[r.getTensorList(s.id).getItem(o,i,a)]}case"TensorListScatterV2":case"TensorListScatter":{const s=C("indices",n,e,r),l=function hne(t,n,e,r){if(n.length!==t.shape[0])throw new Error(`Expected len(indices) == tensor.shape[0], but saw: ${n.length} vs. ${t.shape[0]}`);const s=Math.max(...n);if(null!=r&&-1!==r&&s>=r)throw new Error(`Max index must be < array size (${s}  vs. ${r})`);const o=new ku([],e,t.dtype,r),i=oo(t,0);return n.forEach((a,l)=>{o.setItem(a,i[l])}),o}(C("tensor",n,e,r),s,C("elementShape",n,e,r),C("numElements",n,e,r));return r.addTensorList(l),[l.idTensor]}case"TensorListReserve":case"EmptyTensorList":{const s=C("elementShape",n,e,r),o=C("elementDType",n,e,r);let i;i="TensorListReserve"===n.op?"numElements":"maxNumElements";const l=function dne(t,n,e){return new ku([],t,n,e)}(s,o,C(i,n,e,r));return r.addTensorList(l),[l.idTensor]}case"TensorListGather":{const s=C("tensorListId",n,e,r),o=C("indices",n,e,r),i=C("elementShape",n,e,r),a=C("elementDType",n,e,r);return[r.getTensorList(s.id).gather(o,a,i)]}case"TensorListStack":{const s=C("tensorListId",n,e,r),o=C("elementShape",n,e,r),i=C("elementDType",n,e,r),a=C("numElements",n,e,r);return[r.getTensorList(s.id).stack(o,i,a)]}case"TensorListFromTensor":{const a=function cne(t,n,e){const r=t.dtype;if(t.shape.length<1)throw new Error(`Tensor must be at least a vector, but saw shape: ${t.shape}`);if(t.dtype!==e)throw new Error(`Invalid data types; op elements ${t.dtype}, but list elements ${e}`);zs(t.shape.slice(1),n,"TensorList shape mismatch: ");const o=oo(t);return new ku(o,n,r)}(C("tensor",n,e,r),C("elementShape",n,e,r),C("elementDType",n,e,r));return r.addTensorList(a),[a.idTensor]}case"TensorListConcat":{const s=C("tensorListId",n,e,r),o=r.getTensorList(s.id),i=C("dtype",n,e,r),a=C("elementShape",n,e,r);return[o.concat(i,a)]}case"TensorListPushBack":{const s=C("tensorListId",n,e,r),o=C("tensor",n,e,r),i=r.getTensorList(s.id);return i.pushBack(o),[i.idTensor]}case"TensorListPopBack":{const s=C("tensorListId",n,e,r),o=C("elementShape",n,e,r),i=C("elementDType",n,e,r);return[r.getTensorList(s.id).popBack(o,i)]}case"TensorListSplit":{const s=C("tensor",n,e,r),o=C("elementShape",n,e,r),a=function fne(t,n,e){let r=0;const s=n.map(c=>(r+=c,r));if(r!==t.shape[0])throw new Error(`Expected sum of lengths to be equal to\n          tensor.shape[0], but sum of lengths is\n        ${r}, and tensor's shape is: ${t.shape}`);const i=PD(t.shape.slice(1),e),a=0===r?0:t.size/r,l=U(()=>{const c=[];t=H(t,[1,r,a]);for(let d=0;d<n.length;++d)c[d]=H(At(t,[0,0===d?0:s[d-1],0],[1,n[d],a]),i);return t.dispose(),c}),u=new ku([],e,t.dtype,n.length);for(let c=0;c<l.length;c++)u.setItem(c,l[c]);return u}(s,C("lengths",n,e,r),o);return r.addTensorList(a),[a.idTensor]}default:throw TypeError(`Node type ${n.op} is not implemented`)}});return function(e,r,s){return t.apply(this,arguments)}}(),gne=M({maxPoolWithArgmax_:function mne(t,n,e,r,s=!1){const i={x:T(t,"x","maxPoolWithArgmax")},l=F.runKernel(_w,i,{filterSize:n,strides:e,pad:r,includeBatchInIndex:s});return{result:l[0],indexes:l[1]}}});function $O(t,n,e){const[r,s]=C("fusedOps",t,n,e),o="biasadd"===r,i="prelu"===s,a="fusedbatchnorm"===r,l=C("numArgs",t,n,e);if(o){if(i&&2!==l)throw new Error("FusedConv2d and DepthwiseConv2d with BiasAdd and Prelu must have two extra arguments: bias and alpha.");if(!i&&1!==l)throw new Error("FusedConv2d and DepthwiseConv2d with BiasAdd must have one extra argument: bias.")}if(a)throw new Error("FusedConv2d and DepthwiseConv2d with FusedBatchNorm is not supported.");const u=C("strides",t,n,e),c=yy(t,n,e),d=C("dataFormat",t,n,e).toUpperCase(),h=C("dilations",t,n,e),[f,p]=C("args",t,n,e);return{stride:u,pad:c,dataFormat:d,dilations:h,biasArg:f,preluArg:p,activationFunc:s,leakyreluAlpha:C("leakyreluAlpha",t,n,e)}}function bne(t,n,e){if(e<=0)throw new Error("The number of values should be positive.");return F.runKernel(ww,{},{start:t,stop:n,num:e})}const xne=M({multinomial_:function vne(t,n,e,r=!1){const s=T(t,"logits","multinomial"),o=s.size,i=s.rank;if(o<2)throw new Error(`Error in multinomial: you need at least 2 outcomes, but got ${o}.`);if(i>2)throw new Error(`Rank of probabilities must be 1 or 2, but is ${i}`);e=e||Math.random();const l={logits:1===i?H(s,[1,-1]):s},c=F.runKernel(Sw,l,{numSamples:n,seed:e,normalized:r});return 1===i?H(c,[c.size]):c}});function LD(){return(LD=J(function*(t){const n=T(t,"condition","whereAsync","bool"),e=yield n.data(),r=DI(n.shape,e);return t!==n&&n.dispose(),r})).apply(this,arguments)}const Ine=function Cne(t){return LD.apply(this,arguments)};function BD(){return(BD=J(function*(t,n){const e=T(t,"x","setdiff1d"),r=T(n,"y","setdiff1d");S(e.dtype===r.dtype,()=>`x and y should have the same dtype, but got x (${e.dtype}) and y (${r.dtype}).`),S(1===e.rank,()=>`x should be 1D tensor, but got x (${e.shape}).`),S(1===r.rank,()=>`y should be 1D tensor, but got y (${r.shape}).`);const s=yield e.data(),o=yield r.data(),i=new Set(o);let a=0;for(let c=0;c<s.length;c++)i.has(s[c])||a++;const l=new Xn([a],e.dtype),u=new Xn([a],"int32");for(let c=0,d=0;c<s.length;c++)i.has(s[c])||(l.values[d]=s[c],u.values[d]=c,d++);return[l.toTensor(),u.toTensor()]})).apply(this,arguments)}function zD(t,n,e){return{boxes:C("boxes",t,n,e),scores:C("scores",t,n,e),maxOutputSize:C("maxOutputSize",t,n,e),iouThreshold:C("iouThreshold",t,n,e),scoreThreshold:C("scoreThreshold",t,n,e),softNmsSigma:C("softNmsSigma",t,n,e)}}const Sne=function(){var t=J(function*(n,e,r){switch(n.op){case"NonMaxSuppressionV5":{const{boxes:s,scores:o,maxOutputSize:i,iouThreshold:a,scoreThreshold:l,softNmsSigma:u}=zD(n,e,r),c=yield Wa.nonMaxSuppressionWithScoreAsync(s,o,i,a,l,u);return[c.selectedIndices,c.selectedScores]}case"NonMaxSuppressionV4":{const{boxes:s,scores:o,maxOutputSize:i,iouThreshold:a,scoreThreshold:l}=zD(n,e,r),u=C("padToMaxOutputSize",n,e,r),c=yield Wa.nonMaxSuppressionPaddedAsync(s,o,i,a,l,u);return[c.selectedIndices,c.validOutputs]}case"NonMaxSuppressionV3":case"NonMaxSuppressionV2":{const{boxes:s,scores:o,maxOutputSize:i,iouThreshold:a,scoreThreshold:l}=zD(n,e,r);return[yield Wa.nonMaxSuppressionAsync(s,o,i,a,l)]}case"Where":{const s=Ae(C("condition",n,e,r),"bool"),o=[yield Ine(s)];return s.dispose(),o}case"ListDiff":return function Dne(t,n){return BD.apply(this,arguments)}(C("x",n,e,r),C("y",n,e,r));default:throw TypeError(`Node type ${n.op} is not implemented`)}});return function(e,r,s){return t.apply(this,arguments)}}();class Tne{constructor(n,e){this.keyDType=n,this.valueDType=e,this.handle=Fe(0),this.tensorMap=new Map,ir(this.handle)}get id(){return this.handle.id}clearAndClose(){this.tensorMap.forEach(n=>n.dispose()),this.tensorMap.clear(),this.handle.dispose()}size(){return this.tensorMap.size}tensorSize(){return Fe(this.size(),"int32")}import(n,e){var r=this;return J(function*(){r.checkKeyAndValueTensor(n,e);const s=yield n.data();return r.tensorMap.forEach(o=>o.dispose()),r.tensorMap.clear(),U(()=>{const o=oo(e),i=s.length,a=o.length;S(i===a,()=>`The number of elements doesn't match, keys has ${i} elements, the values has ${a} elements.`);for(let l=0;l<i;l++){const u=s[l],c=o[l];ir(c),r.tensorMap.set(u,c)}return r.handle})})()}find(n,e){var r=this;return J(function*(){r.checkKeyAndValueTensor(n,e);const s=yield n.data();return U(()=>{const o=[];for(let i=0;i<s.length;i++){const l=r.findWithDefault(s[i],e);o.push(l)}return Fs(o)})})()}findWithDefault(n,e){return this.tensorMap.get(n)??e}checkKeyAndValueTensor(n,e){if(n.dtype!==this.keyDType)throw new Error(`Expect key dtype ${this.keyDType}, but got ${n.dtype}`);if(e.dtype!==this.valueDType)throw new Error(`Expect value dtype ${this.valueDType}, but got ${e.dtype}`)}}const kne=function(){var t=J(function*(n,e,r,s){switch(n.op){case"HashTable":case"HashTableV2":{const o=C("keyDType",n,e,r),i=C("valueDType",n,e,r),a=new Tne(o,i);return s.addHashTable(n.name,a),[a.handle]}case"LookupTableImport":case"LookupTableImportV2":{const o=C("tableHandle",n,e,r,s),i=C("keys",n,e,r),a=C("values",n,e,r);return[yield s.getHashTableById(o.id).import(i,a)]}case"LookupTableFind":case"LookupTableFindV2":{const o=C("tableHandle",n,e,r,s),i=C("keys",n,e,r),a=C("defaultValue",n,e,r);return[yield s.getHashTableById(o.id).find(i,a)]}case"LookupTableSize":case"LookupTableSizeV2":{const o=C("tableHandle",n,e,r,s);return[s.getHashTableById(o.id).tensorSize()]}default:throw TypeError(`Node type ${n.op} is not implemented`)}});return function(e,r,s,o){return t.apply(this,arguments)}}(),FO=M({sparseToDense_:function One(t,n,e,r=0){const s=T(t,"sparseIndices","sparseToDense","int32"),o=T(n,"sparseValues","sparseToDense"),i=T(r,"defaultValue","sparseToDense",o.dtype);return function Fne(t,n,e,r){if("int32"!==t.dtype)throw new Error(`tf.sparseToDense() expects the indices to be int32 type, but the dtype was ${t.dtype}.`);if(t.rank>2)throw new Error(`sparseIndices should be a scalar, vector, or matrix, but got shape ${t.shape}.`);const s=t.rank>0?t.shape[0]:1,o=t.rank>1?t.shape[1]:1;if(e.length!==o)throw new Error(`outputShape has incorrect number of elements:, ${e.length}, should be: ${o}.`);if(0!==n.rank&&(1!==n.rank||n.size!==s))throw new Error(`sparseValues has incorrect shape ${n.shape}, should be [] or [${s}]`);if(n.dtype!==r.dtype)throw new Error("sparseValues.dtype must match defaultValues.dtype")}(s,o,e,i),F.runKernel(Pw,{sparseIndices:s,sparseValues:o,defaultValue:i},{outputShape:e})}}),Lne=M({bincount_:function Pne(t,n,e){const r=T(t,"x","bincount"),s=T(n,"weights","bincount");return S("int32"===r.dtype,()=>`Error in bincount: input dtype must be int32, but got ${r.dtype}`),S(e>=0,()=>`size must be non-negative, but got ${e}.`),S(s.size===r.size||0===s.size,()=>`Error in bincount: weights must have the same size as input or0-length, but got input shape: ${r.shape}, weights shape: ${s.shape}.`),F.runKernel(nw,{x:r,weights:s},{size:e})}}),zne=M({denseBincount_:function Bne(t,n,e,r=!1){const s=T(t,"x","denseBincount"),o=T(n,"weights","denseBincount");return S("int32"===s.dtype,()=>`Error in denseBincount: input dtype must be int32, but got ${s.dtype}`),S(s.rank<=2,()=>`Error in denseBincount: input must be at most rank 2, but got rank ${s.rank}.`),S(e>=0,()=>`size must be non-negative, but got ${e}.`),S(o.size===s.size||0===o.size,()=>`Error in denseBincount: weights must have the same shape as x or 0-length, but got x shape: ${s.shape}, weights shape: ${o.shape}.`),F.runKernel(lw,{x:s,weights:o},{size:e,binaryOutput:r})}}),Wne=M({scatterND_:function Une(t,n,e){const r=T(t,"indices","scatterND","int32"),s=T(n,"updates","scatterND");return m2(s,r,e),F.runKernel(Ow,{indices:r,updates:s},{shape:e})}}),Gne=M({gatherND_:function Hne(t,n){const e=T(n,"indices","gatherND","int32"),s={params:T(t,"x","gatherND"),indices:e};return F.runKernel(bw,s)}});function OO(t,n,e,r){const s=((o,i,a)=>{switch(o.category){case"arithmetic":return U(()=>((t,n,e)=>{switch(t.op){case"BiasAdd":case"AddV2":case"Add":return[me(C("a",t,n,e),C("b",t,n,e))];case"AddN":return[ine(C("tensors",t,n,e))];case"FloorMod":case"Mod":return[Y2(C("a",t,n,e),C("b",t,n,e))];case"Mul":return[V(C("a",t,n,e),C("b",t,n,e))];case"RealDiv":case"Div":return[Me(C("a",t,n,e),C("b",t,n,e))];case"DivNoNan":return[G2(C("a",t,n,e),C("b",t,n,e))];case"FloorDiv":return[EC(C("a",t,n,e),C("b",t,n,e))];case"Sub":return[$e(C("a",t,n,e),C("b",t,n,e))];case"Minimum":return[xh(C("a",t,n,e),C("b",t,n,e))];case"Maximum":return[oi(C("a",t,n,e),C("b",t,n,e))];case"Pow":return[Ua(C("a",t,n,e),C("b",t,n,e))];case"SquaredDifference":return[JC(C("a",t,n,e),C("b",t,n,e))];default:throw TypeError(`Node type ${t.op} is not implemented`)}})(o,i,a));case"basic_math":return U(()=>((t,n,e)=>{switch(t.op){case"Abs":case"ComplexAbs":return[Yn(C("x",t,n,e))];case"Acos":return[F2(C("x",t,n,e))];case"Acosh":return[O2(C("x",t,n,e))];case"Asin":return[P2(C("x",t,n,e))];case"Asinh":return[L2(C("x",t,n,e))];case"Atan":return[B2(C("x",t,n,e))];case"Atan2":return[z2(C("x",t,n,e),C("y",t,n,e))];case"Atanh":return[V2(C("x",t,n,e))];case"Ceil":return[U2(C("x",t,n,e))];case"Complex":return[$a(C("real",t,n,e),C("imag",t,n,e))];case"Cos":return[Hg(C("x",t,n,e))];case"Cosh":return[kI(C("x",t,n,e))];case"Elu":return[mh(C("x",t,n,e))];case"Erf":return[j2(C("x",t,n,e))];case"Exp":return[Rs(C("x",t,n,e))];case"Expm1":return[q2(C("x",t,n,e))];case"Floor":return[yh(C("x",t,n,e))];case"Log":return[hs(C("x",t,n,e))];case"Log1p":return[eI(C("x",t,n,e))];case"Imag":return[BC(C("x",t,n,e))];case"Neg":return[mn(C("x",t,n,e))];case"Reciprocal":return[Z2(C("x",t,n,e))];case"Real":return[Ag(C("x",t,n,e))];case"Relu":return[ai(C("x",t,n,e))];case"Round":return[Q2(C("x",t,n,e))];case"Selu":return[FC(C("x",t,n,e))];case"Sigmoid":return[bu(C("x",t,n,e))];case"Sin":return[_I(C("x",t,n,e))];case"Sign":return[J2(C("x",t,n,e))];case"Sinh":return[SI(C("x",t,n,e))];case"Softplus":return[Ch(C("x",t,n,e))];case"Sqrt":return[yr(C("x",t,n,e))];case"Square":return[zt(C("x",t,n,e))];case"Tanh":return[PC(C("x",t,n,e))];case"Tan":return[tF(C("x",t,n,e))];case"ClipByValue":return[Kr(C("x",t,n,e),C("clipValueMin",t,n,e),C("clipValueMax",t,n,e))];case"Relu6":return[UC(C("x",t,n,e))];case"Rsqrt":return[NI(Br(t.inputNames[0],n,e))];case"Prod":return[RI(C("x",t,n,e),C("axes",t,n,e))];case"LeakyRelu":return[Dg(C("x",t,n,e),C("alpha",t,n,e))];case"Prelu":return[Eg(C("x",t,n,e),C("alpha",t,n,e))];default:throw TypeError(`Node type ${t.op} is not implemented`)}})(o,i,a));case"control":return pne(o,i,a);case"convolution":return U(()=>((t,n,e)=>{switch(t.op){case"Conv1D":{const r=C("stride",t,n,e),s=C("pad",t,n,e),o=C("dataFormat",t,n,e).toUpperCase(),i=C("dilation",t,n,e);return[DC(C("x",t,n,e),C("filter",t,n,e),r,s,o,i)]}case"Conv2D":{const r=C("strides",t,n,e),s=yy(t,n,e),o=C("dataFormat",t,n,e).toUpperCase(),i=C("dilations",t,n,e);return[Vi(C("x",t,n,e),C("filter",t,n,e),[r[1],r[2]],s,o,[i[1],i[2]])]}case"_FusedConv2D":{const{stride:r,pad:s,dataFormat:o,dilations:i,biasArg:a,preluArg:l,activationFunc:u,leakyreluAlpha:c}=$O(t,n,e);return[n2({x:C("x",t,n,e),filter:C("filter",t,n,e),strides:[r[1],r[2]],pad:s,dataFormat:o,dilations:[i[1],i[2]],bias:a,activation:u,preluActivationWeights:l,leakyreluAlpha:c})]}case"FusedDepthwiseConv2dNative":{const{stride:r,pad:s,dataFormat:o,dilations:i,biasArg:a,preluArg:l,activationFunc:u,leakyreluAlpha:c}=$O(t,n,e);return[N9({x:C("x",t,n,e),filter:C("filter",t,n,e),strides:[r[1],r[2]],pad:s,dataFormat:o,dilations:[i[1],i[2]],bias:a,activation:u,preluActivationWeights:l,leakyreluAlpha:c})]}case"Conv2DBackpropInput":case"Conv2dTranspose":{const r=C("outputShape",t,n,e),s=C("strides",t,n,e),o=yy(t,n,e);return[SC(C("x",t,n,e),C("filter",t,n,e),r,[s[1],s[2]],o)]}case"DepthwiseConv2dNative":case"DepthwiseConv2d":{const r=C("strides",t,n,e),s=yy(t,n,e),o=C("dilations",t,n,e),i=C("dataFormat",t,n,e).toUpperCase();return[ph(C("input",t,n,e),C("filter",t,n,e),[r[1],r[2]],s,i,[o[1],o[2]])]}case"Conv3D":{const r=C("strides",t,n,e),s=C("pad",t,n,e),o=C("dataFormat",t,n,e).toUpperCase(),i=C("dilations",t,n,e);return[X$(C("x",t,n,e),C("filter",t,n,e),[r[1],r[2],r[3]],s,o,[i[1],i[2],i[3]])]}case"AvgPool":{const r=C("strides",t,n,e),s=C("pad",t,n,e),o=C("kernelSize",t,n,e);return[Cg(C("x",t,n,e),[o[1],o[2]],[r[1],r[2]],s)]}case"MaxPool":{const r=C("strides",t,n,e),s=C("pad",t,n,e),o=C("kernelSize",t,n,e);return[_g(C("x",t,n,e),[o[1],o[2]],[r[1],r[2]],s)]}case"MaxPoolWithArgmax":{const r=C("strides",t,n,e),s=C("pad",t,n,e),o=C("kernelSize",t,n,e),i=C("includeBatchInIndex",t,n,e),{result:a,indexes:l}=gne(C("x",t,n,e),[o[1],o[2]],[r[1],r[2]],s,i);return[a,l]}case"AvgPool3D":{const r=C("strides",t,n,e),s=C("pad",t,n,e),o=C("kernelSize",t,n,e);return[K$(C("x",t,n,e),[o[1],o[2],o[3]],[r[1],r[2],r[3]],s)]}case"MaxPool3D":{const r=C("strides",t,n,e),s=C("pad",t,n,e),o=C("kernelSize",t,n,e);return[Z$(C("x",t,n,e),[o[1],o[2],o[3]],[r[1],r[2],r[3]],s)]}case"Dilation2D":{const r=C("strides",t,n,e),s=C("pad",t,n,e),o=C("dilations",t,n,e),i=r[1],a=r[2],l=o[1],u=o[2];return[H2(C("x",t,n,e),C("filter",t,n,e),[i,a],s,[l,u],"NHWC")]}default:throw TypeError(`Node type ${t.op} is not implemented`)}})(o,i,a));case"creation":return U(()=>((t,n,e)=>{switch(t.op){case"Fill":{const r=C("shape",t,n,e),s=C("dtype",t,n,e);return[Ig(r,C("value",t,n,e),s)]}case"LinSpace":return[bne(C("start",t,n,e),C("stop",t,n,e),C("num",t,n,e))];case"Multinomial":{const r=C("logits",t,n,e),s=C("numSamples",t,n,e),o=C("seed",t,n,e);return[xne(r,s,o)]}case"OneHot":{const r=C("indices",t,n,e),s=C("depth",t,n,e),o=C("onValue",t,n,e),i=C("offValue",t,n,e);return[AC(r,s,o,i)]}case"Ones":return[ii(C("shape",t,n,e),C("dtype",t,n,e))];case"OnesLike":return[fs(C("x",t,n,e))];case"RandomUniform":return[wh(C("shape",t,n,e),C("minval",t,n,e),C("maxval",t,n,e),C("dtype",t,n,e))];case"Range":return[ZC(C("start",t,n,e),C("stop",t,n,e),C("step",t,n,e),C("dtype",t,n,e))];case"TruncatedNormal":{const r=C("shape",t,n,e),s=C("mean",t,n,e),o=C("stdDev",t,n,e),i=C("seed",t,n,e);return[LC(r,s,o,C("dtype",t,n,e),i)]}case"Zeros":return[Nn(C("shape",t,n,e),C("dtype",t,n,e))];case"ZerosLike":return[Ct(C("x",t,n,e))];default:throw TypeError(`Node type ${t.op} is not implemented`)}})(o,i,a));case"dynamic":return Sne(o,i,a);case"evaluation":return U(()=>((t,n,e)=>{switch(t.op){case"TopKV2":{const r=C("x",t,n,e),s=C("k",t,n,e),o=C("sorted",t,n,e),i=nF(r,s,o);return[i.values,i.indices]}case"Unique":{const r=C("x",t,n,e),s=$I(r);return[s.values,s.indices]}case"UniqueV2":{const r=C("x",t,n,e),s=C("axis",t,n,e),o=$I(r,s);return[o.values,o.indices]}default:throw TypeError(`Node type ${t.op} is not implemented`)}})(o,i,a));case"image":return U(()=>((t,n,e)=>{switch(t.op){case"ResizeBilinear":{const r=C("images",t,n,e),s=C("size",t,n,e),o=C("alignCorners",t,n,e),i=C("halfPixelCenters",t,n,e);return[Wa.resizeBilinear(r,[s[0],s[1]],o,i)]}case"ResizeNearestNeighbor":{const r=C("images",t,n,e),s=C("size",t,n,e),o=C("alignCorners",t,n,e),i=C("halfPixelCenters",t,n,e);return[Wa.resizeNearestNeighbor(r,[s[0],s[1]],o,i)]}case"CropAndResize":{const r=C("image",t,n,e),s=C("boxes",t,n,e),o=C("boxInd",t,n,e),i=C("cropSize",t,n,e),a=C("method",t,n,e),l=C("extrapolationValue",t,n,e);return[Wa.cropAndResize(r,s,o,i,a,l)]}default:throw TypeError(`Node type ${t.op} is not implemented`)}})(o,i,a));case"graph":return U(()=>((t,n,e)=>{switch(t.op){case"Const":return n[t.name];case"PlaceholderWithDefault":const r=C("default",t,n,e);return[Br(t.name,n,e)||r];case"Placeholder":return[Br(t.name,n,e)];case"Identity":case"StopGradient":case"FakeQuantWithMinMaxVars":case"Snapshot":return[mi(C("x",t,n,e))];case"IdentityN":return C("x",t,n,e).map(u=>mi(u));case"Shape":return[Os(C("x",t,n,e).shape,"int32")];case"ShapeN":return C("x",t,n,e).map(u=>Os(u.shape));case"Size":return[Fe(C("x",t,n,e).size,"int32")];case"Rank":return[Fe(C("x",t,n,e).rank,"int32")];case"NoOp":return[Fe(1)];case"Print":const o=C("x",t,n,e),i=C("data",t,n,e),a=C("message",t,n,e),l=C("summarize",t,n,e);console.warn("The graph has a tf.print() operation,usually used for debugging, which slows down performance."),console.log(a);for(let u=0;u<i.length;u++)console.log(Array.prototype.slice.call(i[u].dataSync()).slice(0,l));return[o];default:throw TypeError(`Node type ${t.op} is not implemented`)}})(o,i,a));case"logical":return U(()=>((t,n,e)=>{switch(t.op){case"Equal":return[Ba(C("a",t,n,e),C("b",t,n,e))];case"NotEqual":return[yu(C("a",t,n,e),C("b",t,n,e))];case"Greater":return[Eo(C("a",t,n,e),C("b",t,n,e))];case"GreaterEqual":return[Va(C("a",t,n,e),C("b",t,n,e))];case"Less":return[TI(C("a",t,n,e),C("b",t,n,e))];case"LessEqual":return[wu(C("a",t,n,e),C("b",t,n,e))];case"LogicalAnd":return[No(C("a",t,n,e),C("b",t,n,e))];case"LogicalNot":return[Wg(C("a",t,n,e))];case"LogicalOr":return[AI(C("a",t,n,e),C("b",t,n,e))];case"Select":case"SelectV2":return[ms(C("condition",t,n,e),C("a",t,n,e),C("b",t,n,e))];default:throw TypeError(`Node type ${t.op} is not implemented`)}})(o,i,a));case"matrices":return U(()=>((t,n,e)=>{switch(t.op){case"BatchMatMul":case"BatchMatMulV2":case"MatMul":return[Nt(C("a",t,n,e),C("b",t,n,e),C("transposeA",t,n,e),C("transposeB",t,n,e))];case"Transpose":return[Bt(C("x",t,n,e),C("perm",t,n,e))];case"_FusedMatMul":const[r,s]=C("fusedOps",t,n,e),o="biasadd"===r,i="prelu"===s,a=C("numArgs",t,n,e),l=C("leakyreluAlpha",t,n,e);if(o){if(i&&2!==a)throw new Error("Fused MatMul with BiasAdd and Prelu must have two extra arguments: bias and alpha.");if(!i&&1!==a)throw new Error("Fused MatMul with BiasAdd must have one extra argument: bias.")}const[u,c]=C("args",t,n,e);return[WC({a:C("a",t,n,e),b:C("b",t,n,e),transposeA:C("transposeA",t,n,e),transposeB:C("transposeB",t,n,e),bias:u,activation:s,preluActivationWeights:c,leakyreluAlpha:l})];default:throw TypeError(`Node type ${t.op} is not implemented`)}})(o,i,a));case"normalization":return U(()=>((t,n,e)=>{switch(t.op){case"FusedBatchNorm":case"FusedBatchNormV2":case"FusedBatchNormV3":return[mu(C("x",t,n,e),C("mean",t,n,e),C("variance",t,n,e),C("offset",t,n,e),C("scale",t,n,e),C("epsilon",t,n,e))];case"LRN":return[K2(C("x",t,n,e),C("radius",t,n,e),C("bias",t,n,e),C("alpha",t,n,e),C("beta",t,n,e))];case"Softmax":return[Tg(C("x",t,n,e))];case"LogSoftmax":return[NC(C("x",t,n,e))];case"SparseToDense":return[FO(C("sparseIndices",t,n,e),C("outputShape",t,n,e),C("sparseValues",t,n,e),C("defaultValue",t,n,e))];default:throw TypeError(`Node type ${t.op} is not implemented`)}})(o,i,a));case"reduction":return U(()=>((t,n,e)=>{switch(t.op){case"Max":{const i=C("axis",t,n,e),a=C("keepDims",t,n,e);return[$s(C("x",t,n,e),i,a)]}case"Mean":{const i=C("axis",t,n,e),a=C("keepDims",t,n,e);return[pn(C("x",t,n,e),i,a)]}case"Min":{const i=C("axis",t,n,e),a=C("keepDims",t,n,e);return[vh(C("x",t,n,e),i,a)]}case"Sum":{const i=C("axis",t,n,e),a=C("keepDims",t,n,e);return[Oe(C("x",t,n,e),i,a)]}case"All":{const i=C("axis",t,n,e),a=C("keepDims",t,n,e);return[wC(C("x",t,n,e),i,a)]}case"Any":{const i=C("axis",t,n,e),a=C("keepDims",t,n,e);return[vg(C("x",t,n,e),i,a)]}case"ArgMax":{const i=C("axis",t,n,e);return[xg(C("x",t,n,e),i)]}case"ArgMin":{const i=C("axis",t,n,e);return[M2(C("x",t,n,e),i)]}case"Prod":{const i=C("axis",t,n,e),a=C("keepDims",t,n,e);return[RI(C("x",t,n,e),i,a)]}case"Cumsum":{const i=C("axis",t,n,e),a=C("exclusive",t,n,e),l=C("reverse",t,n,e);return[EI(C("x",t,n,e),i,a,l)]}case"Bincount":const r=C("x",t,n,e),s=C("weights",t,n,e),o=C("size",t,n,e);return[Lne(r,s,o)];case"DenseBincount":{const i=C("x",t,n,e),a=C("weights",t,n,e),l=C("size",t,n,e),u=C("binaryOutput",t,n,e);return[zne(i,a,l,u)]}default:throw TypeError(`Node type ${t.op} is not implemented`)}})(o,i,a));case"slice_join":return U(()=>((t,n,e)=>{switch(t.op){case"ConcatV2":case"Concat":{const r=C("n",t,n,e),s=C("axis",t,n,e);let o=C("tensors",t,n,e);return o=o.slice(0,r),[Sn(o,s)]}case"Gather":{const r=C("x",t,n,e),s=C("indices",t,n,e);return[bh(r,Ae(s,"int32"),0)]}case"GatherV2":{const r=C("axis",t,n,e),s=C("batchDims",t,n,e),o=C("x",t,n,e),i=C("indices",t,n,e);return[bh(o,Ae(i,"int32"),r,s)]}case"Reverse":{const r=C("dims",t,n,e),s=[];for(let i=0;i<r.length;i++)r[i]&&s.push(i);const o=C("x",t,n,e);return[li(o,s)]}case"ReverseV2":{const r=C("axis",t,n,e),s=C("x",t,n,e);return[li(s,r)]}case"Slice":{const r=C("begin",t,n,e),s=C("size",t,n,e);return[At(C("x",t,n,e),r,s)]}case"StridedSlice":{const r=C("begin",t,n,e),s=C("end",t,n,e),o=C("strides",t,n,e),i=C("beginMask",t,n,e),a=C("endMask",t,n,e),l=C("ellipsisMask",t,n,e),u=C("newAxisMask",t,n,e),c=C("shrinkAxisMask",t,n,e),d=C("x",t,n,e);return[eF(d,r,s,o,i,a,l,u,c)]}case"Pack":return U(()=>{const r=C("axis",t,n,e),s=C("tensors",t,n,e),o=s[0].shape,i=vu(s[0]).shape,a=s.map(l=>{const u=Mt(l.shape,o);if(!u&&!Mt(vu(l).shape,i))throw new Error("the input tensors shape does not match");return u?l:H(l,o)});return[Fs(a,r)]});case"Unpack":{const r=C("axis",t,n,e),s=C("tensor",t,n,e);return oo(s,r)}case"Tile":{const r=C("reps",t,n,e);return[za(C("x",t,n,e),r)]}case"Split":case"SplitV":{const r=C("axis",t,n,e),s=C("numOrSizeSplits",t,n,e),o=C("x",t,n,e);return ps(o,s,r)}case"ScatterNd":{const r=C("indices",t,n,e),s=C("values",t,n,e),o=C("shape",t,n,e);return[Wne(r,s,o)]}case"GatherNd":{const r=C("x",t,n,e),s=C("indices",t,n,e);return[Gne(r,s)]}case"SparseToDense":{const r=C("sparseIndices",t,n,e),s=C("outputShape",t,n,e),o=C("sparseValues",t,n,e),i=C("defaultValue",t,n,e);return[FO(r,o,s,o.dtype===i.dtype?i:Ae(i,o.dtype))]}default:throw TypeError(`Node type ${t.op} is not implemented`)}})(o,i,a));case"spectral":return U(()=>((t,n,e)=>{switch(t.op){case"FFT":return[Rg(C("x",t,n,e))];case"IFFT":return[Dh(C("x",t,n,e))];case"RFFT":return[$g(C("x",t,n,e))];case"IRFFT":return[zC(C("x",t,n,e))];default:throw TypeError(`Node type ${t.op} is not implemented`)}})(o,i,a));case"transformation":return U(()=>((t,n,e)=>{switch(t.op){case"Cast":return[Ae(C("x",t,n,e),C("dtype",t,n,e))];case"ExpandDims":{const r=C("axis",t,n,e);return[As(C("x",t,n,e),r)]}case"Squeeze":{const r=C("axis",t,n,e);return[vu(C("x",t,n,e),r)]}case"Reshape":return[H(C("x",t,n,e),C("shape",t,n,e))];case"MirrorPad":return[X2(C("x",t,n,e),C("padding",t,n,e),C("mode",t,n,e))];case"PadV2":case"Pad":return[Sg(C("x",t,n,e),C("padding",t,n,e),C("constantValue",t,n,e))];case"SpaceToBatchND":{const r=C("blockShape",t,n,e),s=C("paddings",t,n,e);return[Ug(C("x",t,n,e),r,s)]}case"BatchToSpaceND":{const r=C("blockShape",t,n,e),s=C("crops",t,n,e);return[Gg(C("x",t,n,e),r,s)]}case"DepthToSpace":{const r=C("blockSize",t,n,e),s=C("dataFormat",t,n,e).toUpperCase();return[W2(C("x",t,n,e),r,s)]}case"BroadcastTo":return[kg(C("x",t,n,e),C("shape",t,n,e))];default:throw TypeError(`Node type ${t.op} is not implemented`)}})(o,i,a));case"hash_table":return kne(o,i,a,r);case"custom":const l=EO(o.op);if(l&&l.customExecutor)return l.customExecutor(new sne(o,i,a));throw TypeError(`Custom op ${o.op} is not registered.`);default:throw TypeError(`Unknown op '${o.op}'. File an issue at https://github.com/tensorflow/tfjs/issues so we can add it, or register a custom execution with tf.registerOp()`)}})(t,n,e);return cd(s)?s.then(o=>[].concat(o)):[].concat(s)}class MO{constructor(n={},e={},r={},s={}){this.weightMap=n,this.tensorArrayMap=e,this.tensorListMap=r,this.functionMap=s,this.rootContext={id:0,frameName:"",iterationId:0},this.contexts=[this.rootContext],this.lastId=0,this.generateCurrentContextIds()}newFrame(n,e){return{id:n,frameName:e,iterationId:0}}set currentContext(n){this.contexts!==n&&(this.contexts=n,this.generateCurrentContextIds())}get currentContext(){return this.contexts}get currentContextId(){return this._currentContextIds[0]}get currentContextIds(){return this._currentContextIds}generateCurrentContextIds(){const n=[];for(let e=0;e<this.contexts.length-1;e++){const r=this.contexts.slice(0,this.contexts.length-e);n.push(this.contextIdforContexts(r))}n.push(""),this._currentContextIds=n}contextIdforContexts(n){return n?n.map(e=>0===e.id&&0===e.iterationId?"":`${e.frameName}-${e.iterationId}`).join("/"):""}enterFrame(n){this.contexts&&(this.lastId++,this.contexts=this.contexts.slice(),this.contexts.push(this.newFrame(this.lastId,n)),this._currentContextIds.unshift(this.contextIdforContexts(this.contexts)))}exitFrame(){if(!(this.contexts&&this.contexts.length>1))throw new Error("Cannot exit frame, the context is empty");this.contexts=this.contexts.slice(),this.contexts.splice(-1),this.currentContextIds.shift()}nextIteration(){if(!(this.contexts&&this.contexts.length>0))throw new Error("Cannot increase frame iteration, the context is empty");{this.contexts=this.contexts.slice(),this.lastId++;const n=Object.assign({},this.contexts[this.contexts.length-1]);n.iterationId+=1,n.id=this.lastId,this.contexts.splice(-1,1,n),this._currentContextIds.splice(0,1,this.contextIdforContexts(this.contexts))}}getWeight(n){return this.weightMap[n]}addTensorArray(n){this.tensorArrayMap[n.id]=n}getTensorArray(n){return this.tensorArrayMap[n]}addTensorList(n){this.tensorListMap[n.id]=n}getTensorList(n){return this.tensorListMap[n]}dispose(n){for(const e in this.tensorArrayMap)this.tensorArrayMap[e].clearAndClose(n);for(const e in this.tensorListMap)this.tensorListMap[e].clearAndClose(n)}}function PO(t,n,e,r){const s=new Set,o=[];let i=null,a=null;const l=new Set,u=Object.keys(t).map(h=>Yr(h)[0]);let c=[];null!=r&&(c=r.map(h=>Yr(h.name)[0]));const d=[...n];for(;d.length>0;){const h=d.pop();if((LO(h)||Jne(h)||ere(h))&&null==i&&(i=h,a=i.children.map(f=>f.name).filter(f=>s.has(f))),s.add(h.name),null==e[h.name]&&-1===u.indexOf(h.name)&&-1===c.indexOf(h.name)){if(0===h.inputs.length){o.push(h.name);continue}h.inputs.forEach(f=>{l.has(f.name)||(l.add(f.name),d.push(f))})}}return{inputs:t,outputs:n,usedNodes:s,missingInputs:o,dynamicNode:i,syncInputs:a}}const Yne=["Switch","Merge","Enter","Exit","NextIteration","StatelessIf","StatelessWhile","if","While"],Zne=["NonMaxSuppressionV2","NonMaxSuppressionV3","NonMaxSuppressionV5","Where"],Qne=["HashTable","HashTableV2","LookupTableImport","LookupTableImportV2","LookupTableFind","LookupTableFindV2","LookupTableSize","LookupTableSizeV2"];function LO(t){return Yne.indexOf(t.op)>=0}function Jne(t){return Zne.indexOf(t.op)>=0}function ere(t){return Qne.indexOf(t.op)>=0}class by{constructor(n,e){this.graph=n,this.parent=e,this.compiledMap=new Map,this._weightMap={},this.SEPERATOR=",",this._functions={},this._functionExecutorMap={},this._outputs=n.outputs,this._inputs=n.inputs,this._initNodes=n.initNodes,this._signature=n.signature,this._functions=n.functions,null!=n.functions&&Object.keys(n.functions).forEach(r=>{this._functionExecutorMap[r]=new by(n.functions[r],this)})}get weightIds(){return this.parent?this.parent.weightIds:this._weightIds}get functionExecutorMap(){return this.parent?this.parent.functionExecutorMap:this._functionExecutorMap}get weightMap(){return this.parent?this.parent.weightMap:this._weightMap}set weightMap(n){const e=Object.keys(n).map(r=>n[r].map(s=>s.id));this._weightIds=[].concat(...e),this._weightMap=n}set resourceManager(n){this._resourceManager=n}get inputs(){return this._inputs.map(n=>({name:n.name,shape:n.attrParams.shape?n.attrParams.shape.value:void 0,dtype:n.attrParams.dtype?n.attrParams.dtype.value:void 0}))}get outputs(){return this._outputs.map(n=>({name:n.name,shape:n.attrParams.shape?n.attrParams.shape.value:void 0,dtype:n.attrParams.dtype?n.attrParams.dtype.value:void 0}))}get inputNodes(){return this._inputs.map(n=>n.signatureKey||n.name)}get outputNodes(){return this._outputs.map(n=>{const e=n.signatureKey||n.name;return n.defaultOutput?`${e}:${n.defaultOutput}`:e})}get functions(){return Object.keys(this._functions).reduce((n,e)=>(n[e]=this._functions[e].signature,n),{})}getCompilationKey(n,e){const r=n.map(o=>o.name).sort(),s=e.map(o=>o.name).sort();return r.join(this.SEPERATOR)+"--"+s.join(this.SEPERATOR)}compile(n,e){const r=PO(n,e,this.weightMap,this._initNodes),{missingInputs:s,dynamicNode:o,syncInputs:i}=r;if(null!=o)throw new Error(`This execution contains the node '${o.name}', which has the dynamic op '${o.op}'. Please use model.executeAsync() instead. Alternatively, to avoid the dynamic ops, specify the inputs [${i}]`);if(s.length>0){const a=e.map(u=>u.name),l=Object.keys(n);throw new Error(`Cannot compute the outputs [${a}] from the provided inputs [${l}]. Missing the following inputs: [${s}]`)}return function Xne(t,n,e){const{usedNodes:r,inputs:s}=e,o=[],i=Object.keys(s).map(c=>Yr(c)[0]).map(c=>t.nodes[c]),a=t.initNodes;i.forEach(c=>{r.has(c.name)&&o.push(c)}),t.weights.forEach(c=>{r.has(c.name)&&o.push(c)}),a?.forEach(c=>{r.has(c.name)&&o.push(c)});const l=new Set,u=[];for(;o.length>0;){const c=o.pop();l.add(c.name),n[c.name]||u.push(c),c.children.forEach(d=>{!l.has(d.name)&&r.has(d.name)&&d.inputs.every(h=>l.has(h.name))&&o.push(d)})}return u}(this.graph,this.weightMap,r)}execute(n,e){n=this.mapInputs(n);const r=Object.keys(n).sort();this.checkInputs(n),this.checkInputShapeAndType(n),e=this.mapOutputs(e),this.checkOutputs(e);const s=r.map(d=>this.graph.nodes[Yr(d)[0]]),o=e.map(d=>Yr(d)[0]);let i=o.map(d=>this.graph.nodes[d]);0===i.length&&(i=this._outputs);const a=this.getCompilationKey(s,i);let l=this.compiledMap.get(a);null==l&&(l=this.compile(n,i),this.compiledMap.set(a,l));const u={},c={};return U(()=>{const d=new MO(this.weightMap,u,c,this.functionExecutorMap),h=Object.assign({},this.weightMap);Object.keys(n).forEach(m=>{const[g,y]=Yr(m),b=[];b[y]=n[m],h[g]=b});const f=this.getFrozenTensorIds(h),p={};for(let m=0;m<l.length;m++){const g=l[m];if(!h[g.name]){const y=OO(g,h,d,this._resourceManager);if(cd(y))throw new Error(`The execution of the op '${g.op}' returned a promise. Please use model.executeAsync() instead.`);h[g.name]=y,this.checkTensorForDisposal(g.name,g,h,d,f,o,p)}}return null==this.parent&&d.dispose(f),e.map(m=>Br(m,h,d))})}getFrozenTensorIds(n){const e=[].concat.apply([],Object.keys(n).map(r=>n[r]).map(r=>r.map(s=>s.id)));return new Set(e)}checkTensorForDisposal(n,e,r,s,o,i,a){"control"===e.category||-1!==i.indexOf(n)||(r[n].forEach(l=>{null!=l&&(a[l.id]=(a[l.id]||0)+e.children.length)}),e.inputs.forEach(l=>{if("control"!==l.category){const u=function Bte(t,n,e){return n[gy(t,e.currentContextId)]}(l.name,r,s);u?.forEach(c=>{if(c&&!o.has(c.id)){const d=a[c.id];1===d?(c.dispose(),delete a[c.id]):null!=d&&a[c.id]--}})}}))}executeAsync(n,e){var r=this;return J(function*(){return r._executeAsync(n,e)})()}_executeAsync(n,e,r=!1,s={},o={}){var i=this;return J(function*(){r||(n=i.mapInputs(n),i.checkInputs(n),i.checkInputShapeAndType(n),e=i.mapOutputs(e),i.checkOutputs(e));const a=new MO(i.weightMap,s,o,i.functionExecutorMap),l=yield i.executeWithControlFlow(n,a,e,r),u=e.map(f=>Br(f,l,a)),c=u.map(f=>f.id),d=Object.keys(n).map(f=>n[f].id),h=new Set([...c,...d,...i.weightIds]);return Object.keys(l).forEach(f=>{l[f].forEach(m=>{m&&!m.isDisposed&&!h.has(m.id)&&m.dispose()})}),null==i.parent&&a.dispose(h),u})()}executeFunctionAsync(n,e,r){var s=this;return J(function*(){const o=n.reduce((i,a,l)=>(i[s.inputs[l].name]=a,i),{});return s._executeAsync(o,s.outputNodes,!0,e,r)})()}executeWithControlFlow(n,e,r,s){var o=this;return J(function*(){const i=Object.keys(n),a=i.map(x=>o.graph.nodes[Yr(x)[0]]),l=r.map(x=>Yr(x)[0]);let u=l.map(x=>o.graph.nodes[x]);0===u.length&&(u=o._outputs);const{usedNodes:c,missingInputs:d,dynamicNode:h,syncInputs:f}=PO(n,u,o.weightMap,o._initNodes),p=[...a,...o.graph.weights,...o._initNodes||[]].map(x=>({node:x,contexts:e.currentContext})),m=Object.assign({},o.weightMap);Object.keys(n).forEach(x=>{const[w,_]=Yr(x),D=[];D[_]=n[x],m[w]=D});const g={},y=o.getFrozenTensorIds(m),b={};for(;p.length>0;){const x=o.processStack(a,p,e,m,b,y,l,g,c);yield Promise.all(x)}null==h&&!s&&console.warn("This model execution did not contain any nodes with control flow or dynamic output shapes. You can use model.execute() instead.");const v=u.filter(x=>!LO(x)&&!Br(x.name,m,e)).map(x=>x.name);if(v.length>0){let x="";throw null!=h&&(x=`Alternatively, to avoid the dynamic ops, use model.execute() and specify the inputs [${f}]`),new Error(`Cannot compute the outputs [${v}] from the provided inputs [${i}]. Consider providing the following inputs: [${d}]. ${x}`)}return m})()}processStack(n,e,r,s,o,i,a,l,u){const c=[];for(;e.length>0;){const d=e.pop();r.currentContext=d.contexts;let h="";if("Enter"===d.node.op&&C("isConstant",d.node,s,r)&&([h]=pi(d.node.name,r)),null==s[d.node.name]){const f=OO(d.node,s,r,this._resourceManager);h||([h]=pi(d.node.name,r));const p=r.currentContext;cd(f)?c.push(f.then(m=>(s[h]=m,r.currentContext=p,this.checkTensorForDisposal(h,d.node,s,r,i,a,l),this.processChildNodes(d.node,e,r,s,o,u),m))):(s[h]=f,this.checkTensorForDisposal(h,d.node,s,r,i,a,l),this.processChildNodes(d.node,e,r,s,o,u))}else this.processChildNodes(d.node,e,r,s,o,u)}return c}processChildNodes(n,e,r,s,o,i){n.children.forEach(a=>{const[l]=pi(a.name,r);o[l]||!i.has(a.name)||("Merge"===a.op?a.inputNames.some(u=>!!Br(u,s,r))&&(o[l]=!0,e.push({contexts:r.currentContext,node:a})):a.inputNames.every(u=>!!Br(u,s,r))&&(o[l]=!0,e.push({contexts:r.currentContext,node:a})))})}dispose(){Object.keys(this.weightMap).forEach(n=>this.weightMap[n].forEach(e=>e.dispose()))}checkInputShapeAndType(n){Object.keys(n).forEach(e=>{const r=n[e],[s]=Yr(e),o=this.graph.nodes[s];if(o.attrParams.shape&&o.attrParams.shape.value){const i=o.attrParams.shape.value;S(i.length===r.shape.length&&r.shape.every((l,u)=>-1===i[u]||i[u]===l),()=>`The shape of dict['${o.name}'] provided in model.execute(dict) must be [${i}], but was [${r.shape}]`)}o.attrParams.dtype&&o.attrParams.dtype.value&&S(r.dtype===o.attrParams.dtype.value,()=>`The dtype of dict['${o.name}'] provided in model.execute(dict) must be ${o.attrParams.dtype.value}, but was ${r.dtype}`)})}mapInputs(n){const e={};for(const r in n)null!=this._signature&&null!=this._signature.inputs&&null!=this._signature.inputs[r]?e[this._signature.inputs[r].name]=n[r]:e[r]=n[r];return e}checkInputs(n){const e=Object.keys(n).filter(r=>{const[s]=Yr(r);return null==this.graph.nodes[s]});if(e.length>0)throw new Error(`The dict provided in model.execute(dict) has keys: [${e}] that are not part of graph`)}mapOutputs(n){return n.map(e=>null!=this._signature&&null!=this._signature.outputs&&null!=this._signature.outputs[e]?this._signature.outputs[e].name:e,{})}checkOutputs(n){n.forEach(e=>{const[r]=Yr(e);if(!this.graph.nodes[r])throw new Error(`The output '${e}' is not found in the graph`)})}}class tre{constructor(n={},e={}){this.hashTableNameToHandle=n,this.hashTableMap=e}addHashTable(n,e){this.hashTableNameToHandle[n]=e.handle,this.hashTableMap[e.id]=e}getHashTableHandleByName(n){return this.hashTableNameToHandle[n]}getHashTableById(n){return this.hashTableMap[n]}dispose(){for(const n in this.hashTableMap)this.hashTableMap[n].clearAndClose(),delete this.hashTableMap[n];for(const n in this.hashTableNameToHandle)this.hashTableNameToHandle[n].dispose(),delete this.hashTableNameToHandle[n]}}const nre="?tfjs-format=file",rre="model.json";class sre{constructor(n,e={}){this.modelUrl=n,this.loadOptions=e,this.version="n/a",null==e&&(this.loadOptions={}),this.resourceManager=new tre}get modelVersion(){return this.version}get inputNodes(){return this.executor.inputNodes}get outputNodes(){return this.executor.outputNodes}get inputs(){return this.executor.inputs}get outputs(){return this.executor.outputs}get weights(){return this.executor.weightMap}get metadata(){return this.artifacts.userDefinedMetadata}get modelSignature(){return this.signature}findIOHandler(){const n=this.modelUrl;if(null!=n.load)this.handler=n;else if(null!=this.loadOptions.requestInit)this.handler=F$(n,this.loadOptions);else{const e=((t,n)=>ln.getLoadHandlers(t,this.loadOptions))(n);if(0===e.length)e.push(F$(n,this.loadOptions));else if(e.length>1)throw new Error(`Found more than one (${e.length}) load handlers for URL '${[n]}'`);this.handler=e[0]}}load(){var n=this;return J(function*(){if(n.findIOHandler(),null==n.handler.load)throw new Error("Cannot proceed with model loading because the IOHandler provided does not have the `load` method implemented.");const e=yield n.handler.load();return n.loadSync(e)})()}loadSync(n){this.artifacts=n;const e=this.artifacts.modelTopology;let r;r=null!=this.artifacts.userDefinedMetadata&&null!=this.artifacts.userDefinedMetadata.signature?this.artifacts.userDefinedMetadata.signature:this.artifacts.signature,this.signature=r,this.version=`${e.versions.producer}.${e.versions.minConsumer}`;const s=function y$(t,n){const e={};let r,s=0;for(const o of n){const i=o.name,a=o.dtype,l=o.shape,u=te(l);let c;if("quantization"in o){const d=o.quantization;if("uint8"===d.dtype||"uint16"===d.dtype){if(!("min"in d)||!("scale"in d))throw new Error(`Weight ${o.name} with quantization ${d.dtype} doesn't have corresponding metadata min and scale.`)}else{if("float16"!==d.dtype)throw new Error(`Weight ${o.name} has unknown quantization dtype ${d.dtype}. Supported quantization dtypes are: 'uint8', 'uint16', and 'float16'.`);if("float32"!==a)throw new Error(`Weight ${o.name} is quantized with ${d.dtype} which only supports weights of type float32 not ${a}.`)}const h=Zw[d.dtype],f=t.slice(s,s+u*h),p="uint8"===d.dtype?new Uint8Array(f):new Uint16Array(f);if("float32"===a)if("uint8"===d.dtype||"uint16"===d.dtype){c=new Float32Array(p.length);for(let m=0;m<p.length;m++)c[m]=p[m]*d.scale+d.min}else{if("float16"!==d.dtype)throw new Error(`Unsupported quantization type ${d.dtype} for weight type float32.`);void 0===r&&(r=$K()),c=r(p)}else{if("int32"!==a)throw new Error(`Unsupported dtype in weight '${i}': ${a}`);if("uint8"!==d.dtype&&"uint16"!==d.dtype)throw new Error(`Unsupported quantization type ${d.dtype} for weight type int32.`);c=new Int32Array(p.length);for(let m=0;m<p.length;m++)c[m]=Math.round(p[m]*d.scale+d.min)}s+=u*h}else if("string"===a){const d=te(o.shape);c=[];for(let h=0;h<d;h++){const f=new Uint32Array(t.slice(s,s+4))[0];s+=4;const p=new Uint8Array(t.slice(s,s+f));c.push(p),s+=f}}else{const d=Zw[a],h=t.slice(s,s+u*d);if("float32"===a)c=new Float32Array(h);else if("int32"===a)c=new Int32Array(h);else if("bool"===a)c=new Uint8Array(h);else{if("complex64"!==a)throw new Error(`Unsupported dtype in weight '${i}': ${a}`);{c=new Float32Array(h);const f=new Float32Array(c.length/2),p=new Float32Array(c.length/2);for(let y=0;y<f.length;y++)f[y]=c[2*y],p[y]=c[2*y+1];const m=Fa(f,l,"float32"),g=Fa(p,l,"float32");e[i]=$a(m,g),m.dispose(),g.dispose()}}s+=u*d}"complex64"!==a&&(e[i]=Fa(c,l,a))}return e}(this.artifacts.weightData,this.artifacts.weightSpecs);if(this.executor=new by(NO.Instance.transformGraph(e,this.signature)),this.executor.weightMap=this.convertTensorMapToTensorsMap(s),this.executor.resourceManager=this.resourceManager,null!=n.modelInitializer&&null!=n.modelInitializer.node){const o=NO.Instance.transformGraph(n.modelInitializer);this.initializer=new by(o),this.initializer.weightMap=this.executor.weightMap,this.initializer.resourceManager=this.resourceManager,this.initializer.executeAsync({},[])}return!0}save(n,e){var r=this;return J(function*(){if("string"==typeof n){const s=x$(n);if(0===s.length)throw new Error(`Cannot find any save handlers for URL '${n}'`);if(s.length>1)throw new Error(`Found more than one (${s.length}) save handlers for URL '${n}'`);n=s[0]}if(null==n.save)throw new Error("GraphModel.save() cannot proceed because the IOHandler provided does not have the `save` attribute defined.");return n.save(r.artifacts)})()}predict(n,e){return this.execute(n,this.outputNodes)}normalizeInputs(n){if(!(n instanceof an||Array.isArray(n)))return n;if((n=Array.isArray(n)?n:[n]).length!==this.inputNodes.length)throw new Error(`Input tensor count mismatch,the graph model has ${this.inputNodes.length} placeholders, while there are ${n.length} input tensors.`);return this.inputNodes.reduce((e,r,s)=>(e[r]=n[s],e),{})}normalizeOutputs(n){return n=n||this.outputNodes,Array.isArray(n)?n:[n]}execute(n,e){n=this.normalizeInputs(n),e=this.normalizeOutputs(e);const r=this.executor.execute(n,e);return r.length>1?r:r[0]}executeAsync(n,e){var r=this;return J(function*(){n=r.normalizeInputs(n),e=r.normalizeOutputs(e);const s=yield r.executor.executeAsync(n,e);return s.length>1?s:s[0]})()}convertTensorMapToTensorsMap(n){return Object.keys(n).reduce((e,r)=>(e[r]=[n[r]],e),{})}dispose(){this.executor.dispose(),this.initializer&&this.initializer.dispose(),this.resourceManager.dispose()}}function VD(){return(VD=J(function*(t,n={}){if(null==t)throw new Error("modelUrl in loadGraphModel() cannot be null. Please provide a url or an IOHandler that loads the model");null==n&&(n={}),n.fromTFHub&&null==t.load&&(t.endsWith("/")||(t+="/"),t=`${t}${rre}${nre}`);const e=new sre(t,n);return yield e.load(),e})).apply(this,arguments)}function Ee(t,n){Array.isArray(t)||(t=[t]),t.forEach(e=>{null!=e&&S("complex64"!==e.dtype,()=>`${n} does not support complex64 tensors in the CPU backend.`)})}B(340),Symbol("out"),Symbol("field"),Symbol("quote"),Symbol("quoteafterquote"),Symbol("quoteinquote");const $re=DI;let Fre=(()=>{class t extends W0{constructor(){super(),this.blockSize=48,this.firstUse=!0,this.data=new WR(this,Pi())}nextDataId(){return t.nextDataId++}write(e,r,s){this.firstUse&&(this.firstUse=!1,ne().get("IS_NODE")&&Iu("\n============================\nHi there \u{1f44b}. Looks like you are running TensorFlow.js in Node.js. To speed things up dramatically, install our node backend, which binds to TensorFlow C++, by running npm i @tensorflow/tfjs-node, or npm i @tensorflow/tfjs-node-gpu if you have CUDA. Then call require('@tensorflow/tfjs-node'); (-gpu suffix for CUDA) at the start of your program. Visit https://github.com/tensorflow/tfjs-node for more details.\n============================"));const o={id:this.nextDataId()};return this.data.set(o,{values:e,dtype:s,refCount:1}),o}makeTensorInfo(e,r,s){let o;if("string"===r&&null!=s&&s.length>0&&ad(s[0])){const i=s.map(a=>ah(a));o=this.write(i,e,r)}else o=this.write(s,e,r);return{dataId:o,shape:e,dtype:r}}refCount(e){return this.data.has(e)?this.data.get(e).refCount:0}incRef(e){this.data.get(e).refCount++}decRef(e){this.data.has(e)&&this.data.get(e).refCount--}move(e,r,s,o,i){this.data.set(e,{values:r,dtype:o,refCount:i})}numDataIds(){return this.data.numDataIds()}read(e){var r=this;return J(function*(){return r.readSync(e)})()}readSync(e){const{dtype:r,complexTensorInfos:s}=this.data.get(e);return"complex64"===r?di(this.readSync(s.real.dataId),this.readSync(s.imag.dataId)):this.data.get(e).values}bufferSync(e){const r=this.readSync(e.dataId);let s=r;if("string"===e.dtype)try{s=r.map(o=>iu(o))}catch{throw new Error("Failed to decode encoded string bytes into utf-8")}return yt(e.shape,e.dtype,s)}makeOutput(e,r,s){const o=this.write(e,r,s);return Pi().makeTensorFromDataId(o,r,s,this)}disposeData(e,r=!1){if(this.data.has(e)){if(this.data.get(e).refCount--,!r&&this.data.get(e).refCount>0)return!1;const{complexTensorInfos:s}=this.data.get(e);null!=s&&(this.disposeData(s.real.dataId,!0),this.disposeData(s.imag.dataId,!0)),this.data.delete(e)}return!0}disposeIntermediateTensorInfo(e){this.disposeData(e.dataId)}time(e){return J(function*(){const r=Pr();return e(),{kernelMs:Pr()-r}})()}memory(){return{unreliable:!0,reasons:["The reported memory is an upper bound. Due to automatic garbage collection, the true allocated memory may be less."]}}where(e){Ee([e],"where");const r=this.readSync(e.dataId);return $re(e.shape,r)}dispose(){}floatPrecision(){return 32}epsilon(){return super.epsilon()}}return t.nextDataId=0,t})();function Pt(t,n,e){return({inputs:r,attrs:s,backend:o})=>{const{x:i}=r;if(Ee(i,t),"string"===i.dtype||"string"===e)throw new Error("unaryKernelFunc does not support string input/output");const a=o,l=a.data.get(i.dataId).values,u=te(i.shape),c=e||i.dtype,d=ru(c,u);for(let h=0;h<u;++h)d[h]=n(l[h],s);return a.makeTensorInfo(i.shape,c,d)}}function Au(t,n,e){return({inputs:r,attrs:s,backend:o})=>{const{x:i}=r;if(Ee(i,t),"string"===i.dtype||"string"===e)throw new Error("unaryKernelFunc does not support string input/output");const a=o,l=a.data.get(i.dataId).values,u=e||i.dtype,c=n(l,u,s);return a.makeTensorInfo(i.shape,u,c)}}q$("cpu",()=>new Fre,1);const XO=Pt(Dd,t=>t>=0?t:Math.exp(t)-1),Mre={kernelName:Dd,backendName:"cpu",kernelFunc:XO};function Fo(t){const{inputs:n,backend:e}=t,{x:r}=n;return e.incRef(r.dataId),{dataId:r.dataId,shape:r.shape,dtype:r.dtype}}const Pre={kernelName:Ad,backendName:"cpu",kernelFunc:Fo};function YO(t){const{inputs:n,backend:e,attrs:r}=t,{x:s}=n,{alpha:o}=r;Ee([s],"leakyRelu");const i=te(s.shape),a=e.data.get(s.dataId).values,l=or("float32",i);for(let u=0;u<a.length;u++)l[u]=a[u]<0?o*a[u]:a[u];return e.makeTensorInfo(s.shape,"float32",l)}const Lre={kernelName:Im,backendName:"cpu",kernelFunc:YO};function Tn(t){return(n,e,r,s,o)=>{const i=bt(n,e),a=i.length,l=Le(i),c=or(o,te(i)),d=n.length,h=e.length,f=Le(n),p=Le(e),m=gh(n,i),g=gh(e,i);if(m.length+g.length===0)for(let y=0;y<c.length;++y)c[y]=t(r[y%r.length],s[y%s.length]);else for(let y=0;y<c.length;++y){const b=ud(y,a,l),v=b.slice(-d);m.forEach(D=>v[D]=0);const x=Do(v,d,f),w=b.slice(-h);g.forEach(D=>w[D]=0);const _=Do(w,h,p);c[y]=t(r[x],s[_])}return[c,i]}}const Bre=Tn((t,n)=>t<0?n*t:t);function ZO(t){const{inputs:n,backend:e}=t,{x:r,alpha:s}=n;Ee([r,s],"prelu");const o=e.data.get(r.dataId).values,i=e.data.get(s.dataId).values,[a,l]=Bre(r.shape,s.shape,o,i,r.dtype);return e.makeTensorInfo(l,r.dtype,a)}const zre={kernelName:Um,backendName:"cpu",kernelFunc:ZO},QO=Pt(Wd,t=>Math.max(0,t)),Vre={kernelName:Wd,backendName:"cpu",kernelFunc:QO},JO=Pt(Hd,t=>Math.min(Math.max(0,t),6)),Ure={kernelName:Hd,backendName:"cpu",kernelFunc:JO};function KD(t,n,e,r,s){if("linear"===e)return Fo({inputs:{x:n},backend:t});if("relu"===e)return QO({inputs:{x:n},backend:t});if("elu"===e)return XO({inputs:{x:n},backend:t});if("relu6"===e)return JO({inputs:{x:n},backend:t});if("prelu"===e)return ZO({inputs:{x:n,alpha:r},backend:t});if("leakyrelu"===e)return YO({inputs:{x:n},backend:t,attrs:{alpha:s}});throw new Error(`Activation ${e} has not been implemented for the CPU backend.`)}function Zr(t){const{inputs:n,backend:e}=t,{real:r,imag:s}=n,o=e.data.get(r.dataId).values,i=e.data.get(s.dataId).values,a=e.makeTensorInfo(r.shape,"complex64");return e.data.get(a.dataId).complexTensorInfos={real:e.makeTensorInfo(r.shape,"float32",o),imag:e.makeTensorInfo(s.shape,"float32",i)},a}const Wre={kernelName:rw,backendName:"cpu",kernelFunc:Zr};function Cy(t,n,e="float32"){if("complex64"===e)return Zr({inputs:{real:Cy(t,n,"float32"),imag:Cy(t,n,"float32")},backend:t});const r=gr(te(n),e);return t.makeTensorInfo(n,e,r)}function Qa(t){const{inputs:n,backend:e}=t,{input:r}=n,s=e.data.get(r.dataId).complexTensorInfos.real,o=e.data.get(s.dataId).values;return e.makeTensorInfo(s.shape,s.dtype,o)}const Hre={kernelName:Rw,backendName:"cpu",kernelFunc:Qa};function Yi(t){const{inputs:n,backend:e,attrs:r}=t,{x:s}=n,{dtype:o}=r;if("complex64"===o){if("complex64"===s.dtype)return Fo({inputs:{x:s},backend:e});const i=Cy(e,s.shape,s.dtype),a=Yi({inputs:{x:s},backend:e,attrs:{dtype:"float32"}}),l=Zr({inputs:{real:a,imag:i},backend:e});return e.disposeIntermediateTensorInfo(i),e.disposeIntermediateTensorInfo(a),l}if("complex64"===s.dtype){const i=Qa({inputs:{input:s},backend:e}),a=Yi({inputs:{x:i},backend:e,attrs:{dtype:o}});return e.disposeIntermediateTensorInfo(i),a}if(!KR(s.dtype,o)){const i=Fo({inputs:{x:s},backend:e});return{dataId:i.dataId,shape:i.shape,dtype:o}}if("int32"===o){const i=e.data.get(s.dataId).values,a=Int32Array.from(i);return e.makeTensorInfo(s.shape,"int32",a)}if("bool"===o){const i=e.data.get(s.dataId).values,a=Ra([0],s.dtype),[l,u]=Tn((c,d)=>c!==d?1:0)(s.shape,[],i,a,"bool");return e.makeTensorInfo(u,"bool",l)}throw new Error(`Error in Cast: failed to cast ${s.dtype} to ${o}`)}const Gre={kernelName:bd,backendName:"cpu",kernelFunc:Yi};function er(t,n,e,r){return null==e?({inputs:s,backend:o})=>{const{a:i,b:a}=s,l=o;Ee([i,a],t);const u=l.data.get(i.dataId).values,c=l.data.get(a.dataId).values,d=r||i.dtype,[h,f]=n(i.shape,a.shape,u,c,d);return l.makeTensorInfo(f,d,h)}:({inputs:s,backend:o})=>{const{a:i,b:a}=s,l=o;if("complex64"===i.dtype||"complex64"===a.dtype){const u=Yi({inputs:{x:i},backend:l,attrs:{dtype:"complex64"}}),c=l.data.get(u.dataId),h=c.complexTensorInfos.imag,f=l.data.get(c.complexTensorInfos.real.dataId).values,p=l.data.get(h.dataId).values,m=Yi({inputs:{x:a},backend:l,attrs:{dtype:"complex64"}}),g=l.data.get(m.dataId),b=g.complexTensorInfos.imag,v=l.data.get(g.complexTensorInfos.real.dataId).values,x=l.data.get(b.dataId).values,[w,_,D]=e(i.shape,a.shape,f,p,v,x),A=l.makeTensorInfo(D,"float32",w),R=l.makeTensorInfo(D,"float32",_),O=Zr({inputs:{real:A,imag:R},backend:l});return l.disposeIntermediateTensorInfo(u),l.disposeIntermediateTensorInfo(m),l.disposeIntermediateTensorInfo(A),l.disposeIntermediateTensorInfo(R),O}{const u=l.data.get(i.dataId).values,c=l.data.get(a.dataId).values,d=r||i.dtype,[h,f]=n(i.shape,a.shape,u,c,d);return l.makeTensorInfo(f,d,h)}}}function XD(t){return(n,e,r,s,o,i)=>{const a=bt(n,e),l=te(a),u=a.length,c=Le(a),d=or("float32",l),h=or("float32",l),f=gh(n,a),p=gh(e,a),m=di(r,s),g=di(o,i),y=n.length,b=Le(n),v=e.length,x=Le(e);if(f.length+p.length===0)for(let w=0;w<d.length;w++){const _=w%m.length,D=w%g.length,A=t(m[2*_],m[2*_+1],g[2*D],g[2*D+1]);d[w]=A.real,h[w]=A.imag}else for(let w=0;w<d.length;w++){const _=ud(w,u,c),D=_.slice(-y);f.forEach(K=>D[K]=0);const A=Do(D,y,b),R=_.slice(-v);p.forEach(K=>R[K]=0);const O=Do(R,v,x),G=t(m[2*A],m[2*A+1],g[2*O],g[2*O+1]);d[w]=G.real,h[w]=G.imag}return[d,h,a]}}const eM=Tn((t,n)=>t+n),jre=XD((t,n,e,r)=>({real:t+e,imag:n+r})),jh=er(su,eM,jre),qre={kernelName:su,backendName:"cpu",kernelFunc:jh};function sn(t){const{inputs:n,backend:e,attrs:r}=t,{x:s}=n,{shape:o}=r,i=te(s.shape),a=qR(o,i),l=te(a);S(i===l,()=>`The new shape (${a}) has ${l} elements and the old shape (${s.shape}) has ${i} elements. The new shape and old shape must have the same number of elements.`),e.incRef(s.dataId);const u=e.data.get(s.dataId);if(null!=u.complexTensorInfos){const d=u.complexTensorInfos.imag;u.complexTensorInfos.real.shape=a,d.shape=a}return{dataId:s.dataId,shape:a,dtype:s.dtype}}const Kre={kernelName:Wm,backendName:"cpu",kernelFunc:sn};function tM(t){const{inputs:n,backend:e,attrs:r}=t,{a:s,b:o}=n,{transposeA:i,transposeB:a}=r;Ee([s,o],"matMul");const l=s.shape.length,u=o.shape.length,c=i?s.shape[l-2]:s.shape[l-1],d=a?o.shape[u-1]:o.shape[u-2],h=i?s.shape[l-1]:s.shape[l-2],f=a?o.shape[u-2]:o.shape[u-1],p=s.shape.slice(0,-2),m=o.shape.slice(0,-2),g=te(p),y=te(m);S(l>=2&&u>=2&&(g===y||1===g||1===y),()=>`Error in matMul: the input batch dimensions must either be the same or at least one input batch dimension must be 1. Got input batch dimensions of (${p}) and (${m}).`);const x=(g>y?s.shape.slice(0,-2):o.shape.slice(0,-2)).concat([h,f]);S(c===d,()=>`Error in matMul: inner shapes (${c}) and (${d}) of Tensors with shapes ${s.shape} and ${o.shape} and transposeA=${i} and transposeB=${a} must match.`);const _=a?[y,f,d]:[y,d,f],D=sn({inputs:{x:s},backend:e,attrs:{shape:i?[g,c,h]:[g,h,c]}}),A=sn({inputs:{x:o},backend:e,attrs:{shape:_}}),R=i?D.shape[1]:D.shape[2],O=i?D.shape[2]:D.shape[1],G=a?A.shape[1]:A.shape[2],K=Math.max(g,y),j=e.data.get(D.dataId).values,Q=e.data.get(A.dataId).values,q=Le(D.shape),Y=Le(A.shape),[re,ee,se]=i?[q[0],1,q[1]]:[q[0],q[1],1],[ue,de,ge]=a?[1,Y[1],Y[0]]:[Y[1],1,Y[0]],pe=O*G,ye=yt([K,O,G],D.dtype),ve=ye.values,De=e.blockSize;for(let Te=0;Te<K;Te++)for(let Pe=0;Pe<O;Pe+=De)for(let Be=0;Be<G;Be+=De)for(let tt=0;tt<R;tt+=De){const vt=Math.min(Pe+De,O),Lt=Math.min(Be+De,G),cn=Math.min(tt+De,R);for(let en=Pe;en<vt;en++)for(let Kt=Be;Kt<Lt;Kt++){let Xt=0;for(let tn=tt;tn<cn;tn++){const Cn=Math.min(Te,g-1)*re,yi=Math.min(Te,y-1)*ge;Xt+=j[Cn+en*ee+tn*se]*Q[tn*ue+Kt*de+yi]}ve[Te*pe+(en*G+Kt)]+=Xt}}return e.disposeIntermediateTensorInfo(D),e.disposeIntermediateTensorInfo(A),e.makeTensorInfo(x,ye.dtype,ye.values)}const Xre={kernelName:lm,backendName:"cpu",kernelFunc:tM},Zre={kernelName:rg,backendName:"cpu",kernelFunc:function Yre(t){const{inputs:n,backend:e,attrs:r}=t,{a:s,b:o,bias:i,preluActivationWeights:a}=n,{transposeA:l,transposeB:u,activation:c,leakyreluAlpha:d}=r;let h,f,p;const m=[];h=tM({inputs:{a:s,b:o},attrs:{transposeA:l,transposeB:u},backend:e}),i&&(f=jh({inputs:{a:h,b:i},backend:e}),m.push(h),h=f),c&&(p=KD(e,h,c,a,d),m.push(h),h=p);for(const y of m)e.disposeIntermediateTensorInfo(y);return h}};function nM(t){const n=new Float32Array(t.length);for(let e=0;e<t.length;++e)n[e]=Math.abs(t[e]);return n}const Qre={kernelName:nm,backendName:"cpu",kernelFunc:t=>{const{x:n}=t.inputs,e=t.backend;Ee(n,"abs");let r=new Float32Array(te(n.shape));return r=nM(e.data.get(n.dataId).values),e.makeOutput(r,n.shape,"float32")}},Jre=Pt(dd,t=>Math.acos(t)),ese={kernelName:dd,backendName:"cpu",kernelFunc:Jre},tse=Pt(hd,t=>Math.acosh(t)),nse={kernelName:hd,backendName:"cpu",kernelFunc:tse},sse={kernelName:rm,backendName:"cpu",kernelFunc:function rse(t){const{inputs:n,backend:e}=t,r=n;Ee(n,"addN");const s=r.map(a=>e.data.get(a.dataId).values),o=yt(r[0].shape,r[0].dtype),i=o.values;for(let a=0;a<r.length;a++){const l=s[a];for(let u=0;u<i.length;u++)i[u]+=l[u]}return e.makeTensorInfo(o.shape,o.dtype,o.values)}};function YD(t,n,e,r,s){const o=n.length,i=te(n),a=Le(n),l=Le(s),u=or(e,te(s));for(let c=0;c<i;++c){const d=ud(c,o,a),h=new Array(d.length);for(let p=0;p<h.length;p++)h[p]=d[r[p]];u[Do(h,o,l)]=t[c]}return u}function Vs(t){const{inputs:n,attrs:e,backend:r}=t,{x:s}=n,{perm:o}=e;Ee(s,"transpose");const a=new Array(s.shape.length);for(let d=0;d<a.length;d++)a[d]=s.shape[o[d]];const u=YD(r.data.get(s.dataId).values,s.shape,s.dtype,o,a);return{dataId:r.write(u,a,s.dtype),shape:a,dtype:s.dtype}}const ose={kernelName:Jm,backendName:"cpu",kernelFunc:Vs},ase={kernelName:"All",backendName:"cpu",kernelFunc:function ise(t){const{inputs:n,backend:e,attrs:r}=t,{x:s}=n,{axis:o,keepDims:i}=r;Ee(s,"all");const a=ft(o,s.shape);let l=a;const u=xn(l,s.shape.length);let c=s;null!=u&&(c=Vs({inputs:{x:s},backend:e,attrs:{perm:u}}),l=En(l.length,s.shape.length)),lr("all",l,c.shape.length);const[d,h]=Qn(c.shape,l),f=te(h),p=gr(te(d),c.dtype),m=e.data.get(c.dataId).values;for(let y=0;y<p.length;++y){const b=y*f;let v=m[b];for(let x=0;x<f;++x){const w=m[b+x];v=v&&w}p[y]=v}null!=u&&e.disposeIntermediateTensorInfo(c);const g=e.makeTensorInfo(d,c.dtype,p);if(i){const b=sn({inputs:{x:g},backend:e,attrs:{shape:vn(d,a)}});return e.disposeIntermediateTensorInfo(g),b}return g}},use={kernelName:"Any",backendName:"cpu",kernelFunc:function lse(t){const{inputs:n,backend:e,attrs:r}=t,{x:s}=n,{axis:o,keepDims:i}=r;Ee(s,"any");const a=ft(o,s.shape);let l=a;const u=xn(l,s.shape.length);let c=s;null!=u&&(c=Vs({inputs:{x:s},backend:e,attrs:{perm:u}}),l=En(l.length,s.shape.length)),lr("any",l,c.shape.length);const[d,h]=Qn(c.shape,l),f=te(h),p=gr(te(d),c.dtype),m=e.data.get(c.dataId).values;for(let y=0;y<p.length;++y){const b=y*f;let v=m[b];for(let x=0;x<f;++x){const w=m[b+x];v=v||w}p[y]=v}null!=u&&e.disposeIntermediateTensorInfo(c);const g=e.makeTensorInfo(d,c.dtype,p);if(i){const b=sn({inputs:{x:g},backend:e,attrs:{shape:vn(d,a)}});return e.disposeIntermediateTensorInfo(g),b}return g}},dse={kernelName:sm,backendName:"cpu",kernelFunc:function cse(t){const{inputs:n,backend:e,attrs:r}=t,{x:s}=n,{axis:o}=r;Ee(s,"argMax");let i=ft(o,s.shape);const a=xn(i,s.shape.length);let l=s;const u=[];null!=a&&(l=Vs({inputs:{x:s},backend:e,attrs:{perm:a}}),u.push(l),i=En(i.length,l.shape.length)),i=[i[0]],lr("argMax",i,l.shape.length);const[c,d]=Qn(l.shape,i),f=gr(te(c),"int32"),p=te(d),m=e.data.get(l.dataId).values;for(let g=0;g<f.length;++g){const y=g*p;let b=m[y],v=0;for(let x=0;x<p;++x){const w=m[y+x];w>b&&(b=w,v=x)}f[g]=v}return u.forEach(g=>e.disposeIntermediateTensorInfo(g)),e.makeTensorInfo(c,"int32",f)}},fse={kernelName:om,backendName:"cpu",kernelFunc:function hse(t){const{inputs:n,backend:e,attrs:r}=t,{x:s}=n,{axis:o}=r;Ee(s,"argMin");let i=ft(o,s.shape);const a=xn(i,s.shape.length);let l=s;const u=[];null!=a&&(l=Vs({inputs:{x:s},backend:e,attrs:{perm:a}}),u.push(l),i=En(i.length,l.shape.length)),i=[i[0]],lr("argMin",i,l.shape.length);const[c,d]=Qn(l.shape,i),f=gr(te(c),"int32"),p=te(d),m=e.data.get(l.dataId).values;for(let g=0;g<f.length;++g){const y=g*p;let b=m[y],v=0;for(let x=0;x<p;++x){const w=m[y+x];w<b&&(b=w,v=x)}f[g]=v}return u.forEach(g=>e.disposeIntermediateTensorInfo(g)),e.makeTensorInfo(c,"int32",f)}},pse=Pt(fd,t=>Math.asin(t)),mse={kernelName:fd,backendName:"cpu",kernelFunc:pse},gse=Pt(pd,t=>Math.asinh(t)),yse={kernelName:pd,backendName:"cpu",kernelFunc:gse},bse=Pt(md,t=>Math.atan(t)),vse={kernelName:md,backendName:"cpu",kernelFunc:bse},xse=Tn((t,n)=>Math.atan2(t,n)),wse=er(yd,xse),Cse={kernelName:yd,backendName:"cpu",kernelFunc:wse},Ise=Pt(gd,t=>Math.atanh(t)),Dse={kernelName:gd,backendName:"cpu",kernelFunc:Ise};function ZD(t,n,e,r,s,o){const i=s.strideHeight,a=s.strideWidth,l=s.dilationHeight,u=s.dilationWidth,c=s.effectiveFilterHeight,d=s.effectiveFilterWidth,h=s.padInfo.top,f=s.padInfo.left,p="max"===o?Number.NEGATIVE_INFINITY:Number.POSITIVE_INFINITY,m=yt(s.outShape,e),g=m.values,y=s.outShape[1]*s.outShape[2]*s.outShape[3],b=s.outShape[2]*s.outShape[3],v=s.outShape[3];for(let x=0;x<s.batchSize;++x){const w=x*y,_=x*r[0];for(let D=0;D<s.inChannels;++D)for(let A=0;A<s.outHeight;++A){const R=A*i-h,O=Math.max(0,R),G=Math.min(s.inHeight,c+R),K=w+A*b;for(let j=0;j<s.outWidth;++j){const Q=j*a-f,q=Math.max(0,Q),Y=Math.min(s.inWidth,d+Q);let re=p,ee=0,se=0;for(let de=O;de<G;de+=l){const ge=_+de*r[1];for(let pe=q;pe<Y;pe+=u){const ve=t[ge+pe*r[2]+D];"max"===o&&ve>re?re=ve:"avg"===o&&(ee+=ve,se++)}if(isNaN(re))break}g[K+j*v+D]="avg"===o?ee/se:re}}}return m}function rM(t,n,e,r,s=!1,o=!1){const i=yt(r.outShape,"int32"),a=r.strideHeight,l=r.strideWidth,u=r.dilationHeight,c=r.dilationWidth,d=r.effectiveFilterHeight,h=r.effectiveFilterWidth,f=r.padInfo.top,p=r.padInfo.left,m=yt(n,e,t);for(let g=0;g<r.batchSize;++g)for(let y=0;y<r.inChannels;++y)for(let b=0;b<r.outHeight;++b){const v=b*a-f;let x=v;for(;x<0;)x+=u;const w=Math.min(r.inHeight,d+v);for(let _=0;_<r.outWidth;++_){const D=_*l-p;let A=D;for(;A<0;)A+=c;const R=Math.min(r.inWidth,h+D);let O=Number.NEGATIVE_INFINITY,G=-1;for(let K=x;K<w;K+=u){const j=K-v;for(let Q=A;Q<R;Q+=c){const q=Q-D,Y=m.get(g,K,Q,y);Y>O&&(O=Y,G=s?o?((g*r.inHeight+K)*r.inWidth+Q)*r.inChannels+y:(K*r.inWidth+Q)*r.inChannels+y:j*h+q)}}i.set(G,g,b,_,y)}}return i}function sM(t,n,e,r,s,o){const i=s.strideDepth,a=s.strideHeight,l=s.strideWidth,u=s.dilationDepth,c=s.dilationHeight,d=s.dilationWidth,h=s.effectiveFilterDepth,f=s.effectiveFilterHeight,p=s.effectiveFilterWidth,m=s.padInfo.front,g=s.padInfo.top,y=s.padInfo.left,b="max"===o?Number.NEGATIVE_INFINITY:Number.POSITIVE_INFINITY,v=yt(s.outShape,e),x=v.values,w=s.outShape[1]*s.outShape[2]*s.outShape[3]*s.outShape[4],_=s.outShape[2]*s.outShape[3]*s.outShape[4],D=s.outShape[3]*s.outShape[4],A=s.outShape[4];for(let R=0;R<s.batchSize;++R){const O=R*w,G=R*r[0];for(let K=0;K<s.inChannels;++K)for(let j=0;j<s.outDepth;++j){const Q=j*i-m;let q=Q;for(;q<0;)q+=u;const Y=Math.min(s.inDepth,h+Q),re=O+j*_;for(let ee=0;ee<s.outHeight;++ee){const se=ee*a-g;let ue=se;for(;ue<0;)ue+=c;const de=Math.min(s.inHeight,f+se),ge=re+ee*D;for(let pe=0;pe<s.outWidth;++pe){const ye=pe*l-y;let ve=ye;for(;ve<0;)ve+=d;const De=Math.min(s.inWidth,p+ye),Te=ge+pe*A;let Pe=b,Be=0,tt=0;for(let Lt=q;Lt<Y;Lt+=u){const cn=G+Lt*r[1];for(let en=ue;en<de;en+=c){const Kt=cn+en*r[2];for(let Xt=ve;Xt<De;Xt+=d){const Cn=t[Kt+Xt*r[3]+K];if("max"===o&&Cn>Pe?Pe=Cn:"avg"===o&&(Be+=Cn,tt++),isNaN(Pe))break}if(isNaN(Pe))break}if(isNaN(Pe))break}x[Te+K]="avg"===o?Be/tt:Pe}}}}return v}const Ese={kernelName:im,backendName:"cpu",kernelFunc:function Sse(t){const{inputs:n,backend:e,attrs:r}=t,{x:s}=n;Ee(s,"avgPool");const{filterSize:o,strides:i,pad:a,dimRoundingMode:l}=r;S(ar(i,1),()=>`Error in avgPool: Either strides or dilations must be 1. Got strides ${i} and dilations '1'`);const c=ks(s.shape,o,i,1,a,l);let d;if(1===c.filterWidth&&1===c.filterHeight&&Mt(c.inShape,c.outShape))d=Fo({inputs:{x:s},backend:e});else{const h=e.data.get(s.dataId).values,f=Le(s.shape),p=ZD(h,0,s.dtype,f,c,"avg");d=e.makeTensorInfo(c.outShape,s.dtype,p.values)}return d}},Tse={kernelName:am,backendName:"cpu",kernelFunc:function Nse(t){const{inputs:n,backend:e,attrs:r}=t,{x:s}=n,{filterSize:o,strides:i,pad:a,dimRoundingMode:l,dataFormat:u}=r;Ee(s,"avgPool3d");const c=ri(s.shape,o,i,1,a,l,u),h=sM(e.data.get(s.dataId).values,0,s.dtype,Le(s.shape),c,"avg");return e.makeTensorInfo(h.shape,"float32",h.values)}},Ase={kernelName:tw,backendName:"cpu",kernelFunc:function kse(t){const{inputs:n,backend:e,attrs:r}=t,{dy:s,input:o}=n,{filterSize:i,strides:a,pad:l,dimRoundingMode:u}=r;Ee([s,o],"avgPool3DGrad");const c=ri(o.shape,i,a,1,l,u),d=c.strideDepth,h=c.strideHeight,f=c.strideWidth,p=c.filterDepth,m=c.filterHeight,g=c.filterWidth,y=c.dilationDepth,b=c.dilationHeight,v=c.dilationWidth,x=c.effectiveFilterDepth,w=c.effectiveFilterHeight,_=c.effectiveFilterWidth,D=x-1-c.padInfo.front,A=_-1-c.padInfo.left,R=w-1-c.padInfo.top,O=yt(o.shape,"float32"),G=1/(p*m*g),K=e.bufferSync(s);for(let j=0;j<c.batchSize;++j)for(let Q=0;Q<c.inChannels;++Q)for(let q=0;q<c.inDepth;++q)for(let Y=0;Y<c.inHeight;++Y)for(let re=0;re<c.inWidth;++re){const ee=q-D,se=Y-R,ue=re-A;let de=0;for(let ge=0;ge<x;ge+=y){const pe=(ee+ge)/d;if(!(pe<0||pe>=c.outDepth||Math.floor(pe)!==pe))for(let ye=0;ye<w;ye+=b){const ve=(se+ye)/h;if(!(ve<0||ve>=c.outHeight||Math.floor(ve)!==ve))for(let De=0;De<_;De+=v){const Te=(ue+De)/f;Te<0||Te>=c.outWidth||Math.floor(Te)!==Te||(de+=K.get(j,pe,ve,Te,Q))}}}O.set(de*G,j,q,Y,re,Q)}return e.makeTensorInfo(O.shape,O.dtype,O.values)}},$se={kernelName:ew,backendName:"cpu",kernelFunc:function Rse(t){const{inputs:n,backend:e,attrs:r}=t,{dy:s,input:o}=n,i=o;Ee([s,o],"avgPoolGrad");const{filterSize:a,strides:l,pad:u}=r,c=ks(i.shape,a,l,1,u),d=c.strideHeight,h=c.strideWidth,f=c.filterHeight,p=c.filterWidth,m=c.dilationHeight,g=c.dilationWidth,y=c.effectiveFilterHeight,b=c.effectiveFilterWidth,v=b-1-c.padInfo.left,x=y-1-c.padInfo.top,w=yt(i.shape,"float32"),_=1/(f*p),D=e.data.get(s.dataId).values,A=yt(s.shape,"float32",D);for(let R=0;R<c.batchSize;++R)for(let O=0;O<c.inChannels;++O)for(let G=0;G<c.inHeight;++G)for(let K=0;K<c.inWidth;++K){const j=G-x,Q=K-v;let q=0;for(let Y=0;Y<y;Y+=m){const re=(j+Y)/d;if(!(re<0||re>=c.outHeight||Math.floor(re)!==re))for(let ee=0;ee<b;ee+=g){const se=(Q+ee)/h;se<0||se>=c.outWidth||Math.floor(se)!==se||(q+=A.get(R,re,se,O))}}w.set(q*_,R,G,K,O)}return e.makeTensorInfo(w.shape,w.dtype,w.values)}},Ose={kernelName:xm,backendName:"cpu",kernelFunc:function Fse(t){const{inputs:n,backend:e,attrs:r}=t,{x:s,scale:o,offset:i,mean:a,variance:l}=n;S(a.shape.length===l.shape.length,()=>"Batch normalization gradient requires mean and variance to have equal ranks."),S(null==i||a.shape.length===i.shape.length,()=>"Batch normalization gradient requires mean and offset to have equal ranks."),S(null==o||a.shape.length===o.shape.length,()=>"Batch normalization gradient requires mean and scale to have equal ranks."),Ee([s,a,l,o,i],"batchNorm");let{varianceEpsilon:u}=r;null==u&&(u=.001);const c=e.data.get(s.dataId).values,d=e.data.get(a.dataId).values,h=e.data.get(l.dataId).values,f=o?e.data.get(o.dataId).values:new Float32Array([1]),p=i?e.data.get(i.dataId).values:new Float32Array([0]),m=new Float32Array(c.length),g=p.length,y=f.length,b=h.length,v=d.length;let x=0,w=0,_=0,D=0;for(let A=0;A<c.length;++A)m[A]=p[x++]+(c[A]-d[w++])*f[_++]/Math.sqrt(h[D++]+u),x>=g&&(x=0),w>=v&&(w=0),_>=y&&(_=0),D>=b&&(D=0);return e.makeTensorInfo(s.shape,s.dtype,m)}};function oM(t,n,e,r,s){const o=yC(r,n,e),i=te(e),a=Le(r);if(o){const d=bC(n,a);return"string"===s?t.slice(d,d+i):t.subarray(d,d+i)}const u=yt(r,s,"string"===s?II(t):t),c=yt(e,s);for(let d=0;d<c.size;++d){const h=c.indexToLoc(d),f=h.map((p,m)=>p+n[m]);c.set(u.get(...f),...h)}return"string"===s?D2(c.values):c.values}function Ja(t){const{inputs:n,backend:e,attrs:r}=t,{x:s}=n,{begin:o,size:i}=r;Ee(s,"slice");const[a,l]=yg(s,o,i);gC(s,a,l);const c=oM(e.data.get(s.dataId).values,a,l,s.shape,s.dtype);return e.makeTensorInfo(l,s.dtype,c)}const Mse={kernelName:Km,backendName:"cpu",kernelFunc:Ja},Lse={kernelName:um,backendName:"cpu",kernelFunc:function Pse(t){const{inputs:n,backend:e,attrs:r}=t,{x:s}=n,{blockShape:o,crops:i}=r;Ee([s],"batchToSpaceND");const a=o.reduce((y,b)=>y*b),l=Sh(s.shape,o,a),u=Eh(l.length,o.length),c=Nh(s.shape,o,a),d=dI(i,o.length),h=hI(c,i,o.length),f=sn({inputs:{x:s},backend:e,attrs:{shape:l}}),p=Vs({inputs:{x:f},backend:e,attrs:{perm:u}}),m=sn({inputs:{x:p},backend:e,attrs:{shape:c}}),g=Ja({inputs:{x:m},backend:e,attrs:{begin:d,size:h}});return e.disposeIntermediateTensorInfo(f),e.disposeIntermediateTensorInfo(p),e.disposeIntermediateTensorInfo(m),g}};function QD(t,n,e,r,s){const o=te(r),i=gr(s,e);for(let a=0;a<t.length;a++){const l=t[a];if(l<0)throw new Error("Input x must be non-negative!");l>=s||(i[l]+=o>0?n[a]:1)}return i}function iM(t,n,e,r=!1){const s=t.shape[0],o=t.shape[1],i=yt([s,e],n.dtype);for(let a=0;a<s;a++)for(let l=0;l<o;l++){const u=t.get(a,l);if(u<0)throw new Error("Input x must be non-negative!");u>=e||i.set(r?1:n.size>0?i.get(a,u)+n.get(a,l):i.get(a,u)+1,a,u)}return i}const zse={kernelName:nw,backendName:"cpu",kernelFunc:function Bse(t){const{inputs:n,backend:e,attrs:r}=t,{x:s,weights:o}=n,{size:i}=r,u=QD(e.data.get(s.dataId).values,e.data.get(o.dataId).values,o.dtype,o.shape,i);return e.makeTensorInfo([i],o.dtype,u)}};function Ru(t){return(n,e,r)=>{const s=or(e,n.length);for(let o=0;o<n.length;++o)s[o]=t(n[o],r);return s}}const aM=Ru(t=>Math.ceil(t)),Vse=Au(vd,aM),Use={kernelName:vd,backendName:"cpu",kernelFunc:Vse},Wse=Pt(xd,(t,n)=>t>n.clipValueMax?n.clipValueMax:t<n.clipValueMin?n.clipValueMin:t),Hse={kernelName:xd,backendName:"cpu",kernelFunc:Wse},Gse={kernelName:cm,backendName:"cpu",kernelFunc:t=>{const{x:n}=t.inputs,e=t.backend,r=new Float32Array(te(n.shape)),s=e.data.get(n.dataId),i=s.complexTensorInfos.imag,a=e.data.get(s.complexTensorInfos.real.dataId).values,l=e.data.get(i.dataId).values;for(let u=0;u<a.length;u++)r[u]=Math.hypot(a[u],l[u]);return e.makeOutput(r,n.shape,"float32")}};function lM(t,n,e,r){const s=ru(e,te(n));if(r&&"string"!==e){let o=0;t.forEach(i=>{const a=te(i.shape);s.set(i.vals,o),o+=a})}else{let o=0;t.forEach(i=>{const a="string"===e?II(i.vals):i.vals;let l=0;for(let u=0;u<i.shape[0];++u){const c=u*n[1]+o;for(let d=0;d<i.shape[1];++d)s[c+d]=a[l++]}o+=i.shape[1]})}return s}function $u(t){const{inputs:n,backend:e}=t,{input:r}=n,s=e.data.get(r.dataId).complexTensorInfos.imag,o=e.data.get(s.dataId).values;return e.makeTensorInfo(s.shape,s.dtype,o)}const jse={kernelName:xw,backendName:"cpu",kernelFunc:$u};function Fu(t){const{inputs:n,backend:e,attrs:r}=t,{axis:s}=r,o=ft(s,n[0].shape)[0];let i=ci(n.map(m=>m.shape),o);if(0===te(i))return e.makeTensorInfo(i,n[0].dtype,[]);const a=n.filter(m=>te(m.shape)>0);if(1===a.length)return Fo({inputs:{x:a[0]},backend:e});if(lI(a.map(m=>m.shape),o),"complex64"===a[0].dtype){const m=a.map(x=>Qa({inputs:{input:x},backend:e})),g=a.map(x=>$u({inputs:{input:x},backend:e})),y=Fu({inputs:m,backend:e,attrs:{axis:o}}),b=Fu({inputs:g,backend:e,attrs:{axis:o}}),v=Zr({inputs:{real:y,imag:b},backend:e});return m.forEach(x=>e.disposeIntermediateTensorInfo(x)),g.forEach(x=>e.disposeIntermediateTensorInfo(x)),e.disposeIntermediateTensorInfo(y),e.disposeIntermediateTensorInfo(b),v}const u=a.map(m=>{const y=[-1,te(m.shape.slice(o))];return sn({inputs:{x:m},backend:e,attrs:{shape:y}})}),c=u.map(m=>({vals:e.data.get(m.dataId).values,shape:m.shape}));i=ci(u.map(m=>m.shape),1);const h=lM(c,i,n[0].dtype,1===u[0].shape[0]),f=ci(a.map(m=>m.shape),o),p=e.makeTensorInfo(f,n[0].dtype,h);return u.forEach(m=>e.disposeIntermediateTensorInfo(m)),p}const qse={kernelName:dm,backendName:"cpu",kernelFunc:Fu};function uM(t){const{inputs:n,backend:e,attrs:r}=t,{x:s,filter:o}=n,{strides:i,pad:a,dataFormat:l,dilations:u,dimRoundingMode:c}=r;Ee([s,o],"conv2d");const d=si(l),h=Zn(s.shape,o.shape,i,u,a,c,!1,d),f=h.filterHeight,p=h.filterWidth,m=h.dilationHeight,g=h.dilationWidth,y=h.padInfo.left,b=h.padInfo.top,v="channelsLast"===h.dataFormat,x=new Xn(h.outShape,s.dtype),w=Le(s.shape),_=Le(o.shape),D=w[0],A=v?w[1]:w[2],R=v?w[2]:1,O=v?1:w[1],G=x.strides[0],K=v?x.strides[1]:x.strides[2],j=v?x.strides[2]:1,Q=v?1:x.strides[1],q=e.data.get(s.dataId).values,Y=e.data.get(o.dataId).values,re=x.values;for(let ee=0;ee<h.batchSize;++ee){const se=ee*D,ue=ee*G;for(let de=0;de<h.outHeight;++de){const ge=ue+de*K,pe=de*h.strideHeight-b;for(let ye=0;ye<f;++ye){const ve=pe+ye*m;if(ve<0||ve>=h.inHeight)continue;const De=ye*_[0],Te=se+ve*A;for(let Pe=0;Pe<h.outWidth;++Pe){const Be=ge+Pe*j,tt=Pe*h.strideWidth-y;for(let vt=0;vt<p;++vt){const Lt=tt+vt*g;if(Lt<0||Lt>=h.inWidth)continue;const en=Te+Lt*R;let Kt=De+vt*_[1];for(let Xt=0;Xt<h.inChannels;++Xt){const tn=q[en+Xt*O];for(let Cn=0;Cn<h.outChannels;++Cn)re[Be+Cn*Q]+=tn*Y[Kt+Cn];Kt+=h.outChannels}}}}}}return e.makeTensorInfo(x.shape,x.dtype,re)}const Kse={kernelName:hm,backendName:"cpu",kernelFunc:uM},Yse={kernelName:sw,backendName:"cpu",kernelFunc:function Xse(t){const{inputs:n,backend:e,attrs:r}=t,{x:s,dy:o}=n,{strides:i,pad:a,dataFormat:l,dimRoundingMode:u,filterShape:c}=r;Ee([s,o],"conv2dBackpropFilter");const d=si(l),h=Zn(s.shape,c,i,1,a,u,!1,d),{strideHeight:f,strideWidth:p,filterHeight:m,filterWidth:g}=h,y="channelsLast"===h.dataFormat,b=new Xn(h.filterShape,"float32"),v=h.padInfo.left,x=h.padInfo.top,w=e.data.get(s.dataId).values,_=e.data.get(o.dataId).values,D=new Xn(s.shape,s.dtype,w),A=new Xn(o.shape,o.dtype,_);for(let R=0;R<m;++R){const O=Math.max(0,Math.ceil((x-R)/f)),G=Math.min(h.outHeight,(h.inHeight+x-R)/f);for(let K=0;K<g;++K){const j=Math.max(0,Math.ceil((v-K)/p)),Q=Math.min(h.outWidth,(h.inWidth+v-K)/p);for(let q=0;q<h.inChannels;++q)for(let Y=0;Y<h.outChannels;++Y){let re=0;for(let ee=0;ee<h.batchSize;++ee)for(let se=O;se<G;++se){const ue=R+se*f-x;for(let de=j;de<Q;++de){const ge=K+de*p-v;re+=y?D.get(ee,ue,ge,q)*A.get(ee,se,de,Y):D.get(ee,q,ue,ge)*A.get(ee,Y,se,de)}}b.set(re,R,K,q,Y)}}}return e.makeTensorInfo(b.shape,b.dtype,b.values)}},Qse={kernelName:fm,backendName:"cpu",kernelFunc:function Zse(t){const{inputs:n,backend:e,attrs:r}=t,{dy:s,filter:o}=n,{inputShape:i,strides:a,pad:l,dataFormat:u,dimRoundingMode:c}=r;Ee([s,o],"conv2dBackpropInput");const d=Le(o.shape),h=Le(s.shape);let f=si(u);const p=Zn(i,o.shape,a,1,l,c,!1,f),m=new Xn(p.inShape,"float32"),g=m.values,y=e.data.get(s.dataId).values,b=e.data.get(o.dataId).values,[v,x,w]=d,{batchSize:_,filterHeight:D,filterWidth:A,inChannels:R,inHeight:O,inWidth:G,outChannels:K,outHeight:j,outWidth:Q,strideHeight:q,strideWidth:Y}=p;f=p.dataFormat;const re=D-1-p.padInfo.top,ee=A-1-p.padInfo.left,se="channelsLast"===f,ue=m.strides[0],de=se?m.strides[1]:m.strides[2],ge=se?m.strides[2]:1,pe=se?1:m.strides[1],ye=h[0],ve=se?h[1]:h[2],De=se?h[2]:1,Te=se?1:h[1];for(let Pe=0;Pe<_;++Pe)for(let Be=0;Be<R;++Be)for(let tt=0;tt<O;++tt){const vt=tt-re,Lt=Math.max(0,Math.ceil(vt/q)),cn=Math.min(j,(D+vt)/q);for(let en=0;en<G;++en){const Kt=en-ee,Xt=Math.max(0,Math.ceil(Kt/Y)),tn=Math.min(Q,(A+Kt)/Y);let Cn=0;for(let dr=Lt;dr<cn;++dr){const Mo=dr*q-vt;for(let vs=Xt;vs<tn;++vs){const ho=ye*Pe+ve*dr+De*vs,bi=v*(D-1-Mo)+x*(A-1-(vs*Y-Kt))+w*Be;for(let ea=0;ea<K;++ea)Cn+=y[ho+Te*ea]*b[bi+ea]}}g[ue*Pe+de*tt+ge*en+pe*Be]=Cn}}return e.makeTensorInfo(m.shape,m.dtype,m.values)}},eoe={kernelName:pm,backendName:"cpu",kernelFunc:function Jse(t){const{inputs:n,backend:e,attrs:r}=t,{x:s,filter:o}=n,{strides:i,pad:a,dilations:l}=r;Ee([s,o],"conv3d");const u=Bi(s.shape,o.shape,i,l,a),{filterDepth:c,filterHeight:d,filterWidth:h,dilationDepth:f,dilationHeight:p,dilationWidth:m,padInfo:g}=u,y=g.front,b=g.left,v=g.top,x=new Xn(u.outShape,s.dtype),w=e.data.get(s.dataId).values,_=e.data.get(o.dataId).values,D=x.values,A=Le(s.shape),R=Le(o.shape);for(let O=0;O<u.batchSize;++O){const G=O*A[0],K=O*x.strides[0];for(let j=0;j<u.outDepth;++j){const Q=K+j*x.strides[1],q=j*u.strideDepth-y;for(let Y=0;Y<c;++Y){const re=q+Y*f;if(re<0||re>=u.inDepth)continue;const ee=Y*R[0],se=G+re*A[1];for(let ue=0;ue<u.outHeight;++ue){const de=Q+ue*x.strides[2],ge=ue*u.strideHeight-v;for(let pe=0;pe<d;++pe){const ye=ge+pe*p;if(ye<0||ye>=u.inHeight)continue;const ve=ee+pe*R[1],De=se+ye*A[2];for(let Te=0;Te<u.outWidth;++Te){const Pe=de+Te*u.outChannels,Be=Te*u.strideWidth-b;for(let tt=0;tt<h;++tt){const vt=Be+tt*m;if(vt<0||vt>=u.inWidth)continue;const cn=De+vt*u.inChannels;let en=ve+tt*R[2];for(let Kt=0;Kt<u.inChannels;++Kt){const Xt=w[cn+Kt];for(let tn=0;tn<u.outChannels;++tn)D[Pe+tn]+=Xt*_[en+tn];en+=u.outChannels}}}}}}}}return e.makeTensorInfo(x.shape,x.dtype,x.values)}},noe={kernelName:ow,backendName:"cpu",kernelFunc:function toe(t){const{inputs:n,backend:e,attrs:r}=t,{x:s,dy:o}=n,{strides:i,pad:a,filterShape:l}=r;Ee([s,o],"conv3dBackpropFilterV2");const u=Le(s.shape),c=Le(o.shape),d=Bi(s.shape,l,i,1,a),h=d.strideDepth,f=d.strideHeight,p=d.strideWidth,m=d.filterDepth,g=d.filterHeight,y=d.filterWidth,b=new Xn(d.filterShape,"float32"),v=b.values,[x,w,_,D]=b.strides,A=e.data.get(o.dataId).values,[R,O,G,K]=c,j=e.data.get(s.dataId).values,[Q,q,Y,re]=u,ee=d.padInfo.front,se=d.padInfo.left,ue=d.padInfo.top;for(let de=0;de<m;++de){const ge=Math.max(0,Math.ceil((ee-de)/h)),pe=Math.min(d.outDepth,(d.inDepth+ee-de)/h),ye=de*x;for(let ve=0;ve<g;++ve){const De=Math.max(0,Math.ceil((ue-ve)/f)),Te=Math.min(d.outHeight,(d.inHeight+ue-ve)/f),Pe=ve*w+ye;for(let Be=0;Be<y;++Be){const tt=Math.max(0,Math.ceil((se-Be)/p)),vt=Math.min(d.outWidth,(d.inWidth+se-Be)/p),Lt=Be*_+Pe;for(let cn=0;cn<d.inChannels;++cn){const en=cn*D+Lt;for(let Kt=0;Kt<d.outChannels;++Kt){let Xt=0;for(let tn=0;tn<d.batchSize;++tn){const Cn=tn*Q,yi=tn*R;for(let dr=ge;dr<pe;++dr){const vs=(de+dr*h-ee)*q+Cn,rl=dr*O+yi;for(let ho=De;ho<Te;++ho){const ea=(ve+ho*f-ue)*Y+vs,ta=ho*G+rl;for(let na=tt;na<vt;++na)Xt+=j[(Be+na*p-se)*re+ea+cn]*A[na*K+ta+Kt]}}}v[en+Kt]=Xt}}}}}return e.makeTensorInfo(b.shape,b.dtype,b.values)}},soe={kernelName:iw,backendName:"cpu",kernelFunc:function roe(t){const{inputs:n,backend:e,attrs:r}=t,{dy:s,filter:o}=n,{pad:i,strides:a,inputShape:l}=r;Ee([s],"conv3dBackpropInputV2");const u=Le(s.shape),c=Le(o.shape),d=Bi(l,o.shape,a,1,i),h=new Xn(d.inShape,"float32"),f=h.values,[p,m,g,y]=h.strides,b=e.data.get(s.dataId).values,[v,x,w,_]=u,D=e.data.get(o.dataId).values,[A,R,O,G]=c,{batchSize:K,filterDepth:j,filterHeight:Q,filterWidth:q,inChannels:Y,inDepth:re,inHeight:ee,inWidth:se,outChannels:ue,outDepth:de,outHeight:ge,outWidth:pe,strideDepth:ye,strideHeight:ve,strideWidth:De}=d,Te=j-1-d.padInfo.front,Pe=Q-1-d.padInfo.top,Be=q-1-d.padInfo.left;for(let tt=0;tt<K;++tt)for(let vt=0;vt<Y;++vt)for(let Lt=0;Lt<re;++Lt){const cn=Lt-Te,en=Math.max(0,Math.ceil(cn/ye)),Kt=Math.min(de,(j+cn)/ye);for(let Xt=0;Xt<ee;++Xt){const tn=Xt-Pe,Cn=Math.max(0,Math.ceil(tn/ve)),yi=Math.min(ge,(Q+tn)/ve);for(let dr=0;dr<se;++dr){const Mo=dr-Be,vs=Math.max(0,Math.ceil(Mo/De)),rl=Math.min(pe,(q+Mo)/De);let ho=0;for(let bi=en;bi<Kt;++bi){const ea=bi*ye-cn;for(let ta=Cn;ta<yi;++ta){const na=ta*ve-tn;for(let rf=vs;rf<rl;++rf){const I_=v*tt+x*bi+w*ta+_*rf,Rve=A*(j-1-ea)+R*(Q-1-na)+O*(q-1-(rf*De-Mo))+G*vt;for(let Wy=0;Wy<ue;++Wy)ho+=b[I_+Wy]*D[Rve+Wy]}}}f[p*tt+m*Lt+g*Xt+y*dr+vt]=ho}}}return e.makeTensorInfo(h.shape,h.dtype,h.values)}},ooe=Pt(wd,t=>Math.cos(t)),ioe={kernelName:wd,backendName:"cpu",kernelFunc:ooe},aoe=Pt(Cd,t=>Math.cosh(t)),loe={kernelName:Cd,backendName:"cpu",kernelFunc:aoe},coe={kernelName:aw,backendName:"cpu",kernelFunc:function uoe(t){const{inputs:n,backend:e,attrs:r}=t,{image:s,boxes:o,boxInd:i}=n,{cropSize:a,method:l,extrapolationValue:u}=r,[c,d,h,f]=s.shape,p=o.shape[0],[m,g]=a,y=yt([p,m,g,f],"float32"),b=e.data.get(o.dataId).values,v=e.data.get(i.dataId).values,x=e.data.get(s.dataId).values,w=Le(s.shape),_=Le(y.shape);for(let D=0;D<p;D++){const A=4*D,R=b[A],O=b[A+1],G=b[A+2],K=b[A+3],j=v[D];if(j>=c)continue;const Q=m>1?(G-R)*(d-1)/(m-1):0,q=g>1?(K-O)*(h-1)/(g-1):0;for(let Y=0;Y<m;Y++){const re=m>1?R*(d-1)+Y*Q:.5*(R+G)*(d-1);if(re<0||re>d-1)for(let ee=0;ee<g;ee++)for(let se=0;se<f;se++)y.values[se+ee*_[2]+Y*_[1]+D*_[0]]=u;else if("bilinear"===l){const ee=Math.floor(re),se=Math.ceil(re),ue=re-ee;for(let de=0;de<g;de++){const ge=g>1?O*(h-1)+de*q:.5*(O+K)*(h-1);if(ge<0||ge>h-1){for(let De=0;De<f;De++)y.values[De+de*_[2]+Y*_[1]+D*_[0]]=u;continue}const pe=Math.floor(ge),ye=Math.ceil(ge),ve=ge-pe;for(let De=0;De<f;De++){let Te=De+pe*w[2]+ee*w[1]+j*w[0];const Pe=x[Te];Te=De+ye*w[2]+ee*w[1]+j*w[0];const Be=x[Te];Te=De+pe*w[2]+se*w[1]+j*w[0];const tt=x[Te];Te=De+ye*w[2]+se*w[1]+j*w[0];const vt=x[Te],Lt=Pe+(Be-Pe)*ve;Te=De+de*_[2]+Y*_[1]+D*_[0],y.values[Te]=Lt+(tt+(vt-tt)*ve-Lt)*ue}}}else for(let ee=0;ee<g;++ee){const se=g>1?O*(h-1)+ee*q:.5*(O+K)*(h-1);if(se<0||se>h-1){for(let ge=0;ge<f;ge++)y.values[ge+ee*_[2]+Y*_[1]+D*_[0]]=u;continue}const ue=Math.round(se),de=Math.round(re);for(let ge=0;ge<f;ge++)y.values[ge+ee*_[2]+Y*_[1]+D*_[0]]=x[ge+ue*w[2]+de*w[1]+j*w[0]]}}}return e.makeTensorInfo(y.shape,y.dtype,y.values)}},hoe={kernelName:mm,backendName:"cpu",kernelFunc:function doe(t){const{inputs:n,backend:e,attrs:r}=t,{x:s}=n,{axis:o,exclusive:i,reverse:a}=r;Ee(s,"cumsum");const l=xn([o],s.shape.length);let u=s;null!=l&&(u=Vs({inputs:{x:s},backend:e,attrs:{perm:l}}));const c=En(1,s.shape.length)[0];if(c!==u.shape.length-1)throw new Error(`backend.cumsum in CPU expects an inner-most axis=${u.shape.length-1} but got axis=${c}`);const d=ds(u.dtype,"int32"),h=gr(te(u.shape),d),f=e.data.get(u.dataId).values,p=u.shape[u.shape.length-1],m=a?(y,b)=>y+p-b-1:(y,b)=>y+b;for(let y=0;y<f.length;y+=p)for(let b=0;b<p;b++){const v=m(y,b);if(0===b)h[v]=i?0:f[v];else{const x=m(y,b-1);h[v]=i?f[x]+h[x]:f[v]+h[x]}}const g=e.makeTensorInfo(u.shape,d,h);if(null!=l){const b=Vs({inputs:{x:g},backend:e,attrs:{perm:gu(l)}});return e.disposeIntermediateTensorInfo(g),e.disposeIntermediateTensorInfo(u),b}return g}},poe={kernelName:lw,backendName:"cpu",kernelFunc:function foe(t){const{inputs:n,backend:e,attrs:r}=t,{x:s,weights:o}=n,{size:i,binaryOutput:a}=r;if(1===s.shape.length){const c=QD(e.data.get(s.dataId).values,e.data.get(o.dataId).values,o.dtype,o.shape,i);return e.makeTensorInfo([i],o.dtype,c)}if(2===s.shape.length){const c=iM(e.bufferSync(s),e.bufferSync(o),i,a);return e.makeTensorInfo(c.shape,o.dtype,c.values)}throw new Error(`Error in denseBincount: input must be at most rank 2, but got rank${s.shape.length}.`)}},goe={kernelName:uw,backendName:"cpu",kernelFunc:function moe(t){const{inputs:n,backend:e,attrs:r}=t,{x:s}=n,{blockSize:o,dataFormat:i}=r;S("NHWC"===i,()=>`Only NHWC dataFormat supported on CPU for depthToSpace. Got ${i}`),S(o>1,()=>`blockSize should be > 1 for depthToSpace, but was: ${o}`);const a=s.shape[0],l=s.shape[1],u=s.shape[2],c=s.shape[3],d=l*o,h=u*o,f=c/(o*o),p=e.data.get(s.dataId).values,m=new Float32Array(a*d*h*f);let g=0;for(let y=0;y<a;++y)for(let b=0;b<d;++b){const v=Math.floor(b/o),x=b%o;for(let w=0;w<h;++w){const _=Math.floor(w/o),A=(x*o+w%o)*f;for(let R=0;R<f;++R)m[g++]=p[R+A+c*(_+u*(v+l*y))]}}return e.makeTensorInfo([a,d,h,f],s.dtype,m)}};function cM(t){const{inputs:n,backend:e,attrs:r}=t,{x:s,filter:o}=n,{strides:i,pad:a,dilations:l,dimRoundingMode:u}=r;Ee([s,o],"depthwiseConv2DNative");const c=Le(s.shape),d=Le(o.shape);let h=l;null==h&&(h=[1,1]),S(ar(i,h),()=>`Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${i} and dilations '${h}'`);const f=Zn(s.shape,o.shape,i,h,a,u,!0),{filterHeight:p,filterWidth:m,dilationHeight:g,dilationWidth:y,padInfo:b}=f,v=b.left,x=b.top,w=f.outChannels/f.inChannels,_=new Xn(f.outShape,s.dtype),D=e.data.get(s.dataId).values,A=e.data.get(o.dataId).values,R=_.values;for(let O=0;O<f.batchSize;++O){const G=O*c[0],K=O*_.strides[0];for(let j=0;j<f.outHeight;++j){const Q=K+j*_.strides[1],q=j*f.strideHeight-v;for(let Y=0;Y<p;++Y){const re=q+Y*g;if(re<0||re>=f.inHeight)continue;const ee=Y*d[0],se=G+re*c[1];for(let ue=0;ue<f.outWidth;++ue){const de=Q+ue*_.strides[2],ge=ue*f.strideWidth-x;for(let pe=0;pe<m;++pe){const ye=ge+pe*y;if(ye<0||ye>=f.inWidth)continue;const De=se+ye*f.inChannels;let Te=de,Pe=ee+pe*d[1];for(let Be=0;Be<f.inChannels;++Be){const tt=D[De+Be];for(let vt=0;vt<w;++vt)R[Te+vt]+=tt*A[Pe+vt];Te+=w,Pe+=w}}}}}}return e.makeTensorInfo(_.shape,_.dtype,_.values)}const yoe={kernelName:gm,backendName:"cpu",kernelFunc:cM},voe={kernelName:cw,backendName:"cpu",kernelFunc:function boe(t){const{inputs:n,backend:e,attrs:r}=t,{x:s,dy:o}=n,{strides:i,dilations:a,pad:l,dimRoundingMode:u,filterShape:c}=r;Ee([s,o],"depthwiseConv2dNativeBackpropFilter");const d=Zn(s.shape,c,i,a,l,u,!0),{strideHeight:h,strideWidth:f,filterHeight:p,filterWidth:m}=d,g=new Xn(d.filterShape,"float32"),y=d.padInfo.left,b=d.padInfo.top,v=d.outChannels/d.inChannels,x=e.data.get(s.dataId).values,w=new Xn(s.shape,s.dtype,x),_=e.data.get(o.dataId).values,D=new Xn(o.shape,o.dtype,_);for(let A=0;A<p;++A){const R=Math.max(0,Math.ceil((b-A)/h)),O=Math.min(d.outHeight,(d.inHeight+b-A)/h);for(let G=0;G<m;++G){const K=Math.max(0,Math.ceil((y-G)/f)),j=Math.min(d.outWidth,(d.inWidth+y-G)/f);for(let Q=0;Q<d.outChannels;++Q){const q=Math.trunc(Q/v),Y=Q%v;let re=0;for(let ee=0;ee<d.batchSize;++ee)for(let se=R;se<O;++se){const ue=A+se*h-b;for(let de=K;de<j;++de)re+=w.get(ee,ue,G+de*f-y,q)*D.get(ee,se,de,Q)}g.set(re,A,G,q,Y)}}}return e.makeTensorInfo(g.shape,g.dtype,g.values)}},woe={kernelName:dw,backendName:"cpu",kernelFunc:function xoe(t){const{inputs:n,backend:e,attrs:r}=t,{dy:s,filter:o}=n,{strides:i,dilations:a,pad:l,dimRoundingMode:u,inputShape:c}=r;Ee([s,o],"depthwiseConv2DNativeBackpropInput");const d=Le(s.shape),h=Le(o.shape),f=Zn(c,o.shape,i,a,l,u,!0),p=new Xn(f.inShape,"float32"),m=p.values,[g,y,b]=p.strides,v=e.data.get(s.dataId).values,[x,w,_]=d,D=e.data.get(o.dataId).values,[A,R,O]=h,{batchSize:G,filterHeight:K,filterWidth:j,inChannels:Q,inHeight:q,inWidth:Y,outChannels:re,outHeight:ee,outWidth:se,strideHeight:ue,strideWidth:de}=f,ge=K-1-f.padInfo.top,pe=j-1-f.padInfo.left,ye=re/Q;for(let ve=0;ve<G;++ve)for(let De=0;De<Q;++De)for(let Te=0;Te<q;++Te){const Pe=Te-ge,Be=Math.max(0,Math.ceil(Pe/ue)),tt=Math.min(ee,(K+Pe)/ue);for(let vt=0;vt<Y;++vt){const Lt=vt-pe,cn=Math.max(0,Math.ceil(Lt/de)),en=Math.min(se,(j+Lt)/de);let Kt=0;for(let Xt=Be;Xt<tt;++Xt){const tn=Xt*ue-Pe;for(let Cn=cn;Cn<en;++Cn){const dr=x*ve+w*Xt+_*Cn,Mo=A*(K-1-tn)+R*(j-1-(Cn*de-Lt))+O*De;for(let vs=0;vs<ye;++vs)Kt+=v[dr+(De*ye+vs)]*D[Mo+vs]}}m[g*ve+y*Te+b*vt+De]=Kt}}return e.makeTensorInfo(p.shape,p.dtype,p.values)}},Ioe={kernelName:"Diag",backendName:"cpu",kernelFunc:function Coe(t){const{inputs:n,backend:e}=t,{x:r}=n,s=te(r.shape),o=e.data.get(r.dataId).values,i=yt([s,s],r.dtype),a=i.values;for(let u=0;u<o.length;u++)a[u*s+u]=o[u];const l=[...r.shape,...r.shape];return e.makeTensorInfo(l,i.dtype,i.values)}},Doe={kernelName:ym,backendName:"cpu",kernelFunc:({inputs:t,backend:n,attrs:e})=>{const{x:r,filter:s}=t,{strides:o,pad:i,dilations:a}=e,l=n,u=l.data.get(r.dataId).values,c=r.shape.length,d=l.data.get(s.dataId).values,h=s.shape.length,{batchSize:f,inHeight:p,inWidth:m,inChannels:g,outHeight:y,outWidth:b,padInfo:v,strideHeight:x,strideWidth:w,filterHeight:_,filterWidth:D,dilationHeight:A,dilationWidth:R,outShape:O}=fh(r.shape,s.shape,o,i,"NHWC",a),G=te(O),K=O.length,j=ru(r.dtype,G);for(let q=0;q<f;++q)for(let Y=0;Y<y;++Y){const re=Y*x-v.top;for(let ee=0;ee<b;++ee){const se=ee*w-v.left;for(let ue=0;ue<g;++ue){let de=Number.MIN_SAFE_INTEGER;for(let pe=0;pe<_;++pe){const ye=re+pe*A;if(ye>=0&&ye<p)for(let ve=0;ve<D;++ve){const De=se+ve*R;if(De>=0&&De<m){const Te=Do([q,ye,De,ue],c,Le(r.shape)),Pe=Do([pe,ve,ue],h,Le(s.shape)),Be=u[Te]+d[Pe];Be>de&&(de=Be)}}}j[Do([q,Y,ee,ue],K,Le(O))]=de}}}return{dataId:l.write(Ra(j,r.dtype),O,r.dtype),shape:O,dtype:r.dtype}}},_oe={kernelName:fw,backendName:"cpu",kernelFunc:({inputs:t,backend:n,attrs:e})=>{const{x:r,filter:s,dy:o}=t,{strides:i,pad:a,dilations:l}=e,u=n,c=Ns(r.shape,u.data.get(r.dataId).values),d=Ns(s.shape,u.data.get(s.dataId).values),{batchSize:h,inHeight:f,inWidth:p,inChannels:m,outHeight:g,outWidth:y,padInfo:b,strideHeight:v,strideWidth:x,filterHeight:w,filterWidth:_,dilationHeight:D,dilationWidth:A,outShape:R}=fh(r.shape,s.shape,i,a,"NHWC",l);S(o.rank===R.length,()=>`Error in ${fw}, dy must have the same rank as output ${R.length}, but got ${o.rank}`);const O=Ns(R,u.data.get(o.dataId).values),G=ZR(s.shape,s.dtype);for(let j=0;j<h;++j)for(let Q=0;Q<g;++Q){const q=Q*v-b.top;for(let Y=0;Y<y;++Y){const re=Y*x-b.left;for(let ee=0;ee<m;++ee){let se=Number.MIN_SAFE_INTEGER,ue=0,de=0;for(let ge=0;ge<w;++ge){const pe=q+ge*D;if(pe>=0&&pe<f)for(let ye=0;ye<_;++ye){const ve=re+ye*A;if(ve>=0&&ve<p){const De=c[j][pe][ve][ee]+d[ge][ye][ee];De>se&&(se=De,ue=ge,de=ye)}}}G[ue][de][ee]+=O[j][Q][Y][ee]}}}return{dataId:u.write(Ra(G,r.dtype),s.shape,s.dtype),shape:s.shape,dtype:s.dtype}}},Soe={kernelName:hw,backendName:"cpu",kernelFunc:({inputs:t,backend:n,attrs:e})=>{const{x:r,filter:s,dy:o}=t,{strides:i,pad:a,dilations:l}=e,u=n,c=Ns(r.shape,u.data.get(r.dataId).values),d=Ns(s.shape,u.data.get(s.dataId).values),{batchSize:h,inHeight:f,inWidth:p,inChannels:m,outHeight:g,outWidth:y,padInfo:b,strideHeight:v,strideWidth:x,filterHeight:w,filterWidth:_,dilationHeight:D,dilationWidth:A,outShape:R}=fh(r.shape,s.shape,i,a,"NHWC",l);S(o.rank===R.length,()=>`Error in ${hw}, dy must have the same rank as output ${R.length}, but got ${o.rank}`);const O=Ns(R,u.data.get(o.dataId).values),G=ZR(r.shape,r.dtype);for(let j=0;j<h;++j)for(let Q=0;Q<g;++Q){const q=Q*v-b.top;for(let Y=0;Y<y;++Y){const re=Y*x-b.left;for(let ee=0;ee<m;++ee){let se=Number.MIN_SAFE_INTEGER,ue=q<0?0:q,de=re<0?0:re;for(let ge=0;ge<w;++ge){const pe=q+ge*D;if(pe>=0&&pe<f)for(let ye=0;ye<_;++ye){const ve=re+ye*A;if(ve>=0&&ve<p){const De=c[j][pe][ve][ee]+d[ge][ye][ee];De>se&&(se=De,ue=pe,de=ve)}}}G[j][ue][de][ee]+=O[j][Q][Y][ee]}}}return{dataId:u.write(Ra(G,r.dtype),r.shape,r.dtype),shape:r.shape,dtype:r.dtype}}},Noe={kernelName:pw,backendName:"cpu",kernelFunc:function Eoe(t){const{inputs:n,backend:e}=t,{dy:r,y:s}=n;Ee([r,s],"eluGrad");const o=new Float32Array(te(s.shape)),i=e.data.get(s.dataId).values,a=e.data.get(r.dataId).values;for(let l=0;l<i.length;++l){const u=i[l];o[l]=u>=1?a[l]:a[l]*(u+1)}return e.makeTensorInfo(s.shape,"float32",o)}},Toe=Tn((t,n)=>t===n?1:0),dM=er(bm,Toe,null,"bool"),koe={kernelName:bm,backendName:"cpu",kernelFunc:dM},Aoe=pI,Roe=mI,$oe=gI,Foe=yI,Ooe=bI,Moe=vI,Poe=Pt(_d,t=>{const n=Math.sign(t),e=Math.abs(t),r=1/(1+Aoe*e);return n*(1-((((Moe*r+Ooe)*r+Foe)*r+$oe)*r+Roe)*r*Math.exp(-e*e))}),Loe={kernelName:_d,backendName:"cpu",kernelFunc:Poe},hM=Ru(t=>Math.exp(t)),fM=Au(Sd,hM),Boe={kernelName:Sd,backendName:"cpu",kernelFunc:fM};function Iy(t){const{inputs:n,backend:e,attrs:r}=t,{input:s}=n,{dim:o}=r,i=s.shape.length,a=s.shape.slice();let l=o;return o<0&&(S(-(i+1)<=o,()=>`Axis must be in the interval [${-(i+1)}, ${i}]`),l=i+o+1),a.splice(l,0,1),sn({inputs:{x:s},backend:e,attrs:{shape:a}})}const zoe={kernelName:vm,backendName:"cpu",kernelFunc:Iy},pM=Ru(t=>Math.expm1(t)),Voe=Au(Ed,pM),Uoe={kernelName:Ed,backendName:"cpu",kernelFunc:Voe},JD=Tn((t,n)=>t*n),Woe=XD((t,n,e,r)=>({real:t*e-n*r,imag:t*r+n*e})),e_=er(zd,JD,Woe),Hoe={kernelName:zd,backendName:"cpu",kernelFunc:e_},Goe=Tn((t,n)=>t/n),t_=er(Id,Goe),n_={kernelName:Id,backendName:"cpu",kernelFunc:t_},mM=Tn((t,n)=>t-n),joe=XD((t,n,e,r)=>({real:t-e,imag:n-r})),r_=er(th,mM,joe),qoe={kernelName:th,backendName:"cpu",kernelFunc:r_};function gM(t,n,e){const r=t.shape,s=r[0],o=r[1],i=e.data.get(t.dataId),a=i.complexTensorInfos.real,l=i.complexTensorInfos.imag,u=[s,o],c=te(u),d=or("float32",c),h=or("float32",c);for(let g=0;g<s;g++){const y=Ja({inputs:{x:a},backend:e,attrs:{begin:[g,0],size:[1,o]}}),b=Ja({inputs:{x:l},backend:e,attrs:{begin:[g,0],size:[1,o]}}),v=Zr({inputs:{real:y,imag:b},backend:e}),{real:x,imag:w}=Koe(v,n,e),_=di(x,w);for(let D=0;D<o;D++){const A=xI(_,D);d[g*o+D]=A.real,h[g*o+D]=A.imag}e.disposeIntermediateTensorInfo(y),e.disposeIntermediateTensorInfo(b),e.disposeIntermediateTensorInfo(v)}const f=e.makeTensorInfo(u,"float32",d),p=e.makeTensorInfo(u,"float32",h),m=Zr({inputs:{real:f,imag:p},backend:e});return e.disposeIntermediateTensorInfo(f),e.disposeIntermediateTensorInfo(p),m}function Koe(t,n,e){const r=te(t.shape),s=e.data.get(t.dataId),o=e.data.get(s.complexTensorInfos.real.dataId).values,i=e.data.get(s.complexTensorInfos.imag.dataId).values;if(function Xoe(t){return 0==(t&t-1)}(r)){const a=s_(o,i,r,n,e),l=[t.shape[0],t.shape[1]];if(n){const u=e.makeTensorInfo(l,"float32",a.real),c=e.makeTensorInfo(l,"float32",a.imag),d=e.makeTensorInfo([],"float32",Oi(r,"float32")),h=Fo({inputs:{x:d},backend:e}),f=n_.kernelFunc({inputs:{a:u,b:d},backend:e}),p=n_.kernelFunc({inputs:{a:c,b:h},backend:e}),m=e.data.get(f.dataId).values,g=e.data.get(p.dataId).values;return e.disposeIntermediateTensorInfo(u),e.disposeIntermediateTensorInfo(c),e.disposeIntermediateTensorInfo(d),e.disposeIntermediateTensorInfo(h),e.disposeIntermediateTensorInfo(f),e.disposeIntermediateTensorInfo(p),{real:m,imag:g}}return a}{const l=function Yoe(t,n,e){const r=new Float32Array(2*n);for(let s=0;s<n;s++){let o=0,i=0;for(let a=0;a<n;a++){const l=w2(s*a,n,e),u=xI(t,a);o+=u.real*l.real-u.imag*l.imag,i+=u.real*l.imag+u.imag*l.real}e&&(o/=n,i/=n),v2(r,o,i,s)}return r}(di(o,i),r,n);return g2(l)}}function s_(t,n,e,r,s){if(1===e)return{real:t,imag:n};const o=di(t,n),i=e/2,a=y2(o),l=a.real,u=a.imag,c=[l.length],d=s.makeTensorInfo(c,"float32",l),h=s.makeTensorInfo(c,"float32",u),f=Zr({inputs:{real:d,imag:h},backend:s}),p=b2(o),m=p.real,g=p.imag,y=[m.length],b=s.makeTensorInfo(y,"float32",m),v=s.makeTensorInfo(y,"float32",g),x=Zr({inputs:{real:b,imag:v},backend:s}),w=s_(l,u,i,r,s),_=w.real,D=w.imag,A=[_.length],R=s.makeTensorInfo(A,"float32",_),O=s.makeTensorInfo(A,"float32",D),G=Zr({inputs:{real:R,imag:O},backend:s}),K=s_(m,g,i,r,s),j=K.real,Q=K.imag,q=[j.length],Y=s.makeTensorInfo(q,"float32",j),re=s.makeTensorInfo(q,"float32",Q),ee=Zr({inputs:{real:Y,imag:re},backend:s}),se=x2(e,r),ue=[se.real.length],de=s.makeTensorInfo(ue,"float32",se.real),ge=s.makeTensorInfo(ue,"float32",se.imag),pe=Zr({inputs:{real:de,imag:ge},backend:s}),ye=e_({inputs:{a:pe,b:ee},backend:s}),ve=jh({inputs:{a:G,b:ye},backend:s}),De=r_({inputs:{a:G,b:ye},backend:s}),Te=Qa({inputs:{input:ve},backend:s}),Pe=Qa({inputs:{input:De},backend:s}),Be=$u({inputs:{input:ve},backend:s}),tt=$u({inputs:{input:De},backend:s}),vt=Fu({inputs:[Te,Pe],backend:s,attrs:{axis:0}}),Lt=Fu({inputs:[Be,tt],backend:s,attrs:{axis:0}}),cn=s.data.get(vt.dataId).values,en=s.data.get(Lt.dataId).values;return s.disposeIntermediateTensorInfo(d),s.disposeIntermediateTensorInfo(h),s.disposeIntermediateTensorInfo(f),s.disposeIntermediateTensorInfo(b),s.disposeIntermediateTensorInfo(v),s.disposeIntermediateTensorInfo(x),s.disposeIntermediateTensorInfo(R),s.disposeIntermediateTensorInfo(O),s.disposeIntermediateTensorInfo(G),s.disposeIntermediateTensorInfo(Y),s.disposeIntermediateTensorInfo(re),s.disposeIntermediateTensorInfo(ee),s.disposeIntermediateTensorInfo(de),s.disposeIntermediateTensorInfo(ge),s.disposeIntermediateTensorInfo(pe),s.disposeIntermediateTensorInfo(ye),s.disposeIntermediateTensorInfo(ve),s.disposeIntermediateTensorInfo(De),s.disposeIntermediateTensorInfo(Te),s.disposeIntermediateTensorInfo(Be),s.disposeIntermediateTensorInfo(Pe),s.disposeIntermediateTensorInfo(tt),s.disposeIntermediateTensorInfo(vt),s.disposeIntermediateTensorInfo(Lt),{real:cn,imag:en}}const Qoe={kernelName:"FFT",backendName:"cpu",kernelFunc:function Zoe(t){const{inputs:n,backend:e}=t,{input:r}=n,s=te(r.shape),o=r.shape[r.shape.length-1],a=sn({inputs:{x:r},backend:e,attrs:{shape:[s/o,o]}}),l=gM(a,!1,e),u=sn({inputs:{x:l},backend:e,attrs:{shape:r.shape}});return e.disposeIntermediateTensorInfo(a),e.disposeIntermediateTensorInfo(l),u}};function o_(t){const{backend:n,attrs:e}=t,{shape:r,value:s,dtype:o}=e,i=o||ld(s),a=ru(i,te(r));return function eie(t,n,e){t.fill(n)}(a,s),n.makeTensorInfo(r,i,a)}const Joe={kernelName:gw,backendName:"cpu",kernelFunc:o_},tie={kernelName:yw,backendName:"cpu",kernelFunc:({inputs:t,backend:e})=>{const{image:r}=t,s=e,o=or(r.dtype,te(r.shape)),[i,a,l,u]=r.shape,c=s.data.get(r.dataId).values;for(let h=0;h<i;h++){const f=h*l*a*u;for(let p=0;p<a;p++){const m=p*(l*u);for(let g=0;g<l;g++){const y=g*u;for(let b=0;b<u;b++){const w=Math.round(l-[i,p,g,b][2]),_=f+m+y+b;let D=c[_];w>=0&&w<l&&(D=c[f+m+w*u+b]),o[_]=D}}}}return{dataId:s.write(o,r.shape,r.dtype),shape:r.shape,dtype:r.dtype}}},yM=Ru(t=>Math.floor(t)),nie=Au(Nd,yM),rie={kernelName:Nd,backendName:"cpu",kernelFunc:nie},sie=Tn((t,n)=>Math.floor(t/n)),oie=er(Td,sie,null,"int32"),iie={kernelName:Td,backendName:"cpu",kernelFunc:oie},lie={kernelName:sg,backendName:"cpu",kernelFunc:function aie(t){const{inputs:n,backend:e,attrs:r}=t,{x:s,filter:o,bias:i,preluActivationWeights:a}=n,{strides:l,pad:u,dataFormat:c,dilations:d,dimRoundingMode:h,activation:f,leakyreluAlpha:p}=r;let m=uM({inputs:{x:s,filter:o},backend:e,attrs:{strides:l,pad:u,dataFormat:c,dilations:d,dimRoundingMode:h}});if(i){const g=m;m=jh({inputs:{a:m,b:i},backend:e}),e.disposeIntermediateTensorInfo(g)}if(f){const g=m;m=KD(e,m,f,a,p),e.disposeIntermediateTensorInfo(g)}return m}},cie={kernelName:og,backendName:"cpu",kernelFunc:function uie(t){const{inputs:n,backend:e,attrs:r}=t,{x:s,filter:o,bias:i,preluActivationWeights:a}=n,{strides:l,pad:u,dataFormat:c,dilations:d,dimRoundingMode:h,activation:f,leakyreluAlpha:p}=r;let m=cM({inputs:{x:s,filter:o},backend:e,attrs:{strides:l,pad:u,dataFormat:c,dilations:d,dimRoundingMode:h}});if(i){const g=m;m=jh({inputs:{a:m,b:i},backend:e}),e.disposeIntermediateTensorInfo(g)}if(f){const g=m;m=KD(e,m,f,a,p),e.disposeIntermediateTensorInfo(g)}return m}},hie={kernelName:bw,backendName:"cpu",kernelFunc:function die(t){const{inputs:n,backend:e}=t,{params:r,indices:s}=n,o=te(r.shape),i=s.shape,a=i[i.length-1],[l,u,c,d]=fI(r,s);if(0===u)return e.makeTensorInfo(l,r.dtype,[]);const h=yt([u,c],r.dtype),f=e.data.get(s.dataId).values,p=e.data.get(r.dataId).values;for(let m=0;m<u;m++){const g=[];let y=0;for(let b=0;b<a;b++){const v=f[m*a+b];y+=v*d[b],g.push(v)}if(y<0||y>=o/c)throw new Error(`Invalid indices: ${g} does not index into ${r.shape}`);for(let b=0;b<c;b++)h.values[m*c+b]=p[y*c+b]}return e.makeTensorInfo(l,h.dtype,h.values)}};function bM(t,n,e){const r=yt(e,t.dtype);for(let s=0;s<r.size;++s){const i=r.indexToLoc(s).slice(),u=n.locToIndex([i[0],i[2]]);i[2]=n.values[u];const c=t.locToIndex(i);r.values[s]=t.values[c]}return r}const pie={kernelName:wm,backendName:"cpu",kernelFunc:function fie(t){const{inputs:n,backend:e,attrs:r}=t,{x:s,indices:o}=n,{axis:i,batchDims:a}=r;Ee([s,o],"gatherV2");let l=a;null==a&&(l=0);const u=te(o.shape),d=CI(s,o,ft(i,s.shape)[0],l),h=sn({inputs:{x:s},backend:e,attrs:{shape:[d.batchSize,d.outerSize,d.dimSize,d.sliceSize]}}),f=sn({inputs:{x:o},backend:e,attrs:{shape:[d.batchSize,u/d.batchSize]}}),p=[d.batchSize,d.outerSize,u/d.batchSize,d.sliceSize],m=e.bufferSync(f),y=bM(e.bufferSync(h),m,p);return e.disposeIntermediateTensorInfo(h),e.disposeIntermediateTensorInfo(f),e.makeTensorInfo(d.outputShape,y.dtype,y.values)}},vM=Tn((t,n)=>t>n?1:0),mie=er(Cm,vM,null,"bool"),gie={kernelName:Cm,backendName:"cpu",kernelFunc:mie},yie=Tn((t,n)=>t>=n?1:0),bie=er(kd,yie,null,"bool"),vie={kernelName:kd,backendName:"cpu",kernelFunc:bie},wie={kernelName:vw,backendName:"cpu",kernelFunc:function xie(t){const{inputs:n,backend:e}=t,{input:r}=n,s=te(r.shape),o=r.shape[r.shape.length-1],a=sn({inputs:{x:r},backend:e,attrs:{shape:[s/o,o]}}),l=gM(a,!0,e),u=sn({inputs:{x:l},backend:e,attrs:{shape:r.shape}});return e.disposeIntermediateTensorInfo(a),e.disposeIntermediateTensorInfo(l),u}},Cie=Pt(Rd,t=>Number.isFinite(t)?1:0,"bool"),Iie={kernelName:Rd,backendName:"cpu",kernelFunc:Cie},Die=Pt($d,t=>Math.abs(t)===1/0?1:0,"bool"),_ie={kernelName:$d,backendName:"cpu",kernelFunc:Die},Sie=Pt(Fd,t=>Number.isNaN(t)?1:0,"bool"),Eie={kernelName:Fd,backendName:"cpu",kernelFunc:Sie},xM=Tn((t,n)=>t<n?1:0),Nie=er(Dm,xM,null,"bool"),Tie={kernelName:Dm,backendName:"cpu",kernelFunc:Nie},kie=Tn((t,n)=>t<=n?1:0),Aie=er(_m,kie,null,"bool"),Rie={kernelName:_m,backendName:"cpu",kernelFunc:Aie};function wM(t,n,e){const r=(n-t)/(e-1),s=gr(e,"float32");s[0]=t;for(let o=1;o<s.length;o++)s[o]=s[o-1]+r;return s}const Fie={kernelName:ww,backendName:"cpu",kernelFunc:function $ie(t){const{backend:n,attrs:e}=t,{start:r,stop:s,num:o}=e,i=wM(r,s,o);return n.makeTensorInfo([i.length],"float32",i)}},CM=Ru(t=>Math.log(t)),Oie=Au(Od,CM),Mie={kernelName:Od,backendName:"cpu",kernelFunc:Oie},Pie=Pt(Md,t=>Math.log1p(t)),Lie={kernelName:Md,backendName:"cpu",kernelFunc:Pie},Bie=Tn((t,n)=>t&&n),zie=er(Sm,Bie,null,"bool"),Vie={kernelName:Sm,backendName:"cpu",kernelFunc:zie},Uie=Pt(Em,t=>t?0:1,"bool"),Wie={kernelName:Em,backendName:"cpu",kernelFunc:Uie},Hie=Tn((t,n)=>t||n),Gie=er(Nm,Hie,null,"bool"),jie={kernelName:Nm,backendName:"cpu",kernelFunc:Gie},Kie={kernelName:Tm,backendName:"cpu",kernelFunc:function qie(t){const{inputs:n,backend:e,attrs:r}=t,{x:s}=n,{depthRadius:o,bias:i,alpha:a,beta:l}=r;Ee(s,"LRN");const u=s.shape[3],c=u-1,d=e.data.get(s.dataId).values,h=te(s.shape),f=new Float32Array(h);function p(m){const g=m%u;let y=m-g+Math.max(0,g-o);const b=m-g+Math.min(g+o,c);let v=0;for(;y<=b;y++){const x=d[y];v+=x*x}return v}for(let m=0;m<h;m++){const g=p(m),y=d[m]*Math.pow(i+a*g,-l);f[m]=y}return e.makeTensorInfo(s.shape,s.dtype,f)}},Yie={kernelName:Cw,backendName:"cpu",kernelFunc:function Xie(t){const{inputs:n,backend:e,attrs:r}=t,{x:s,y:o,dy:i}=n,{depthRadius:a,bias:l,alpha:u,beta:c}=r;Ee(i,"LRNGrad");const d=te(i.shape),h=i.shape[3],f=e.data.get(i.dataId).values,p=e.data.get(s.dataId).values,m=e.data.get(o.dataId).values,g=new Float32Array(d),y=d;for(let b=0;b<y;b++){const v=b%h,x=b-v+Math.max(0,v-a),w=b-v+Math.min(h,v+a+1);let _=0;for(let D=x;D<w;D++)_+=Math.pow(p[D],2);_=u*_+l;for(let D=x;D<w;D++){let A=-2*u*c*p[D]*m[b]/_;b===D&&(A+=Math.pow(_,-c)),A*=f[b],g[D]+=A}}return e.makeTensorInfo(i.shape,s.dtype,g)}};function IM(t,n,e,r){const s=or(r,te(e));for(let o=0;o<s.length;++o){const i=o*n;let a=t[i];for(let l=0;l<n;++l){const u=t[i+l];u>a&&(a=u)}s[o]=a}return s}function DM(t){const{inputs:n,backend:e,attrs:r}=t,{x:s}=n,{reductionIndices:o,keepDims:i}=r,a=e;let l=s.shape;const u=l.length,c=ft(o,l);let d=c;const h=xn(d,u);let f=a.data.get(s.dataId).values;if(null!=h){const x=new Array(u);for(let w=0;w<x.length;w++)x[w]=l[h[w]];f=YD(f,l,s.dtype,h,x),d=En(d.length,u),l=x}Ee(s,"max"),lr("max",d,u);const[p,m]=Qn(l,d),y=IM(f,te(m),p,s.dtype),b=a.write(y,p,s.dtype);let v=p;return i&&(v=vn(p,c)),{dataId:b,shape:v,dtype:s.dtype}}const Zie={kernelName:km,backendName:"cpu",kernelFunc:DM},_M=Tn((t,n)=>Math.max(t,n)),Qie=er(Pd,_M),Jie={kernelName:Pd,backendName:"cpu",kernelFunc:Qie},tae={kernelName:Am,backendName:"cpu",kernelFunc:function eae(t){const{inputs:n,backend:e,attrs:r}=t,{x:s}=n;Ee(s,"maxPool");const{filterSize:o,strides:i,pad:a,dimRoundingMode:l}=r;S(ar(i,1),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${i} and dilations '1'`);const c=ks(s.shape,o,i,1,a,l);let d;if(1===c.filterWidth&&1===c.filterHeight&&Mt(c.inShape,c.outShape))d=Fo({inputs:{x:s},backend:e});else{const h=e.data.get(s.dataId).values,f=Le(s.shape),p=ZD(h,0,s.dtype,f,c,"max");d=e.makeTensorInfo(c.outShape,s.dtype,p.values)}return d}},rae={kernelName:Rm,backendName:"cpu",kernelFunc:function nae(t){const{inputs:n,backend:e,attrs:r}=t,{x:s}=n,{filterSize:o,strides:i,pad:a,dimRoundingMode:l,dataFormat:u}=r;Ee(s,"maxPool3d");const c=ri(s.shape,o,i,1,a,l,u),h=sM(e.data.get(s.dataId).values,0,s.dtype,Le(s.shape),c,"max");return e.makeTensorInfo(h.shape,"float32",h.values)}},oae={kernelName:Dw,backendName:"cpu",kernelFunc:function sae(t){const{inputs:n,backend:e,attrs:r}=t,{dy:s,input:o}=n,{filterSize:i,strides:a,pad:l,dimRoundingMode:u}=r;Ee([s,o],"maxPool3DGrad");const c=ri(o.shape,i,a,1,l,u),h=function _se(t,n){const e=yt(n.outShape,"int32"),r=n.strideDepth,s=n.strideHeight,o=n.strideWidth,i=n.dilationDepth,a=n.dilationHeight,l=n.dilationWidth,u=n.effectiveFilterDepth,c=n.effectiveFilterHeight,d=n.effectiveFilterWidth,h=n.padInfo.front,f=n.padInfo.top,p=n.padInfo.left;for(let m=0;m<n.batchSize;++m)for(let g=0;g<n.inChannels;++g)for(let y=0;y<n.outDepth;++y){const b=y*r-h;let v=b;for(;v<0;)v+=i;const x=Math.min(n.inDepth,u+b);for(let w=0;w<n.outHeight;++w){const _=w*s-f;let D=_;for(;D<0;)D+=a;const A=Math.min(n.inHeight,c+_);for(let R=0;R<n.outWidth;++R){const O=R*o-p;let G=O;for(;G<0;)G+=l;const K=Math.min(n.inWidth,d+O);let j=Number.NEGATIVE_INFINITY,Q=-1;for(let q=v;q<x;q+=i){const Y=q-b;for(let re=D;re<A;re+=a){const ee=re-_;for(let se=G;se<K;se+=l){const ue=se-O,de=t.get(m,q,re,se,g);de>=j&&(j=de,Q=Y*c*d+ee*c+ue)}}}e.set(Q,m,y,w,R,g)}}}return e}(e.bufferSync(o),c),f=c.strideDepth,p=c.strideHeight,m=c.strideWidth,g=c.dilationDepth,y=c.dilationHeight,b=c.dilationWidth,v=c.effectiveFilterDepth,x=c.effectiveFilterHeight,w=c.effectiveFilterWidth,_=v-1-c.padInfo.front,D=w-1-c.padInfo.left,A=x-1-c.padInfo.top,R=yt(o.shape,"float32"),O=e.bufferSync(s);for(let G=0;G<c.batchSize;++G)for(let K=0;K<c.inChannels;++K)for(let j=0;j<c.inDepth;++j)for(let Q=0;Q<c.inHeight;++Q)for(let q=0;q<c.inWidth;++q){const Y=j-_,re=Q-A,ee=q-D;let se=0;for(let ue=0;ue<v;ue+=g){const de=(Y+ue)/f;if(!(de<0||de>=c.outDepth||Math.floor(de)!==de))for(let ge=0;ge<x;ge+=y){const pe=(re+ge)/p;if(!(pe<0||pe>=c.outHeight||Math.floor(pe)!==pe))for(let ye=0;ye<w;ye+=b){const ve=(ee+ye)/m;if(ve<0||ve>=c.outWidth||Math.floor(ve)!==ve)continue;const Pe=v*x*w-1-h.get(G,de,pe,ve,K)===ue*x*w+ge*w+ye?1:0;0!==Pe&&(se+=O.get(G,de,pe,ve,K)*Pe)}}}R.set(se,G,j,Q,q,K)}return e.makeTensorInfo(R.shape,R.dtype,R.values)}},aae={kernelName:Iw,backendName:"cpu",kernelFunc:function iae(t){const{inputs:n,backend:e,attrs:r}=t,{dy:s,input:o,output:i}=n,a=o;Ee([o,i],"maxPoolGrad");const{filterSize:l,strides:u,pad:c,dimRoundingMode:d}=r,h=ks(a.shape,l,u,1,c,d),f=e.data.get(a.dataId).values,p=yt(h.outShape,a.dtype,rM(f,a.shape,a.dtype,h).values),m=h.strideHeight,g=h.strideWidth,y=h.dilationHeight,b=h.dilationWidth,v=h.effectiveFilterHeight,x=h.effectiveFilterWidth,w=x-1-h.padInfo.left,_=v-1-h.padInfo.top,D=yt(a.shape,"float32"),A=e.data.get(s.dataId).values,R=yt(s.shape,"float32",A);for(let O=0;O<h.batchSize;++O)for(let G=0;G<h.inChannels;++G)for(let K=0;K<h.inHeight;++K)for(let j=0;j<h.inWidth;++j){const Q=K-_,q=j-w;let Y=0;for(let re=0;re<v;re+=y){const ee=(Q+re)/m;if(!(ee<0||ee>=h.outHeight||Math.floor(ee)!==ee))for(let se=0;se<x;se+=b){const ue=(q+se)/g;if(ue<0||ue>=h.outWidth||Math.floor(ue)!==ue)continue;const pe=v*x-1-p.get(O,ee,ue,G)===re*x+se?1:0;0!==pe&&(Y+=R.get(O,ee,ue,G)*pe)}}D.set(Y,O,K,j,G)}return e.makeTensorInfo(D.shape,D.dtype,D.values)}},uae={kernelName:_w,backendName:"cpu",kernelFunc:({inputs:t,attrs:n,backend:e})=>{const{x:r}=t,{filterSize:s,strides:o,pad:i,includeBatchInIndex:a}=n,l=e;Ee(r,"MaxPoolWithArgmax");const u=l.data.get(r.dataId).values,c=ks(r.shape,s,o,[1,1],i),[d,h]=function lae(t,n,e,r,s){const i=ZD(t,0,e,Le(n),s,"max"),a=rM(t,n,e,s,!0,r);return[i.values,a.values]}(u,r.shape,r.dtype,a,c),f=l.write(d,c.outShape,r.dtype),p=l.write(h,c.outShape,r.dtype);return[{dataId:f,shape:c.outShape,dtype:r.dtype},{dataId:p,shape:c.outShape,dtype:"int32"}]}};function Dy(t){const{inputs:n,backend:e,attrs:r}=t,{x:s}=n,{axis:o,keepDims:i}=r;let a;Ee(s,"sum"),a="bool"===s.dtype?Yi({inputs:{x:s},backend:e,attrs:{dtype:"int32"}}):Fo({inputs:{x:s},backend:e});const l=a.shape.length,u=ft(o,a.shape),c=xn(u,l);let d=u,h=a;null!=c&&(h=Vs({inputs:{x:a},backend:e,attrs:{perm:c}}),d=En(d.length,l)),lr("sum",d,h.shape.length);const[f,p]=Qn(h.shape,d);let g=Cy(e,f,ds(h.dtype,"int32"));const y=te(p),b=e.data.get(g.dataId).values,v=e.data.get(h.dataId).values;for(let x=0;x<b.length;++x){const w=x*y;let _=0;for(let D=0;D<y;++D)_+=v[w+D];b[x]=_}if(i){const w=g;g=sn({inputs:{x:g},backend:e,attrs:{shape:vn(g.shape,u)}}),e.disposeIntermediateTensorInfo(w)}return e.disposeIntermediateTensorInfo(a),null!=c&&e.disposeIntermediateTensorInfo(h),g}const cae={kernelName:Xm,backendName:"cpu",kernelFunc:Dy},hae={kernelName:$m,backendName:"cpu",kernelFunc:function dae(t){const{inputs:n,backend:e,attrs:r}=t,{x:s}=n,{axis:o,keepDims:i}=r,a=ft(o,s.shape),c=te(Qn(s.shape,a)[1]),d=[],h=e.makeTensorInfo([],"float32",new Float32Array([c]));d.push(h);const f=Yi({inputs:{x:s},backend:e,attrs:{dtype:"float32"}});d.push(f);const p=t_({inputs:{a:f,b:h},backend:e});d.push(p);const m=Dy({inputs:{x:p},backend:e,attrs:{axis:o,keepDims:i}});return d.forEach(g=>e.disposeIntermediateTensorInfo(g)),m}},pae={kernelName:Fm,backendName:"cpu",kernelFunc:function fae(t){const{inputs:n,backend:e,attrs:r}=t,{x:s}=n,{axis:o,keepDims:i}=r;Ee(s,"min");const a=ft(o,s.shape);let l=a;const u=xn(l,s.shape.length);let c=s;null!=u&&(c=Vs({inputs:{x:s},backend:e,attrs:{perm:u}}),l=En(l.length,s.shape.length)),lr("min",l,c.shape.length);const[d,h]=Qn(c.shape,l),f=te(h),p=gr(te(d),c.dtype),m=e.data.get(c.dataId).values;for(let y=0;y<p.length;++y){const b=y*f;let v=m[b];for(let x=0;x<f;++x){const w=m[b+x];w<v&&(v=w)}p[y]=v}null!=u&&e.disposeIntermediateTensorInfo(c);const g=e.makeTensorInfo(d,c.dtype,p);if(i){const b=sn({inputs:{x:g},backend:e,attrs:{shape:vn(d,a)}});return e.disposeIntermediateTensorInfo(g),b}return g}},SM=Tn((t,n)=>Math.min(t,n)),mae=er(Ld,SM),gae={kernelName:Ld,backendName:"cpu",kernelFunc:mae},bae={kernelName:Om,backendName:"cpu",kernelFunc:function yae(t){const{inputs:n,backend:e,attrs:r}=t,{x:s}=n,{paddings:o,mode:i}=r;Ee(s,"mirrorPad");const a=o.map((v,x)=>v[0]+s.shape[x]+v[1]),l=o.map(v=>v[0]),u=o.map((v,x)=>v[0]+s.shape[x]),c="reflect"===i?0:1,d=e.data.get(s.dataId).values,h=s.shape.length,f=Le(s.shape),p=te(a),m=a.length,g=Le(a),y=or(s.dtype,p);for(let v=0;v<p;v++){let x=ud(v,m,g);for(let _=0;_<m;_++)x[_]<l[_]?x[_]=2*l[_]-x[_]-c:x[_]>=u[_]&&(x[_]=2*(u[_]-1)-x[_]+c);x=x.map((_,D)=>_-l[D]);const w=Do(x,h,f);y[v]=d[w]}return{dataId:e.write(y,a,s.dtype),shape:a,dtype:s.dtype}}},vae=Tn((t,n)=>{const e=t%n;return t<0&&n<0||t>=0&&n>=0?e:(e+n)%n}),xae=er(Bd,vae),wae={kernelName:Bd,backendName:"cpu",kernelFunc:xae};var Cae=B(537);function EM(t){const{inputs:n,backend:e,attrs:r}=t,{logits:s}=n,{dim:o}=r,i=s.shape.length;let a=o;if(-1===a&&(a=i-1),a!==i-1)throw Error(`Softmax along a non-last dimension is not yet supported. Logits was rank ${i} and dim was ${a}`);const l=ft([a],s.shape),u=DM({inputs:{x:s},backend:e,attrs:{reductionIndices:l,keepDims:!1}}),c=vn(u.shape,l),d=sn({inputs:{x:u},backend:e,attrs:{shape:c}}),h=r_({inputs:{a:s,b:d},backend:e}),f=fM({inputs:{x:h},backend:e}),p=Dy({inputs:{x:f},backend:e,attrs:{axis:l,keepDims:!1}}),m=sn({inputs:{x:p},backend:e,attrs:{shape:c}}),g=t_({inputs:{a:f,b:m},backend:e});return e.disposeIntermediateTensorInfo(u),e.disposeIntermediateTensorInfo(d),e.disposeIntermediateTensorInfo(h),e.disposeIntermediateTensorInfo(f),e.disposeIntermediateTensorInfo(p),e.disposeIntermediateTensorInfo(m),g}const Iae={kernelName:Qm,backendName:"cpu",kernelFunc:EM},_ae={kernelName:Sw,backendName:"cpu",kernelFunc:function Dae(t){const{inputs:n,backend:e,attrs:r}=t,{logits:s}=n,{numSamples:o,seed:i,normalized:a}=r;Ee(s,"multinomial");const l=a?s:EM({inputs:{logits:s},backend:e,attrs:{dim:-1}}),u=l.shape[0],c=l.shape[1],d=e.data.get(l.dataId).values,h=[u,o],f=gr(te(h),"int32");for(let p=0;p<u;++p){const m=p*c,g=new Float32Array(c-1);g[0]=d[m];for(let v=1;v<g.length;++v)g[v]=g[v-1]+d[m+v];const y=Cae.alea(i.toString()),b=p*o;for(let v=0;v<o;++v){const x=y();f[b+v]=g.length;for(let w=0;w<g.length;w++)if(x<g[w]){f[b+v]=w;break}}}return a||e.disposeIntermediateTensorInfo(l),e.makeTensorInfo(h,"int32",f)}};function NM(t,n,e){const r=Oi(-1,e);return JD([],n,r,t,e)}const Eae={kernelName:Mm,backendName:"cpu",kernelFunc:function Sae(t){const{inputs:n,backend:e}=t,{x:r}=n;Ee(r,"neg");const s=e.data.get(r.dataId).values,[o,i]=NM(s,r.shape,r.dtype);return e.makeTensorInfo(i,r.dtype,o)}},Nae=HC,kae={kernelName:Ew,backendName:"cpu",kernelFunc:function Tae(t){const{inputs:n,backend:e,attrs:r}=t,{boxes:s,scores:o}=n,{maxOutputSize:i,iouThreshold:a,scoreThreshold:l}=r;Ee(s,"NonMaxSuppression");const u=e.data.get(s.dataId).values,c=e.data.get(o.dataId).values,{selectedIndices:d}=Nae(u,c,i,a,l);return e.makeTensorInfo([d.length],"int32",new Int32Array(d))}},Aae=GC,$ae={kernelName:Nw,backendName:"cpu",kernelFunc:function Rae(t){const{inputs:n,backend:e,attrs:r}=t,{boxes:s,scores:o}=n,{maxOutputSize:i,iouThreshold:a,scoreThreshold:l,padToMaxOutputSize:u}=r;Ee(s,"NonMaxSuppressionPadded");const c=e.data.get(s.dataId).values,d=e.data.get(o.dataId).values,{selectedIndices:h,validOutputs:f}=Aae(c,d,i,a,l,u);return[e.makeTensorInfo([h.length],"int32",new Int32Array(h)),e.makeTensorInfo([],"int32",new Int32Array([f]))]}},Fae=jC,Mae={kernelName:Tw,backendName:"cpu",kernelFunc:function Oae(t){const{inputs:n,backend:e,attrs:r}=t,{boxes:s,scores:o}=n,{maxOutputSize:i,iouThreshold:a,scoreThreshold:l,softNmsSigma:u}=r;Ee(s,"NonMaxSuppressionWithScore");const c=e.data.get(s.dataId).values,d=e.data.get(o.dataId).values,h=i,f=a,p=l,m=u,{selectedIndices:g,selectedScores:y}=Fae(c,d,h,f,p,m);return[e.makeTensorInfo([g.length],"int32",new Int32Array(g)),e.makeTensorInfo([y.length],"float32",new Float32Array(y))]}},TM=Tn((t,n)=>t!==n?1:0),Pae=er(Pm,TM,null,"bool"),Lae={kernelName:Pm,backendName:"cpu",kernelFunc:Pae},zae={kernelName:Bm,backendName:"cpu",kernelFunc:function Bae(t){const{inputs:n,backend:e,attrs:r}=t,{indices:s}=n,{depth:o,onValue:i,offValue:a}=r;Ee(s,"oneHot");const l=te(s.shape),u=new Float32Array(l*o);u.fill(a);const c=e.data.get(s.dataId).values;for(let d=0;d<l;++d)c[d]>=0&&c[d]<o&&(u[d*o+c[d]]=i);return e.makeTensorInfo([...s.shape,o],"int32",u)}};function _y(t){const{inputs:n,backend:e}=t,{x:r}=n;if("string"===r.dtype)throw new Error("zerosLike is not supported for string tensors");if("complex64"===r.dtype){const s=Qa({inputs:{input:r},backend:e}),o=_y({inputs:{x:s},backend:e}),i=$u({inputs:{input:r},backend:e}),a=_y({inputs:{x:i},backend:e}),l=Zr({inputs:{real:o,imag:a},backend:e});return e.disposeIntermediateTensorInfo(s),e.disposeIntermediateTensorInfo(o),e.disposeIntermediateTensorInfo(i),e.disposeIntermediateTensorInfo(a),l}return o_({backend:e,attrs:{shape:r.shape,value:0,dtype:r.dtype}})}const Vae={kernelName:ng,backendName:"cpu",kernelFunc:_y},Uae={kernelName:Lm,backendName:"cpu",kernelFunc:function kM(t){const{inputs:n,backend:e}=t,{x:r}=n;if("string"===r.dtype)throw new Error("onesLike is not supported for string tensors");if("complex64"===r.dtype){const s=Qa({inputs:{input:r},backend:e}),o=kM({inputs:{x:s},backend:e}),i=$u({inputs:{input:r},backend:e}),a=_y({inputs:{x:i},backend:e}),l=Zr({inputs:{real:o,imag:a},backend:e});return e.disposeIntermediateTensorInfo(s),e.disposeIntermediateTensorInfo(o),e.disposeIntermediateTensorInfo(i),e.disposeIntermediateTensorInfo(a),l}return o_({backend:e,attrs:{shape:r.shape,value:1,dtype:r.dtype}})}};function AM(t){const{inputs:n,backend:e,attrs:r}=t,{axis:s}=r;if(1===n.length)return Iy({inputs:{input:n[0]},backend:e,attrs:{dim:s}});const o=n[0].shape,i=n[0].dtype;n.forEach(c=>{cs(o,c.shape,"All tensors passed to stack must have matching shapes"),S(i===c.dtype,()=>"All tensors passed to stack must have matching dtypes")});const a=[],u=Fu({inputs:n.map(c=>{const d=Iy({inputs:{input:c},backend:e,attrs:{dim:s}});return a.push(d),d}),backend:e,attrs:{axis:s}});return a.forEach(c=>e.disposeIntermediateTensorInfo(c)),u}const Wae={kernelName:zm,backendName:"cpu",kernelFunc:AM},RM={kernelName:Vm,backendName:"cpu",kernelFunc:function Hae(t){const{inputs:n,backend:e,attrs:r}=t,{x:s}=n,{paddings:o,constantValue:i}=r;Ee(s,"pad");const a=o.map((b,v)=>b[0]+s.shape[v]+b[1]),l=o.map(b=>b[0]),u=e.data.get(s.dataId).values,c=te(s.shape),d=s.shape.length,h=Le(s.shape),f=te(a),p=a.length,m=Le(a),g=or(s.dtype,f);0!==i&&g.fill(i);for(let b=0;b<c;b++)g[Do(ud(b,d,h).map((_,D)=>_+l[D]),p,m)]=u[b];return{dataId:e.write(g,a,s.dtype),shape:a,dtype:s.dtype}}},Gae=Tn((t,n)=>Math.pow(t,n)),jae=er(Vd,Gae),qae={kernelName:Vd,backendName:"cpu",kernelFunc:jae};function $M(t,n,e,r){const[s,o]=Qn(t,r),i=ds(n,"int32"),a=gr(te(s),i),l=te(o);for(let u=0;u<a.length;++u){const c=u*l;let d=1;for(let h=0;h<l;++h)d*=e[c+h];a[u]=d}return{outVals:a,outShape:s,outDtype:i}}const Xae={kernelName:kw,backendName:"cpu",kernelFunc:function Kae(t){const{inputs:n,backend:e,attrs:r}=t,{x:s}=n,{axis:o,keepDims:i}=r;Ee(s,"prod");const a=s.shape.length,l=ft(o,s.shape),u=xn(l,a);let c=l,d=s;const h=[];null!=u&&(d=Vs({inputs:{x:s},backend:e,attrs:{perm:u}}),h.push(d),c=En(c.length,a));const f=e.data.get(d.dataId).values,{outVals:p,outShape:m,outDtype:g}=$M(d.shape,d.dtype,f,c);let y=m;return i&&(y=vn(m,l)),h.forEach(b=>e.disposeIntermediateTensorInfo(b)),e.makeTensorInfo(y,g,p)}};function FM(t,n,e,r){if(t===n||t<n&&e<0||n<t&&e>1)return gr(0,r);const l=gr(Math.abs(Math.ceil((n-t)/e)),r);n<t&&1===e&&(e=-1),l[0]=t;for(let u=1;u<l.length;u++)l[u]=l[u-1]+e;return l}const Zae={kernelName:Aw,backendName:"cpu",kernelFunc:function Yae(t){const{backend:n,attrs:e}=t,{start:r,stop:s,dtype:o,step:i}=e,a=FM(r,s,i,o);return n.makeTensorInfo([a.length],o,a)}},Qae=Pt(Ud,t=>1/t),Jae={kernelName:Ud,backendName:"cpu",kernelFunc:Qae},tle={kernelName:Gm,backendName:"cpu",kernelFunc:function ele(t){const{inputs:n,backend:e,attrs:r}=t,{images:s}=n,{alignCorners:o,halfPixelCenters:i,size:a}=r;Ee(s,"resizeBilinear");const l=Le(s.shape),[u,c]=a,[d,h,f,p]=s.shape,m=e.data.get(s.dataId).values,g=new Float32Array(te([d,u,c,p])),y=[o&&u>1?h-1:h,o&&c>1?f-1:f],b=[o&&u>1?u-1:u,o&&c>1?c-1:c];let v=0;const x=y[0]/b[0],w=y[1]/b[1];for(let _=0;_<d;_++)for(let D=0;D<u;D++){let A;A=i?x*(D+.5)-.5:x*D;const R=Math.max(0,Math.floor(A)),O=A-R,G=Math.min(h-1,Math.ceil(A)),K=_*l[0]+R*l[1],j=_*l[0]+G*l[1];for(let Q=0;Q<c;Q++){let q;q=i?w*(Q+.5)-.5:w*Q;const Y=Math.max(0,Math.floor(q)),re=q-Y,ee=Math.min(f-1,Math.ceil(q)),se=K+Y*l[2],ue=j+Y*l[2],de=K+ee*l[2],ge=j+ee*l[2];for(let pe=0;pe<p;pe++){const ye=m[se+pe],ve=m[ue+pe],Pe=ye+(m[de+pe]-ye)*re;g[v++]=Pe+(ve+(m[ge+pe]-ve)*re-Pe)*O}}}return e.makeTensorInfo([d,u,c,p],"float32",g)}},rle={kernelName:Fw,backendName:"cpu",kernelFunc:function nle(t){const{inputs:n,backend:e,attrs:r}=t,{images:s,dy:o}=n,{alignCorners:i}=r;Ee([o,s],"resizeBilinearGrad");const a=Le(s.shape),[l,u,c,d]=s.shape,[,h,f]=o.shape,p=new Float32Array(l*u*c*d),m=[i&&h>1?u-1:u,i&&f>1?c-1:c],g=[i&&h>1?h-1:h,i&&f>1?f-1:f],y=m[0]/g[0],b=m[1]/g[1],v=e.data.get(o.dataId).values;let x=0;for(let w=0;w<l;w++){const _=w*a[0];for(let D=0;D<h;D++){const A=D*y,R=Math.floor(A),O=Math.min(Math.ceil(A),u-1),G=_+R*a[1],K=_+O*a[1],j=A-R,Q=1-j;for(let q=0;q<f;q++){const Y=q*b,re=Math.floor(Y),ee=Math.min(Math.ceil(Y),c-1),se=Y-re,ue=1-se,de=G+re*a[2],ge=G+ee*a[2],pe=K+re*a[2],ye=K+ee*a[2],ve=Q*ue,De=Q*se,Te=j*ue,Pe=j*se;for(let Be=0;Be<d;Be++){const tt=v[x++];p[de+Be]+=tt*ve,p[ge+Be]+=tt*De,p[pe+Be]+=tt*Te,p[ye+Be]+=tt*Pe}}}}return e.makeTensorInfo([l,c,u,d],"float32",p)}},ole={kernelName:Hm,backendName:"cpu",kernelFunc:function sle(t){const{inputs:n,backend:e,attrs:r}=t,{images:s}=n,{alignCorners:o,halfPixelCenters:i,size:a}=r;Ee(s,"resizeNearestNeighbor");const l=Le(s.shape),[u,c]=a,[d,h,f,p]=s.shape,m=e.data.get(s.dataId).values,g=new Float32Array(d*u*c*p),y=[o&&u>1?h-1:h,o&&c>1?f-1:f],b=[o&&u>1?u-1:u,o&&c>1?c-1:c],v=y[0]/b[0],x=y[1]/b[1];let w=0;for(let _=0;_<d;_++){const D=_*l[0];for(let A=0;A<u;A++){const R=i?v*(A+.5):v*A;let O=Math.min(h-1,o?Math.round(R):Math.floor(R));i&&(O=Math.max(0,O));const G=D+O*l[1];for(let K=0;K<c;K++){const j=i?x*(K+.5):x*K;let Q=Math.min(f-1,o?Math.round(j):Math.floor(j));i&&(Q=Math.max(0,Q));const q=G+Q*l[2];for(let Y=0;Y<p;Y++)g[w++]=m[q+Y]}}}return e.makeTensorInfo([d,u,c,p],s.dtype,g)}},ale={kernelName:$w,backendName:"cpu",kernelFunc:function ile(t){const{inputs:n,backend:e,attrs:r}=t,{images:s,dy:o}=n,{alignCorners:i}=r;Ee([o,s],"resizeNearestNeighborGrad");const a=Le(s.shape),l=Le(o.shape),[u,c,d,h]=s.shape,[,f,p]=o.shape,m=new Float32Array(u*c*d*h),g=e.data.get(o.dataId).values,y=[i&&f>1?c-1:c,i&&p>1?d-1:d],b=[i&&f>1?f-1:f,i&&p>1?p-1:p],v=y[0]/b[0],x=y[1]/b[1],w=1/v,_=1/x,D=2*Math.ceil(w)+2,A=2*Math.ceil(_)+2;for(let R=0;R<u;R++){const O=R*a[0];for(let G=0;G<c;G++){const K=O+G*a[1],j=Math.floor(G*w),Q=Math.floor(j-D/2);for(let q=0;q<d;q++){const Y=K+q*a[2],re=Math.floor(q*_),ee=Math.floor(re-A/2);for(let se=0;se<h;se++){let ue=0;for(let de=0;de<D;de++){const ge=de+Q;if(ge<0||ge>=f)continue;const pe=O+ge*l[1],ye=ge*v;if(G===Math.min(c-1,i?Math.round(ye):Math.floor(ye)))for(let De=0;De<A;De++){const Te=De+ee;if(Te<0||Te>=p)continue;const Pe=pe+Te*l[2],Be=Te*x;q===Math.min(d-1,i?Math.round(Be):Math.floor(Be))&&(ue+=g[Pe+se])}}m[Y+se]=ue}}}}return e.makeTensorInfo(s.shape,s.dtype,m)}},ule={kernelName:jm,backendName:"cpu",kernelFunc:function lle(t){const{inputs:n,backend:e,attrs:r}=t,{x:s}=n,{dims:o}=r;Ee(s,"reverse");const i=s.shape.length,a=ft(o,s.shape);if(0===i)return Fo({inputs:{x:s},backend:e});const l=new Xn(s.shape,s.dtype),u=e.bufferSync(s);for(let c=0;c<l.size;c++){const d=l.indexToLoc(c),h=d.slice();a.forEach(f=>h[f]=s.shape[f]-1-h[f]),l.set(u.get(...h),...d)}return e.makeTensorInfo(l.shape,l.dtype,l.values)}},cle={kernelName:Ww,backendName:"cpu",kernelFunc:({inputs:t,attrs:n,backend:e})=>{const{image:r}=t,{radians:s,fillValue:o,center:i}=n,a=e,l=or(r.dtype,te(r.shape)),[u,c,d,h]=r.shape,[f,p]=cI(i,c,d),g=Math.sin(s),y=Math.cos(s),b=a.data.get(r.dataId).values;for(let x=0;x<u;x++){const w=x*d*c*h;for(let _=0;_<c;_++){const D=_*(d*h);for(let A=0;A<d;A++){const R=A*h;for(let O=0;O<h;O++){const G=[u,_,A,O],K=G[2],j=G[1];let Q=(K-f)*y-(j-p)*g,q=(K-f)*g+(j-p)*y;Q=Math.round(Q+f),q=Math.round(q+p);let Y=o;"number"!=typeof o&&(Y=3===O?255:o[O]),Q>=0&&Q<d&&q>=0&&q<c&&(Y=b[w+q*(d*h)+Q*h+O]),l[w+D+R+O]=Y}}}}return{dataId:a.write(l,r.shape,r.dtype),shape:r.shape,dtype:r.dtype}}},dle=Pt(Gd,t=>{const n=Math.floor(t);return t-n<.5?Math.floor(t):t-n>.5?Math.ceil(t):n%2==0?n:n+1}),hle={kernelName:Gd,backendName:"cpu",kernelFunc:dle},OM=Ru(t=>1/Math.sqrt(t)),fle=Au(jd,OM),ple={kernelName:jd,backendName:"cpu",kernelFunc:fle};function MM(t,n,e,r,s,o,i,a,l,u){const c=[r/s,s],d=t.values,h=n.values;if(0===r)return yt(e,n.dtype);const f=yt(c,n.dtype);f.values.fill(l);for(let p=0;p<o;p++){const m=[];let g=0;for(let y=0;y<i;y++){const b=d[p*i+y];m.push(b),g+=b*a[y]}if(g<0||g>=r/s)throw new Error(`Invalid indices: ${m} does not index into ${e}`);for(let y=0;y<s;y++)u?f.values[g*s+y]+=h[p*s+y]:f.values[g*s+y]=0===n.rank?h[0]:h[p*s+y]}return f}const gle={kernelName:Ow,backendName:"cpu",kernelFunc:function mle(t){const{inputs:n,backend:e,attrs:r}=t,{indices:s,updates:o}=n,{shape:i}=r,{sliceRank:a,numUpdates:l,sliceSize:u,strides:c,outputSize:d}=Th(0,s,i),m=MM(e.bufferSync(s),e.bufferSync(o),i,d,u,l,a,c,0,!0);return e.makeTensorInfo(i,m.dtype,m.values)}},ble={kernelName:qm,backendName:"cpu",kernelFunc:function yle(t){const{inputs:n,backend:e}=t,{condition:r,t:s,e:o}=n;Ee([r,s,o],"select");const i=r.shape.length,a=e.data.get(r.dataId).values,l=e.data.get(s.dataId).values,u=e.data.get(o.dataId).values,c=ds(s.dtype,o.dtype),d=gr(te(s.shape),c);let h=0;const f=0===i||i>1||1===s.shape.length?1:te(s.shape.slice(1));for(let p=0;p<a.length;p++)for(let m=0;m<f;m++)d[h++]=1===a[p]?l[p]:u[p];return e.makeTensorInfo(s.shape,c,d)}},vle=zg,xle=Vg,wle=Pt(qd,t=>t>=0?xle*t:vle*(Math.exp(t)-1)),Cle={kernelName:qd,backendName:"cpu",kernelFunc:wle},Ile=Pt(Zd,t=>1/(1+Math.exp(-t))),Dle={kernelName:Zd,backendName:"cpu",kernelFunc:Ile},_le=Pt(Yd,t=>t<0?-1:t>0?1:0),Sle={kernelName:Yd,backendName:"cpu",kernelFunc:_le},Ele=Pt(Kd,t=>Math.sin(t)),Nle={kernelName:Kd,backendName:"cpu",kernelFunc:Ele},Tle=Pt(Xd,t=>Math.sinh(t)),kle={kernelName:Xd,backendName:"cpu",kernelFunc:Tle},PM=Math.log(1.1920928955078125e-7)+2,Ale=Pt(Qd,t=>{const n=t>-PM,e=t<PM,r=Math.exp(t);let s;return s=e?r:n?t:Math.log(1+r),s}),Rle={kernelName:Qd,backendName:"cpu",kernelFunc:Ale},Fle={kernelName:Ym,backendName:"cpu",kernelFunc:function $le(t){const{inputs:n,backend:e,attrs:r}=t,{x:s}=n,{blockShape:o,paddings:i}=r;Ee([s],"spaceToBatchND");const a=te(o),l=[[0,0]];l.push(...i);for(let _=1+o.length;_<s.shape.length;++_)l.push([0,0]);const u=RM.kernelFunc({inputs:{x:s},backend:e,attrs:{paddings:l,constantValue:0}}),c=Sh(u.shape,o,a,!1),d=Eh(c.length,o.length,!1),h=Nh(u.shape,o,a,!1),m=sn({inputs:{x:u},backend:e,attrs:{shape:c}}),b=Vs({inputs:{x:m},backend:e,attrs:{perm:d}}),w=sn({inputs:{x:b},backend:e,attrs:{shape:h}});return e.disposeIntermediateTensorInfo(u),e.disposeIntermediateTensorInfo(m),e.disposeIntermediateTensorInfo(b),w}},Mle={kernelName:Pw,backendName:"cpu",kernelFunc:function Ole(t){const{inputs:n,backend:e,attrs:r}=t,{sparseIndices:s,sparseValues:o,defaultValue:i}=n,{outputShape:a}=r,{sliceRank:l,numUpdates:u,sliceSize:c,strides:d,outputSize:h}=Th(0,s,a),y=MM(e.bufferSync(s),e.bufferSync(o),a,h,c,u,l,d,e.data.get(i.dataId).values[0],!1);return e.makeTensorInfo(a,y.dtype,y.values)}},Lle={kernelName:Zm,backendName:"cpu",kernelFunc:function Ple(t){const{inputs:n,backend:e,attrs:r}=t,{x:s}=n,{numOrSizeSplits:o,axis:i}=r,a=ft(i,s.shape)[0],l=wI(s,o,a),u=new Array(s.shape.length).fill(0),c=s.shape.slice();return l.map(d=>{const h=[...c];h[a]=d;const f=Ja({inputs:{x:s},backend:e,attrs:{begin:u,size:h}});return u[a]+=d,f})}},Ble=Pt(Jd,t=>Math.sqrt(t)),zle={kernelName:Jd,backendName:"cpu",kernelFunc:Ble},Vle={kernelName:Mw,backendName:"cpu",kernelFunc:({inputs:t,backend:n})=>{const{x:e}=t,r=n;Ee(e,"square");const s=r.data.get(e.dataId).values,o=new Float32Array(s.length);for(let a=0;a<s.length;++a){const l=s[a];o[a]=l*l}return{dataId:r.write(o,e.shape,e.dtype),shape:e.shape,dtype:e.dtype}}},LM=Tn((t,n)=>{const e=t-n;return e*e}),Ule=er(eh,LM),Wle={kernelName:eh,backendName:"cpu",kernelFunc:Ule},Hle=Pt(oh,(t,n)=>{const e=n;return isNaN(t)?NaN:t>0?1:e.alpha}),Gle={kernelName:oh,backendName:"cpu",kernelFunc:Hle};function BM(t,n,e,r){const s=yt(t,n.dtype);for(let o=0;o<s.size;o++){const i=s.indexToLoc(o),a=new Array(i.length);for(let l=0;l<a.length;l++)a[l]=i[l]*e[l]+r[l];s.set(n.get(...a),...i)}return s}const qle={kernelName:Lw,backendName:"cpu",kernelFunc:function jle(t){const{inputs:n,backend:e,attrs:r}=t,{x:s}=n,{begin:o,end:i,strides:a,beginMask:l,endMask:u,ellipsisMask:c,newAxisMask:d,shrinkAxisMask:h}=r;Ee(s,"stridedSlice");const{nonStrided:f,$begin:p,$strides:m,size:g,newShape:y,outShape:b}=vC(s.shape,o,i,a,l,u,c,d,h),v=sn({inputs:{x:s},backend:e,attrs:{shape:y}});let x;if(f){const _=Ja({inputs:{x:v},backend:e,attrs:{begin:p,size:g}});x=sn({inputs:{x:_},backend:e,attrs:{shape:b}}),e.disposeIntermediateTensorInfo(_)}else if(b.some(_=>0===_))x=e.makeTensorInfo(b,s.dtype,[]);else{const D=BM(b,e.bufferSync(v),m,p);x=e.makeTensorInfo(D.shape,D.dtype,D.values)}const w=sn({inputs:{x},backend:e,attrs:{shape:b}});return e.disposeIntermediateTensorInfo(v),e.disposeIntermediateTensorInfo(x),w}},Kle=Pt(nh,t=>Math.tan(t)),Xle={kernelName:nh,backendName:"cpu",kernelFunc:Kle},Yle=Pt(rh,t=>Math.tanh(t));function zM(t,n){const e=new Array(t.rank);for(let s=0;s<e.length;s++)e[s]=t.shape[s]*n[s];const r=yt(e,t.dtype);for(let s=0;s<r.values.length;++s){const o=r.indexToLoc(s),i=new Array(t.rank);for(let l=0;l<i.length;l++)i[l]=o[l]%t.shape[l];const a=t.locToIndex(i);r.values[s]=t.values[a]}return r}function VM(t,n,e,r,s){const o=n[n.length-1],[i,a]=[t.length/o,o],l=or(e,i*r),u=or("int32",i*r);for(let d=0;d<i;d++){const h=d*a,f=t.subarray(h,h+a),p=[];for(let b=0;b<f.length;b++)p.push({value:f[b],index:b});p.sort((b,v)=>v.value-b.value);const m=d*r,g=l.subarray(m,m+r),y=u.subarray(m,m+r);for(let b=0;b<r;b++)g[b]=p[b].value,y[b]=p[b].index}const c=n.slice();return c[c.length-1]=r,[yt(c,e,l),yt(c,"int32",u)]}function UM(t,n,e){switch(e){case"reflect":return function sue(t,n){let e=t;if(e<0)if(n<=1)e=0;else{const r=2*n;e<r&&(e=r*Math.trunc(-e/r)+e),e=e<-n?e+r:-e-1}else if(e>n-1)if(n<=1)e=0;else{const r=2*n;e-=r*Math.trunc(e/r),e>=n&&(e=r-e-1)}return ka(0,e,n-1)}(t,n);case"wrap":return function oue(t,n){let e=t;return e<0?n<=1?e=0:e+=n*(Math.trunc(-e/(n-1))+1):e>n-1&&(n<=1?e=0:e-=n*Math.trunc(e/(n-1))),ka(0,e,n-1)}(t,n);case"nearest":return function aue(t,n){return ka(0,t,n-1)}(t,n);default:return function iue(t,n){return t}(t)}}function qh(t,n,e,r,s,o,i,a,l,u,c){return 0<=a&&a<n&&0<=l&&l<e?t[i*r+a*s+l*o+u]:c}function lue(t,n,e,r,s,o,i,a,l,u,c){return qh(t,n,e,r,s,o,i,Math.round(a),Math.round(l),u,c)}function uue(t,n,e,r,s,o,i,a,l,u,c){const d=Math.floor(a),h=Math.floor(l),f=d+1,p=h+1;return(f-a)*((p-l)*qh(t,n,e,r,s,o,i,d,h,u,c)+(l-h)*qh(t,n,e,r,s,o,i,d,p,u,c))+(a-d)*((p-l)*qh(t,n,e,r,s,o,i,f,h,u,c)+(l-h)*qh(t,n,e,r,s,o,i,f,p,u,c))}function WM(t,n,e,r){const s=ft(n,e)[0],o=[1,e[0],1];for(let p=0;p<s;p++)o[0]*=e[p];o[1]=e[s];for(let p=s+1;p<e.length;p++)o[2]*=e[p];const i={},a=new Int32Array(e[s]),l=new Xn(o,r,t),u=[],c=1===o[0]&&1===o[2];for(let p=0;p<e[s];p++){let m;if(c)m=t[p].toString();else{const g=[];for(let y=0;y<o[0];y++)for(let b=0;b<o[2];b++)g.push(l.get(y,p,b));m=g.join(",")}if(void 0!==i[m])a[p]=i[m];else{const g=Object.keys(i).length;i[m]=g,a[p]=g,u.push(p)}}const d=o.slice();d[1]=Object.keys(i).length;const h=new Xn(d,r);u.forEach((p,m)=>{for(let g=0;g<o[0];g++)for(let y=0;y<o[2];y++)h.set(l.get(g,p,y),g,m,y)});const f=e.slice();return f[s]=d[1],{outputValues:h.values,outputShape:f,indices:a}}const gue=[Zre,Qre,ese,nse,qre,sse,ase,use,dse,fse,mse,yse,vse,Cse,Dse,Ese,Tse,Ase,$se,Xre,Ose,Lse,zse,Gre,Use,Hse,Wre,Gse,qse,Yse,Qse,Kse,noe,soe,eoe,ioe,loe,coe,hoe,poe,goe,yoe,voe,woe,Ioe,Doe,Soe,_oe,n_,Mre,Noe,koe,Loe,Boe,zoe,Uoe,Qoe,Joe,tie,rie,iie,lie,cie,hie,pie,gie,vie,Pre,wie,jse,Iie,_ie,Eie,Lre,Tie,Rie,Fie,Mie,Lie,Vie,Wie,jie,Kie,Yie,Jie,tae,rae,oae,aae,uae,Zie,hae,pae,gae,bae,wae,_ae,Hoe,Eae,kae,$ae,Mae,Lae,zae,Uae,Wae,RM,qae,zre,Xae,Zae,Hre,Jae,Vre,Ure,Kre,tle,rle,ole,ale,ule,cle,hle,ple,gle,ble,Cle,Dle,Sle,Nle,kle,Mse,Iae,Rle,Fle,Mle,Lle,zle,Vle,Wle,Gle,qle,qoe,cae,Xle,{kernelName:rh,backendName:"cpu",kernelFunc:Yle},{kernelName:sh,backendName:"cpu",kernelFunc:function Qle(t){const{inputs:n,backend:e,attrs:r}=t,{x:s}=n,{reps:o}=r;Ee(s,"tile");const i=zM(e.bufferSync(s),o);return e.makeTensorInfo(i.shape,i.dtype,i.values)}},{kernelName:Bw,backendName:"cpu",kernelFunc:function eue(t){const{inputs:n,backend:e,attrs:r}=t,{x:s}=n,{k:o}=r;Ee(s,"topk");const a=e.data.get(s.dataId).values,[l,u]=VM(a,s.shape,s.dtype,o);return[e.makeTensorInfo(l.shape,l.dtype,l.values),e.makeTensorInfo(u.shape,u.dtype,u.values)]}},ose,{kernelName:zw,backendName:"cpu",kernelFunc:function nue(t){const{inputs:n,attrs:e,backend:r}=t,{image:s,transforms:o}=n,{interpolation:i,fillMode:a,fillValue:l,outputShape:u}=e,[c,d,h,f]=s.shape,[p,m]=u??[d,h],g=[c,p,m,f],y=Le(s.shape),b=y[0],v=y[1],x=y[2],w=or(s.dtype,te(g));w.fill(l);const _=r.data.get(s.dataId).values,D=r.data.get(o.dataId).values;for(let R=0;R<c;++R){const O=1===o.shape[0]?D:D.subarray(8*R,8*R+8);for(let G=0;G<p;++G)for(let K=0;K<m;++K)for(let j=0;j<f;++j){let Q;const q=O[6]*K+O[7]*G+1;if(0===q)continue;const re=(O[3]*K+O[4]*G+O[5])/q,ee=UM((O[0]*K+O[1]*G+O[2])/q,h,a),se=UM(re,d,a);switch(i){case"nearest":Q=lue(_,d,h,b,v,x,R,se,ee,j,l);break;case"bilinear":Q=uue(_,d,h,b,v,x,R,se,ee,j,l);break;default:throw new Error(`Error in Transform: Expect 'nearest' or 'bilinear', but got ${i}`)}w[R*b+G*v+K*x+j]=Q}return r.makeTensorInfo(g,s.dtype,w)}return{dataId:r.write(w,g,s.dtype),shape:s.shape,dtype:s.dtype}}},{kernelName:Vw,backendName:"cpu",kernelFunc:function cue(t){const{inputs:n,attrs:e,backend:r}=t,{axis:s}=e,{x:o}=n;Ee(o,"unique");const i=r.data.get(o.dataId).values,{outputValues:a,outputShape:l,indices:u}=WM(i,s,o.shape,o.dtype);return[r.makeTensorInfo(l,o.dtype,a),r.makeTensorInfo([u.length],"int32",u)]}},{kernelName:eg,backendName:"cpu",kernelFunc:function hue(t){const{inputs:n,backend:e,attrs:r}=t,{value:s}=n;let{axis:o}=r;o<0&&(o+=s.shape.length);const i=s.shape.length,a=s.shape[o],l=new Array(i-1);let u=0;for(let f=0;f<i;f++)f!==o&&(l[u++]=s.shape[f]);const c=new Array(i).fill(0),d=s.shape.slice();d[o]=1;const h=new Array(a);for(let f=0;f<h.length;f++){c[o]=f;const p=Ja({inputs:{x:s},backend:e,attrs:{begin:c,size:d}});h[f]=sn({inputs:{x:p},backend:e,attrs:{shape:l}}),e.disposeIntermediateTensorInfo(p)}return h}},{kernelName:tg,backendName:"cpu",kernelFunc:function pue(t){const{inputs:n,backend:e,attrs:r}=t,{x:s,segmentIds:o}=n,{numSegments:i}=r;Ee(s,"unsortedSegmentSum");const u=[],c=[],d=s.shape.length-o.shape.length;let h=o;for(let p=0;p<d;++p){const m=Iy({inputs:{input:h},backend:e,attrs:{dim:p+1}});h=m,c.push(m)}for(let p=0;p<i;++p){const m=Oi(p,"int32"),g=e.makeTensorInfo([],"int32",m),y=dM({inputs:{a:g,b:h},backend:e}),b=Yi({inputs:{x:y},backend:e,attrs:{dtype:"float32"}}),v=e_({inputs:{a:b,b:s},backend:e}),x=Dy({inputs:{x:v},backend:e,attrs:{axis:0,keepDims:!1}});u.push(x),c.push(g),c.push(y),c.push(b),c.push(v),c.push(x)}const f=AM({inputs:u,backend:e,attrs:{axis:0}});return c.forEach(p=>e.disposeIntermediateTensorInfo(p)),f}},Vae];for(const t of gue)jw(t);const Zi={},i_={alpha:!1,antialias:!1,premultipliedAlpha:!1,preserveDrawingBuffer:!1,depth:!1,stencil:!1,failIfMajorPerformanceCaveat:!0};function Oo(t){if(!(t in Zi)){const e=function vue(t){if(1!==t&&2!==t)throw new Error("Cannot get WebGL rendering context, WebGL is disabled.");const n=function bue(t){if(typeof OffscreenCanvas<"u"&&2===t)return new OffscreenCanvas(300,150);if(typeof document<"u")return document.createElement("canvas");throw new Error("Cannot create a canvas in this context")}(t);return n.addEventListener("webglcontextlost",e=>{e.preventDefault(),delete Zi[t]},!1),1===t?n.getContext("webgl",i_)||n.getContext("experimental-webgl",i_):n.getContext("webgl2",i_)}(t);if(null===e)return console.log("Could not get context for WebGL version",t),null;Zi[t]=e}const n=Zi[t];return n.isContextLost()?(delete Zi[t],Oo(t)):(n.disable(n.DEPTH_TEST),n.disable(n.STENCIL_TEST),n.disable(n.BLEND),n.disable(n.DITHER),n.disable(n.POLYGON_OFFSET_FILL),n.disable(n.SAMPLE_COVERAGE),n.enable(n.SCISSOR_TEST),n.enable(n.CULL_FACE),n.cullFace(n.BACK),Zi[t])}var Ou=(()=>{return(t=Ou||(Ou={}))[t.DENSE=0]="DENSE",t[t.SHARED_BATCH=1]="SHARED_BATCH",Ou;var t})(),Qr=(()=>{return(t=Qr||(Qr={}))[t.RENDER=0]="RENDER",t[t.UPLOAD=1]="UPLOAD",t[t.PIXELS=2]="PIXELS",t[t.DOWNLOAD=3]="DOWNLOAD",Qr;var t})(),tr=(()=>{return(t=tr||(tr={}))[t.UNPACKED_FLOAT16=0]="UNPACKED_FLOAT16",t[t.UNPACKED_FLOAT32=1]="UNPACKED_FLOAT32",t[t.PACKED_4X1_UNSIGNED_BYTE=2]="PACKED_4X1_UNSIGNED_BYTE",t[t.PACKED_2X2_FLOAT32=3]="PACKED_2X2_FLOAT32",t[t.PACKED_2X2_FLOAT16=4]="PACKED_2X2_FLOAT16",tr;var t})();function Kh(t,n){return[n,t]}function Xh(t){const n=te(t);return G0(Math.ceil(n/4))}function Mu(t,n){return[Math.max(1,Math.ceil(n/2)),Math.max(1,Math.ceil(t/2))]}function a_(t,n){const e=t;let r,s,o,i,a,l,u,c,d,h;return 2===ne().getNumber("WEBGL_VERSION")?(r=e.R32F,s=e.R16F,o=e.RGBA16F,i=e.RGBA32F,a=e.RED,u=4,c=1,d=e.HALF_FLOAT,h=e.FLOAT):(r=t.RGBA,s=t.RGBA,o=t.RGBA,i=e.RGBA,a=t.RGBA,u=4,c=4,d=null!=n?n.HALF_FLOAT_OES:null,h=t.FLOAT),l=t.RGBA,{internalFormatFloat:r,internalFormatHalfFloat:s,internalFormatPackedHalfFloat:o,internalFormatPackedFloat:i,textureFormatFloat:a,downloadTextureFormat:l,downloadUnpackNumChannels:u,defaultNumChannels:c,textureTypeHalfFloat:d,textureTypeFloat:h}}function Ne(t,n){const e=n();return ne().getBool("DEBUG")&&function Cue(t){const n=t.getError();if(n!==t.NO_ERROR)throw new Error("WebGL Error: "+function Sue(t,n){switch(n){case t.NO_ERROR:return"NO_ERROR";case t.INVALID_ENUM:return"INVALID_ENUM";case t.INVALID_VALUE:return"INVALID_VALUE";case t.INVALID_OPERATION:return"INVALID_OPERATION";case t.INVALID_FRAMEBUFFER_OPERATION:return"INVALID_FRAMEBUFFER_OPERATION";case t.OUT_OF_MEMORY:return"OUT_OF_MEMORY";case t.CONTEXT_LOST_WEBGL:return"CONTEXT_LOST_WEBGL";default:return`Unknown error code ${n}`}}(t,n))}(t),e}function _ue(t){return!!(ne().getBool("WEBGL_RENDER_FLOAT32_ENABLED")||0===t||5.96e-8<Math.abs(t)&&Math.abs(t)<65504)}function Sy(t,n){return gi(t,()=>t.getExtension(n),'Extension "'+n+'" not supported on this browser.')}const Tue=/ERROR: [0-9]+:([0-9]+):/g;function l_(t,n){if(Ne(t,()=>t.validateProgram(n)),!1===t.getProgramParameter(n,t.VALIDATE_STATUS))throw console.log(t.getProgramInfoLog(n)),new Error("Shader program validation failed.")}function HM(t,n,e,r,s,o,i){const a=t.getAttribLocation(n,e);return-1!==a&&(Ne(t,()=>t.bindBuffer(t.ARRAY_BUFFER,r)),Ne(t,()=>t.vertexAttribPointer(a,s,t.FLOAT,!1,o,i)),Ne(t,()=>t.enableVertexAttribArray(a)),!0)}function Vue(t,n,e,r){Ne(t,()=>function Lue(t,n,e){(function jM(t,n){const e=t.MAX_COMBINED_TEXTURE_IMAGE_UNITS-1,r=n+t.TEXTURE0;if(r<t.TEXTURE0||r>e)throw new Error(`textureUnit must be in [gl.TEXTURE0, gl.TEXTURE${e}].`)})(t,e),Ne(t,()=>t.activeTexture(t.TEXTURE0+e)),Ne(t,()=>t.bindTexture(t.TEXTURE_2D,n))}(t,n,r)),Ne(t,()=>t.uniform1i(e,r))}function u_(t,n,e){Ne(t,()=>t.bindFramebuffer(t.FRAMEBUFFER,e)),Ne(t,()=>t.framebufferTexture2D(t.FRAMEBUFFER,t.COLOR_ATTACHMENT0,t.TEXTURE_2D,n,0))}function GM(t,n){Ne(t,()=>t.bindFramebuffer(t.FRAMEBUFFER,n)),Ne(t,()=>t.framebufferTexture2D(t.FRAMEBUFFER,t.COLOR_ATTACHMENT0,t.TEXTURE_2D,null,0))}function Ey(t){const n=t.checkFramebufferStatus(t.FRAMEBUFFER);if(n!==t.FRAMEBUFFER_COMPLETE)throw new Error("Error binding framebuffer: "+function Uue(t,n){switch(n){case t.FRAMEBUFFER_INCOMPLETE_ATTACHMENT:return"FRAMEBUFFER_INCOMPLETE_ATTACHMENT";case t.FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT:return"FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT";case t.FRAMEBUFFER_INCOMPLETE_DIMENSIONS:return"FRAMEBUFFER_INCOMPLETE_DIMENSIONS";case t.FRAMEBUFFER_UNSUPPORTED:return"FRAMEBUFFER_UNSUPPORTED";default:return`unknown error ${n}`}}(t,n))}function gi(t,n,e){const r=Ne(t,()=>n());if(null==r)throw new Error(e);return r}function Pu(t,n=2){return te(t.slice(0,t.length-n))}function Lu(t){if(0===t.length)throw Error("Cannot get rows and columns of an empty shape array.");return[t.length>1?t[t.length-2]:1,t[t.length-1]]}function c_(t){let n=[1,1,1];return 0===t.length||1===t.length&&1===t[0]||(n=[Pu(t),...Lu(t)]),n}function Ny(t){return t%2==0}function Ty(t,n){if(Mt(t=t.slice(-2),n=n.slice(-2))||!t.length||!n.length||0===t[0]||0===t[1]||0===n[0]||0===n[1])return!0;if(t.length!==n.length){const e=t.slice(-1)[0],r=n.slice(-1)[0];if(e===r||Ny(e)&&Ny(r)&&(1===t[0]||1===n[0]))return!0}return t[1]===n[1]&&Ny(t[0])&&Ny(n[0])}let ky,Ay;function Us(t,n){return null!=t.getExtension(n)}function qM(t){try{if(null!=Oo(t))return!0}catch(n){return console.log("Error when getting WebGL context: ",n),!1}return!1}function d_(t){const n=a_(t),e=t.createTexture();t.bindTexture(t.TEXTURE_2D,e),t.texImage2D(t.TEXTURE_2D,0,n.internalFormatFloat,1,1,0,n.textureFormatFloat,n.textureTypeFloat,null);const o=t.createFramebuffer();t.bindFramebuffer(t.FRAMEBUFFER,o),t.framebufferTexture2D(t.FRAMEBUFFER,t.COLOR_ATTACHMENT0,t.TEXTURE_2D,e,0);const i=t.checkFramebufferStatus(t.FRAMEBUFFER)===t.FRAMEBUFFER_COMPLETE;return t.bindTexture(t.TEXTURE_2D,null),t.bindFramebuffer(t.FRAMEBUFFER,null),t.deleteTexture(e),t.deleteFramebuffer(o),i}function Yh(t,n){Array.isArray(t)||(t=[t]),t.forEach(e=>{null!=e&&S("complex64"!==e.dtype,()=>`${n} does not support complex64 tensors in the WebGL backend.`)})}const He=ne();function Er(){let t,n,e,r,s,o,i,a,l,u;return 2===ne().getNumber("WEBGL_VERSION")?(t="#version 300 es",n="in",e="out",r="in",s="texture",o="outputColor",i="out vec4 outputColor;",a="\n      bool isnan_custom(float val) {\n        return (val > 0.0 || val < 0.0) ? false : val != 0.0;\n      }\n\n      bvec4 isnan_custom(vec4 val) {\n        return bvec4(isnan_custom(val.x),\n          isnan_custom(val.y), isnan_custom(val.z), isnan_custom(val.w));\n      }\n\n      #define isnan(value) isnan_custom(value)\n    ",l="",u="\n      #define round(value) newRound(value)\n      int newRound(float value) {\n        return int(floor(value + 0.5));\n      }\n\n      ivec4 newRound(vec4 value) {\n        return ivec4(floor(value + vec4(0.5)));\n      }\n    "):(t="",n="attribute",e="varying",r="varying",s="texture2D",o="gl_FragColor",i="",a="\n      #define isnan(value) isnan_custom(value)\n      bool isnan_custom(float val) {\n        return (val > 0. || val < 1. || val == 0.) ? false : true;\n      }\n      bvec4 isnan_custom(vec4 val) {\n        return bvec4(isnan(val.x), isnan(val.y), isnan(val.z), isnan(val.w));\n      }\n    ",l="\n      uniform float INFINITY;\n\n      bool isinf(float val) {\n        return abs(val) == INFINITY;\n      }\n      bvec4 isinf(vec4 val) {\n        return equal(abs(val), vec4(INFINITY));\n      }\n    ",u="\n      int round(float value) {\n        return int(floor(value + 0.5));\n      }\n\n      ivec4 round(vec4 value) {\n        return ivec4(floor(value + vec4(0.5)));\n      }\n    "),{version:t,attribute:n,varyingVs:e,varyingFs:r,texture2D:s,output:o,defineOutput:i,defineSpecialNaN:a,defineSpecialInf:l,defineRound:u}}function el(t,n,e="index"){const r=Le(n);return r.map((s,o)=>`int ${t[o]} = ${e} / ${s}; ${o===r.length-1?`int ${t[o+1]} = ${e} - ${t[o]} * ${s}`:`index -= ${t[o]} * ${s}`};`).join("")}function h_(t){const n=Le(t).map(e=>e.toString());return`\n  int getFlatIndex(ivec3 coords) {\n    return coords.x * ${n[0]} + coords.y * ${n[1]} + coords.z;\n  }\n`}He.registerFlag("HAS_WEBGL",()=>He.getNumber("WEBGL_VERSION")>0),He.registerFlag("WEBGL_VERSION",()=>qM(2)?2:qM(1)?1:0),He.registerFlag("WEBGL_CHECK_NUMERICAL_PROBLEMS",()=>!1),He.registerFlag("WEBGL_BUFFER_SUPPORTED",()=>2===He.get("WEBGL_VERSION")),He.registerFlag("WEBGL_CPU_FORWARD",()=>!0),He.registerFlag("WEBGL_FORCE_F16_TEXTURES",()=>!1),He.registerFlag("WEBGL_PACK",()=>He.getBool("HAS_WEBGL")),He.registerFlag("WEBGL_PACK_NORMALIZATION",()=>He.getBool("WEBGL_PACK")),He.registerFlag("WEBGL_PACK_CLIP",()=>He.getBool("WEBGL_PACK")),He.registerFlag("WEBGL_PACK_DEPTHWISECONV",()=>!1),He.registerFlag("WEBGL_PACK_BINARY_OPERATIONS",()=>He.getBool("WEBGL_PACK")),He.registerFlag("WEBGL_PACK_UNARY_OPERATIONS",()=>He.getBool("WEBGL_PACK")),He.registerFlag("WEBGL_PACK_ARRAY_OPERATIONS",()=>He.getBool("WEBGL_PACK")),He.registerFlag("WEBGL_PACK_IMAGE_OPERATIONS",()=>He.getBool("WEBGL_PACK")),He.registerFlag("WEBGL_PACK_REDUCE",()=>He.getBool("WEBGL_PACK")),He.registerFlag("WEBGL_LAZILY_UNPACK",()=>He.getBool("WEBGL_PACK")),He.registerFlag("WEBGL_CONV_IM2COL",()=>He.getBool("WEBGL_PACK")),He.registerFlag("WEBGL_MAX_TEXTURE_SIZE",()=>function Hue(t){if(null==ky){const n=Oo(t);ky=n.getParameter(n.MAX_TEXTURE_SIZE)}return ky}(He.getNumber("WEBGL_VERSION"))),He.registerFlag("WEBGL_MAX_TEXTURES_IN_SHADER",()=>function Gue(t){if(null==Ay){const n=Oo(t);Ay=n.getParameter(n.MAX_TEXTURE_IMAGE_UNITS)}return Math.min(16,Ay)}(He.getNumber("WEBGL_VERSION"))),He.registerFlag("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION",()=>{const t=He.getNumber("WEBGL_VERSION");return 0===t?0:function jue(t){if(0===t)return 0;let n;const e=Oo(t);return n=Us(e,"EXT_disjoint_timer_query_webgl2")&&2===t?2:Us(e,"EXT_disjoint_timer_query")?1:0,n}(t)}),He.registerFlag("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE",()=>He.getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")>0&&!d$()),He.registerFlag("WEBGL_RENDER_FLOAT32_CAPABLE",()=>function que(t){if(0===t)return!1;const n=Oo(t);if(1===t){if(!Us(n,"OES_texture_float"))return!1}else if(!Us(n,"EXT_color_buffer_float"))return!1;return d_(n)}(He.getNumber("WEBGL_VERSION"))),He.registerFlag("WEBGL_RENDER_FLOAT32_ENABLED",()=>!He.getBool("WEBGL_FORCE_F16_TEXTURES")&&He.getBool("WEBGL_RENDER_FLOAT32_CAPABLE")),He.registerFlag("WEBGL_DOWNLOAD_FLOAT_ENABLED",()=>function Kue(t){if(0===t)return!1;const n=Oo(t);if(1!==t){if(Us(n,"EXT_color_buffer_float"))return d_(n);const r="EXT_color_buffer_half_float";if(Us(n,r)){const s=n.getExtension(r);return function Xue(t,n){const e=a_(t,n),r=t.createTexture();t.bindTexture(t.TEXTURE_2D,r),t.texImage2D(t.TEXTURE_2D,0,e.internalFormatHalfFloat,1,1,0,e.textureFormatFloat,e.textureTypeHalfFloat,null);const i=t.createFramebuffer();t.bindFramebuffer(t.FRAMEBUFFER,i),t.framebufferTexture2D(t.FRAMEBUFFER,t.COLOR_ATTACHMENT0,t.TEXTURE_2D,r,0);const a=t.checkFramebufferStatus(t.FRAMEBUFFER)===t.FRAMEBUFFER_COMPLETE;return t.bindTexture(t.TEXTURE_2D,null),t.bindFramebuffer(t.FRAMEBUFFER,null),t.deleteTexture(r),t.deleteFramebuffer(i),a}(n,s)}return!1}return!(!Us(n,"OES_texture_float")||!Us(n,"WEBGL_color_buffer_float"))&&d_(n)}(He.getNumber("WEBGL_VERSION"))),He.registerFlag("WEBGL_FENCE_API_ENABLED",()=>function Yue(t){return 2===t&&null!=Oo(t).fenceSync}(He.getNumber("WEBGL_VERSION"))),He.registerFlag("WEBGL_SIZE_UPLOAD_UNIFORM",()=>He.getBool("WEBGL_RENDER_FLOAT32_ENABLED")?4:0),He.registerFlag("WEBGL_DELETE_TEXTURE_THRESHOLD",()=>-1,t=>{if(t<0&&-1!==t)throw new Error(`WEBGL_DELETE_TEXTURE_THRESHOLD must be -1 (indicating never delete) or at least 0, but got ${t}.`)}),He.registerFlag("WEBGL_FLUSH_THRESHOLD",()=>d$()&&He.getBool("IS_CHROME")?1:-1,t=>{if(t<0&&-1!==t)throw new Error(`WEBGL_FLUSH_THRESHOLD must be -1 (indicating never manual flush) or at least 0, but got ${t}.`)});const KM="\n  const float FLOAT_MAX = 1.70141184e38;\n  const float FLOAT_MIN = 1.17549435e-38;\n\n  lowp vec4 encode_float(highp float v) {\n    if (isnan(v)) {\n      return vec4(255, 255, 255, 255);\n    }\n\n    highp float av = abs(v);\n\n    if(av < FLOAT_MIN) {\n      return vec4(0.0, 0.0, 0.0, 0.0);\n    } else if(v > FLOAT_MAX) {\n      return vec4(0.0, 0.0, 128.0, 127.0) / 255.0;\n    } else if(v < -FLOAT_MAX) {\n      return vec4(0.0, 0.0,  128.0, 255.0) / 255.0;\n    }\n\n    highp vec4 c = vec4(0,0,0,0);\n\n    highp float e = floor(log2(av));\n    highp float m = exp2(fract(log2(av))) - 1.0;\n\n    c[2] = floor(128.0 * m);\n    m -= c[2] / 128.0;\n    c[1] = floor(32768.0 * m);\n    m -= c[1] / 32768.0;\n    c[0] = floor(8388608.0 * m);\n\n    highp float ebias = e + 127.0;\n    c[3] = floor(ebias / 2.0);\n    ebias -= c[3] * 2.0;\n    c[2] += floor(ebias) * 128.0;\n\n    c[3] += 128.0 * step(0.0, -v);\n\n    return c / 255.0;\n  }\n";class Zue{constructor(n){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.outPackingScheme=Ou.DENSE;const e=Xh(n),r=Er();this.outputShape=n,this.userCode=`\n      ivec3 outCoordsFromFlatIndex(int index) {\n        ${el(["r","c","d"],n)}\n        return ivec3(r, c, d);\n      }\n\n      void main() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n          vec2(${e[0]}, ${e[1]}));\n        int index = 4 * (resTexRC.x * ${e[1]} + resTexRC.y);\n\n        vec4 result = vec4(0.);\n\n        for (int i=0; i<4; i++) {\n          int flatIndex = index + i;\n          ivec3 rc = outCoordsFromFlatIndex(flatIndex);\n          result[i] = getA(rc.x, rc.y, rc.z);\n        }\n\n        ${r.output} = result;\n      }\n    `}}class Que{constructor(n){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outPackingScheme=Ou.DENSE;const e=Xh(n),r=Er();this.outputShape=n,this.userCode=`\n      ivec3 outCoordsFromFlatIndex(int index) {\n        ${el(["r","c","d"],n)}\n        return ivec3(r, c, d);\n      }\n\n      void main() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n          vec2(${e[0]}, ${e[1]}));\n        int index = 4 * (resTexRC.x * ${e[1]} + resTexRC.y);\n\n        vec4 result = vec4(0.);\n\n        for (int i=0; i<4; i++) {\n          int flatIndex = index + i;\n          ivec3 rc = outCoordsFromFlatIndex(flatIndex);\n          result[i] = getChannel(getA(rc.x, rc.y, rc.z), vec2(rc.y, rc.z));\n        }\n\n        ${r.output} = result;\n      }\n    `}}class Jue{constructor(n){this.variableNames=["A"],this.outTexUsage=Qr.DOWNLOAD;const e=Er();this.outputShape=n,this.userCode=`\n      ${KM}\n\n      void main() {\n        float x = getAAtOutCoords();\n        ${e.output} = encode_float(x);\n      }\n    `}}class ece{constructor(n){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!1,this.outTexUsage=Qr.DOWNLOAD;const e=Er();this.outputShape=n,this.userCode=`\n      ${KM}\n\n      void main() {\n        ivec3 coords = getOutputCoords();\n        float x = getChannel(getAAtOutCoords(), vec2(coords.y, coords.z));\n        ${e.output} = encode_float(x);\n      }\n    `}}class tce{constructor(n,e,r=!1){this.variableNames=["A"];const s=Er(),[o,i]=e;this.outputShape=n;let a="result";r&&(a="floor(result * 255. + 0.5)"),this.userCode=`\n      ${h_(n)}\n\n      void main() {\n        ivec3 coords = getOutputCoords();\n\n        int flatIndex = getFlatIndex(coords);\n        int offset = imod(flatIndex, 4);\n\n        flatIndex = idiv(flatIndex, 4, 1.);\n\n        int r = flatIndex / ${i};\n        int c = imod(flatIndex, ${i});\n        vec2 uv = (vec2(c, r) + halfCR) / vec2(${i}.0, ${o}.0);\n        vec4 values = ${s.texture2D}(A, uv);\n\n        float result;\n\n        if(offset == 0) {\n          result = values[0];\n        } else if(offset == 1) {\n          result = values[1];\n        } else if(offset == 2) {\n          result = values[2];\n        } else {\n          result = values[3];\n        }\n\n        ${s.output} = vec4(${a}, 0., 0., 0.);\n      }\n    `}}class nce{constructor(n,e,r=!1){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0;const s=Er(),[o,i]=e;this.outputShape=n;let a="",l="result";r&&(l="floor(result * 255. + 0.5)");for(let u=0;u<=1;u++)for(let c=0;c<=1;c++){const d=2*u+c;a+=`\n          localCoords = coords;\n          if(localCoords[2] + ${c} < ${n[2]}) {\n            localCoords[2] += ${c};\n            if(localCoords[1] + ${u} < ${n[1]}) {\n              localCoords[1] += ${u};\n\n              flatIndex = getFlatIndex(localCoords);\n              offset = imod(flatIndex, 4);\n\n              flatIndex = idiv(flatIndex, 4, 1.);\n\n              r = flatIndex / ${i};\n              c = imod(flatIndex, ${i});\n              uv = (vec2(c, r) + halfCR) / vec2(${i}.0, ${o}.0);\n              values = ${s.texture2D}(A, uv);\n\n              if(offset == 0) {\n                result[${d}] = values[0];\n              } else if(offset == 1) {\n                result[${d}] = values[1];\n              } else if(offset == 2) {\n                result[${d}] = values[2];\n              } else {\n                result[${d}] = values[3];\n              }\n            }\n          }\n        `}this.userCode=`\n      ${h_(n)}\n\n      void main() {\n        ivec3 coords = getOutputCoords();\n\n        vec4 result = vec4(0.);\n        int flatIndex, r, c, offset;\n        ivec3 localCoords;\n        vec2 uv;\n        vec4 values;\n\n        ${a}\n\n        ${s.output} = ${l};\n      }\n    `}}function Zh(t,n,e,r,s,o){!function Mue(t,n){const e=ne().getNumber("WEBGL_MAX_TEXTURE_SIZE");if(t<=0||n<=0)throw new Error(`Requested texture size [${t}x${n}] is invalid.`);if(t>e||n>e)throw new Error(`Requested texture size [${t}x${n}] greater than WebGL maximum on this browser / GPU [${e}x${e}].`)}(n,e);const i=function Oue(t){return gi(t,()=>t.createTexture(),"Unable to create WebGLTexture.")}(t),a=t.TEXTURE_2D;return Ne(t,()=>t.bindTexture(a,i)),Ne(t,()=>t.texParameteri(a,t.TEXTURE_WRAP_S,t.CLAMP_TO_EDGE)),Ne(t,()=>t.texParameteri(a,t.TEXTURE_WRAP_T,t.CLAMP_TO_EDGE)),Ne(t,()=>t.texParameteri(a,t.TEXTURE_MIN_FILTER,t.NEAREST)),Ne(t,()=>t.texParameteri(a,t.TEXTURE_MAG_FILTER,t.NEAREST)),Ne(t,()=>t.texImage2D(a,0,r,n,e,0,s,o,null)),Ne(t,()=>t.bindTexture(t.TEXTURE_2D,null)),i}function XM(t){return t.internalFormatFloat}function YM(t){return t.internalFormatHalfFloat}function ZM(t){return t.downloadTextureFormat}function QM(t){return t.internalFormatPackedFloat}function JM(t){return t.internalFormatPackedHalfFloat}class vce{constructor(n){this.outputTexture=null,this.program=null,this.disposed=!1,this.vertexAttrsAreBound=!1,this.itemsToPoll=[];const e=ne().getNumber("WEBGL_VERSION");null!=n?(this.gl=n,function yue(t,n){Zi[t]=n}(e,n)):this.gl=Oo(e);let r="WEBGL_color_buffer_float";const s="EXT_color_buffer_half_float";if(1===ne().getNumber("WEBGL_VERSION")){const i="OES_texture_half_float";if(this.textureFloatExtension=Sy(this.gl,"OES_texture_float"),Us(this.gl,i))this.textureHalfFloatExtension=Sy(this.gl,i);else if(ne().get("WEBGL_FORCE_F16_TEXTURES"))throw new Error("GL context does not support half float textures, yet the environment flag WEBGL_FORCE_F16_TEXTURES is set to true.");if(this.colorBufferFloatExtension=this.gl.getExtension(r),Us(this.gl,s))this.colorBufferHalfFloatExtension=Sy(this.gl,s);else if(ne().get("WEBGL_FORCE_F16_TEXTURES"))throw new Error("GL context does not support color renderable half floats, yet the environment flag WEBGL_FORCE_F16_TEXTURES is set to true.")}else if(r="EXT_color_buffer_float",Us(this.gl,r))this.colorBufferFloatExtension=this.gl.getExtension(r);else{if(!Us(this.gl,s))throw new Error("GL context does not support color renderable floats");this.colorBufferHalfFloatExtension=this.gl.getExtension(s)}this.vertexBuffer=function sce(t){return function $ue(t,n){const e=gi(t,()=>t.createBuffer(),"Unable to create WebGLBuffer");return Ne(t,()=>t.bindBuffer(t.ARRAY_BUFFER,e)),Ne(t,()=>t.bufferData(t.ARRAY_BUFFER,n,t.STATIC_DRAW)),e}(t,new Float32Array([-1,1,0,0,1,-1,-1,0,0,0,1,1,0,1,1,1,-1,0,1,0]))}(this.gl),this.indexBuffer=function oce(t){return function Fue(t,n){const e=gi(t,()=>t.createBuffer(),"Unable to create WebGLBuffer");return Ne(t,()=>t.bindBuffer(t.ELEMENT_ARRAY_BUFFER,e)),Ne(t,()=>t.bufferData(t.ELEMENT_ARRAY_BUFFER,n,t.STATIC_DRAW)),e}(t,new Uint16Array([0,1,2,2,1,3]))}(this.gl),this.framebuffer=function Pue(t){return gi(t,()=>t.createFramebuffer(),"Unable to create WebGLFramebuffer.")}(this.gl),this.textureConfig=a_(this.gl,this.textureHalfFloatExtension)}get debug(){return ne().getBool("DEBUG")}dispose(){if(this.disposed)return;null!=this.program&&console.warn("Disposing a GPGPUContext that still has a bound WebGLProgram. This is probably a resource leak, delete the program with GPGPUContext.deleteProgram before disposing."),null!=this.outputTexture&&console.warn("Disposing a GPGPUContext that still has a bound output matrix texture.  This is probably a resource leak, delete the output matrix texture with GPGPUContext.deleteMatrixTexture before disposing.");const n=this.gl;Ne(n,()=>n.finish()),Ne(n,()=>n.bindFramebuffer(n.FRAMEBUFFER,null)),Ne(n,()=>n.deleteFramebuffer(this.framebuffer)),Ne(n,()=>n.bindBuffer(n.ARRAY_BUFFER,null)),Ne(n,()=>n.bindBuffer(n.ELEMENT_ARRAY_BUFFER,null)),Ne(n,()=>n.deleteBuffer(this.indexBuffer)),this.disposed=!0}createFloat32MatrixTexture(n,e){return this.throwIfDisposed(),function ice(t,n,e,r){const[s,o]=Kh(n,e);return Zh(t,s,o,XM(r),r.textureFormatFloat,t.FLOAT)}(this.gl,n,e,this.textureConfig)}createFloat16MatrixTexture(n,e){return this.throwIfDisposed(),function ace(t,n,e,r){const[s,o]=Kh(n,e);return Zh(t,s,o,YM(r),r.textureFormatFloat,r.textureTypeHalfFloat)}(this.gl,n,e,this.textureConfig)}createUnsignedBytesMatrixTexture(n,e){return this.throwIfDisposed(),function lce(t,n,e,r){const[s,o]=Kh(n,e);return Zh(t,s,o,ZM(r),t.RGBA,t.UNSIGNED_BYTE)}(this.gl,n,e,this.textureConfig)}uploadPixelDataToTexture(n,e){this.throwIfDisposed(),function fce(t,n,e){Ne(t,()=>t.bindTexture(t.TEXTURE_2D,n)),e.data instanceof Uint8Array?Ne(t,()=>t.texImage2D(t.TEXTURE_2D,0,t.RGBA,e.width,e.height,0,t.RGBA,t.UNSIGNED_BYTE,e.data)):Ne(t,()=>t.texImage2D(t.TEXTURE_2D,0,t.RGBA,t.RGBA,t.UNSIGNED_BYTE,e)),Ne(t,()=>t.bindTexture(t.TEXTURE_2D,null))}(this.gl,n,e)}uploadDenseMatrixToTexture(n,e,r,s){this.throwIfDisposed(),function hce(t,n,e,r,s,o){let i,a,l;Ne(t,()=>t.bindTexture(t.TEXTURE_2D,n)),s instanceof Uint8Array?(i=new Uint8Array(e*r*4),a=t.UNSIGNED_BYTE,l=t.RGBA):(i=new Float32Array(e*r*4),a=t.FLOAT,l=o.internalFormatPackedFloat),i.set(s),Ne(t,()=>t.texImage2D(t.TEXTURE_2D,0,l,e,r,0,t.RGBA,a,i)),Ne(t,()=>t.bindTexture(t.TEXTURE_2D,null))}(this.gl,n,e,r,s,this.textureConfig)}createFloat16PackedMatrixTexture(n,e){return this.throwIfDisposed(),function cce(t,n,e,r){const[s,o]=Mu(n,e);return Zh(t,s,o,JM(r),t.RGBA,r.textureTypeHalfFloat)}(this.gl,n,e,this.textureConfig)}createPackedMatrixTexture(n,e){return this.throwIfDisposed(),function uce(t,n,e,r){const[s,o]=Mu(n,e);return Zh(t,s,o,QM(r),t.RGBA,t.FLOAT)}(this.gl,n,e,this.textureConfig)}deleteMatrixTexture(n){this.throwIfDisposed(),this.outputTexture===n&&(GM(this.gl,this.framebuffer),this.outputTexture=null),Ne(this.gl,()=>this.gl.deleteTexture(n))}downloadByteEncodedFloatMatrixFromOutputTexture(n,e,r){return this.downloadMatrixDriver(n,()=>function gce(t,n,e,r){const[s,o]=Kh(n,e),a=new Uint8Array(function xue(t,n){return t*n}(n*e,4));return Ne(t,()=>t.readPixels(0,0,s,o,r.downloadTextureFormat,t.UNSIGNED_BYTE,a)),new Float32Array(a.buffer)}(this.gl,e,r,this.textureConfig))}downloadPackedMatrixFromBuffer(n,e,r,s,o,i){return function yce(t,n,e,r,s,o,i,a){const l=t,u=new Float32Array(function wue(t,n){const[e,r]=Mu(t,n);return e*r*4}(o,i));return l.bindBuffer(l.PIXEL_PACK_BUFFER,n),l.getBufferSubData(l.PIXEL_PACK_BUFFER,0,u),l.bindBuffer(l.PIXEL_PACK_BUFFER,null),u}(this.gl,n,0,0,0,o,i)}downloadFloat32MatrixFromBuffer(n,e){return function mce(t,n,e){const r=t,s=new Float32Array(e);return r.bindBuffer(r.PIXEL_PACK_BUFFER,n),r.getBufferSubData(r.PIXEL_PACK_BUFFER,0,s),r.bindBuffer(r.PIXEL_PACK_BUFFER,null),s}(this.gl,n,e)}createBufferFromTexture(n,e,r){this.bindTextureToFrameBuffer(n);const s=function pce(t,n,e,r){const s=t.createBuffer();Ne(t,()=>t.bindBuffer(t.PIXEL_PACK_BUFFER,s));const a=16*n*e;return Ne(t,()=>t.bufferData(t.PIXEL_PACK_BUFFER,a,t.STREAM_READ)),Ne(t,()=>t.readPixels(0,0,e,n,t.RGBA,t.FLOAT,0)),Ne(t,()=>t.bindBuffer(t.PIXEL_PACK_BUFFER,null)),s}(this.gl,e,r);return this.unbindTextureToFrameBuffer(),s}createAndWaitForFence(){const n=this.createFence(this.gl);return this.pollFence(n)}createFence(n){let e,r;if(ne().getBool("WEBGL_FENCE_API_ENABLED")){const s=n,o=s.fenceSync(s.SYNC_GPU_COMMANDS_COMPLETE,0);n.flush(),r=()=>{const i=s.clientWaitSync(o,0,0);return i===s.ALREADY_SIGNALED||i===s.CONDITION_SATISFIED},e=o}else ne().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")>0?(e=this.beginQuery(),this.endQuery(),r=()=>this.isQueryAvailable(e,ne().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))):r=()=>!0;return{query:e,isFencePassed:r}}downloadMatrixFromPackedTexture(n,e,r){return this.downloadMatrixDriver(n,()=>function bce(t,n,e){const r=new Float32Array(n*e*4);return Ne(t,()=>t.readPixels(0,0,e,n,t.RGBA,t.FLOAT,r)),r}(this.gl,e,r))}createProgram(n){this.throwIfDisposed();const e=this.gl,r=function Nue(t,n){const e=gi(t,()=>t.createShader(t.FRAGMENT_SHADER),"Unable to create fragment WebGLShader.");if(Ne(t,()=>t.shaderSource(e,n)),Ne(t,()=>t.compileShader(e)),!1===t.getShaderParameter(e,t.COMPILE_STATUS))throw function kue(t,n){const e=Tue.exec(n);if(null==e)return console.log(`Couldn't parse line number in error: ${n}`),void console.log(t);const r=+e[1],s=t.split("\n"),o=s.length.toString().length+2,i=s.map((d,h)=>nu((h+1).toString(),o)+d);let a=0;for(let d=0;d<i.length;d++)a=Math.max(i[d].length,a);const l=i.slice(0,r-1),u=i.slice(r-1,r),c=i.slice(r);console.log(l.join("\n")),console.log(n.split("\n")[0]),console.log(`%c ${nu(u[0],a)}`,"border:1px solid red; background-color:#e3d2d2; color:#a61717"),console.log(c.join("\n"))}(n,t.getShaderInfoLog(e)),new Error("Failed to compile fragment shader.");return e}(e,n),s=function rce(t){const n=Er();return function Eue(t,n){const e=gi(t,()=>t.createShader(t.VERTEX_SHADER),"Unable to create vertex WebGLShader.");if(Ne(t,()=>t.shaderSource(e,n)),Ne(t,()=>t.compileShader(e)),!1===t.getShaderParameter(e,t.COMPILE_STATUS))throw console.log(t.getShaderInfoLog(e)),new Error("Failed to compile vertex shader.");return e}(t,`${n.version}\n    precision highp float;\n    ${n.attribute} vec3 clipSpacePos;\n    ${n.attribute} vec2 uv;\n    ${n.varyingVs} vec2 resultUV;\n\n    void main() {\n      gl_Position = vec4(clipSpacePos, 1);\n      resultUV = uv;\n    }`)}(e),o=function Aue(t){return gi(t,()=>t.createProgram(),"Unable to create WebGLProgram.")}(e);return Ne(e,()=>e.attachShader(o,s)),Ne(e,()=>e.attachShader(o,r)),function Rue(t,n){if(Ne(t,()=>t.linkProgram(n)),!1===t.getProgramParameter(n,t.LINK_STATUS))throw console.log(t.getProgramInfoLog(n)),new Error("Failed to link vertex and fragment shaders.")}(e,o),this.debug&&l_(e,o),this.vertexAttrsAreBound||(this.setProgram(o),this.vertexAttrsAreBound=function dce(t,n,e){return Ne(t,()=>t.bindBuffer(t.ARRAY_BUFFER,e)),HM(t,n,"clipSpacePos",e,3,20,0)&&HM(t,n,"uv",e,2,20,12)}(e,this.program,this.vertexBuffer)),o}deleteProgram(n){this.throwIfDisposed(),n===this.program&&(this.program=null),null!=n&&Ne(this.gl,()=>this.gl.deleteProgram(n))}setProgram(n){this.throwIfDisposed(),this.program=n,null!=this.program&&this.debug&&l_(this.gl,this.program),Ne(this.gl,()=>this.gl.useProgram(n))}getUniformLocation(n,e,r=!0){return this.throwIfDisposed(),r?function Bue(t,n,e){return gi(t,()=>t.getUniformLocation(n,e),'uniform "'+e+'" not present in program.')}(this.gl,n,e):function zue(t,n,e){return t.getUniformLocation(n,e)}(this.gl,n,e)}getAttributeLocation(n,e){return this.throwIfDisposed(),Ne(this.gl,()=>this.gl.getAttribLocation(n,e))}getUniformLocationNoThrow(n,e){return this.throwIfDisposed(),this.gl.getUniformLocation(n,e)}setInputMatrixTexture(n,e,r){this.throwIfDisposed(),this.throwIfNoProgram(),Vue(this.gl,n,e,r)}setOutputMatrixTexture(n,e,r){this.setOutputMatrixTextureDriver(n,r,e)}setOutputPackedMatrixTexture(n,e,r){this.throwIfDisposed();const[s,o]=Mu(e,r);this.setOutputMatrixTextureDriver(n,s,o)}setOutputMatrixWriteRegion(n,e,r,s){this.setOutputMatrixWriteRegionDriver(r,n,s,e)}setOutputPackedMatrixWriteRegion(n,e,r,s){throw new Error("setOutputPackedMatrixWriteRegion not implemented.")}debugValidate(){null!=this.program&&l_(this.gl,this.program),Ey(this.gl)}executeProgram(){this.throwIfDisposed(),this.throwIfNoProgram();const n=this.gl;this.debug&&this.debugValidate(),Ne(n,()=>n.drawElements(n.TRIANGLES,6,n.UNSIGNED_SHORT,0))}blockUntilAllProgramsCompleted(){this.throwIfDisposed(),Ne(this.gl,()=>this.gl.finish())}getQueryTimerExtension(){return null==this.disjointQueryTimerExtension&&(this.disjointQueryTimerExtension=Sy(this.gl,2===ne().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")?"EXT_disjoint_timer_query_webgl2":"EXT_disjoint_timer_query")),this.disjointQueryTimerExtension}getQueryTimerExtensionWebGL2(){return this.getQueryTimerExtension()}getQueryTimerExtensionWebGL1(){return this.getQueryTimerExtension()}beginQuery(){if(2===ne().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")){const r=this.gl,s=this.getQueryTimerExtensionWebGL2(),o=r.createQuery();return r.beginQuery(s.TIME_ELAPSED_EXT,o),o}const n=this.getQueryTimerExtensionWebGL1(),e=n.createQueryEXT();return n.beginQueryEXT(n.TIME_ELAPSED_EXT,e),e}endQuery(){if(2===ne().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")){const e=this.gl,r=this.getQueryTimerExtensionWebGL2();return void e.endQuery(r.TIME_ELAPSED_EXT)}const n=this.getQueryTimerExtensionWebGL1();n.endQueryEXT(n.TIME_ELAPSED_EXT)}waitForQueryAndGetTime(n){var e=this;return J(function*(){return yield jR(()=>e.disposed||e.isQueryAvailable(n,ne().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))),e.getQueryTime(n,ne().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))})()}getQueryTime(n,e){if(0===e)return null;if(2===e){const r=this.gl;return r.getQueryParameter(n,r.QUERY_RESULT)/1e6}{const r=this.getQueryTimerExtensionWebGL1();return r.getQueryObjectEXT(n,r.QUERY_RESULT_EXT)/1e6}}isQueryAvailable(n,e){if(0===e)return!0;if(2===e){const r=this.gl,s=this.getQueryTimerExtensionWebGL2(),o=r.getQueryParameter(n,r.QUERY_RESULT_AVAILABLE);return null==this.disjoint&&(this.disjoint=this.gl.getParameter(s.GPU_DISJOINT_EXT)),o&&!this.disjoint}{const r=this.getQueryTimerExtensionWebGL1(),s=r.getQueryObjectEXT(n,r.QUERY_RESULT_AVAILABLE_EXT);return null==this.disjoint&&(this.disjoint=this.gl.getParameter(r.GPU_DISJOINT_EXT)),s&&!this.disjoint}}pollFence(n){return new Promise(e=>{this.addItemToPoll(()=>n.isFencePassed(),()=>e())})}pollItems(){const n=function xce(t){let n=0;for(;n<t.length&&t[n]();++n);return n-1}(this.itemsToPoll.map(e=>e.isDoneFn));for(let e=0;e<=n;++e){const{resolveFn:r}=this.itemsToPoll[e];r()}this.itemsToPoll=this.itemsToPoll.slice(n+1)}addItemToPoll(n,e){this.itemsToPoll.push({isDoneFn:n,resolveFn:e}),!(this.itemsToPoll.length>1)&&jR(()=>(this.pollItems(),0===this.itemsToPoll.length))}bindTextureToFrameBuffer(n){this.throwIfDisposed(),u_(this.gl,n,this.framebuffer),this.debug&&Ey(this.gl)}unbindTextureToFrameBuffer(){null!=this.outputTexture?(u_(this.gl,this.outputTexture,this.framebuffer),this.debug&&Ey(this.gl)):GM(this.gl,this.framebuffer)}downloadMatrixDriver(n,e){this.bindTextureToFrameBuffer(n);const r=e();return this.unbindTextureToFrameBuffer(),r}setOutputMatrixTextureDriver(n,e,r){this.throwIfDisposed();const s=this.gl;u_(s,n,this.framebuffer),this.debug&&Ey(s),this.outputTexture=n,Ne(s,()=>s.viewport(0,0,e,r)),Ne(s,()=>s.scissor(0,0,e,r))}setOutputMatrixWriteRegionDriver(n,e,r,s){this.throwIfDisposed(),Ne(this.gl,()=>this.gl.scissor(n,e,r,s))}throwIfDisposed(){if(this.disposed)throw new Error("Attempted to use disposed GPGPUContext.")}throwIfNoProgram(){if(null==this.program)throw new Error("No GPU program is currently set.")}}const{getBroadcastDims:eP}=X;function wce(t,n,e,r){const s=[];t.forEach(p=>{const m=te(p.shapeInfo.logicalShape);p.shapeInfo.isUniform?s.push(`uniform float ${p.name}${m>1?`[${m}]`:""};`):(s.push(`uniform sampler2D ${p.name};`),s.push(`uniform int offset${p.name};`))});const o=s.join("\n"),i=t.map(p=>function Cce(t,n,e=!1){let r="";return r+=e?tP(t):Bu(t),t.shapeInfo.logicalShape.length<=n.logicalShape.length&&(r+=e?function tde(t,n){const e=t.name,r=e.charAt(0).toUpperCase()+e.slice(1),s="get"+r+"AtOutCoords",o=t.shapeInfo.logicalShape.length,i=n.logicalShape.length,a=eP(t.shapeInfo.logicalShape,n.logicalShape),l=Wt(i),u=i-o;let c;const d=["x","y","z","w","u","v"];c=0===o?"":i<2&&a.length>=1?"coords = 0;":a.map(b=>`coords.${d[b+u]} = 0;`).join("\n");let h="";h=i<2&&o>0?"coords":t.shapeInfo.logicalShape.map((b,v)=>`coords.${d[v+u]}`).join(", ");let f="return outputValue;";const m=1===te(t.shapeInfo.logicalShape),y=1===te(n.logicalShape);if(1!==o||m||y){if(m&&!y)f=1===i?"\n        return vec4(outputValue.x, outputValue.x, 0., 0.);\n      ":"\n        return vec4(outputValue.x);\n      ";else if(a.length){const b=o-2,v=o-1;a.indexOf(b)>-1&&a.indexOf(v)>-1?f="return vec4(outputValue.x);":a.indexOf(b)>-1?f="return vec4(outputValue.x, outputValue.y, outputValue.x, outputValue.y);":a.indexOf(v)>-1&&(f="return vec4(outputValue.xx, outputValue.zz);")}}else f="\n      return vec4(outputValue.xy, outputValue.xy);\n    ";return`\n    vec4 ${s}() {\n      ${l} coords = getOutputCoords();\n      ${c}\n      vec4 outputValue = get${r}(${h});\n      ${f}\n    }\n  `}(t,n):function nde(t,n){const e=t.name,r=e.charAt(0).toUpperCase()+e.slice(1),s="get"+r+"AtOutCoords",a=t.shapeInfo.logicalShape.length,l=n.logicalShape.length;if(!t.shapeInfo.isUniform&&a===l&&null==t.shapeInfo.flatOffset&&Mt(t.shapeInfo.texShape,n.texShape))return`\n      float ${s}() {\n        return sampleTexture(${e}, resultUV);\n      }\n    `;const u=Wt(l),c=eP(t.shapeInfo.logicalShape,n.logicalShape),d=l-a;let h;const f=["x","y","z","w","u","v"];h=0===a?"":l<2&&c.length>=1?"coords = 0;":c.map(m=>`coords.${f[m+d]} = 0;`).join("\n");let p="";return p=l<2&&a>0?"coords":t.shapeInfo.logicalShape.map((m,g)=>`coords.${f[g+d]}`).join(", "),`\n    float ${s}() {\n      ${u} coords = getOutputCoords();\n      ${h}\n      return get${r}(${p});\n    }\n  `}(t,n)),r}(p,n,r)).join("\n"),a=n.texShape,l=Er(),u=function _ce(t){return`\n    float sampleTexture(sampler2D textureSampler, vec2 uv) {\n      return ${t.texture2D}(textureSampler, uv).r;\n    }\n  `}(l);let c,d,h=function Nce(t){return`${t.version}\n    precision highp float;\n    precision highp int;\n    precision highp sampler2D;\n    ${t.varyingFs} vec2 resultUV;\n    ${t.defineOutput}\n    const vec2 halfCR = vec2(0.5, 0.5);\n\n    struct ivec5\n    {\n      int x;\n      int y;\n      int z;\n      int w;\n      int u;\n    };\n\n    struct ivec6\n    {\n      int x;\n      int y;\n      int z;\n      int w;\n      int u;\n      int v;\n    };\n\n    uniform float NAN;\n    ${t.defineSpecialNaN}\n    ${t.defineSpecialInf}\n    ${t.defineRound}\n\n    int imod(int x, int y) {\n      return x - y * (x / y);\n    }\n\n    int idiv(int a, int b, float sign) {\n      int res = a / b;\n      int mod = imod(a, b);\n      if (sign < 0. && mod != 0) {\n        res -= 1;\n      }\n      return res;\n    }\n\n    //Based on the work of Dave Hoskins\n    //https://www.shadertoy.com/view/4djSRW\n    #define HASHSCALE1 443.8975\n    float random(float seed){\n      vec2 p = resultUV * seed;\n      vec3 p3  = fract(vec3(p.xyx) * HASHSCALE1);\n      p3 += dot(p3, p3.yzx + 19.19);\n      return fract((p3.x + p3.y) * p3.z);\n    }\n\n    ${Tce}\n    ${kce}\n    ${Ace}\n  `}(l);return n.isPacked?(c=function Ice(t,n){switch(t.length){case 0:return"\n    int getOutputCoords() {\n      return 0;\n    }\n  ";case 1:return function $ce(t,n){const e=[Math.ceil(n[0]/2),Math.ceil(n[1]/2)];return 1===e[0]?`\n      int getOutputCoords() {\n        return 2 * int(resultUV.x * ${e[1]}.0);\n      }\n    `:1===e[1]?`\n      int getOutputCoords() {\n        return 2 * int(resultUV.y * ${e[0]}.0);\n      }\n    `:`\n    int getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${e[0]}, ${e[1]}));\n      return 2 * (resTexRC.x * ${e[1]} + resTexRC.y);\n    }\n  `}(0,n);case 2:return function Vce(t,n){const e=[Math.ceil(n[0]/2),Math.ceil(n[1]/2)];if(Mt(t,n))return`\n      ivec2 getOutputCoords() {\n        return 2 * ivec2(resultUV.yx * vec2(${e[0]}, ${e[1]}));\n      }\n    `;const r=Math.ceil(t[1]/2);return`\n    ivec2 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${e[0]}, ${e[1]}));\n\n      int index = resTexRC.x * ${e[1]} + resTexRC.y;\n      int r = 2 * (index / ${r});\n      int c = imod(index, ${r}) * 2;\n\n      return ivec2(r, c);\n    }\n  `}(t,n);case 3:return function Oce(t,n){const e=[Math.ceil(n[0]/2),Math.ceil(n[1]/2)],r=Math.ceil(t[2]/2),s=r*Math.ceil(t[1]/2);return`\n    ivec3 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${e[0]}, ${e[1]}));\n      int index = resTexRC.x * ${e[1]} + resTexRC.y;\n\n      int b = index / ${s};\n      index -= b * ${s};\n\n      int r = 2 * (index / ${r});\n      int c = imod(index, ${r}) * 2;\n\n      return ivec3(b, r, c);\n    }\n  `}(t,n);default:return function Pce(t,n){const e=[Math.ceil(n[0]/2),Math.ceil(n[1]/2)],r=Math.ceil(t[t.length-1]/2),s=r*Math.ceil(t[t.length-2]/2);let o=s,i="",a="b, r, c";for(let l=2;l<t.length-1;l++)o*=t[t.length-l-1],i=`\n      int b${l} = index / ${o};\n      index -= b${l} * ${o};\n    `+i,a=`b${l}, `+a;return`\n    ivec${t.length} getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${e[0]}, ${e[1]}));\n      int index = resTexRC.x * ${e[1]} + resTexRC.y;\n\n      ${i}\n\n      int b = index / ${s};\n      index -= b * ${s};\n\n      int r = 2 * (index / ${r});\n      int c = imod(index, ${r}) * 2;\n\n      return ivec${t.length}(${a});\n    }\n  `}(t,n)}}(n.logicalShape,a),d=function Ece(t){return`\n    void setOutput(vec4 val) {\n      ${t.output} = val;\n    }\n  `}(l)):(c=function Dce(t,n){switch(t.length){case 0:return"\n    int getOutputCoords() {\n      return 0;\n    }\n  ";case 1:return function Fce(t,n){return 1===n[0]?`\n      int getOutputCoords() {\n        return int(resultUV.x * ${n[1]}.0);\n      }\n    `:1===n[1]?`\n      int getOutputCoords() {\n        return int(resultUV.y * ${n[0]}.0);\n      }\n    `:`\n    int getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${n[0]}, ${n[1]}));\n      return resTexRC.x * ${n[1]} + resTexRC.y;\n    }\n  `}(0,n);case 2:return function Uce(t,n){return Mt(t,n)?`\n      ivec2 getOutputCoords() {\n        return ivec2(resultUV.yx * vec2(${n[0]}, ${n[1]}));\n      }\n    `:1===t[1]?`\n      ivec2 getOutputCoords() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n                               vec2(${n[0]}, ${n[1]}));\n        int index = resTexRC.x * ${n[1]} + resTexRC.y;\n        return ivec2(index, 0);\n      }\n    `:1===t[0]?`\n      ivec2 getOutputCoords() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n                               vec2(${n[0]}, ${n[1]}));\n        int index = resTexRC.x * ${n[1]} + resTexRC.y;\n        return ivec2(0, index);\n      }\n    `:`\n    ivec2 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${n[0]}, ${n[1]}));\n      int index = resTexRC.x * ${n[1]} + resTexRC.y;\n      int r = index / ${t[1]};\n      int c = index - r * ${t[1]};\n      return ivec2(r, c);\n    }\n  `}(t,n);case 3:return function Mce(t,n){const e=el(["r","c","d"],t);return`\n    ivec3 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${n[0]}, ${n[1]}));\n      int index = resTexRC.x * ${n[1]} + resTexRC.y;\n      ${e}\n      return ivec3(r, c, d);\n    }\n  `}(t,n);case 4:return function Lce(t,n){const e=el(["r","c","d","d2"],t);return`\n    ivec4 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n        vec2(${n[0]}, ${n[1]}));\n      int index = resTexRC.x * ${n[1]} + resTexRC.y;\n      ${e}\n      return ivec4(r, c, d, d2);\n    }\n  `}(t,n);case 5:return function Bce(t,n){const e=el(["r","c","d","d2","d3"],t);return`\n    ivec5 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx * vec2(${n[0]},\n                             ${n[1]}));\n\n      int index = resTexRC.x * ${n[1]} + resTexRC.y;\n\n      ${e}\n\n      ivec5 outShape = ivec5(r, c, d, d2, d3);\n      return outShape;\n    }\n  `}(t,n);case 6:return function zce(t,n){const e=el(["r","c","d","d2","d3","d4"],t);return`\n    ivec6 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n        vec2(${n[0]}, ${n[1]}));\n      int index = resTexRC.x * ${n[1]} + resTexRC.y;\n\n      ${e}\n\n      ivec6 result = ivec6(r, c, d, d2, d3, d4);\n      return result;\n    }\n  `}(t,n);default:throw new Error(`${t.length}-D output sampling is not yet supported`)}}(n.logicalShape,a),d=function Sce(t){return`\n    void setOutput(float val) {\n      ${t.output} = vec4(val, 0, 0, 0);\n    }\n  `}(l)),r&&(h+=Rce),[h,u,d,o,c,i,e].join("\n")}function Bu(t){const n=t.shapeInfo.logicalShape;switch(n.length){case 0:return function Hce(t){const n=t.name,e="get"+n.charAt(0).toUpperCase()+n.slice(1);if(t.shapeInfo.isUniform)return`float ${e}() {return ${n};}`;const[r,s]=t.shapeInfo.texShape;if(1===r&&1===s)return`\n      float ${e}() {\n        return sampleTexture(${n}, halfCR);\n      }\n    `;const[o,i]=t.shapeInfo.texShape;return`\n    float ${e}() {\n      vec2 uv = uvFromFlat(${o}, ${i}, ${tl(n)});\n      return sampleTexture(${n}, uv);\n    }\n  `}(t);case 1:return function jce(t){const n=t.name,e="get"+n.charAt(0).toUpperCase()+n.slice(1);if(t.shapeInfo.isUniform)return`\n      float ${e}(int index) {\n        ${zu(t)}\n      }\n    `;const r=t.shapeInfo.texShape,s=r[0],o=r[1];if(1===o&&1===s)return`\n      float ${e}(int index) {\n        return sampleTexture(${n}, halfCR);\n      }\n    `;const i=tl(n);return 1===o?`\n      float ${e}(int index) {\n        vec2 uv = vec2(0.5, (float(index + ${i}) + 0.5) / ${s}.0);\n        return sampleTexture(${n}, uv);\n      }\n    `:1===s?`\n      float ${e}(int index) {\n        vec2 uv = vec2((float(index + ${i}) + 0.5) / ${o}.0, 0.5);\n        return sampleTexture(${n}, uv);\n      }\n    `:`\n    float ${e}(int index) {\n      vec2 uv = uvFromFlat(${s}, ${o}, index + ${i});\n      return sampleTexture(${n}, uv);\n    }\n  `}(t);case 2:return function Kce(t){const n=t.shapeInfo.logicalShape,e=t.name,r="get"+e.charAt(0).toUpperCase()+e.slice(1),s=t.shapeInfo.texShape;if(null!=s&&Mt(n,s))return`\n    float ${r}(int row, int col) {\n      vec2 uv = (vec2(col, row) + halfCR) / vec2(${s[1]}.0, ${s[0]}.0);\n      return sampleTexture(${e}, uv);\n    }\n  `;const{newShape:o,keptDims:i}=Aa(n);if(o.length<n.length){const h=["row","col"];return`\n      ${Bu(Vu(t,o))}\n      float ${r}(int row, int col) {\n        return ${r}(${Uu(h,i)});\n      }\n    `}if(t.shapeInfo.isUniform)return`\n      float ${r}(int row, int col) {\n        int index = round(dot(vec2(row, col), vec2(${n[1]}, 1)));\n        ${zu(t)}\n      }\n    `;const l=s[0],u=s[1],c=tl(e);return 1===u?`\n    float ${r}(int row, int col) {\n      float index = dot(vec3(row, col, ${c}), vec3(${n[1]}, 1, 1));\n      vec2 uv = vec2(0.5, (index + 0.5) / ${l}.0);\n      return sampleTexture(${e}, uv);\n    }\n  `:1===l?`\n    float ${r}(int row, int col) {\n      float index = dot(vec3(row, col, ${c}), vec3(${n[1]}, 1, 1));\n      vec2 uv = vec2((index + 0.5) / ${u}.0, 0.5);\n      return sampleTexture(${e}, uv);\n    }\n  `:`\n  float ${r}(int row, int col) {\n    // Explicitly use integer operations as dot() only works on floats.\n    int index = row * ${n[1]} + col + ${c};\n    vec2 uv = uvFromFlat(${l}, ${u}, index);\n    return sampleTexture(${e}, uv);\n  }\n`}(t);case 3:return function Yce(t){const n=t.shapeInfo.logicalShape,e=t.name,r="get"+e.charAt(0).toUpperCase()+e.slice(1),s=n[1]*n[2],o=n[2],{newShape:i,keptDims:a}=Aa(n);if(i.length<n.length){const m=["row","col","depth"];return`\n        ${Bu(Vu(t,i))}\n        float ${r}(int row, int col, int depth) {\n          return ${r}(${Uu(m,a)});\n        }\n      `}if(t.shapeInfo.isUniform)return`\n      float ${r}(int row, int col, int depth) {\n        int index = round(dot(vec3(row, col, depth),\n                          vec3(${s}, ${o}, 1)));\n        ${zu(t)}\n      }\n    `;const u=t.shapeInfo.texShape,c=u[0],d=u[1],h=t.shapeInfo.flatOffset;if(d===s&&null==h)return`\n        float ${r}(int row, int col, int depth) {\n          float texR = float(row);\n          float texC = dot(vec2(col, depth), vec2(${o}, 1));\n          vec2 uv = (vec2(texC, texR) + halfCR) /\n                     vec2(${d}.0, ${c}.0);\n          return sampleTexture(${e}, uv);\n        }\n      `;if(d===o&&null==h)return`\n    float ${r}(int row, int col, int depth) {\n      float texR = dot(vec2(row, col), vec2(${n[1]}, 1));\n      float texC = float(depth);\n      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${d}.0, ${c}.0);\n      return sampleTexture(${e}, uv);\n    }\n  `;return`\n      float ${r}(int row, int col, int depth) {\n        // Explicitly use integer operations as dot() only works on floats.\n        int index = row * ${s} + col * ${o} + depth + ${tl(e)};\n        vec2 uv = uvFromFlat(${c}, ${d}, index);\n        return sampleTexture(${e}, uv);\n      }\n  `}(t);case 4:return function Qce(t){const n=t.shapeInfo.logicalShape,e=t.name,r="get"+e.charAt(0).toUpperCase()+e.slice(1),s=n[3],o=n[2]*s,i=n[1]*o,{newShape:a,keptDims:l}=Aa(n);if(a.length<n.length){const m=["row","col","depth","depth2"];return`\n      ${Bu(Vu(t,a))}\n      float ${r}(int row, int col, int depth, int depth2) {\n        return ${r}(${Uu(m,l)});\n      }\n    `}if(t.shapeInfo.isUniform)return`\n      float ${r}(int row, int col, int depth, int depth2) {\n        int index = round(dot(vec4(row, col, depth, depth2),\n                          vec4(${i}, ${o}, ${s}, 1)));\n        ${zu(t)}\n      }\n    `;const u=t.shapeInfo.flatOffset,c=t.shapeInfo.texShape,d=c[0],h=c[1];if(h===i&&null==u)return`\n      float ${r}(int row, int col, int depth, int depth2) {\n        float texR = float(row);\n        float texC =\n            dot(vec3(col, depth, depth2),\n                vec3(${o}, ${s}, 1));\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(${h}.0, ${d}.0);\n        return sampleTexture(${e}, uv);\n      }\n    `;if(h===s&&null==u)return`\n      float ${r}(int row, int col, int depth, int depth2) {\n        float texR = dot(vec3(row, col, depth),\n                         vec3(${n[1]*n[2]}, ${n[2]}, 1));\n        float texC = float(depth2);\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                  vec2(${h}.0, ${d}.0);\n        return sampleTexture(${e}, uv);\n      }\n    `;return`\n    float ${r}(int row, int col, int depth, int depth2) {\n      // Explicitly use integer operations as dot() only works on floats.\n      int index = row * ${i} + col * ${o} +\n          depth * ${s} + depth2;\n      vec2 uv = uvFromFlat(${d}, ${h}, index + ${tl(e)});\n      return sampleTexture(${e}, uv);\n    }\n  `}(t);case 5:return function Jce(t){const n=t.shapeInfo.logicalShape,e=t.name,r="get"+e.charAt(0).toUpperCase()+e.slice(1),s=n[4],o=n[3]*s,i=n[2]*o,a=n[1]*i,{newShape:l,keptDims:u}=Aa(n);if(l.length<n.length){const g=["row","col","depth","depth2","depth3"];return`\n      ${Bu(Vu(t,l))}\n      float ${r}(int row, int col, int depth, int depth2, int depth3) {\n        return ${r}(${Uu(g,u)});\n      }\n    `}if(t.shapeInfo.isUniform)return`\n      float ${r}(int row, int col, int depth, int depth2, int depth3) {\n        float index = dot(\n          vec4(row, col, depth, depth2),\n          vec4(${a}, ${i}, ${o}, ${s})) +\n          depth3;\n        ${zu(t)}\n      }\n    `;const c=t.shapeInfo.flatOffset,d=t.shapeInfo.texShape,h=d[0],f=d[1];if(f===a&&null==c)return`\n      float ${r}(int row, int col, int depth, int depth2, int depth3) {\n        int texR = row;\n        float texC = dot(vec4(col, depth, depth2, depth3),\n                         vec4(${i}, ${o}, ${s}, 1));\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(${f}.0, ${h}.0);\n        return sampleTexture(${e}, uv);\n      }\n    `;if(f===s&&null==c)return`\n      float ${r}(int row, int col, int depth, int depth2, int depth3) {\n        float texR = dot(\n          vec4(row, col, depth, depth2),\n          vec4(${n[1]*n[2]*n[3]},\n               ${n[2]*n[3]}, ${n[3]}, 1));\n        int texC = depth3;\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                  vec2(${f}.0, ${h}.0);\n        return sampleTexture(${e}, uv);\n      }\n    `;return`\n    float ${r}(int row, int col, int depth, int depth2, int depth3) {\n      // Explicitly use integer operations as dot() only works on floats.\n      int index = row * ${a} + col * ${i} + depth * ${o} +\n          depth2 * ${s} + depth3 + ${tl(e)};\n      vec2 uv = uvFromFlat(${h}, ${f}, index);\n      return sampleTexture(${e}, uv);\n    }\n  `}(t);case 6:return function ede(t){const n=t.shapeInfo.logicalShape,e=t.name,r="get"+e.charAt(0).toUpperCase()+e.slice(1),{newShape:s,keptDims:o}=Aa(n);if(s.length<n.length){const y=["row","col","depth","depth2","depth3","depth4"];return`\n      ${Bu(Vu(t,s))}\n      float ${r}(int row, int col, int depth,\n                    int depth2, int depth3, int depth4) {\n        return ${r}(${Uu(y,o)});\n      }\n    `}const i=n[5],a=n[4]*i,l=n[3]*a,u=n[2]*l,c=n[1]*u;if(t.shapeInfo.isUniform)return`\n      float ${r}(int row, int col, int depth,\n                  int depth2, int depth3, int depth4) {\n        int index = round(dot(\n          vec4(row, col, depth, depth2),\n          vec4(${c}, ${u}, ${l}, ${a})) +\n          dot(\n            vec2(depth3, depth4),\n            vec2(${i}, 1)));\n        ${zu(t)}\n      }\n    `;const d=t.shapeInfo.flatOffset,h=t.shapeInfo.texShape,f=h[0],p=h[1];if(p===c&&null==d)return`\n      float ${r}(int row, int col, int depth,\n                    int depth2, int depth3, int depth4) {\n        int texR = row;\n        float texC = dot(vec4(col, depth, depth2, depth3),\n          vec4(${u}, ${l}, ${a}, ${i})) +\n               float(depth4);\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(${p}.0, ${f}.0);\n        return sampleTexture(${e}, uv);\n      }\n    `;if(p===i&&null==d)return`\n      float ${r}(int row, int col, int depth,\n                    int depth2, int depth3, int depth4) {\n        float texR = dot(vec4(row, col, depth, depth2),\n          vec4(${n[1]*n[2]*n[3]*n[4]},\n               ${n[2]*n[3]*n[4]},\n               ${n[3]*n[4]},\n               ${n[4]})) + float(depth3);\n        int texC = depth4;\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                  vec2(${p}.0, ${f}.0);\n        return sampleTexture(${e}, uv);\n      }\n    `;return`\n    float ${r}(int row, int col, int depth,\n                  int depth2, int depth3, int depth4) {\n      // Explicitly use integer operations as dot() only works on floats.\n      int index = row * ${c} + col * ${u} + depth * ${l} +\n          depth2 * ${a} + depth3 * ${i} + depth4 + ${tl(e)};\n      vec2 uv = uvFromFlat(${f}, ${p}, index);\n      return sampleTexture(${e}, uv);\n    }\n  `}(t);default:throw new Error(`${n.length}-D input sampling is not yet supported`)}}function tP(t){switch(t.shapeInfo.logicalShape.length){case 0:return function Wce(t){const n=t.name;return`\n    vec4 ${"get"+n.charAt(0).toUpperCase()+n.slice(1)}() {\n      return ${Er().texture2D}(${n}, halfCR);\n    }\n  `}(t);case 1:return function Gce(t){const n=t.name,e="get"+n.charAt(0).toUpperCase()+n.slice(1),r=t.shapeInfo.texShape,s=[Math.ceil(r[0]/2),Math.ceil(r[1]/2)],o=Er();return`\n    vec4 ${e}(int index) {\n      vec2 uv = packedUVfrom1D(\n        ${s[0]}, ${s[1]}, index);\n      return ${o.texture2D}(${n}, uv);\n    }\n  `}(t);case 2:return function qce(t){const n=t.shapeInfo.logicalShape,e=t.name,r="get"+e.charAt(0).toUpperCase()+e.slice(1),s=t.shapeInfo.texShape,o=s[0],i=s[1],a=Er();if(null!=s&&Mt(n,s))return`\n      vec4 ${r}(int row, int col) {\n        vec2 uv = (vec2(col, row) + halfCR) / vec2(${i}.0, ${o}.0);\n\n        return ${a.texture2D}(${e}, uv);\n      }\n    `;const l=[Math.ceil(s[0]/2),Math.ceil(s[1]/2)];return`\n    vec4 ${r}(int row, int col) {\n      vec2 uv = packedUVfrom2D(${Math.ceil(n[1]/2)}, ${l[0]}, ${l[1]}, row, col);\n      return ${a.texture2D}(${e}, uv);\n    }\n  `}(t);case 3:return function Xce(t){const n=t.shapeInfo.logicalShape,e=t.name,r="get"+e.charAt(0).toUpperCase()+e.slice(1),s=t.shapeInfo.texShape,o=[Math.ceil(s[0]/2),Math.ceil(s[1]/2)];if(1===n[0]){const h=[1,2],p=["b","row","col"];return`\n        ${tP(Vu(t,n.slice(1)))}\n        vec4 ${r}(int b, int row, int col) {\n          return ${r}(${Uu(p,h)});\n        }\n      `}const i=o[0],a=o[1],l=Math.ceil(n[2]/2);return`\n    vec4 ${r}(int b, int row, int col) {\n      vec2 uv = packedUVfrom3D(\n        ${i}, ${a}, ${l*Math.ceil(n[1]/2)}, ${l}, b, row, col);\n      return ${Er().texture2D}(${e}, uv);\n    }\n  `}(t);default:return function Zce(t){const n=t.shapeInfo.logicalShape,e=n.length,r=t.name,s="get"+r.charAt(0).toUpperCase()+r.slice(1),o=t.shapeInfo.texShape,i=[Math.ceil(o[0]/2),Math.ceil(o[1]/2)],a=i[0],l=i[1],u=Math.ceil(n[e-1]/2);let c=u*Math.ceil(n[e-2]/2),d="int b, int row, int col",h=`b * ${c} + (row / 2) * ${u} + (col / 2)`;for(let p=2;p<e-1;p++)d=`int b${p}, `+d,c*=n[e-p-1],h=`b${p} * ${c} + `+h;return`\n    vec4 ${s}(${d}) {\n      int index = ${h};\n      int texR = index / ${l};\n      int texC = index - texR * ${l};\n      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${l}, ${a});\n      return ${Er().texture2D}(${r}, uv);\n    }\n  `}(t)}}const Tce="\nvec2 uvFromFlat(int texNumR, int texNumC, int index) {\n  int texR = index / texNumC;\n  int texC = index - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\nvec2 packedUVfrom1D(int texNumR, int texNumC, int index) {\n  int texelIndex = index / 2;\n  int texR = texelIndex / texNumC;\n  int texC = texelIndex - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\n",kce="\nvec2 packedUVfrom2D(int texelsInLogicalRow, int texNumR,\n  int texNumC, int row, int col) {\n  int texelIndex = (row / 2) * texelsInLogicalRow + (col / 2);\n  int texR = texelIndex / texNumC;\n  int texC = texelIndex - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\n",Ace="\nvec2 packedUVfrom3D(int texNumR, int texNumC,\n    int texelsInBatch, int texelsInLogicalRow, int b,\n    int row, int col) {\n  int index = b * texelsInBatch + (row / 2) * texelsInLogicalRow + (col / 2);\n  int texR = index / texNumC;\n  int texC = index - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\n",Rce="\n  float getChannel(vec4 frag, vec2 innerDims) {\n    vec2 modCoord = mod(innerDims, 2.);\n    return modCoord.x == 0. ?\n      (modCoord.y == 0. ? frag.r : frag.g) :\n      (modCoord.y == 0. ? frag.b : frag.a);\n  }\n  float getChannel(vec4 frag, int dim) {\n    float modCoord = mod(float(dim), 2.);\n    return modCoord == 0. ? frag.r : frag.g;\n  }\n";function tl(t){return`offset${t}`}function zu(t){const n=t.name,e=te(t.shapeInfo.logicalShape);return e<2?`return ${n};`:`\n    for (int i = 0; i < ${e}; i++) {\n      if (i == index) {\n        return ${n}[i];\n      }\n    }\n  `}function Wt(t){if(t<=1)return"int";if(2===t)return"ivec2";if(3===t)return"ivec3";if(4===t)return"ivec4";if(5===t)return"ivec5";if(6===t)return"ivec6";throw Error(`GPU for rank ${t} is not yet supported`)}function Vu(t,n){const e=JSON.parse(JSON.stringify(t));return e.shapeInfo.logicalShape=n,e}function Uu(t,n){return n.map(e=>t[e]).join(", ")}function rP(t,n){if(t.length!==n.length)throw Error(`Binary was compiled with ${t.length} inputs, but was executed with ${n.length} inputs`);t.forEach((e,r)=>{const s=e.logicalShape,o=n[r],i=o.shape;if(!Mt(s,i))throw Error(`Binary was compiled with different shapes than the current args. Shapes ${s} and ${i} must match`);if(e.isUniform&&o.isUniform)return;const a=e.texShape,l=o.isUniform?null:o.texData.texShape;if(!Mt(a,l))throw Error(`Binary was compiled with different texture shapes than the current args. Shape ${a} and ${l} must match`)})}const{addImpl:ide,bincountImpl:sP,bincountReduceImpl:ade,ceilImpl:lde,concatImpl:ude,expImpl:cde,expm1Impl:dde,floorImpl:hde,gatherV2Impl:fde,greaterImpl:pde,lessImpl:mde,linSpaceImpl:gde,logImpl:yde,maxImpl:bde,maximumImpl:vde,minimumImpl:xde,multiplyImpl:wde,negImpl:Cde,prodImpl:Ide,rangeImpl:Dde,rsqrtImpl:_de,simpleAbsImpl:oP,sliceImpl:Sde,stridedSliceImpl:Ede,subImpl:Nde,tileImpl:Tde,topKImpl:kde,transposeImpl:f_,uniqueImpl:Ade}=fe;function iP(t,n){return["x","y","z","w","u","v"].slice(0,n).map(e=>`${t}.${e}`)}function Nr(t,n){return 1===n?[t]:iP(t,n)}class $de{constructor(n){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.outputShape=n;const e=n.length;if(0===e)this.userCode="\n        void main() {\n          setOutput(vec4(getA(), 0., 0., 0.));\n        }\n      ";else{const r=Nr("rc",e),s=Wt(e),o=function Ode(t,n,e){if(1===t)return`rc > ${n[0]}`;let r="";for(let s=t-2;s<t;s++)r+=`${e[s]} >= ${n[s]}`,s<t-1&&(r+="||");return r}(e,n,r),i=function Mde(t,n,e,r){if(1===t)return"";const s=r.slice(-2);return`\n    int r = ${s[0]};\n    int c = ${s[1]};\n    int rp1 = r + 1;\n    int cp1 = c + 1;\n\n    bool cEdge = cp1 >= ${n};\n    bool rEdge = rp1 >= ${e};\n  `}(e,n[n.length-1],n[n.length-2],r),a=function Pde(t,n){const e=t.length,r=function Fde(t,n){const e=[];for(let r=0;r<=1;r++)for(let s=0;s<=1;s++){let o=`${0===r?"r":"rp1"}, ${0===s?"c":"cp1"}`;for(let i=2;i<t;i++)o=`${n[n.length-1-i]},`+o;e.push(o)}return e}(e,n);return 1===e?`getA(rc),\n            rc + 1 >= ${t[0]} ? 0. : getA(rc + 1),\n            0, 0`:`getA(${r[0]}),\n          cEdge ? 0. : getA(${r[1]}),\n          rEdge ? 0. : getA(${r[2]}),\n          rEdge || cEdge ? 0. : getA(${r[3]})`}(n,r);this.userCode=`\n        void main() {\n          ${s} rc = getOutputCoords();\n\n          if(${o}) {\n            setOutput(vec4(0));\n          } else {\n            ${i}\n\n            setOutput(vec4(${a}));\n          }\n        }\n      `}}}class aP{constructor(n,e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=n;let r="";for(let s=0;s<4;s++){let o="thisRC = rc;";s%2==1&&(o+="thisRC.z += 1;"),s>1&&(o+="thisRC.y += 1;"),r+=`\n        ${o}\n        ${s>0?"if(thisRC.y < rows && thisRC.z < cols){":""}\n          int flatIndex = getFlatIndex(thisRC);\n\n          ivec3 inputRC = inputCoordsFromReshapedOutCoords(flatIndex);\n          vec2 inputRCInnerDims = vec2(float(inputRC.y),float(inputRC.z));\n\n          result[${s}] =\n            getChannel(getA(inputRC.x, inputRC.y, inputRC.z), inputRCInnerDims);\n        ${s>0?"}":""}\n      `}this.userCode=`\n      ${function Lde(t){return`\n    ivec3 inputCoordsFromReshapedOutCoords(int index) {\n      ${el(["r","c","d"],t)}\n      return ivec3(r, c, d);\n    }\n  `}(e)}\n      ${h_(n)}\n\n      void main() {\n        ivec3 rc = getOutputCoords();\n\n        vec4 result = vec4(0.);\n\n        ivec3 thisRC;\n        int rows = ${n[1]};\n        int cols = ${n[2]};\n\n        ${r}\n\n        setOutput(result);\n      }\n    `}}class Bde{constructor(n){this.gpgpu=n,this.numUsedTextures=0,this.numFreeTextures=0,this._numBytesAllocated=0,this._numBytesFree=0,this.freeTextures={},this.logEnabled=!1,this.usedTextures={}}acquireTexture(n,e,r){const s=uP(e,r),o=cP(n,s,r);o in this.freeTextures||(this.freeTextures[o]=[]),o in this.usedTextures||(this.usedTextures[o]=[]);const i=lP(n,s,this.gpgpu.gl,this.gpgpu.textureConfig,r);if(this.freeTextures[o].length>0){this.numFreeTextures--,this.numUsedTextures++,this._numBytesFree-=i,this.log();const l=this.freeTextures[o].shift();return this.usedTextures[o].push(l),l}let a;return s===tr.PACKED_2X2_FLOAT32?a=this.gpgpu.createPackedMatrixTexture(n[0],n[1]):s===tr.PACKED_2X2_FLOAT16?a=this.gpgpu.createFloat16PackedMatrixTexture(n[0],n[1]):s===tr.UNPACKED_FLOAT32?a=this.gpgpu.createFloat32MatrixTexture(n[0],n[1]):s===tr.UNPACKED_FLOAT16?a=this.gpgpu.createFloat16MatrixTexture(n[0],n[1]):s===tr.PACKED_4X1_UNSIGNED_BYTE&&(a=this.gpgpu.createUnsignedBytesMatrixTexture(n[0],n[1])),this.usedTextures[o].push(a),this.numUsedTextures++,this._numBytesAllocated+=i,this.log(),a}releaseTexture(n,e,r,s){if(null==this.freeTextures)return;const o=uP(r,s),i=cP(e,o,s);i in this.freeTextures||(this.freeTextures[i]=[]);const a=lP(e,o,this.gpgpu.gl,this.gpgpu.textureConfig,s),l=ne().get("WEBGL_DELETE_TEXTURE_THRESHOLD");-1!==l&&this._numBytesAllocated>l?(this.gpgpu.deleteMatrixTexture(n),this._numBytesAllocated-=a):(this.freeTextures[i].push(n),this.numFreeTextures++,this._numBytesFree+=a),this.numUsedTextures--;const u=this.usedTextures[i],c=u.indexOf(n);if(c<0)throw new Error("Cannot release a texture that was never provided by this texture manager");u.splice(c,1),this.log()}log(){if(!this.logEnabled)return;console.log("Free/Used",`${this.numFreeTextures} / ${this.numUsedTextures}`,`(${this.numFreeTextures+this.numUsedTextures})`);const e=this._numBytesFree/this._numBytesAllocated;console.log(`Bytes allocated: ${this._numBytesAllocated}`),console.log(`Bytes unused: ${this._numBytesFree} (${Math.round(100*e)}%)`)}get numBytesAllocated(){return this._numBytesAllocated}get numBytesFree(){return this._numBytesFree}getNumUsedTextures(){return this.numUsedTextures}getNumFreeTextures(){return this.numFreeTextures}dispose(){if(null!=this.freeTextures){for(const n in this.freeTextures)this.freeTextures[n].forEach(e=>{this.gpgpu.deleteMatrixTexture(e)});for(const n in this.usedTextures)this.usedTextures[n].forEach(e=>{this.gpgpu.deleteMatrixTexture(e)});this.freeTextures=null,this.usedTextures=null,this.numUsedTextures=0,this.numFreeTextures=0,this._numBytesAllocated=0,this._numBytesFree=0}}}function lP(t,n,e,r,s){const o=function Vde(t,n){switch(t){case tr.PACKED_2X2_FLOAT32:return QM(n);case tr.PACKED_2X2_FLOAT16:return JM(n);case tr.UNPACKED_FLOAT32:return XM(n);case tr.UNPACKED_FLOAT16:return YM(n);case tr.PACKED_4X1_UNSIGNED_BYTE:return ZM(n);default:throw new Error(`Unknown physical texture type ${t}`)}}(n,r);let i;if(s){const[l,u]=Mu(t[0],t[1]);i=l*u}else{const[l,u]=Kh(t[0],t[1]);i=l*u}const a=function zde(t,n){if(n===t.R32F)return 4;if(n===t.R16F)return 2;if(n===t.RGBA32F)return 16;if(n===t.RGBA)return 16;if(n===t.RGBA16F)return 8;throw new Error(`Unknown internal format ${n}`)}(e,o);return i*a}function uP(t,n){if(t===Qr.UPLOAD)return tr.PACKED_2X2_FLOAT32;if(t===Qr.RENDER||null==t)return function Ude(t){return ne().getBool("WEBGL_RENDER_FLOAT32_ENABLED")?t?tr.PACKED_2X2_FLOAT32:tr.UNPACKED_FLOAT32:t?tr.PACKED_2X2_FLOAT16:tr.UNPACKED_FLOAT16}(n);if(t===Qr.DOWNLOAD||t===Qr.PIXELS)return tr.PACKED_4X1_UNSIGNED_BYTE;throw new Error(`Unknown logical texture type ${t}`)}function cP(t,n,e){return`${t[0]}_${t[1]}_${n}_${e}`}class Qi{constructor(n,e){this.variableNames=["A"],this.outputShape=n,this.userCode=`\n      float unaryOperation(float x) {\n        ${e}\n      }\n\n      void main() {\n        float x = getAAtOutCoords();\n        float y = unaryOperation(x);\n\n        setOutput(y);\n      }\n    `}}const dP="return abs(x);",$y="return x;";class Wu{constructor(n,e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=n,this.userCode=`\n      vec4 unaryOperation(vec4 x) {\n        ${e}\n      }\n\n      void main() {\n        vec4 x = getAAtOutCoords();\n        vec4 y = unaryOperation(x);\n\n        setOutput(y);\n      }\n    `}}class Zde{constructor(n){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!1,this.outputShape=n;const e=n.length,r=Nr("rc",e),s=Wt(e),o=function Rde(t,n){if(1===t)return"rc";let e="";for(let r=0;r<t;r++)e+=n[r],r<t-1&&(e+=",");return e}(e,r),i=r.slice(-2),a=e<=1?"rc":`vec2(${i.join(",")})`;this.userCode=`\n      void main() {\n        ${s} rc = getOutputCoords();\n        vec4 packedInput = getA(${o});\n\n        setOutput(getChannel(packedInput, ${a}));\n      }\n    `}}const Qde=DI,Fy={};let ohe=(()=>{class t extends W0{constructor(e){if(super(),this.pendingRead=new WeakMap,this.pendingDisposal=new WeakSet,this.dataRefCount=new WeakMap,this.numBytesInGPU=0,this.uploadWaitMs=0,this.downloadWaitMs=0,this.lastGlFlushTime=0,this.warnedAboutMemory=!1,this.warnedAboutCPUBackend=!1,this.pendingDeletes=0,this.disposed=!1,!ne().getBool("HAS_WEBGL"))throw new Error("WebGL is not supported on this device");if(null==e){const r=Oo(ne().getNumber("WEBGL_VERSION"));this.binaryCache=function the(t){return t in Fy||(Fy[t]={}),Fy[t]}(ne().getNumber("WEBGL_VERSION")),this.gpgpu=new vce(r),this.canvas=r.canvas,this.gpgpuCreatedLocally=!0}else this.gpgpu=e,this.binaryCache={},this.gpgpuCreatedLocally=!1,this.canvas=e.gl.canvas;this.textureManager=new Bde(this.gpgpu),this.numMBBeforeWarning=function she(){return null==ne().global.screen?1024:ne().global.screen.height*ne().global.screen.width*window.devicePixelRatio*600/1024/1024}(),this.texData=new WR(this,Pi())}nextDataId(){return t.nextDataId++}numDataIds(){return this.texData.numDataIds()+(this.cpuBackend?this.cpuBackend.numDataIds():0)-this.pendingDeletes}write(e,r,s){if((ne().getBool("WEBGL_CHECK_NUMERICAL_PROBLEMS")||ne().getBool("DEBUG"))&&this.checkNumericalProblems(e),"complex64"===s&&null!=e)throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");const o={id:this.nextDataId()};return this.texData.set(o,{shape:r,dtype:s,values:e,usage:Qr.UPLOAD,refCount:1}),o}refCount(e){return this.texData.has(e)?this.texData.get(e).refCount:0}incRef(e){this.texData.get(e).refCount++}decRef(e){this.texData.has(e)&&this.texData.get(e).refCount--}move(e,r,s,o,i){if(ne().getBool("DEBUG")&&this.checkNumericalProblems(r),"complex64"===o)throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");this.texData.set(e,{shape:s,dtype:o,values:r,usage:Qr.UPLOAD,refCount:i})}disposeIntermediateTensorInfo(e){this.disposeData(e.dataId)}readSync(e){const r=this.texData.get(e),{values:s,dtype:o,complexTensorInfos:i,slice:a,shape:l,isPacked:u}=r;if(null!=a){let f;f=u?new Wu(l,$y):new Qi(l,$y);const p=this.runWebGLProgram(f,[{dataId:e,shape:l,dtype:o}],o),m=this.readSync(p.dataId);return this.disposeIntermediateTensorInfo(p),m}if(null!=s)return this.convertAndCacheOnCPU(e);if("string"===o)return s;const c=null!=this.activeTimers;let d,h;return c&&(d=Pr()),h="complex64"===o?di(this.readSync(i.real.dataId),this.readSync(i.imag.dataId)):this.getValuesFromTexture(e),c&&(this.downloadWaitMs+=Pr()-d),this.convertAndCacheOnCPU(e,h)}read(e){var r=this;return J(function*(){if(r.pendingRead.has(e)){const g=r.pendingRead.get(e);return new Promise(y=>g.push(y))}const s=r.texData.get(e),{values:o,shape:i,slice:a,dtype:l,complexTensorInfos:u,isPacked:c}=s;if(null!=a){let g;g=c?new Wu(i,$y):new Qi(i,$y);const y=r.runWebGLProgram(g,[{dataId:e,shape:i,dtype:l}],l),b=r.read(y.dataId);return r.disposeIntermediateTensorInfo(y),b}if(null!=o)return r.convertAndCacheOnCPU(e);if(!ne().getBool("WEBGL_DOWNLOAD_FLOAT_ENABLED")&&2===ne().getNumber("WEBGL_VERSION"))throw new Error("tensor.data() with WEBGL_DOWNLOAD_FLOAT_ENABLED=false and WEBGL_VERSION=2 not yet supported.");let h,f,d=null;if("complex64"!==l&&ne().get("WEBGL_BUFFER_SUPPORTED")){h=r.decode(e);const g=r.texData.get(h.dataId);d=r.gpgpu.createBufferFromTexture(g.texture,...Xh(i))}if(r.pendingRead.set(e,[]),"complex64"!==l&&(yield r.gpgpu.createAndWaitForFence()),"complex64"===l){const g=yield Promise.all([r.read(u.real.dataId),r.read(u.imag.dataId)]);f=di(g[0],g[1])}else if(null==d)f=r.getValuesFromTexture(e);else{const g=te(i);f=r.gpgpu.downloadFloat32MatrixFromBuffer(d,g)}null!=h&&r.disposeIntermediateTensorInfo(h);const p=r.convertAndCacheOnCPU(e,f),m=r.pendingRead.get(e);return r.pendingRead.delete(e),m.forEach(g=>g(p)),r.pendingDisposal.has(e)&&(r.pendingDisposal.delete(e),r.disposeData(e)&&Pi().removeDataId(e,r),r.pendingDeletes--),p})()}bufferSync(e){const r=this.readSync(e.dataId);let s=r;if("string"===e.dtype)try{s=r.map(o=>iu(o))}catch{throw new Error("Failed to decode encoded string bytes into utf-8")}return yt(e.shape,e.dtype,s)}checkNumericalProblems(e){if(null!=e)for(let r=0;r<e.length;r++){const s=e[r];if(!_ue(s))throw ne().getBool("WEBGL_RENDER_FLOAT32_CAPABLE")?Error(`The value ${s} cannot be represented with your current settings. Consider enabling float32 rendering: 'tf.env().set('WEBGL_RENDER_FLOAT32_ENABLED', true);'`):Error(`The value ${s} cannot be represented on this device.`)}}getValuesFromTexture(e){const{shape:r,dtype:s,isPacked:o}=this.texData.get(e),i=te(r);if(ne().getBool("WEBGL_DOWNLOAD_FLOAT_ENABLED")){const f=this.decode(e),p=this.texData.get(f.dataId),m=this.gpgpu.downloadMatrixFromPackedTexture(p.texture,...Xh(r)).subarray(0,i);return this.disposeIntermediateTensorInfo(f),m}const a=ne().getBool("WEBGL_PACK")&&!0===o,l=a?c_(r):r,u=a?new ece(l):new Jue(l),c=this.runWebGLProgram(u,[{shape:l,dtype:s,dataId:e}],"float32"),d=this.texData.get(c.dataId),h=this.gpgpu.downloadByteEncodedFloatMatrixFromOutputTexture(d.texture,d.texShape[0],d.texShape[1]).subarray(0,i);return this.disposeIntermediateTensorInfo(c),h}timerAvailable(){return ne().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0}time(e){var r=this;return J(function*(){const s=r.activeTimers,o=[];let i=!1;null==r.programTimersStack?(r.programTimersStack=o,i=!0):r.activeTimers.push(o),r.activeTimers=o,e();const a=tu(r.activeTimers.map(c=>c.query)).filter(c=>null!=c),l=tu(r.activeTimers.map(c=>c.name)).filter(c=>null!=c);r.activeTimers=s,i&&(r.programTimersStack=null);const u={uploadWaitMs:r.uploadWaitMs,downloadWaitMs:r.downloadWaitMs,kernelMs:null,wallMs:null};if(ne().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0){const c=yield Promise.all(a);u.kernelMs=function Kq(t){let n=0;for(let e=0;e<t.length;e++)n+=t[e];return n}(c),u.getExtraProfileInfo=()=>c.map((d,h)=>({name:l[h],ms:d})).map(d=>`${d.name}: ${d.ms}`).join(", ")}else u.kernelMs={error:"WebGL query timers are not supported in this environment."};return r.uploadWaitMs=0,r.downloadWaitMs=0,u})()}memory(){return{unreliable:!1,numBytesInGPU:this.numBytesInGPU,numBytesInGPUAllocated:this.textureManager.numBytesAllocated,numBytesInGPUFree:this.textureManager.numBytesFree}}startTimer(){return ne().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0?this.gpgpu.beginQuery():{startMs:Pr(),endMs:null}}endTimer(e){return ne().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0?(this.gpgpu.endQuery(),e):(e.endMs=Pr(),e)}getQueryTime(e){var r=this;return J(function*(){return ne().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0?r.gpgpu.waitForQueryAndGetTime(e):e.endMs-e.startMs})()}disposeData(e,r=!1){if(this.pendingDisposal.has(e))return!1;if(!this.texData.has(e))return!0;if(r?this.texData.get(e).refCount=0:this.texData.get(e).refCount--,!r&&this.texData.get(e).refCount>0)return!1;if(this.pendingRead.has(e))return this.pendingDisposal.add(e),this.pendingDeletes++,!1;this.releaseGPUData(e);const{complexTensorInfos:s}=this.texData.get(e);return null!=s&&(this.disposeData(s.real.dataId,r),this.disposeData(s.imag.dataId,r)),this.texData.delete(e),!0}releaseGPUData(e){const{texture:r,dtype:s,texShape:o,usage:i,isPacked:a,slice:l}=this.texData.get(e),u=l&&l.origDataId||e,c=this.dataRefCount.get(u);c>1?this.dataRefCount.set(u,c-1):(this.dataRefCount.delete(u),null!=r&&(this.numBytesInGPU-=this.computeBytes(o,s),this.textureManager.releaseTexture(r,o,i,a)));const d=this.texData.get(e);d.texture=null,d.texShape=null,d.isPacked=!1,d.slice=null}getTexture(e){return this.uploadToGPU(e),this.texData.get(e).texture}getDataInfo(e){return this.texData.get(e)}getCPUBackend(){return ne().getBool("WEBGL_CPU_FORWARD")?(null==this.cpuBackend&&(this.cpuBackend=Pi().findBackend("cpu")),this.cpuBackend):null}shouldExecuteOnCPU(e,r=128){const s=this.getCPUBackend();return!ne().getBool("IS_TEST")&&!this.warnedAboutCPUBackend&&null==s&&(console.warn("Your application contains ops that are small enough to be executed on the CPU backend, however the CPU backend cannot be found. Consider importing the CPU backend (@tensorflow/tfjs-backend-cpu) for better performance."),this.warnedAboutCPUBackend=!0),null!=s&&e.every(o=>null==this.texData.get(o.dataId).texture&&te(o.shape)<r)}getGPGPUContext(){return this.gpgpu}where(e){Iu("tf.where() in webgl locks the UI thread. Call tf.whereAsync() instead");const r=e.dataSync();return Qde(e.shape,r)}packedUnaryOp(e,r,s){const o=new Wu(e.shape,r),i=this.compileAndRun(o,[e],s);return Pi().makeTensorFromDataId(i.dataId,i.shape,i.dtype)}abs(e){if(this.shouldExecuteOnCPU([e])&&"complex64"!==e.dtype){const o=oP(this.texData.get(e.dataId).values);return this.makeOutput(e.shape,e.dtype,o)}if(ne().getBool("WEBGL_PACK_UNARY_OPERATIONS"))return this.packedUnaryOp(e,dP,e.dtype);const r=new Qi(e.shape,dP),s=this.compileAndRun(r,[e]);return Pi().makeTensorFromDataId(s.dataId,s.shape,s.dtype)}makeTensorInfo(e,r,s){let o;if("string"===r&&null!=s&&s.length>0&&ad(s[0])){const i=s.map(a=>ah(a));o=this.write(i,e,r)}else o=this.write(s,e,r);return this.texData.get(o).usage=null,{dataId:o,shape:e,dtype:r}}makeOutput(e,r,s){const{dataId:o}=this.makeTensorInfo(e,r,s);return Pi().makeTensorFromDataId(o,e,r,this)}unpackTensor(e){const r=new Zde(e.shape);return this.runWebGLProgram(r,[e],e.dtype)}packTensor(e){const r=new $de(e.shape);return this.runWebGLProgram(r,[e],e.dtype,null,!0)}packedReshape(e,r){const s=[Pu(e.shape),...Lu(e.shape)],o={dtype:e.dtype,shape:s,dataId:e.dataId},i=[Pu(r),...Lu(r)],a=new aP(i,s),u=this.runWebGLProgram(a,[o],e.dtype,null,!0);return{dataId:u.dataId,shape:r,dtype:u.dtype}}decode(e){const r=this.texData.get(e),{isPacked:s,shape:o,dtype:i}=r,a=c_(o);let l;return l=s?new Que(a):new Zue(a),{dtype:i,shape:o,dataId:this.runWebGLProgram(l,[{shape:a,dtype:i,dataId:e}],i,null,!0).dataId}}runWebGLProgram(e,r,s,o,i=!1){const a=this.makeTensorInfo(e.outputShape,s),l=this.texData.get(a.dataId);if(e.packedOutput&&(l.isPacked=!0),e.outPackingScheme===Ou.DENSE){const y=Xh(e.outputShape);l.texShape=y.map(b=>2*b)}if(null!=e.outTexUsage&&(l.usage=e.outTexUsage),0===te(a.shape))return l.values=or(a.dtype,0),a;const u=[],c=r.map(y=>{if("complex64"===y.dtype)throw new Error("GPGPUProgram does not support complex64 input. For complex64 dtypes, please separate the program into real and imaginary parts.");let b=this.texData.get(y.dataId);if(null==b.texture){if(!e.packedInputs&&te(y.shape)<=ne().getNumber("WEBGL_SIZE_UPLOAD_UNIFORM"))return{shape:y.shape,texData:null,isUniform:!0,uniformValues:b.values};e.packedInputs&&(b.isPacked=!0,b.shape=y.shape)}else if(!!b.isPacked!=!!e.packedInputs)y=b.isPacked?this.unpackTensor(y):this.packTensor(y),u.push(y),b=this.texData.get(y.dataId);else if(b.isPacked&&!Ty(b.shape,y.shape)){const v=y,x=y.shape;y.shape=b.shape,y=this.packedReshape(y,x),u.push(y),b=this.texData.get(y.dataId),v.shape=x}return this.uploadToGPU(y.dataId),{shape:y.shape,texData:b,isUniform:!1}});this.uploadToGPU(a.dataId);const d={shape:a.shape,texData:l,isUniform:!1},h=function ode(t,n,e){let r="";n.concat(e).forEach(i=>{r+=`${i.shape}_${i.isUniform?"uniform":i.texData.texShape}_${null!=i.texData&&null!=i.texData.slice&&i.texData.slice.flatOffset>0}`});let o=t.constructor.name;return o+="_"+r+"_"+t.userCode,o}(e,c,d),f=this.getAndSaveBinary(h,()=>function rde(t,n,e,r){const s=n.userCode,o=e.map((f,p)=>{const m={logicalShape:f.shape,texShape:f.isUniform?null:f.texData.texShape,isUniform:f.isUniform,isPacked:!f.isUniform&&f.texData.isPacked,flatOffset:null};return null!=f.texData&&null!=f.texData.slice&&f.texData.slice.flatOffset>0&&(m.flatOffset=f.texData.slice.flatOffset),{name:n.variableNames[p],shapeInfo:m}}),i=o.map(f=>f.shapeInfo),a={logicalShape:r.shape,texShape:r.texData.texShape,isUniform:!1,isPacked:r.texData.isPacked,flatOffset:null},l=wce(o,a,s,n.packedInputs),u=t.createProgram(l);let c=null;const d=t.getUniformLocation(u,"NAN",!1);1===ne().getNumber("WEBGL_VERSION")&&(c=t.getUniformLocation(u,"INFINITY",!1));const h={};for(let f=0;f<n.variableNames.length;f++){const p=n.variableNames[f],m=!1;h[p]=t.getUniformLocation(u,p,m),h[`offset${p}`]=t.getUniformLocation(u,`offset${p}`,m)}return{program:n,source:l,webGLProgram:u,uniformLocations:h,inShapeInfos:i,outShapeInfo:a,infLoc:c,nanLoc:d}}(this.gpgpu,e,c,d)),p=null!=this.activeTimers;let m;p&&(m=this.startTimer()),function sde(t,n,e,r,s){rP(n.inShapeInfos,e),rP([n.outShapeInfo],[r]);const o=r.texData.texture,i=r.texData.texShape;r.texData.isPacked?t.setOutputPackedMatrixTexture(o,i[0],i[1]):t.setOutputMatrixTexture(o,i[0],i[1]),t.setProgram(n.webGLProgram),1===ne().getNumber("WEBGL_VERSION")&&null!==n.infLoc&&t.gl.uniform1f(n.infLoc,1/0),null!==n.nanLoc&&t.gl.uniform1f(n.nanLoc,NaN),e.forEach((a,l)=>{const u=n.program.variableNames[l],c=n.uniformLocations[u],d=n.uniformLocations[`offset${u}`];if(null!=c){if(a.isUniform){if(te(a.shape)<2)t.gl.uniform1f(c,a.uniformValues[0]);else{let h=a.uniformValues;h instanceof Float32Array||(h=new Float32Array(h)),t.gl.uniform1fv(c,h)}return}null!=a.texData.slice&&null!=d&&t.gl.uniform1i(d,a.texData.slice.flatOffset),t.setInputMatrixTexture(a.texData.texture,c,l)}}),s?.(t,n.webGLProgram),t.executeProgram()}(this.gpgpu,f,c,d,o),u.forEach(y=>this.disposeIntermediateTensorInfo(y)),p&&(m=this.endTimer(m),this.activeTimers.push({name:e.constructor.name,query:this.getQueryTime(m)}));const g=ne().get("WEBGL_FLUSH_THRESHOLD");if(g>0){const y=Pr();y-this.lastGlFlushTime>g&&(this.gpgpu.gl.flush(),this.lastGlFlushTime=y)}if(!ne().getBool("WEBGL_LAZILY_UNPACK")&&l.isPacked&&!1===i){const y=this.unpackTensor(a);return this.disposeIntermediateTensorInfo(a),y}return a}compileAndRun(e,r,s,o,i=!1){return this.runWebGLProgram(e,r,s=s||r[0].dtype,o,i)}getAndSaveBinary(e,r){return e in this.binaryCache||(this.binaryCache[e]=r()),this.binaryCache[e]}getTextureManager(){return this.textureManager}dispose(){this.disposed||(ne().getBool("IS_TEST")||Object.keys(this.binaryCache).forEach(r=>{this.gpgpu.deleteProgram(this.binaryCache[r].webGLProgram),delete this.binaryCache[r]}),this.textureManager.dispose(),null!=this.canvas&&typeof HTMLCanvasElement<"u"&&this.canvas instanceof HTMLCanvasElement?this.canvas.remove():this.canvas=null,this.gpgpuCreatedLocally&&(this.gpgpu.program=null,this.gpgpu.dispose()),this.disposed=!0)}floatPrecision(){return null==this.floatPrecisionValue&&(this.floatPrecisionValue=U(()=>{if(!ne().get("WEBGL_RENDER_FLOAT32_ENABLED")){const e=ne().getBool("DEBUG");ne().set("DEBUG",!1);const r=this.abs(Fe(1e-8)).dataSync()[0];if(ne().set("DEBUG",e),r>0)return 32}return 16})),this.floatPrecisionValue}epsilon(){return 32===this.floatPrecision()?1e-7:1e-4}uploadToGPU(e){const r=this.texData.get(e),{shape:s,dtype:o,values:i,texture:a,usage:l,isPacked:u}=r;if(null!=a)return;const c=null!=this.activeTimers;let d;c&&(d=Pr());let h=r.texShape;if(null==h&&(h=function Wue(t,n=!1){let e=ne().getNumber("WEBGL_MAX_TEXTURE_SIZE");n&&(e*=2,1===(t=t.map((s,o)=>o>=t.length-2?GR(t[o]):t[o])).length&&(t=[2,t[0]])),2!==t.length&&(t=Aa(t).newShape);let r=te(t);if(t.length<=1&&r<=e)return[1,r];if(2===t.length&&t[0]<=e&&t[1]<=e)return t;if(3===t.length&&t[0]*t[1]<=e&&t[2]<=e)return[t[0]*t[1],t[2]];if(3===t.length&&t[0]<=e&&t[1]*t[2]<=e)return[t[0],t[1]*t[2]];if(4===t.length&&t[0]*t[1]*t[2]<=e&&t[3]<=e)return[t[0]*t[1]*t[2],t[3]];if(4===t.length&&t[0]<=e&&t[1]*t[2]*t[3]<=e)return[t[0],t[1]*t[2]*t[3]];if(n){const s=Pu(t);let o=2,i=2;return t.length&&([o,i]=Lu(t)),r=s*(o/2)*(i/2),G0(r).map(a=>2*a)}return G0(r)}(s,u),r.texShape=h),null!=i){const f=c_(s);let p,m=h[1],g=h[0];const y=i instanceof Uint8Array;u?([m,g]=Mu(h[0],h[1]),p=new nce(f,[g,m],y)):p=new tce(f,[g,m],y);const b=this.makeTensorInfo([g,m],o);this.texData.get(b.dataId).usage=y?Qr.PIXELS:Qr.UPLOAD,this.gpgpu.uploadDenseMatrixToTexture(this.getTexture(b.dataId),m,g,i);const x=this.runWebGLProgram(p,[b],o,null,!0),w=this.texData.get(x.dataId);r.texture=w.texture,r.texShape=w.texShape,r.isPacked=w.isPacked,r.usage=w.usage,this.disposeIntermediateTensorInfo(b),this.texData.delete(x.dataId),r.values=null,c&&(this.uploadWaitMs+=Pr()-d)}else{const f=this.acquireTexture(h,l,o,u);r.texture=f}}convertAndCacheOnCPU(e,r){const s=this.texData.get(e),{dtype:o}=s;return this.releaseGPUData(e),null!=r&&(s.values=function ihe(t,n){if("float32"===n||"complex64"===n)return t;if("int32"===n||"bool"===n){const e="int32"===n?new Int32Array(t.length):new Uint8Array(t.length);for(let r=0;r<e.length;++r)e[r]=Math.round(t[r]);return e}throw new Error(`Unknown dtype ${n}`)}(r,o)),s.values}acquireTexture(e,r,s,o){if(this.numBytesInGPU+=this.computeBytes(e,s),!this.warnedAboutMemory&&this.numBytesInGPU>1024*this.numMBBeforeWarning*1024){const i=(this.numBytesInGPU/1024/1024).toFixed(2);this.warnedAboutMemory=!0,console.warn(`High memory usage in GPU: ${i} MB, most likely due to a memory leak`)}return this.textureManager.acquireTexture(e,r,o)}computeBytes(e,r){return e[0]*e[1]*j0(r)}}return t.nextDataId=0,t})();h$()&&q$("webgl",()=>new ohe,2);class Hu{constructor(n,e,r){this.variableNames=["A","B"],this.outputShape=bt(e,r),this.userCode=`\n      float binaryOperation(float a, float b) {\n        ${n}\n      }\n\n      void main() {\n        float a = getAAtOutCoords();\n        float b = getBAtOutCoords();\n        setOutput(binaryOperation(a, b));\n      }\n    `}}class Qh{constructor(n,e,r,s=!1){this.variableNames=["A","B"],this.supportsBroadcasting=!0,this.packedInputs=!0,this.packedOutput=!0,this.outputShape=bt(e,r);const o=this.outputShape.length;let i="";if(s)if(0===o||1===te(this.outputShape))i="\n          result.y = 0.;\n          result.z = 0.;\n          result.w = 0.;\n        ";else if(i=`\n          ${Wt(o)} coords = getOutputCoords();\n        `,1===o)i+=`\n            result.y = (coords + 1) >= ${this.outputShape[0]} ? 0. : result.y;\n            result.z = 0.;\n            result.w = 0.;\n          `;else{const l=Nr("coords",o);i+=`\n            bool nextRowOutOfBounds =\n              (${l[o-2]} + 1) >= ${this.outputShape[o-2]};\n            bool nextColOutOfBounds =\n              (${l[o-1]} + 1) >= ${this.outputShape[o-1]};\n            result.y = nextColOutOfBounds ? 0. : result.y;\n            result.z = nextRowOutOfBounds ? 0. : result.z;\n            result.w = nextColOutOfBounds || nextRowOutOfBounds ? 0. : result.w;\n          `}this.userCode=`\n      vec4 binaryOperation(vec4 a, vec4 b) {\n        ${n}\n      }\n\n      void main() {\n        vec4 a = getAAtOutCoords();\n        vec4 b = getBAtOutCoords();\n\n        vec4 result = binaryOperation(a, b);\n        ${i}\n\n        setOutput(result);\n      }\n    `}}function Jr(t){const{inputs:n,backend:e}=t,{x:r}=n;return e.incRef(r.dataId),{dataId:r.dataId,shape:r.shape,dtype:r.dtype}}const uhe={kernelName:Ad,backendName:"webgl",kernelFunc:Jr};function Ji(t){const{inputs:n,backend:e}=t,{real:r,imag:s}=n,o=e.makeTensorInfo(r.shape,"complex64"),i=e.texData.get(o.dataId),a=Jr({inputs:{x:r},backend:e}),l=Jr({inputs:{x:s},backend:e});return i.complexTensorInfos={real:a,imag:l},o}const che={kernelName:rw,backendName:"webgl",kernelFunc:Ji},fP="return (a < 0.) ? b * a : a;",pP="\n  vec4 aLessThanZero = vec4(lessThan(a, vec4(0.)));\n  return (aLessThanZero * (b * a)) + ((vec4(1.0) - aLessThanZero) * a);\n",hhe={kernelName:Im,backendName:"webgl",kernelFunc:function dhe(t){const{inputs:n,backend:e,attrs:r}=t,{x:s}=n,{alpha:o}=r,i=e.makeTensorInfo([],"float32",Oi(o,"float32")),a=ne().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new Qh(pP,s.shape,i.shape):new Hu(fP,s.shape,i.shape),l=e.runWebGLProgram(a,[s,i],s.dtype);return e.disposeIntermediateTensorInfo(i),l}},mP="return (a < 0.) ? b * a : a;",gP="\n  vec4 aLessThanZero = vec4(lessThan(a, vec4(0.)));\n  return (aLessThanZero * (b * a)) + ((vec4(1.0) - aLessThanZero) * a);\n",phe={kernelName:Um,backendName:"webgl",kernelFunc:function fhe(t){const{inputs:n,backend:e}=t,{x:r,alpha:s}=n,o=ne().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new Qh(gP,r.shape,s.shape):new Hu(mP,r.shape,s.shape);return e.runWebGLProgram(o,[r,s],r.dtype)}};function _t({opSnippet:t,packedOpSnippet:n,cpuKernelImpl:e,dtype:r}){return({inputs:s,backend:o})=>{const{x:i}=s,a=o,l=r||i.dtype;if(a.shouldExecuteOnCPU([i])&&null!=e){const d=a.texData.get(i.dataId),h=e(d.values,l);return a.makeTensorInfo(i.shape,l,h)}let c;return c=ne().getBool("WEBGL_PACK_UNARY_OPERATIONS")&&null!=n?new Wu(i.shape,n):new Qi(i.shape,t),a.runWebGLProgram(c,[i],l)}}function cr({opSnippet:t,packedOpSnippet:n,checkOutOfBounds:e=!1,supportsComplex:r=!1,cpuKernelImpl:s,dtype:o}){return({inputs:i,backend:a})=>{const{a:l,b:u}=i,c=a;if(r&&"complex64"===l.dtype){const p=c.texData.get(l.dataId),m=c.texData.get(u.dataId),[g,y]=[[p.complexTensorInfos.real,m.complexTensorInfos.real],[p.complexTensorInfos.imag,m.complexTensorInfos.imag]].map(v=>{const[x,w]=v,_={dataId:x.dataId,dtype:x.dtype,shape:l.shape},D={dataId:w.dataId,dtype:w.dtype,shape:u.shape},A=new Hu(t,l.shape,u.shape);return c.runWebGLProgram(A,[_,D],ds(x.dtype,w.dtype))}),b=Ji({inputs:{real:g,imag:y},backend:c});return c.disposeIntermediateTensorInfo(g),c.disposeIntermediateTensorInfo(y),b}const d=o||ds(l.dtype,u.dtype);if(c.shouldExecuteOnCPU([l,u])&&null!=s){const p=c.texData.get(l.dataId),m=c.texData.get(u.dataId),[g,y]=s(l.shape,u.shape,p.values,m.values,d),b=c.makeTensorInfo(y,d);return c.texData.get(b.dataId).values=g,b}let f;return f=ne().getBool("WEBGL_PACK_BINARY_OPERATIONS")&&null!=n?new Qh(n,l.shape,u.shape,e):new Hu(t,l.shape,u.shape),c.runWebGLProgram(f,[l,u],d)}}function My(t,n=!1){if("linear"===t)return"return x;";if("relu"===t)return n?"\n  vec4 result = x * vec4(greaterThanEqual(x, vec4(0.0)));\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n":"if (isnan(x)) return x;\n  return (x < 0.0) ? 0.0 : x;\n";if("elu"===t)return n?"\n  vec4 result;\n\n  result.r = (x.r >= 0.0) ? x.r : (exp(x.r) - 1.0);\n  result.g = (x.g >= 0.0) ? x.g : (exp(x.g) - 1.0);\n  result.b = (x.b >= 0.0) ? x.b : (exp(x.b) - 1.0);\n  result.a = (x.a >= 0.0) ? x.a : (exp(x.a) - 1.0);\n\n  return result;\n":"return (x >= 0.0) ? x : (exp(x) - 1.0);";if("relu6"===t)return n?"\n  vec4 result = min(x, vec4(6.)) * vec4(greaterThanEqual(x, vec4(0.0)));\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n":"if (isnan(x)) return x;\n  return (x < 0.0) ? 0.0 : min(6.0, x);\n";if("prelu"===t)return n?gP:mP;if("leakyrelu"===t)return n?pP:fP;throw new Error(`Activation ${t} has not been implemented for the WebGL backend.`)}class bP{constructor(n,e,r,s=!1,o=!1,i=!1,a=null,l=!1,u=!1){this.variableNames=["matrixA","matrixB"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=r;const d=Math.ceil((s?n[1]:n[2])/2),h=s?"i * 2, rc.y":"rc.y, i * 2",f=o?"rc.z, i * 2":"i * 2, rc.z",p=s?["a.xxyy","a.zzww"]:["a.xxzz","a.yyww"],m=o?["b.xzxz","b.ywyw"]:["b.xyxy","b.zwzw"];let g="",y="";a&&(g=l?`vec4 activation(vec4 a) {\n          vec4 b = getPreluActivationWeightsAtOutCoords();\n          ${a}\n        }`:u?`vec4 activation(vec4 a) {\n          vec4 b = getLeakyreluAlphaAtOutCoords();\n          ${a}\n        }`:`vec4 activation(vec4 x) {\n          ${a}\n        }`,y="result = activation(result);");const b=i?"result += getBiasAtOutCoords();":"";i&&this.variableNames.push("bias"),l&&this.variableNames.push("preluActivationWeights"),u&&this.variableNames.push("leakyreluAlpha");let v="rc.x",x="rc.x";n[0]<e[0]?v=`int(min(float(rc.x), ${n[0]-1}.))`:e[0]<n[0]&&(x=`int(min(float(rc.x), ${e[0]-1}.))`),this.userCode=`\n      ${g}\n\n      const float sharedDimension = ${d}.0;\n\n      vec4 dot2x2ARowBCol(ivec3 rc) {\n        vec4 result = vec4(0);\n        for (int i = 0; i < ${d}; i++) {\n          int batchA = ${v};\n          int batchB = ${x};\n          vec4 a = getMatrixA(batchA, ${h});\n          vec4 b = getMatrixB(batchB, ${f});\n\n          // These swizzled products need to be separately added.\n          // See: https://github.com/tensorflow/tfjs/issues/1735\n          result += (${p[0]} * ${m[0]});\n          result += (${p[1]} * ${m[1]});\n        }\n        return result;\n      }\n\n      void main() {\n        ivec3 rc = getOutputCoords();\n        vec4 result = dot2x2ARowBCol(rc);\n\n        ${b}\n\n        ${y}\n\n        setOutput(result);\n      }\n    `}}class xP{constructor(n,e,r){this.variableNames=["AReal","AImag","BReal","BImag"],this.outputShape=bt(e,r),this.userCode=`\n      float binaryOpComplex(\n          float areal, float aimag, float breal, float bimag) {\n        ${n}\n      }\n\n      void main() {\n        float areal = getARealAtOutCoords();\n        float aimag = getAImagAtOutCoords();\n        float breal = getBRealAtOutCoords();\n        float bimag = getBImagAtOutCoords();\n        setOutput(binaryOpComplex(areal, aimag, breal, bimag));\n      }\n    `}}const wP="return a * b;";function CP(t){const{inputs:n,backend:e}=t,{a:r,b:s}=n,o=ds(r.dtype,s.dtype);if("complex64"===r.dtype){const a=e.texData.get(r.dataId),l=e.texData.get(s.dataId),u=new xP("return areal * breal - aimag * bimag;",r.shape,s.shape),c=new xP("return areal * bimag + aimag * breal;",r.shape,s.shape),d=[{dataId:a.complexTensorInfos.real.dataId,dtype:a.complexTensorInfos.real.dtype,shape:r.shape},{dataId:a.complexTensorInfos.imag.dataId,dtype:a.complexTensorInfos.imag.dtype,shape:r.shape},{dataId:l.complexTensorInfos.real.dataId,dtype:l.complexTensorInfos.real.dtype,shape:s.shape},{dataId:l.complexTensorInfos.imag.dataId,dtype:l.complexTensorInfos.imag.dtype,shape:s.shape}],h=e.runWebGLProgram(u,d,"float32"),f=e.runWebGLProgram(c,d,"float32"),p=Ji({inputs:{real:h,imag:f},backend:e});return e.disposeIntermediateTensorInfo(h),e.disposeIntermediateTensorInfo(f),p}if(e.shouldExecuteOnCPU([r,s])){const a=e.texData.get(r.dataId),l=e.texData.get(s.dataId),[u,c]=wde(r.shape,s.shape,a.values,l.values,o),d=e.makeTensorInfo(c,o);return e.texData.get(d.dataId).values=u,d}let i;return i=ne().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new Qh(wP,r.shape,s.shape):new Hu(wP,r.shape,s.shape),e.runWebGLProgram(i,[r,s],o)}const yhe={kernelName:zd,backendName:"webgl",kernelFunc:CP};function Se(t){const{inputs:n,backend:e,attrs:r}=t,{x:s}=n,{shape:o}=r,i=e,a=te(s.shape),l=qR(o,a),u=te(l);S(a===u,()=>`The new shape (${l}) has ${u} elements and the old shape (${s.shape}) has ${a} elements. The new shape and old shape must have the same number of elements.`);const c=i.texData.get(s.dataId);return!c.isPacked||Ty(s.shape,l)||null!==c.texture&&Ty(c.shape,l)?(i.incRef(s.dataId),{dataId:s.dataId,shape:l,dtype:s.dtype}):function bhe(t,n,e){const r=[Pu(t.shape),...Lu(t.shape)],s={dtype:t.dtype,shape:r,dataId:t.dataId},o=[Pu(n),...Lu(n)],i=new aP(o,r),l=e.runWebGLProgram(i,[s],t.dtype,null,!0);return{dataId:l.dataId,shape:n,dtype:l.dtype}}(s,l,i)}const vhe={kernelName:Wm,backendName:"webgl",kernelFunc:Se};class IP{constructor(n,e){this.variableNames=["x"];const{windowSize:r,batchSize:s,inSize:o,outSize:i}=n;this.outputShape=[s,i];const a=4*Math.floor(r/4),l=r%4;let u="sumValue += dot(values, ones);";if(null!=e){const d=1/e;u=`sumValue += dot(values * ${Kn(d)?d.toPrecision(2):d}, ones);`}let c="";o%r>0&&(c=`\n        if (inIdx < 0 || inIdx >= ${o}) {\n          return 0.0;\n        }\n      `),this.userCode=`\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\n\n      float getValue(int batch, int inIdx) {\n        ${c}\n        return getX(batch, inIdx);\n      }\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n        int outIdx = coords[1];\n        int inOffset = outIdx * ${r};\n\n        float sumValue = 0.0;\n\n        for (int i = 0; i < ${a}; i += 4) {\n          int inIdx = inOffset + i;\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            getValue(batch, inIdx + 3)\n          );\n\n          ${u}\n        }\n\n        int inIdx = inOffset + ${a};\n        if (${1===l}) {\n          vec4 values = vec4(getValue(batch, inIdx), 0.0, 0.0, 0.0);\n\n          ${u}\n        } else if (${2===l}) {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1), 0.0, 0.0);\n\n          ${u}\n        } else if (${3===l}) {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2), 0.0);\n\n          ${u}\n        }\n        setOutput(sumValue);\n      }\n    `}}class xhe{constructor(n,e){this.variableNames=["x"];const{windowSize:r,batchSize:s,inSize:o,outSize:i}=n;this.outputShape=[s,i];let a="0.0",l="";"prod"===e?a="1.0":"min"===e?(a="1.0 / 1e-20",l="min"):"max"===e&&(a="-1.0 / 1e-20",l="max");let u=`${e}(${e}(${e}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;"sum"===e?u="sumValue":"prod"===e?u="prodValue":"all"===e?u="allValue":"any"===e&&(u="anyValue");const c=4*Math.floor(r/4),d=r%4;let h=`\n      if (${"sum"===e}) {\n        sumValue += dot(values, ones);\n      } else if (${"prod"===e}) {\n        vec2 tmp = vec2(values[0], values[1]) * vec2(values[2], values[3]);\n        prodValue *= tmp[0] * tmp[1];\n      } else {\n        minMaxValue = ${l}(values, minMaxValue);\n      }\n    `,f="vec4";"all"===e?(a="1.0",h="\n        bool reducedAllValue = all(values);\n        float floatedReducedAllValue = float(reducedAllValue);\n        allValue = float(allValue >= 1.0 && floatedReducedAllValue >= 1.0);\n      ",f="bvec4"):"any"===e&&(a="0.0",h="\n        bool reducedAnyValue = any(values);\n        float floatedReducedAnyValue = float(reducedAnyValue);\n        anyValue = float(anyValue >= 1.0 || floatedReducedAnyValue >= 1.0);\n      ",f="bvec4");let p="";o%r>0&&(p=`\n        if (inIdx < 0 || inIdx >= ${o}) {\n          return initializationValue;\n        }\n      `),this.userCode=`\n      const float initializationValue = ${a};\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\n\n      float getValue(int batch, int inIdx) {\n        ${p}\n        return getX(batch, inIdx);\n      }\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n        int outIdx = coords[1];\n        int inOffset = outIdx * ${r};\n\n        vec4 minMaxValue = vec4(${a});\n        float prodValue = 1.0;\n        float sumValue = 0.0;\n        float allValue = 1.0;\n        float anyValue = 0.0;\n\n        for (int i = 0; i < ${c}; i += 4) {\n          int inIdx = inOffset + i;\n          ${f} values = ${f}(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            getValue(batch, inIdx + 3)\n          );\n\n          ${h}\n        }\n\n        int inIdx = inOffset + ${c};\n        if (${1===d}) {\n          ${f} values = ${f}(\n            getValue(batch, inIdx),\n            initializationValue,\n            initializationValue,\n            initializationValue\n          );\n\n          ${h}\n        } else if (${2===d}) {\n          ${f} values = ${f}(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            initializationValue,\n            initializationValue\n          );\n\n          ${h}\n        } else if (${3===d}) {\n          ${f} values = ${f}(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            initializationValue\n          );\n\n          ${h}\n        }\n        setOutput(${u});\n      }\n    `}}function nl(t,n,e,r){const s=function whe(t){const n=[];for(;0===n.length||1!==n[n.length-1].outSize;){const e=n.length?n[n.length-1].outSize:t[1],r=Bg(e);n.push({inSize:e,windowSize:r,outSize:Math.ceil(e/r)})}return n}(t.shape);let o=t;for(let i=0;i<s.length;i++){const{inSize:a,windowSize:l,outSize:u}=s[i];let c,d;c="mean"===e?0===i?new IP({windowSize:l,inSize:a,batchSize:t.shape[0],outSize:u},a):new IP({windowSize:l,inSize:a,batchSize:t.shape[0],outSize:u}):new xhe({windowSize:l,inSize:a,batchSize:t.shape[0],outSize:u},e),d=o,o=r.runWebGLProgram(c,[o],n),d.dataId!==t.dataId&&r.disposeIntermediateTensorInfo(d)}return o}class Che{constructor(n,e){this.variableNames=["A"];const r=new Array(n.length);for(let i=0;i<r.length;i++)r[i]=n[e[i]];this.outputShape=r,this.rank=r.length;const s=Wt(this.rank),o=function Ihe(t){const n=t.length;if(n>6)throw Error(`Transpose for rank ${n} is not yet supported`);const e=["resRC.x","resRC.y","resRC.z","resRC.w","resRC.u","resRC.v"],r=new Array(n);for(let s=0;s<t.length;s++)r[t[s]]=e[s];return r.join()}(e);this.userCode=`\n    void main() {\n      ${s} resRC = getOutputCoords();\n      setOutput(getA(${o}));\n    }\n    `}}class Dhe{constructor(n,e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0;const r=new Array(n.length);for(let c=0;c<r.length;c++)r[c]=n[e[c]];if(this.outputShape=r,this.rank=r.length,this.rank>6)throw Error(`Packed transpose for rank ${this.rank} is not yet supported.`);const s=Wt(this.rank),o=iP("rc",this.rank),i=new Array(this.rank);for(let c=0;c<e.length;c++)i[e[c]]=o[c];const a=`vec2(${i.slice(-2).join()})`,l=`++${o[this.rank-1]} < ${r[this.rank-1]}`,u=`getChannel(getA(${i.join()}), ${a})`;this.userCode=`\n    void main() {\n      ${s} rc = getOutputCoords();\n      vec4 result = vec4(0.);\n      result[0] = ${u};\n      if(${l}) {\n        result[1] = ${u};\n      }\n      --${o[this.rank-1]};\n      if(++${o[this.rank-2]} < ${r[this.rank-2]}) {\n        result[2] = ${u};\n        if(${l}) {\n          result[3] = ${u};\n        }\n      }\n      setOutput(result);\n    }\n    `}}function Py(t,n,e){const r=ne().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new Dhe(t.shape,n):new Che(t.shape,n);return e.runWebGLProgram(r,[t],t.dtype)}function p_(t){const{inputs:n,backend:e,attrs:r}=t,{x:s}=n,{axis:o,keepDims:i}=r;return function _he(t,n,e,r){const o=t.shape.length,i=ft(n,t.shape);let a=i;const l=xn(a,o),u=null!=l;let c=t;u&&(c=Py(t,l,r),a=En(a.length,o)),lr("sum",a,o);const[d,h]=Qn(c.shape,a);let f=d;e&&(f=vn(d,i));const p=te(h),y=Se({inputs:{x:c},attrs:{shape:[te(t.shape)/p,p]},backend:r}),v=nl(y,Xw(t.dtype),"sum",r),x=Se({inputs:{x:v},attrs:{shape:f},backend:r});return r.disposeIntermediateTensorInfo(y),r.disposeIntermediateTensorInfo(v),u&&r.disposeIntermediateTensorInfo(c),x}(s,o,i,e)}const She={kernelName:Xm,backendName:"webgl",kernelFunc:p_};function zr(t){const{inputs:n,backend:e,attrs:r}=t,{x:s}=n,{perm:o}=r,i=e,l=new Array(s.shape.length);for(let c=0;c<l.length;c++)l[c]=s.shape[o[c]];let u;if(i.shouldExecuteOnCPU([s])){const d=i.texData.get(s.dataId).values,h=f_(d,s.shape,s.dtype,o,l);u=i.makeTensorInfo(l,s.dtype),i.texData.get(u.dataId).values=h}else u=Py(s,o,i);return u}const Ehe={kernelName:Jm,backendName:"webgl",kernelFunc:zr};function Ly({a:t,b:n,transposeA:e,transposeB:r,backend:s,bias:o=null,preluActivationWeights:i=null,leakyreluAlpha:a=0,activation:l=null}){const u=t.shape.length,c=n.shape.length,d=e?t.shape[u-2]:t.shape[u-1],h=r?n.shape[c-1]:n.shape[c-2],f=e?t.shape[u-1]:t.shape[u-2],p=r?n.shape[c-2]:n.shape[c-1],m=t.shape.slice(0,-2),g=n.shape.slice(0,-2),y=te(m),b=te(g);S(u>=2&&c>=2&&(y===b||1===y||1===b),()=>`Error in matMul: the input batch dimensions must either be the same or at least one input batch dimension must be 1. Got input batch dimensions of (${m}) and (${g}).`);const w=(y>b?t.shape.slice(0,-2):n.shape.slice(0,-2)).concat([f,p]);S(d===h,()=>`Error in matMul: inner shapes (${d}) and (${h}) of Tensors with shapes ${t.shape} and ${n.shape} and transposeA=${e} and transposeB=${r} must match.`);const _=e?[y,d,f]:[y,f,d],D=r?[b,p,h]:[b,h,p],A=Se({inputs:{x:t},backend:s,attrs:{shape:_}}),R=Se({inputs:{x:n},backend:s,attrs:{shape:D}}),O=[A,R],G=Math.max(y,b),K=e?A.shape[1]:A.shape[2],j=null!=o,Q=null!=i,q="leakyrelu"===l,Y=null!=l?My(l,!0):null;let ee;if((1===f||1===p)&&K>1e3&&!1===(j||Q||q||null!=Y)){let ue=A,de=R;e&&(ue=zr({inputs:{x:A},backend:s,attrs:{perm:[0,2,1]}}),O.push(ue)),r&&(de=zr({inputs:{x:R},backend:s,attrs:{perm:[0,2,1]}}),O.push(de));const pe=1===p;let ye=ue;1!==p&&(ye=Se({inputs:{x:ue},backend:s,attrs:{shape:[G,K,1]}}),O.push(ye));const ve=1===p?2:1;let De=de;pe&&(De=Se({inputs:{x:de},backend:s,attrs:{shape:[G,1,K]}}),O.push(De));const Te=CP({inputs:{a:ye,b:De},backend:s});ee=p_({inputs:{x:Te},backend:s,attrs:{axis:ve,keepDims:!0}}),O.push(Te)}else{const ue=ds(t.dtype,n.dtype),de=new bP(_,D,[G,f,p],e,r,j,Y,Q,q),ge=[A,R];if(null!=o&&ge.push(o),Q&&ge.push(i),q){const pe=s.makeTensorInfo([],"float32",Oi(a,"float32"));ge.push(pe),O.push(pe)}ee=s.runWebGLProgram(de,ge,ue)}const se=Se({inputs:{x:ee},backend:s,attrs:{shape:w}});O.push(ee);for(const ue of O)s.disposeIntermediateTensorInfo(ue);return se}const The={kernelName:rg,backendName:"webgl",kernelFunc:function Nhe(t){const{inputs:n,backend:e,attrs:r}=t,{a:s,b:o,bias:i,preluActivationWeights:a}=n,{transposeA:l,transposeB:u,activation:c,leakyreluAlpha:d}=r;return Ly({a:s,b:o,transposeA:l,transposeB:u,backend:e,bias:i,preluActivationWeights:a,leakyreluAlpha:d,activation:c})}},_P="return abs(x);",Ahe={kernelName:nm,backendName:"webgl",kernelFunc:function khe(t){const{inputs:n,backend:e}=t,{x:r}=n;if(e.shouldExecuteOnCPU([r])&&"complex64"!==r.dtype){const o=e.texData.get(r.dataId),i=oP(o.values);return e.makeTensorInfo(r.shape,r.dtype,i)}let s;return s=ne().getBool("WEBGL_PACK_UNARY_OPERATIONS")?new Wu(r.shape,_P):new Qi(r.shape,_P),e.runWebGLProgram(s,[r],r.dtype)}},$he=_t({opSnippet:"if (isnan(x)) return x;\n  if (abs(x) > 1.) {\n    return NAN;\n  }\n  return acos(x);\n"}),Fhe={kernelName:dd,backendName:"webgl",kernelFunc:$he},Mhe=_t({opSnippet:"if (isnan(x)) return x;\n  if (x < 1.0) return NAN;\nreturn log(x + sqrt(x * x - 1.0));"}),Phe={kernelName:hd,backendName:"webgl",kernelFunc:Mhe},SP="return a + b;",Lhe=cr({opSnippet:SP,packedOpSnippet:SP,supportsComplex:!0,cpuKernelImpl:ide}),Bhe={kernelName:su,backendName:"webgl",kernelFunc:Lhe};class zhe{constructor(n,e){this.outputShape=[],this.outputShape=n,this.variableNames=e.map((o,i)=>`T${i}`);const r=[];this.variableNames.forEach(o=>{r.push(`float v${o} = get${o}AtOutCoords();`)});const s=this.variableNames.map(o=>`v${o}`).join(" + ");this.userCode=`\n      void main() {\n        ${r.join("\n        ")}\n\n        float result = ${s};\n        setOutput(result);\n      }\n    `}}class Vhe{constructor(n,e){this.outputShape=[],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=n,this.variableNames=e.map((o,i)=>`T${i}`);const r=[];this.variableNames.forEach(o=>{r.push(`vec4 v${o} = get${o}AtOutCoords();`)});const s=this.variableNames.map(o=>`v${o}`).join(" + ");this.userCode=`\n      void main() {\n        ${r.join("\n        ")}\n\n        vec4 result = ${s};\n        setOutput(result);\n      }\n    `}}const Uhe={kernelName:rm,backendName:"webgl",kernelFunc:function By(t){const{inputs:n,backend:e}=t,r=n;if(1===r.length)return Jr({inputs:{x:r[0]},backend:e});if(r.length>ne().get("WEBGL_MAX_TEXTURES_IN_SHADER")){const l=Math.floor(r.length/2),u=By({inputs:r.slice(0,l),backend:e}),c=By({inputs:r.slice(l),backend:e});return By({inputs:[u,c],backend:e})}const s=r.map(l=>l.dtype).reduce((l,u)=>ds(l,u)),o=r.map(l=>l.shape),a=ne().getBool("WEBGL_PACK")?new Vhe(r[0].shape,o):new zhe(r[0].shape,o);return e.runWebGLProgram(a,r,s)}},Hhe={kernelName:"All",backendName:"webgl",kernelFunc:function Whe(t){const{inputs:n,backend:e,attrs:r}=t,{x:s}=n,{axis:o,keepDims:i}=r,a=s.shape.length,l=ft(o,s.shape);let u=l;const c=xn(u,a);let d=s;null!=c&&(d=zr({inputs:{x:s},backend:e,attrs:{perm:c}}),u=En(u.length,a)),lr("all",u,a);const[h,f]=Qn(d.shape,u),m=Se({inputs:{x:d},backend:e,attrs:{shape:[-1,te(f)]}}),g=nl(m,m.dtype,"all",e);let y;return y=Se(i?{inputs:{x:g},backend:e,attrs:{shape:vn(h,l)}}:{inputs:{x:g},backend:e,attrs:{shape:h}}),e.disposeIntermediateTensorInfo(m),e.disposeIntermediateTensorInfo(g),null!=c&&e.disposeIntermediateTensorInfo(d),y}},jhe={kernelName:"Any",backendName:"webgl",kernelFunc:function Ghe(t){const{inputs:n,backend:e,attrs:r}=t,{x:s}=n,{axis:o,keepDims:i}=r,a=s.shape.length,l=ft(o,s.shape);let u=l;const c=xn(u,a);let d=s;null!=c&&(d=zr({inputs:{x:s},backend:e,attrs:{perm:c}}),u=En(u.length,a)),lr("any",u,a);const[h,f]=Qn(d.shape,u),m=Se({inputs:{x:d},backend:e,attrs:{shape:[-1,te(f)]}}),g=nl(m,m.dtype,"any",e);let y;return y=Se(i?{inputs:{x:g},backend:e,attrs:{shape:vn(h,l)}}:{inputs:{x:g},backend:e,attrs:{shape:h}}),e.disposeIntermediateTensorInfo(m),e.disposeIntermediateTensorInfo(g),null!=c&&e.disposeIntermediateTensorInfo(d),y}};class qhe{constructor(n,e,r){this.variableNames=["A"];const{windowSize:s,batchSize:o,outSize:i}=n;r||this.variableNames.push("bestIndicesA"),this.outputShape=[o,i],this.userCode=`\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n        int outIdx = coords[1];\n        int inOffset = outIdx * ${s};\n\n        int bestIndex = inOffset;\n        float bestValue = getA(batch, bestIndex);\n\n        for (int i = 0; i < ${s}; i++) {\n          int inIdx = ${r?"inOffset + i;":"round(getBestIndicesA(batch, inOffset + i));"};\n          float candidate = getA(batch, inIdx);\n          if (candidate ${"max"===e?">":"<"} bestValue) {\n            bestValue = candidate;\n            bestIndex = inIdx;\n          }\n        }\n        setOutput(float(bestIndex));\n      }\n    `}}class Khe{constructor(n,e,r,s){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,S(n.length>2,()=>`Packed arg${r.charAt(0).toUpperCase()+r.slice(1)} supports only inputs with rank above 2.`);const i=Math.ceil(n[n.length-1]/e);this.outputShape=n.slice(0,-1),i>1&&this.outputShape.push(i),s||this.variableNames.push("bestIndicesA");const a=this.outputShape,l=a.length,u=Wt(l),c=Nr("coords",l);let d,h;if(1===i){h=l+1;const A=Wt(h);d=`\n        ${A} sourceLocR = ${A}(${c.join()}, 0);\n        ++${c[l-1]};\n        ${A} sourceLocG = ${A}(${c.join()}, 0);\n        ++${c[l-2]};\n        ${A} sourceLocA = ${A}(${c.join()}, 0);\n        --${c[l-1]};\n        ${A} sourceLocB = ${A}(${c.join()}, 0);\n        --${c[l-2]};`}else h=l,d=`\n        ${u} sourceLocR = coords;\n        ++${c[l-1]};\n        ${u} sourceLocG = coords;\n        ++${c[l-2]};\n        ${u} sourceLocA = coords;\n        --${c[l-1]};\n        ${u} sourceLocB = coords;\n        --${c[l-2]};`;const f=["x","y","z","w","u","v"].slice(0,h),p="."+f[h-1],m=f.map(A=>"int "+A),g=Nr("sourceLocR",h-1).concat("inIdx.r"),y=Nr("sourceLocG",h-1).concat("inIdx.g"),b=Nr("sourceLocB",h-1).concat("inIdx.b"),v=Nr("sourceLocA",h-1).concat("inIdx.a"),x="max"===r?"greaterThan":"lessThan",w=s?"":`\n          inIdx = round(vec4(getBestIndicesAChannel(${g.join()}),\n                             getBestIndicesAChannel(${y.join()}),\n                             getBestIndicesAChannel(${b.join()}),\n                             getBestIndicesAChannel(${v.join()})));`,_=`vec4(\n            getAChannel(${g.join()}),\n            hasNextCol ? getAChannel(${y.join()}) : 0.,\n            hasNextRow ? getAChannel(${b.join()}) : 0.,\n            hasNextRow && hasNextCol ? getAChannel(${v.join()}) : 0.)`,D=s?"":`\n      float getBestIndicesAChannel(${m.join()}) {\n        return getChannel(getBestIndicesA(${f.join()}),\n                                          vec2(${f.slice(-2).join()}));\n      }`;this.userCode=`\n      float getAChannel(${m.join()}) {\n        return getChannel(getA(${f.join()}),\n                               vec2(${f.slice(-2).join()}));\n      }\n      ${D}\n      void main() {\n        ${u} coords = getOutputCoords();\n        bool hasNextCol = ${c[l-1]} < ${a[l-1]-1};\n        bool hasNextRow = ${c[l-2]} < ${a[l-2]-1};\n        ${d}\n        ivec4 srcIdx = ivec4(sourceLocR${p}, sourceLocG${p},\n          sourceLocB${p}, sourceLocA${p}) * ${e};\n        ivec4 inIdx = srcIdx;\n        vec4 bestIndex = vec4(inIdx);\n        vec4 bestValue = ${_};\n\n        for (int i = 0; i < ${e}; i++) {\n          inIdx = srcIdx;\n          ${w}\n          vec4 candidate = ${_};\n          bvec4 nan = isnan(candidate);\n          bvec4 replace = bvec4(\n            vec4(${x}(candidate, bestValue)) * (vec4(1.0) - vec4(nan)));\n\n          bestValue = vec4(replace.x  ? candidate.x : bestValue.x,\n                           replace.y  ? candidate.y : bestValue.y,\n                           replace.z  ? candidate.z : bestValue.z,\n                           replace.w  ? candidate.w : bestValue.w);\n          bestIndex = mix(bestIndex, vec4(inIdx), vec4(replace));\n          srcIdx++;\n        }\n        setOutput(bestIndex);\n      }\n    `}}function EP(t,n,e,r=null){let s=n.shape[0],o=n.shape[1];null!=r&&(s=r.shape[0],o=r.shape[1]);const i=Bg(o),a={windowSize:i,inSize:o,batchSize:s,outSize:Math.ceil(o/i)},l=new qhe(a,e,null==r),u=[n];null!=r&&u.push(r);const c=t.runWebGLProgram(l,u,"int32");if(1===c.shape[1])return c;const d=EP(t,n,e,c);return t.disposeIntermediateTensorInfo(c),d}function NP(t,n,e,r=null){const s=null!=r?r.shape:n.shape,i=Bg(s[s.length-1]),a=new Khe(s,i,e,null==r),u=t.runWebGLProgram(a,null==r?[n]:[n,r],"int32");if(u.shape.length===n.shape.length){const c=NP(t,n,e,u);return t.disposeIntermediateTensorInfo(u),c}return u}function TP(t,n,e,r){const s=[e];if(lr("arg"+r.charAt(0).toUpperCase()+r.slice(1),s,n.shape.length),!ne().getBool("WEBGL_PACK_REDUCE")||n.shape.length<=2){const o=[],[i,a]=Qn(n.shape,s),l=te(a),u=Se({inputs:{x:n},backend:t,attrs:{shape:[-1,l]}});o.push(u);const c=EP(t,u,r);o.push(c);const d=Se({inputs:{x:c},backend:t,attrs:{shape:i}});return o.forEach(h=>t.disposeIntermediateTensorInfo(h)),d}return NP(t,n,r)}const Yhe={kernelName:sm,backendName:"webgl",kernelFunc:function Xhe(t){const{inputs:n,backend:e,attrs:r}=t,{x:s}=n,{axis:o}=r;let i=ft(o,s.shape);const a=xn(i,s.shape.length);let l=s;const u=[];null!=a&&(l=zr({inputs:{x:s},backend:e,attrs:{perm:a}}),u.push(l),i=En(i.length,l.shape.length)),lr("argMax",[i[0]],l.shape.length);const c=TP(e,l,i[0],"max");return u.forEach(d=>e.disposeIntermediateTensorInfo(d)),c}},Qhe={kernelName:om,backendName:"webgl",kernelFunc:function Zhe(t){const{inputs:n,backend:e,attrs:r}=t,{x:s}=n,{axis:o}=r;let i=ft(o,s.shape);const a=xn(i,s.shape.length);let l=s;const u=[];null!=a&&(l=zr({inputs:{x:s},backend:e,attrs:{perm:a}}),u.push(l),i=En(i.length,l.shape.length)),lr("argMin",[i[0]],l.shape.length);const c=TP(e,l,i[0],"min");return u.forEach(d=>e.disposeIntermediateTensorInfo(d)),c}},efe=_t({opSnippet:"if (isnan(x)) return x;\n  if (abs(x) > 1.) {\n    return NAN;\n  }\n  return asin(x);\n"}),tfe={kernelName:fd,backendName:"webgl",kernelFunc:efe},rfe=_t({opSnippet:"if (isnan(x)) return x;return log(x + sqrt(x * x + 1.0));"}),sfe={kernelName:pd,backendName:"webgl",kernelFunc:rfe},ife=_t({opSnippet:"if (isnan(x)) return x;\n  return atan(x);\n"}),afe={kernelName:md,backendName:"webgl",kernelFunc:ife},cfe=cr({opSnippet:"\n  if (isnan(a)) return a;\n  if (isnan(b)) return b;\n\n  return atan(a, b);\n",packedOpSnippet:"\n  vec4 result = atan(a, b);\n  vec4 isNaN = min(vec4(isnan(a)) + vec4(isnan(b)), vec4(1.0));\n  \n  result.r = isNaN.r > 0. ? NAN : result.r;\n  result.g = isNaN.g > 0. ? NAN : result.g;\n  result.b = isNaN.b > 0. ? NAN : result.b;\n  result.a = isNaN.a > 0. ? NAN : result.a;\n\n  return result;\n"}),dfe={kernelName:yd,backendName:"webgl",kernelFunc:cfe},ffe=_t({opSnippet:"if (isnan(x)) return x;\n  if ((x < -1.0) || (x > 1.0)) return NAN;\nreturn (log(1.0 + x) - log(1.0 - x)) / 2.0;"}),pfe={kernelName:gd,backendName:"webgl",kernelFunc:ffe};class Jh{constructor(n,e,r,s=!1,o=!1){if(this.variableNames=["x"],"avg"===e&&r)throw new Error("Cannot compute positions for average pool.");const i=n.filterWidth,a=n.strideHeight,l=n.strideWidth,u=n.dilationHeight,c=n.dilationWidth,d=n.effectiveFilterHeight,h=n.effectiveFilterWidth,f=n.padInfo.top,p=n.padInfo.left;this.outputShape=n.outShape;const m="avg"===e;let b="0.0";if(m||(b="-1.0 / 1e-20"),r)return void(this.userCode=`\n        const ivec2 strides = ivec2(${a}, ${l});\n        const ivec2 pads = ivec2(${f}, ${p});\n\n        void main() {\n          ivec4 coords = getOutputCoords();\n          int batch = coords[0];\n          int d = coords[3];\n\n          ivec2 xRCCorner = coords.yz * strides - pads;\n          int xRCorner = xRCCorner.x;\n          int xCCorner = xRCCorner.y;\n\n          // max/min x(?, ?, d) to get y(yR, yC, d).\n          // ? = to be determined\n          float minMaxValue = 0.0;\n          float minMaxValueFound = 0.0;\n          int minMaxPosition = 0;\n          float avgValue = 0.0;\n\n          for (int wR = 0; wR < ${d};\n              wR += ${u}) {\n            int xR = xRCorner + wR;\n\n            if (xR < 0 || xR >= ${n.inHeight}) {\n              continue;\n            }\n\n            for (int wC = 0; wC < ${h};\n                wC += ${c}) {\n              int xC = xCCorner + wC;\n\n              if (xC < 0 || xC >= ${n.inWidth}) {\n                continue;\n              }\n\n              float value = getX(batch, xR, xC, d);\n\n              // If a min / max value has already been found, use it. If not,\n              // use the current value.\n              float currMinMaxValue = mix(\n                  value, minMaxValue, minMaxValueFound);\n              if (value >= currMinMaxValue) {\n                minMaxValue = value;\n                minMaxValueFound = 1.0;\n                minMaxPosition = ${s?o?`((batch  * ${n.inHeight} + xR) * ${n.inWidth} + xC) * ${n.inChannels} + d`:`(xR * ${n.inWidth} + xC) * ${n.inChannels} + d`:`wR * ${h} + wC`};\n              }\n            }\n          }\n          setOutput(float(minMaxPosition));\n        }\n      `);let x=`${e}(${e}(${e}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;"avg"===e&&(x="avgValue / count");const w=4*Math.floor(i/4),_=i%4,D=`\n      if (${m}) {\n        avgValue += dot(values, ones);\n      } else {\n        minMaxValue = max(values, minMaxValue);\n      }\n    `;this.userCode=`\n      const ivec2 strides = ivec2(${a}, ${l});\n      const ivec2 pads = ivec2(${f}, ${p});\n      const float initializationValue = ${b};\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\n\n      float count = 0.0;\n\n      float getValue(int batch, int xR, int xC, int d) {\n        if (xC < 0 || xC >= ${n.inWidth}) {\n          return initializationValue;\n        }\n        count += 1.0;\n        return getX(batch, xR, xC, d);\n      }\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d = coords[3];\n\n        ivec2 xRCCorner = coords.yz * strides - pads;\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        // max/min x(?, ?, d) to get y(yR, yC, d).\n        // ? = to be determined\n        vec4 minMaxValue = vec4(${b});\n        float avgValue = 0.0;\n        count = 0.0;\n\n        for (int wR = 0; wR < ${d};\n            wR += ${u}) {\n          int xR = xRCorner + wR;\n\n          if (xR < 0 || xR >= ${n.inHeight}) {\n            continue;\n          }\n\n          for (int wC = 0; wC < ${w}; wC += 4) {\n            int xC = xCCorner + wC * ${c};\n\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              getValue(batch, xR, xC + ${c}, d),\n              getValue(batch, xR, xC + 2 * ${c}, d),\n              getValue(batch, xR, xC + 3 * ${c}, d)\n            );\n\n            ${D}\n          }\n\n          int xC = xCCorner + ${w};\n          if (${1===_}) {\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              initializationValue,\n              initializationValue,\n              initializationValue\n            );\n\n            ${D}\n          } else if (${2===_}) {\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              getValue(batch, xR, xC + ${c}, d),\n              initializationValue,\n              initializationValue\n            );\n\n            ${D}\n          } else if (${3===_}) {\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              getValue(batch, xR, xC + ${c}, d),\n              getValue(batch, xR, xC + 2 * ${c}, d),\n              initializationValue\n            );\n\n            ${D}\n          }\n        }\n        setOutput(${x});\n      }\n    `}}class m_{constructor(n,e,r,s=!1,o=!1){if(this.variableNames=["x"],"avg"===e&&r)throw new Error("Cannot compute positions for average pool.");const i=n.filterWidth,a=n.strideDepth,l=n.strideHeight,u=n.strideWidth,c=n.dilationDepth,d=n.dilationHeight,h=n.dilationWidth,f=n.effectiveFilterDepth,p=n.effectiveFilterHeight,m=n.effectiveFilterWidth,g=n.padInfo.front,y=n.padInfo.top,b=n.padInfo.left;this.outputShape=n.outShape;const v="avg"===e;let x="0.0";if(v||(x="-1.0 / 1e-20"),r)return void(this.userCode=`\n        const ivec3 strides =\n            ivec3(${a}, ${l}, ${u});\n        const ivec3 pads = ivec3(${g}, ${y}, ${b});\n\n        void main() {\n          ivec5 coords = getOutputCoords();\n          int batch = coords.x;\n          int ch = coords.u;\n\n          ivec3 xCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;\n          int xDCorner = xCorner.x;\n          int xRCorner = xCorner.y;\n          int xCCorner = xCorner.z;\n\n          // max/min x(?, ?, ?, ch) to get y(yD, yR, yC, ch).\n          // ? = to be determined\n          float minMaxValue = 0.0;\n          float minMaxValueFound = 0.0;\n          int minMaxPosition = 0;\n\n          for (int wD = 0; wD < ${f};\n              wD += ${c}) {\n            int xD = xDCorner + wD;\n\n            if (xD < 0 || xD >= ${n.inDepth}) {\n              continue;\n            }\n\n            for (int wR = 0; wR < ${p};\n                wR += ${d}) {\n              int xR = xRCorner + wR;\n\n              if (xR < 0 || xR >= ${n.inHeight}) {\n                continue;\n              }\n\n              for (int wC = 0; wC < ${m};\n                  wC += ${h}) {\n                int xC = xCCorner + wC;\n\n                if (xC < 0 || xC >= ${n.inWidth}) {\n                  continue;\n                }\n\n                float value = getX(batch, xD, xR, xC, ch);\n\n                // If a min / max value has already been found, use it. If not,\n                // use the current value.\n                float currMinMaxValue = mix(\n                    value, minMaxValue, minMaxValueFound);\n                if (value >= currMinMaxValue) {\n                  minMaxValue = value;\n                  minMaxValueFound = 1.0;\n                  minMaxPosition = ${s?o?`(((batch * ${n.inDepth} + xD) * ${n.inHeight} + xR) * ${n.inWidth} + xC) * ${n.inChannels} + ch`:`((xD * ${n.inHeight} + xR) * ${n.inWidth} + xC) * ${n.inChannels} + ch`:`wD * ${p} * ${m} +\n                      wR * ${m} + wC`};\n                }\n              }\n            }\n          }\n          setOutput(float(minMaxPosition));\n        }\n      `);let _=`${e}(${e}(${e}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;"avg"===e&&(_="avgValue / count");const D=4*Math.floor(i/4),A=i%4,R=`\n      if (${v}) {\n        avgValue += dot(values, ones);\n      } else {\n        minMaxValue = max(values, minMaxValue);\n      }\n    `;this.userCode=`\n      const ivec3 strides =\n        ivec3(${a}, ${l}, ${u});\n      const ivec3 pads = ivec3(${g}, ${y}, ${b});\n      const float initializationValue = ${x};\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\n\n      float count = 0.0;\n\n      float getValue(int batch, int xD, int xR, int xC, int ch) {\n        if (xC < 0 || xC >= ${n.inWidth}) {\n          return initializationValue;\n        }\n        count += 1.0;\n        return getX(batch, xD, xR, xC, ch);\n      }\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int ch = coords.u;\n\n        ivec3 xCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;\n        int xDCorner = xCorner.x;\n        int xRCorner = xCorner.y;\n        int xCCorner = xCorner.z;\n\n        // max/min x(?, ?, ?, d) to get y(yD, yR, yC, ch).\n        // ? = to be determined\n        vec4 minMaxValue = vec4(${x});\n        float avgValue = 0.0;\n        count = 0.0;\n\n        for (int wD = 0; wD < ${f};\n            wD += ${c}) {\n          int xD = xDCorner + wD;\n\n          if (xD < 0 || xD >= ${n.inDepth}) {\n            continue;\n          }\n\n          for (int wR = 0; wR < ${p};\n            wR += ${d}) {\n            int xR = xRCorner + wR;\n\n            if (xR < 0 || xR >= ${n.inHeight}) {\n              continue;\n            }\n\n            for (int wC = 0; wC < ${D}; wC += 4) {\n              int xC = xCCorner + wC * ${h};\n\n              vec4 values = vec4(\n                getValue(batch, xD, xR, xC, ch),\n                getValue(batch, xD, xR, xC + ${h}, ch),\n                getValue(batch, xD, xR, xC + 2 * ${h}, ch),\n                getValue(batch, xD, xR, xC + 3 * ${h}, ch)\n              );\n\n              ${R}\n            }\n\n            int xC = xCCorner + ${D};\n            if (${1===A}) {\n              vec4 values = vec4(\n                getValue(batch, xD, xR, xC, ch),\n                initializationValue,\n                initializationValue,\n                initializationValue\n              );\n\n              ${R}\n            } else if (${2===A}) {\n              vec4 values = vec4(\n                getValue(batch, xD, xR, xC, ch),\n                getValue(batch, xD, xR, xC + ${h}, ch),\n                initializationValue,\n                initializationValue\n              );\n\n              ${R}\n            } else if (${3===A}) {\n              vec4 values = vec4(\n                getValue(batch, xD, xR, xC, ch),\n                getValue(batch, xD, xR, xC + ${h}, ch),\n                getValue(batch, xD, xR, xC + 2 * ${h}, ch),\n                initializationValue\n              );\n\n              ${R}\n            }\n          }\n          setOutput(${_});\n        }\n      }\n    `}}const gfe={kernelName:im,backendName:"webgl",kernelFunc:function mfe(t){const{inputs:n,backend:e,attrs:r}=t,{x:s}=n;Yh(s,"avgPool");const{filterSize:o,strides:i,pad:a,dimRoundingMode:l}=r;S(ar(i,1),()=>`Error in avgPool: Either strides or dilations must be 1. Got strides ${i} and dilations '1'`);const c=ks(s.shape,o,i,1,a,l);if(1===c.filterWidth&&1===c.filterHeight&&Mt(c.inShape,c.outShape))return Jr({inputs:{x:s},backend:e});const d=new Jh(c,"avg",!1);return e.runWebGLProgram(d,[s],"float32")}},bfe={kernelName:am,backendName:"webgl",kernelFunc:function yfe(t){const{inputs:n,backend:e,attrs:r}=t,{x:s}=n,{filterSize:o,strides:i,pad:a,dimRoundingMode:l,dataFormat:u}=r,d=ri(s.shape,o,i,[1,1,1],a,l,u),h=new m_(d,"avg",!1);return e.runWebGLProgram(h,[s],"float32")}};class vfe{constructor(n){this.variableNames=["dy"],this.outputShape=n.inShape;const l=n.effectiveFilterHeight,u=n.effectiveFilterWidth;this.userCode=`\n      const ivec2 pads = ivec2(${l-1-n.padInfo.top}, ${u-1-n.padInfo.left});\n      const float avgMultiplier = float(${1/(n.filterHeight*n.filterWidth)});\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n\n        ivec2 dyRCCorner = coords.yz - pads;\n        int dyRCorner = dyRCCorner.x;\n        int dyCCorner = dyRCCorner.y;\n\n        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < ${l};\n            wR += ${n.dilationHeight}) {\n          float dyR = float(dyRCorner + wR) / ${n.strideHeight}.0;\n\n          if (dyR < 0.0 || dyR >= ${n.outHeight}.0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          for (int wC = 0; wC < ${u};\n            wC+= ${n.dilationWidth}) {\n            float dyC = float(dyCCorner + wC) / ${n.strideWidth}.0;\n\n            if (dyC < 0.0 || dyC >= ${n.outWidth}.0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            float dyValue = getDy(b, idyR, idyC, d);\n\n            dotProd += dyValue * avgMultiplier;\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}class xfe{constructor(n){this.variableNames=["dy"],this.outputShape=n.inShape;const d=n.effectiveFilterDepth,h=n.effectiveFilterHeight,f=n.effectiveFilterWidth;this.userCode=`\n      const ivec3 pads = ivec3(${d-1-n.padInfo.front}, ${h-1-n.padInfo.top}, ${f-1-n.padInfo.left});\n      const float avgMultiplier = float(${1/(n.filterDepth*n.filterHeight*n.filterWidth)});\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int ch = coords.u;\n\n        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;\n        int dyDCorner = dyCorner.x;\n        int dyRCorner = dyCorner.y;\n        int dyCCorner = dyCorner.z;\n\n        // Convolve dy(?, ?, ?, d) with pos mask(:, :, :, ch) to get\n        // dx(xD, xR, xC, ch).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n\n        for (int wD = 0; wD < ${d};\n            wD += ${n.dilationDepth}) {\n          float dyD = float(dyDCorner + wD) / ${n.strideDepth}.0;\n\n          if (dyD < 0.0 || dyD >= ${n.outDepth}.0 || fract(dyD) > 0.0) {\n            continue;\n          }\n          int idyD = int(dyD);\n\n          for (int wR = 0; wR < ${h};\n              wR += ${n.dilationHeight}) {\n            float dyR = float(dyRCorner + wR) / ${n.strideHeight}.0;\n\n            if (dyR < 0.0 || dyR >= ${n.outHeight}.0 ||\n                fract(dyR) > 0.0) {\n              continue;\n            }\n            int idyR = int(dyR);\n\n            for (int wC = 0; wC < ${f};\n                wC += ${n.dilationWidth}) {\n              float dyC = float(dyCCorner + wC) / ${n.strideWidth}.0;\n\n              if (dyC < 0.0 || dyC >= ${n.outWidth}.0 ||\n                  fract(dyC) > 0.0) {\n                continue;\n              }\n              int idyC = int(dyC);\n\n              float dyValue = getDy(batch, idyD, idyR, idyC, ch);\n\n              dotProd += dyValue * avgMultiplier;\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}const Cfe={kernelName:tw,backendName:"webgl",kernelFunc:function wfe(t){const{inputs:n,backend:e,attrs:r}=t,{dy:s,input:o}=n,i=o,{filterSize:a,strides:l,pad:u,dimRoundingMode:c}=r,h=ri(i.shape,a,l,[1,1,1],u,c),f=new xfe(h);return e.runWebGLProgram(f,[s],i.dtype)}},Dfe={kernelName:ew,backendName:"webgl",kernelFunc:function Ife(t){const{inputs:n,backend:e,attrs:r}=t,{dy:s,input:o}=n,i=o;Yh([s,o],"avgPoolGrad");const{filterSize:a,strides:l,pad:u}=r,c=ks(i.shape,a,l,1,u),d=new vfe(c);return e.runWebGLProgram(d,[s],i.dtype)}},Sfe={kernelName:lm,backendName:"webgl",kernelFunc:function _fe(t){const{inputs:n,backend:e,attrs:r}=t,{a:s,b:o}=n,{transposeA:i,transposeB:a}=r;return Ly({a:s,b:o,transposeA:i,transposeB:a,backend:e})}};class Efe{constructor(n,e,r,s,o,i){this.outputShape=[],this.variableNames=["x","mean","variance"],bt(n,e),bt(n,r);let a="0.0";null!=s&&(bt(n,s),this.variableNames.push("offset"),a="getOffsetAtOutCoords()");let l="1.0";null!=o&&(bt(n,o),this.variableNames.push("scale"),l="getScaleAtOutCoords()"),this.outputShape=n,this.userCode=`\n      void main() {\n        float x = getXAtOutCoords();\n        float mean = getMeanAtOutCoords();\n        float variance = getVarianceAtOutCoords();\n        float offset = ${a};\n        float scale = ${l};\n        float inv = scale * inversesqrt(variance + float(${i}));\n        setOutput(dot(vec3(x, -mean, offset), vec3(inv, inv, 1)));\n      }\n    `}}class Nfe{constructor(n,e,r,s,o,i){this.packedInputs=!0,this.packedOutput=!0,this.variableNames=["x","mean","variance"],bt(n,e),bt(n,r);let a="vec4(0.0)";null!=s&&(bt(n,s),this.variableNames.push("offset"),a="getOffsetAtOutCoords()");let l="vec4(1.0)";null!=o&&(bt(n,o),this.variableNames.push("scale"),l="getScaleAtOutCoords()"),this.outputShape=n,this.userCode=`\n      void main() {\n        vec4 offset = ${a};\n        vec4 scale = ${l};\n\n        vec4 x = getXAtOutCoords();\n        vec4 mean = getMeanAtOutCoords();\n        vec4 variance = getVarianceAtOutCoords();\n\n        vec4 inv = scale * inversesqrt(variance + vec4(${i}));\n\n        setOutput((x - mean) * inv + offset);\n      }\n    `}}const Tfe={kernelName:xm,backendName:"webgl",kernelFunc:({inputs:t,backend:n,attrs:e})=>{const{x:r,mean:s,variance:o,offset:i,scale:a}=t;S(s.shape.length===o.shape.length,()=>"Batch normalization gradient requires mean and variance to have equal ranks."),S(null==i||s.shape.length===i.shape.length,()=>"Batch normalization gradient requires mean and offset to have equal ranks."),S(null==a||s.shape.length===a.shape.length,()=>"Batch normalization gradient requires mean and scale to have equal ranks.");let{varianceEpsilon:l}=e;null==l&&(l=.001);const u=[r,s,o];let c=null;null!=i&&(c=i.shape,u.push(i));let d=null;null!=a&&(d=a.shape,u.push(a));const h=ne().getBool("WEBGL_PACK_NORMALIZATION")?new Nfe(r.shape,s.shape,o.shape,c,d,l):new Efe(r.shape,s.shape,o.shape,c,d,l);return n.runWebGLProgram(h,u,u[0].dtype)}};class kfe{constructor(n){this.variableNames=["source"],this.outputShape=n,this.rank=n.length;const e=Wt(this.rank),r=`uniform int start[${this.rank}];`,s=function Afe(t){if(1===t)return"sourceLoc";if(t<=6)return g_.slice(0,t).map(n=>"sourceLoc."+n).join(",");throw Error(`Slicing for rank ${t} is not yet supported`)}(this.rank);let o;o=`\n        ${e} sourceLoc;\n        ${e} coords = getOutputCoords();\n        ${n.map((a,l)=>`sourceLoc.${g_[l]} = start[${l}] + coords.${g_[l]};`).join("\n")}\n      `,this.userCode=`\n      ${r}\n      void main() {\n        ${o}\n        setOutput(getSource(${s}));\n      }\n    `}getCustomSetupFunc(n){if(n.length!==this.rank)throw Error(`The rank (${this.rank}) of the program must match the length of start (${n.length})`);return(e,r)=>{null==this.startLoc&&(this.startLoc=e.getUniformLocationNoThrow(r,"start"),null==this.startLoc)||e.gl.uniform1iv(this.startLoc,n)}}}const g_=["x","y","z","w","u","v"];class Rfe{constructor(n){this.variableNames=["source"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=n,this.rank=n.length;const e=Wt(this.rank),r=Nr("coords",this.rank),s=Nr("sourceLoc",this.rank),o=1===this.rank?"sourceLoc":`vec2(${s.slice(-2).join()})`,i=`getChannel(getSource(${s.join()}), ${o})`,a=`\n      result.x = ${i};\n      if (++${r[this.rank-1]} < ${n[this.rank-1]}) {\n        ++${s[this.rank-1]};\n        result.y = ${i};\n        --${s[this.rank-1]};\n      }\n    `,l=1===this.rank?"":`\n      --${r[this.rank-1]};\n      if (++${r[this.rank-2]} < ${n[this.rank-2]}) {\n        ++${s[this.rank-2]};\n        result.z = ${i};\n        if (++${r[this.rank-1]} < ${n[this.rank-1]}) {\n          ++${s[this.rank-1]};\n          result.w = ${i};\n        }\n      }\n    `,u=this.rank<=4?`sourceLoc = coords +\n            ${e}(${n.map((c,d)=>`start[${d}]`).join()});`:n.map((c,d)=>`${s[d]} = ${r[d]} + start[${d}];`).join("\n");this.userCode=`\n      uniform int start[${this.rank}];\n      void main() {\n        ${e} coords = getOutputCoords();\n        ${e} sourceLoc;\n        ${u}\n        vec4 result = vec4(0.);\n        ${a}\n        ${l}\n        setOutput(result);\n      }\n    `}getCustomSetupFunc(n){if(n.length!==this.rank)throw Error(`The rank (${this.rank}) of the program must match the length of start (${n.length})`);return(e,r)=>{null==this.startLoc&&(this.startLoc=e.getUniformLocationNoThrow(r,"start"),null==this.startLoc)||e.gl.uniform1iv(this.startLoc,n)}}}function ef(t){const{inputs:n,backend:e,attrs:r}=t,{x:s}=n,{begin:o,size:i}=r,[a,l]=yg(s,o,i);if(gC(s,a,l),0===te(l))return e.makeTensorInfo(l,s.dtype,[]);if(e.shouldExecuteOnCPU([s])||"string"===s.dtype){const d=e.texData.get(s.dataId),h=Sde(d.values,a,l,s.shape,s.dtype);return e.makeTensorInfo(l,s.dtype,h)}const{isPacked:u}=e.texData.get(s.dataId),c=yC(s.shape,a,l);if(u||!c){const d=ne().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new Rfe(l):new kfe(l),h=d.getCustomSetupFunc(a);return e.runWebGLProgram(d,[s],s.dtype,h)}return e.uploadToGPU(s.dataId),function $fe(t,n,e,r){const s=r.texData.get(t.dataId),o=r.makeTensorInfo(e,t.dtype),i=r.texData.get(o.dataId);Object.assign(i,s),i.refCount=1,i.shape=e,i.dtype=t.dtype;let a=bC(n,Le(t.shape));s.slice&&(a+=s.slice.flatOffset),i.slice={flatOffset:a,origDataId:s.slice&&s.slice.origDataId||t.dataId};const l=r.dataRefCount.get(i.slice.origDataId)||1;return r.dataRefCount.set(i.slice.origDataId,l+1),o}(s,a,l,e)}const Ffe={kernelName:Km,backendName:"webgl",kernelFunc:ef},Ofe={kernelName:um,backendName:"webgl",kernelFunc:t=>{const{inputs:n,backend:e,attrs:r}=t,{x:s}=n,{blockShape:o,crops:i}=r;S(s.shape.length<=4,()=>"batchToSpaceND for rank > 4 with a WebGL backend not implemented yet");const a=o.reduce((b,v)=>b*v),l=Sh(s.shape,o,a),u=Eh(l.length,o.length),c=Nh(s.shape,o,a),d=dI(i,o.length),h=hI(c,i,o.length),f=[],p=Se({inputs:{x:s},backend:e,attrs:{shape:l}}),m=zr({inputs:{x:p},backend:e,attrs:{perm:u}}),g=Se({inputs:{x:m},backend:e,attrs:{shape:c}}),y=ef({inputs:{x:g},backend:e,attrs:{begin:d,size:h}});return f.push(p),f.push(m),f.push(g),f.forEach(b=>e.disposeIntermediateTensorInfo(b)),y}},Pfe={kernelName:nw,backendName:"webgl",kernelFunc:function Mfe(t){const{inputs:n,backend:e,attrs:r}=t,{x:s,weights:o}=n,{size:i}=r,a=e.readSync(s.dataId),l=e.readSync(o.dataId),u=sP(a,l,o.dtype,o.shape,i);return e.makeTensorInfo([i],o.dtype,u)}},kP=cr({opSnippet:"return float(a != b);",dtype:"bool"}),Lfe={kernelName:Pm,backendName:"webgl",kernelFunc:kP};function nf(t){const{inputs:n,backend:e}=t,{input:r}=n;return Jr({inputs:{x:e.texData.get(r.dataId).complexTensorInfos.real},backend:e})}const Bfe={kernelName:Rw,backendName:"webgl",kernelFunc:nf},Ufe={kernelName:bd,backendName:"webgl",kernelFunc:function y_(t){const{inputs:n,backend:e,attrs:r}=t,{x:s}=n,{dtype:o}=r;if("complex64"===o){if("complex64"===s.dtype)return Jr({inputs:{x:s},backend:e});const i=Nn(s.shape),a=y_({inputs:{x:s},backend:e,attrs:{dtype:"float32"}}),l=Ji({inputs:{real:a,imag:i},backend:e});return i.dispose(),e.disposeIntermediateTensorInfo(a),l}if("complex64"===s.dtype){const i=nf({inputs:{input:s},backend:e}),a=y_({inputs:{x:i},backend:e,attrs:{dtype:o}});return e.disposeIntermediateTensorInfo(i),a}if(!KR(s.dtype,o)){const i=Jr({inputs:{x:s},backend:e});return{dataId:i.dataId,shape:i.shape,dtype:o}}if("int32"===o)return function Vfe(t,n){const e=new Qi(t.shape,"return float(int(x));"),r=n.runWebGLProgram(e,[t],"int32");return{dataId:r.dataId,shape:r.shape,dtype:r.dtype}}(s,e);if("bool"===o){const i=e.makeTensorInfo([],"bool",or("bool",1)),l=kP({inputs:{a:s,b:i},backend:e});return e.disposeIntermediateTensorInfo(i),l}throw new Error(`Error in Cast: failed to cast ${s.dtype} to ${o}`)}},AP="return ceil(x);",Wfe=_t({opSnippet:AP,packedOpSnippet:AP,cpuKernelImpl:lde}),Hfe={kernelName:vd,backendName:"webgl",kernelFunc:Wfe};class Gfe{constructor(n){this.variableNames=["A"],this.outputShape=n,this.userCode="\n      uniform float minVal;\n      uniform float maxVal;\n\n      void main() {\n        float value = getAAtOutCoords();\n        if (isnan(value)) {\n          setOutput(value);\n          return;\n        }\n\n        setOutput(clamp(value, minVal, maxVal));\n      }\n    "}getCustomSetupFunc(n,e){return(r,s)=>{null==this.minLoc&&(this.minLoc=r.getUniformLocationNoThrow(s,"minVal"),this.maxLoc=r.getUniformLocationNoThrow(s,"maxVal")),r.gl.uniform1f(this.minLoc,n),r.gl.uniform1f(this.maxLoc,e)}}}class jfe{constructor(n){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=n,this.userCode="\n      uniform float minVal;\n      uniform float maxVal;\n\n      void main() {\n        vec4 value = getAAtOutCoords();\n\n        if (any(isnan(value))) {\n          setOutput(value);\n          return;\n        }\n\n        setOutput(clamp(value, vec4(minVal), vec4(maxVal)));\n      }\n    "}getCustomSetupFunc(n,e){return(r,s)=>{null==this.minLoc&&(this.minLoc=r.getUniformLocationNoThrow(s,"minVal"),this.maxLoc=r.getUniformLocationNoThrow(s,"maxVal")),r.gl.uniform1f(this.minLoc,n),r.gl.uniform1f(this.maxLoc,e)}}}const Kfe={kernelName:xd,backendName:"webgl",kernelFunc:function qfe(t){const{inputs:n,backend:e,attrs:r}=t,{x:s}=n,{clipValueMin:o,clipValueMax:i}=r;let a;a=ne().getBool("WEBGL_PACK_CLIP")?new jfe(s.shape):new Gfe(s.shape);const l=a.getCustomSetupFunc(o,i);return e.runWebGLProgram(a,[s],s.dtype,l)}};class Xfe{constructor(n){this.variableNames=["real","imag"],this.outputShape=n,this.userCode="\n      void main() {\n        float re = abs(getRealAtOutCoords());\n        float im = abs(getImagAtOutCoords());\n        float mx = max(re, im);\n\n        // sadly the length function in glsl is not underflow-safe\n        // (at least not on Intel GPUs). So the safe solution is\n        // to ensure underflow-safety in all cases.\n        setOutput(\n          mx == 0.0 ? 0.0 : mx * length(vec2(1, min(re, im)/mx))\n        );\n      }\n    "}}function RP(t,n){return{dataId:n.dataId,dtype:n.dtype,shape:t.shape}}const Zfe={kernelName:cm,backendName:"webgl",kernelFunc:function Yfe(t){const{inputs:n,backend:e}=t,{x:r}=n,s=e.texData.get(r.dataId),o=new Xfe(r.shape),i=[RP(r,s.complexTensorInfos.real),RP(r,s.complexTensorInfos.imag)];return e.runWebGLProgram(o,i,i[0].dtype)}};class Qfe{constructor(n){this.outputShape=[],this.outputShape=ci(n,1),this.variableNames=n.map((i,a)=>`T${a}`);const e=new Array(n.length-1);e[0]=n[0][1];for(let i=1;i<e.length;i++)e[i]=e[i-1]+n[i][1];const r=[`if (yC < ${e[0]}) setOutput(getT0(yR, yC));`];for(let i=1;i<e.length;i++)r.push(`else if (yC < ${e[i]}) setOutput(getT${i}(yR, yC-${e[i-1]}));`);r.push(`else setOutput(getT${e.length}(yR, yC-${e[e.length-1]}));`),this.userCode=`\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int yR = coords.x;\n        int yC = coords.y;\n\n        ${r.join("\n        ")}\n      }\n    `}}class Jfe{constructor(n,e){this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[],this.outputShape=ci(n,e);const r=this.outputShape,s=r.length,o=Wt(s),i=Nr("coords",s),a=["x","y","z","w","u","v"].slice(0,s);this.variableNames=n.map((m,g)=>`T${g}`);const l=new Array(n.length-1);l[0]=n[0][e];for(let m=1;m<l.length;m++)l[m]=l[m-1]+n[m][e];const u=a[e],c=a.slice(-2),d=a.join();let h=`if (${u} < ${l[0]}) {\n        return getChannel(\n            getT0(${d}), vec2(${c.join()}));\n        }`;for(let m=1;m<l.length;m++){const g=l[m-1];h+=`\n        if (${u} < ${l[m]}  && ${u} >= ${l[m-1]}) {\n          return getChannel(\n            getT${m}(${zy(a,u,g)}),\n            vec2(${zy(c,u,g)}));\n        }`}const p=l[l.length-1];h+=`\n        return getChannel(\n          getT${l.length}(${zy(a,u,p)}),\n          vec2(${zy(c,u,p)}));`,this.userCode=`\n      float getValue(${a.map(m=>"int "+m)}) {\n        ${h}\n      }\n\n      void main() {\n        ${o} coords = getOutputCoords();\n        vec4 result = vec4(getValue(${i}), 0., 0., 0.);\n\n        ${i[s-1]} = ${i[s-1]} + 1;\n        if (${i[s-1]} < ${r[s-1]}) {\n          result.g = getValue(${i});\n        }\n\n        ${i[s-2]} = ${i[s-2]} + 1;\n        if (${i[s-2]} < ${r[s-2]}) {\n          result.a = getValue(${i});\n        }\n\n        ${i[s-1]} = ${i[s-1]} - 1;\n        if (${i[s-2]} < ${r[s-2]} &&\n            ${i[s-1]} < ${r[s-1]}) {\n          result.b = getValue(${i});\n        }\n        setOutput(result);\n      }\n    `}}function zy(t,n,e){const r=t.indexOf(n);return t.map((o,i)=>i===r?`${o} - ${e}`:o).join()}function Vy(t){const{inputs:n,backend:e}=t,{input:r}=n;return Jr({inputs:{x:e.texData.get(r.dataId).complexTensorInfos.imag},backend:e})}const epe={kernelName:xw,backendName:"webgl",kernelFunc:Vy};function Gu(t,n,e){const r=t[0].dtype;if("complex64"===r){const u=t.map(p=>nf({inputs:{input:p},backend:e})),c=t.map(p=>Vy({inputs:{input:p},backend:e})),d=Gu(u,n,e),h=Gu(c,n,e),f=Ji({inputs:{real:d,imag:h},backend:e});return u.forEach(p=>e.disposeIntermediateTensorInfo(p)),c.forEach(p=>e.disposeIntermediateTensorInfo(p)),e.disposeIntermediateTensorInfo(d),e.disposeIntermediateTensorInfo(h),f}if("string"===r){const{tensors2D:u,outShape:c}=$P(t,n,e),d=u.map(g=>({vals:e.readSync(g.dataId),shape:g.shape})),f=ude(d,c,r,1===u[0].shape[0]),p=ci(t.map(g=>g.shape),n),m=e.makeTensorInfo(p,r,f);return u.forEach(g=>e.disposeIntermediateTensorInfo(g)),m}if(t.length>ne().getNumber("WEBGL_MAX_TEXTURES_IN_SHADER")){const u=Math.floor(t.length/2),c=Gu(t.slice(0,u),n,e),d=Gu(t.slice(u),n,e),h=Gu([c,d],n,e);return e.disposeIntermediateTensorInfo(c),e.disposeIntermediateTensorInfo(d),h}if(ne().getBool("WEBGL_PACK_ARRAY_OPERATIONS")&&t[0].shape.length>1){const u=new Jfe(t.map(c=>c.shape),n);return e.runWebGLProgram(u,t,r)}const{tensors2D:s,outShape:o}=$P(t,n,e),i=new Qfe(s.map(u=>u.shape)),a=e.runWebGLProgram(i,s,r);s.forEach(u=>e.disposeIntermediateTensorInfo(u));const l=Se({inputs:{x:a},attrs:{shape:o},backend:e});return e.disposeIntermediateTensorInfo(a),l}function $P(t,n,e){const r=ci(t.map(o=>o.shape),n);return{tensors2D:t.map(o=>Se({inputs:{x:o},attrs:{shape:[-1,te(o.shape.slice(n))]},backend:e})),outShape:r}}function FP(t){const{inputs:n,backend:e,attrs:r}=t,{axis:s}=r,o=ft(s,n[0].shape)[0],i=ci(n.map(u=>u.shape),o);if(0===te(i))return e.makeTensorInfo(i,n[0].dtype,[]);const a=n.filter(u=>te(u.shape)>0);return 1===a.length?Jr({inputs:{x:a[0]},backend:e}):(lI(a.map(u=>u.shape),o),Gu(a,o,e))}const tpe={kernelName:dm,backendName:"webgl",kernelFunc:FP};class OP{constructor(n,e=!1,r=null,s=!1,o=!1){this.variableNames=["x","W"],this.outputShape=n.outShape;const i=n.padInfo.top,a=n.padInfo.left,l=n.strideHeight,u=n.strideWidth,c=n.dilationHeight,d=n.dilationWidth,h=n.filterHeight,f=n.filterWidth,p=4*Math.floor(n.inChannels/4),m=n.inChannels%4,g="channelsLast"===n.dataFormat,y=g?1:2,b=g?2:3,v=g?3:1;let x="",w="";r&&(x=s?`float activation(float a) {\n          float b = getPreluActivationWeightsAtOutCoords();\n          ${r}\n        }`:o?`float activation(float a) {\n          float b = getLeakyreluAlphaAtOutCoords();\n          ${r}\n        }`:`\n          float activation(float x) {\n            ${r}\n          }\n        `,w="result = activation(result);");const _=e?"result += getBiasAtOutCoords();":"";e&&this.variableNames.push("bias"),s&&this.variableNames.push("preluActivationWeights"),o&&this.variableNames.push("leakyreluAlpha"),this.userCode=`\n      ${x}\n\n      const ivec2 strides = ivec2(${l}, ${u});\n      const ivec2 pads = ivec2(${i}, ${a});\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d2 = coords[${v}];\n\n        ivec2 xRCCorner =\n            ivec2(coords[${y}], coords[${b}]) * strides - pads;\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        // Convolve x(?, ?, d1) with w(:, :, d1, d2) to get y(yR, yC, d2).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < ${h}; wR++) {\n          int xR = xRCorner + wR * ${c};\n\n          if (xR < 0 || xR >= ${n.inHeight}) {\n            continue;\n          }\n\n          for (int wC = 0; wC < ${f}; wC++) {\n            int xC = xCCorner + wC * ${d};\n\n            if (xC < 0 || xC >= ${n.inWidth}) {\n              continue;\n            }\n\n            for (int d1 = 0; d1 < ${p}; d1 += 4) {\n              vec4 wValues = vec4(\n                getW(wR, wC, d1, d2),\n                getW(wR, wC, d1 + 1, d2),\n                getW(wR, wC, d1 + 2, d2),\n                getW(wR, wC, d1 + 3, d2)\n              );\n\n              if (${g}) {\n                vec4 xValues = vec4(\n                  getX(batch, xR, xC, d1),\n                  getX(batch, xR, xC, d1 + 1),\n                  getX(batch, xR, xC, d1 + 2),\n                  getX(batch, xR, xC, d1 + 3)\n                );\n                dotProd += dot(xValues, wValues);\n              } else {\n                vec4 xValues = vec4(\n                  getX(batch, d1, xR, xC),\n                  getX(batch, d1 + 1, xR, xC),\n                  getX(batch, d1 + 2, xR, xC),\n                  getX(batch, d1 + 3, xR, xC)\n                );\n                dotProd += dot(xValues, wValues);\n              }\n            }\n\n            if (${1===m}) {\n\n              if (${g}) {\n                dotProd +=\n                    getX(batch, xR, xC, ${p}) *\n                    getW(wR, wC, ${p}, d2);\n              } else {\n                dotProd +=\n                    getX(batch, ${p}, xR, xC) *\n                    getW(wR, wC, ${p}, d2);\n              }\n\n            } else if (${2===m}) {\n              vec2 wValues = vec2(\n                getW(wR, wC, ${p}, d2),\n                getW(wR, wC, ${p} + 1, d2)\n              );\n\n              if (${g}) {\n                vec2 xValues = vec2(\n                  getX(batch, xR, xC, ${p}),\n                  getX(batch, xR, xC, ${p} + 1)\n                );\n                dotProd += dot(xValues, wValues);\n              } else {\n                vec2 xValues = vec2(\n                  getX(batch, ${p}, xR, xC),\n                  getX(batch, ${p} + 1, xR, xC)\n                );\n                dotProd += dot(xValues, wValues);\n              }\n\n            } else if (${3===m}) {\n              vec3 wValues = vec3(\n                getW(wR, wC, ${p}, d2),\n                getW(wR, wC, ${p} + 1, d2),\n                getW(wR, wC, ${p} + 2, d2)\n              );\n\n              if (${g}) {\n                vec3 xValues = vec3(\n                  getX(batch, xR, xC, ${p}),\n                  getX(batch, xR, xC, ${p} + 1),\n                  getX(batch, xR, xC, ${p} + 2)\n                );\n                dotProd += dot(xValues, wValues);\n              } else {\n                vec3 xValues = vec3(\n                  getX(batch, ${p}, xR, xC),\n                  getX(batch, ${p} + 1, xR, xC),\n                  getX(batch, ${p} + 2, xR, xC)\n                );\n                dotProd += dot(xValues, wValues);\n              }\n\n            }\n          }\n        }\n\n        float result = dotProd;\n        ${_}\n        ${w}\n        setOutput(result);\n      }\n    `}}class npe{constructor(n){this.variableNames=["x","W"],this.outputShape=n.outShape;const e=n.padInfo.front,r=n.padInfo.top,s=n.padInfo.left,o=n.strideDepth,i=n.strideHeight,a=n.strideWidth,l=n.dilationDepth,u=n.dilationHeight,c=n.dilationWidth,d=n.filterDepth,h=n.filterHeight,f=n.filterWidth,p=4*Math.floor(n.inChannels/4),m=n.inChannels%4;this.userCode=`\n      const ivec3 strides = ivec3(${o}, ${i}, ${a});\n      const ivec3 pads = ivec3(${e}, ${r}, ${s});\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int d2 = coords.u;\n\n        ivec3 xFRCCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;\n        int xFCorner = xFRCCorner.x;\n        int xRCorner = xFRCCorner.y;\n        int xCCorner = xFRCCorner.z;\n\n        // Convolve x(?, ?, ?, d1) with w(:, :, :, d1, d2) to get\n        // y(yF, yR, yC, d2). ? = to be determined. : = across all\n        // values in that axis.\n        float dotProd = 0.0;\n        for (int wF = 0; wF < ${d}; wF++) {\n          int xF = xFCorner + wF * ${l};\n\n          if (xF < 0 || xF >= ${n.inDepth}) {\n            continue;\n          }\n\n          for (int wR = 0; wR < ${h}; wR++) {\n            int xR = xRCorner + wR * ${u};\n\n            if (xR < 0 || xR >= ${n.inHeight}) {\n              continue;\n            }\n\n            for (int wC = 0; wC < ${f}; wC++) {\n              int xC = xCCorner + wC * ${c};\n\n              if (xC < 0 || xC >= ${n.inWidth}) {\n                continue;\n              }\n\n              for (int d1 = 0; d1 < ${p}; d1 += 4) {\n                vec4 xValues = vec4(\n                  getX(batch, xF, xR, xC, d1),\n                  getX(batch, xF, xR, xC, d1 + 1),\n                  getX(batch, xF, xR, xC, d1 + 2),\n                  getX(batch, xF, xR, xC, d1 + 3)\n                );\n                vec4 wValues = vec4(\n                  getW(wF, wR, wC, d1, d2),\n                  getW(wF, wR, wC, d1 + 1, d2),\n                  getW(wF, wR, wC, d1 + 2, d2),\n                  getW(wF, wR, wC, d1 + 3, d2)\n                );\n\n                dotProd += dot(xValues, wValues);\n              }\n\n              if (${1===m}) {\n                dotProd +=\n                  getX(batch, xF, xR, xC, ${p}) *\n                  getW(wF, wR, wC, ${p}, d2);\n              } else if (${2===m}) {\n                vec2 xValues = vec2(\n                  getX(batch, xF, xR, xC, ${p}),\n                  getX(batch, xF, xR, xC, ${p} + 1)\n                );\n                vec2 wValues = vec2(\n                  getW(wF, wR, wC, ${p}, d2),\n                  getW(wF, wR, wC, ${p} + 1, d2)\n                );\n                dotProd += dot(xValues, wValues);\n              } else if (${3===m}) {\n                vec3 xValues = vec3(\n                  getX(batch, xF, xR, xC, ${p}),\n                  getX(batch, xF, xR, xC, ${p} + 1),\n                  getX(batch, xF, xR, xC, ${p} + 2)\n                );\n                vec3 wValues = vec3(\n                  getW(wF, wR, wC, ${p}, d2),\n                  getW(wF, wR, wC, ${p} + 1, d2),\n                  getW(wF, wR, wC, ${p} + 2, d2)\n                );\n                dotProd += dot(xValues, wValues);\n              }\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}class rpe{constructor(n,e,r){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=n;const{filterWidth:s,inChannels:o,strideWidth:i,strideHeight:a,padInfo:l,outWidth:u,dilationWidth:c,dilationHeight:d,dataFormat:h}=r,{left:f,top:p}=l,m=o*s,g=Er(),y="channelsLast"===h,b=y?0:1,v=y?1:2;let x="";for(let w=0;w<=1;w++)for(let _=0;_<=1;_++)x+=`\n          blockIndex = rc.y + ${_};\n          pos = rc.x + ${w};\n\n          if(blockIndex < ${n[1]} && pos < ${n[0]}) {\n            offsetY = int(blockIndex / (${u})) * ${a} - ${p};\n            d0 = offsetY + ${d} * (pos / ${m});\n\n            if(d0 < ${e[b]} && d0 >= 0) {\n\n              offsetX = int(mod(float(blockIndex), ${u}.) * ${i}. - ${f}.);\n              d1 = offsetX + ${c} * (int(mod(float(pos), ${m}.) / ${o}.));\n\n              if(d1 < ${e[v]} && d1 >= 0) {\n\n                ch = int(mod(float(pos), ${o}.));\n\n                if (${y}) {\n                  innerDims = vec2(d1, ch);\n                  result[${2*w+_}] = getChannel(\n                    getA(d0, int(innerDims.x),\n                    int(innerDims.y)), innerDims);\n                } else {\n                  innerDims = vec2(d0, d1);\n                  result[${2*w+_}] = getChannel(\n                    getA(ch, int(innerDims.x),\n                    int(innerDims.y)), innerDims);\n                }\n              }\n            }\n          }\n        `;this.userCode=`\n      void main() {\n        ivec2 rc = getOutputCoords();\n\n        vec4 result = vec4(0);\n\n        int blockIndex, pos, offsetY, d0, offsetX, d1, ch;\n        vec2 innerDims;\n\n        ${x}\n\n        ${g.output} = result;\n      }\n    `}}function MP({x:t,filter:n,convInfo:e,backend:r,bias:s=null,preluActivationWeights:o=null,leakyreluAlpha:i=0,activation:a=null}){const l=t.shape,u=r.texData.get(t.dataId),f="channelsLast"===e.dataFormat;let g;const y=[],v=l[2]%2!=0&&!!u.isPacked;if((1!=l[0]*l[1]*l[2]&&1!==e.outChannels||!(e.inChannels>1e3))&&ne().getBool("WEBGL_LAZILY_UNPACK")&&ne().getBool("WEBGL_PACK_BINARY_OPERATIONS")&&v){const w={dataId:t.dataId,shape:[1,f?l[0]*l[1]*(l[2]+1):l[0]*l[2]*(l[3]+1),e.inChannels],dtype:t.dtype},_=u.shape;u.shape=u.shape.slice(),u.shape[u.shape.length-2]++,S(Ty(u.shape,w.shape),()=>`packed reshape ${u.shape} to ${w.shape} isn't free`);const D=Se({inputs:{x:n},backend:r,attrs:{shape:[1,e.inChannels,e.outChannels]}});y.push(D);const A=Ly({a:w,b:D,backend:r,transposeA:!1,transposeB:!1,bias:s,activation:a,preluActivationWeights:o,leakyreluAlpha:i}),R=r.texData.get(A.dataId);S(R.isPacked,()=>"batchMatMul result is expected to be packed"),u.shape=_,R.shape=e.outShape,g=Jr({inputs:{x:A},backend:r}),g.shape=e.outShape,y.push(A)}else{const w=Se({inputs:{x:t},backend:r,attrs:{shape:[1,f?l[0]*l[1]*l[2]:l[0]*l[2]*l[3],e.inChannels]}}),_=Se({inputs:{x:n},backend:r,attrs:{shape:[1,e.inChannels,e.outChannels]}}),D=Ly({a:w,b:_,transposeA:!1,transposeB:!1,backend:r,bias:s,activation:a,preluActivationWeights:o,leakyreluAlpha:i});g=Se({inputs:{x:D},backend:r,attrs:{shape:e.outShape}}),y.push(w),y.push(_),y.push(D)}for(const x of y)r.disposeIntermediateTensorInfo(x);return g}function PP({x:t,filter:n,convInfo:e,backend:r,bias:s=null,preluActivationWeights:o=null,leakyreluAlpha:i=0,activation:a=null}){const{filterWidth:l,filterHeight:u,inChannels:c,outWidth:d,outHeight:h,dataFormat:f}=e,p="channelsLast"===f,m=l*u*c,g=h*d,y=[m,g],x=[],w=Se({inputs:{x:t},backend:r,attrs:{shape:t.shape.slice(1)}}),_=Se({inputs:{x:n},backend:r,attrs:{shape:[1,m,te(n.shape)/m]}});x.push(w),x.push(_);const D=new rpe(y,w.shape,e),A=r.runWebGLProgram(D,[w],"float32"),R=Se({inputs:{x:A},backend:r,attrs:{shape:[1,y[0],y[1]]}});x.push(A),x.push(R);const O=null!=s,G=null!=o,K="leakyrelu"===a,j=a?My(a,!0):null,Q=new bP(R.shape,_.shape,[1,g,e.outChannels],!0,!1,O,j,G,K),q=[R,_];if(s&&q.push(s),G&&q.push(o),K){const se=r.makeTensorInfo([],"float32",Oi(i,"float32"));q.push(se),x.push(se)}const Y=r.runWebGLProgram(Q,q,"float32"),ee=Se({inputs:{x:Y},backend:r,attrs:{shape:p?[1,h,d,e.outChannels]:[1,e.outChannels,h,d]}});x.push(Y);for(const se of x)r.disposeIntermediateTensorInfo(se);return ee}const ope={kernelName:hm,backendName:"webgl",kernelFunc:function spe(t){const{inputs:n,backend:e,attrs:r}=t,{x:s,filter:o}=n,{strides:i,pad:a,dataFormat:l,dilations:u,dimRoundingMode:c}=r,d=si(l),h=Zn(s.shape,o.shape,i,u,a,c,!1,d);let f;if(1!==h.filterHeight||1!==h.filterWidth||1!==h.dilationHeight||1!==h.dilationWidth||1!==h.strideHeight||1!==h.strideWidth||"SAME"!==h.padInfo.type&&"VALID"!==h.padInfo.type)if(ne().getBool("WEBGL_CONV_IM2COL")&&1===s.shape[0])f=PP({x:s,filter:o,convInfo:h,backend:e});else{const m=new OP(h);f=e.runWebGLProgram(m,[s,o],"float32")}else f=MP({x:s,filter:o,convInfo:h,backend:e});const p=Se({inputs:{x:f},backend:e,attrs:{shape:h.outShape}});return e.disposeIntermediateTensorInfo(f),p}};class ipe{constructor(n){this.variableNames=["x","dy"],this.outputShape=n.filterShape,this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int wR = coords.x;\n        int wC = coords.y;\n        int d1 = coords.z;\n        int d2 = coords.w;\n\n        // Convolve x(?, ?, d1) with dy(:, :, d2) to get dw(wR, wC, d1, d2).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n\n        for (int b = 0; b < ${n.batchSize}; b++) {\n          for (int yR = 0; yR < ${n.outHeight}; yR++) {\n            int xR = wR + yR * ${n.strideHeight} - ${n.padInfo.top};\n\n            if (xR < 0 || xR >= ${n.inHeight}) {\n              continue;\n            }\n\n            for (int yC = 0; yC < ${n.outWidth}; yC++) {\n              int xC = wC + yC * ${n.strideWidth} - ${n.padInfo.left};\n\n              if (xC < 0 || xC >= ${n.inWidth}) {\n                continue;\n              }\n\n              if (${"channelsLast"===n.dataFormat}) {\n                float dyValue = getDy(b, yR, yC, d2);\n                float xValue = getX(b, xR, xC, d1);\n                dotProd += (xValue * dyValue);\n              } else {\n                float dyValue = getDy(b, d2, yR, yC);\n                float xValue = getX(b, d1, xR, xC);\n                dotProd += (xValue * dyValue);\n              }\n\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}class ape{constructor(n){this.variableNames=["dy","W"],this.outputShape=n.inShape;const e=n.filterHeight,r=n.filterWidth,i="channelsLast"===n.dataFormat;this.userCode=`\n      const ivec2 pads = ivec2(${e-1-n.padInfo.top}, ${r-1-n.padInfo.left});\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d1 = coords[${i?3:1}];\n\n        ivec2 dyCorner = ivec2(coords[${i?1:2}], coords[${i?2:3}]) - pads;\n        int dyRCorner = dyCorner.x;\n        int dyCCorner = dyCorner.y;\n\n        // Convolve dy(?, ?, d2) with w(:, :, d1, d2) to compute dx(xR, xC, d1).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < ${e}; wR++) {\n          float dyR = float(dyRCorner + wR) / ${n.strideHeight}.0;\n\n          if (dyR < 0.0 || dyR >= ${n.outHeight}.0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          int wRPerm = ${e} - 1 - wR;\n\n          for (int wC = 0; wC < ${r}; wC++) {\n            float dyC = float(dyCCorner + wC) / ${n.strideWidth}.0;\n\n            if (dyC < 0.0 || dyC >= ${n.outWidth}.0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            int wCPerm = ${r} - 1 - wC;\n\n            for (int d2 = 0; d2 < ${n.outChannels}; d2++) {\n\n              if (${i}) {\n                float xValue = getDy(batch, idyR, idyC, d2);\n                float wValue = getW(wRPerm, wCPerm, d1, d2);\n                dotProd += xValue * wValue;\n              } else {\n                float xValue = getDy(batch, d2, idyR, idyC);\n                float wValue = getW(wRPerm, wCPerm, d1, d2);\n                dotProd += xValue * wValue;\n              }\n\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}class lpe{constructor(n){this.variableNames=["x","dy"],this.outputShape=n.filterShape,this.userCode=`\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int wF = coords.x;\n        int wR = coords.y;\n        int wC = coords.z;\n        int d1 = coords.w;\n        int d2 = coords.u;\n\n        float dotProd = 0.0;\n\n        for (int b = 0; b < ${n.batchSize}; b++) {\n          for (int yF = 0; yF < ${n.outDepth}; yF++) {\n            int xF = wF + yF * ${n.strideDepth} - ${n.padInfo.front};\n\n            if (xF < 0 || xF >= ${n.inDepth}) {\n              continue;\n            }\n\n            for (int yR = 0; yR < ${n.outHeight}; yR++) {\n              int xR = wR + yR * ${n.strideHeight} - ${n.padInfo.top};\n\n              if (xR < 0 || xR >= ${n.inHeight}) {\n                continue;\n              }\n\n              for (int yC = 0; yC < ${n.outWidth}; yC++) {\n                int xC = wC + yC * ${n.strideWidth} - ${n.padInfo.left};\n\n                if (xC < 0 || xC >= ${n.inWidth}) {\n                  continue;\n                }\n\n                float dyValue = getDy(b, yF, yR, yC, d2);\n                float xValue = getX(b, xF, xR, xC, d1);\n                dotProd += (xValue * dyValue);\n              }\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}class upe{constructor(n){this.variableNames=["dy","W"],this.outputShape=n.inShape;const e=n.filterDepth,r=n.filterHeight,s=n.filterWidth;this.userCode=`\n      const ivec3 pads = ivec3(${e-1-n.padInfo.front}, ${r-1-n.padInfo.top}, ${s-1-n.padInfo.left});\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int d1 = coords.u;\n\n\n        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;\n        int dyFCorner = dyCorner.x;\n        int dyRCorner = dyCorner.y;\n        int dyCCorner = dyCorner.z;\n\n        float dotProd = 0.0;\n        for (int wF = 0; wF < ${e}; wF++) {\n          float dyF = float(dyFCorner + wF) / ${n.strideDepth}.0;\n\n          if (dyF < 0.0 || dyF >= ${n.outDepth}.0 || fract(dyF) > 0.0) {\n            continue;\n          }\n          int idyF = int(dyF);\n\n          int wFPerm = ${e} - 1 - wF;\n\n          for (int wR = 0; wR < ${r}; wR++) {\n            float dyR = float(dyRCorner + wR) / ${n.strideHeight}.0;\n\n            if (dyR < 0.0 || dyR >= ${n.outHeight}.0 ||\n              fract(dyR) > 0.0) {\n              continue;\n            }\n            int idyR = int(dyR);\n\n            int wRPerm = ${r} - 1 - wR;\n\n            for (int wC = 0; wC < ${s}; wC++) {\n              float dyC = float(dyCCorner + wC) / ${n.strideWidth}.0;\n\n              if (dyC < 0.0 || dyC >= ${n.outWidth}.0 ||\n                  fract(dyC) > 0.0) {\n                continue;\n              }\n              int idyC = int(dyC);\n\n              int wCPerm = ${s} - 1 - wC;\n\n              for (int d2 = 0; d2 < ${n.outChannels}; d2++) {\n                float xValue = getDy(batch, idyF, idyR, idyC, d2);\n                float wValue = getW(wFPerm, wRPerm, wCPerm, d1, d2);\n                dotProd += xValue * wValue;\n              }\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}const dpe={kernelName:sw,backendName:"webgl",kernelFunc:function cpe(t){const{inputs:n,backend:e,attrs:r}=t,{x:s,dy:o}=n,{strides:i,pad:a,dataFormat:l,dimRoundingMode:u,filterShape:c}=r,d=si(l),h=Zn(s.shape,c,i,1,a,u,!1,d),f=new ipe(h);return e.runWebGLProgram(f,[s,o],"float32")}},fpe={kernelName:fm,backendName:"webgl",kernelFunc:function hpe(t){const{inputs:n,backend:e,attrs:r}=t,{dy:s,filter:o}=n,{inputShape:i,strides:a,pad:l,dataFormat:u,dimRoundingMode:c}=r,d=si(u),h=Zn(i,o.shape,a,1,l,c,!1,d),f=new ape(h);return e.runWebGLProgram(f,[s,o],"float32")}},mpe={kernelName:pm,backendName:"webgl",kernelFunc:function ppe(t){const{inputs:n,backend:e,attrs:r}=t,{x:s,filter:o}=n,{strides:i,pad:a,dilations:l}=r,u=Bi(s.shape,o.shape,i,l,a),c=new npe(u);return e.runWebGLProgram(c,[s,o],"float32")}},ype={kernelName:ow,backendName:"webgl",kernelFunc:function gpe(t){const{inputs:n,backend:e,attrs:r}=t,{x:s,dy:o}=n,{strides:i,pad:a,filterShape:l}=r,u=Bi(s.shape,l,i,1,a),c=new lpe(u);return e.runWebGLProgram(c,[s,o],"float32")}},vpe={kernelName:iw,backendName:"webgl",kernelFunc:function bpe(t){const{inputs:n,backend:e,attrs:r}=t,{dy:s,filter:o}=n,{pad:i,strides:a,inputShape:l}=r,u=Bi(l,o.shape,a,1,i),c=new upe(u);return e.runWebGLProgram(c,[s,o],"float32")}},wpe=_t({opSnippet:"if (isnan(x)) return x;\n  return cos(x);\n"}),Cpe={kernelName:wd,backendName:"webgl",kernelFunc:wpe},Ipe=_t({opSnippet:"\n  float e2x = exp(-x);\n  return (e2x + 1.0 / e2x) / 2.0;\n"}),Dpe={kernelName:Cd,backendName:"webgl",kernelFunc:Ipe};class _pe{constructor(n,e,r,s,o){this.variableNames=["Image","Boxes","BoxInd"],this.outputShape=[];const[i,a,l,u]=n,[c]=e,[d,h]=r;this.outputShape=[c,d,h,u];const f="bilinear"===s?1:0,[p,m]=[a-1+".0",l-1+".0"],[g,y,b]=d>1?[""+(a-1)/(d-1),"(y2-y1) * height_ratio",`y1*${p} + float(y)*(height_scale)`]:["0.0","0.0",`0.5 * (y1+y2) * ${p}`],[v,x,w]=h>1?[""+(l-1)/(h-1),"(x2-x1) * width_ratio",`x1*${m} + float(x)*(width_scale)`]:["0.0","0.0",`0.5 * (x1+x2) * ${m}`];this.userCode=`\n      const float height_ratio = float(${g});\n      const float width_ratio = float(${v});\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int y = coords[1];\n        int x = coords[2];\n        int d = coords[3];\n\n        // get box vals\n        float y1 = getBoxes(b,0);\n        float x1 = getBoxes(b,1);\n        float y2 = getBoxes(b,2);\n        float x2 = getBoxes(b,3);\n\n        // get image in batch index\n        int bInd = round(getBoxInd(b));\n        if(bInd < 0 || bInd >= ${i}) {\n          return;\n        }\n\n        float height_scale = ${y};\n        float width_scale = ${x};\n\n        float in_y = ${b};\n        if( in_y < 0.0 || in_y > ${p} ) {\n          setOutput(float(${o}));\n          return;\n        }\n        float in_x = ${w};\n        if( in_x < 0.0 || in_x > ${m} ) {\n          setOutput(float(${o}));\n          return;\n        }\n\n        vec2 sourceFracIndexCR = vec2(in_x,in_y);\n        if(${f} == 1) {\n          // Compute the four integer indices.\n          ivec2 sourceFloorCR = ivec2(sourceFracIndexCR);\n          ivec2 sourceCeilCR = ivec2(ceil(sourceFracIndexCR));\n\n          float topLeft = getImage(b, sourceFloorCR.y, sourceFloorCR.x, d);\n          float bottomLeft = getImage(b, sourceCeilCR.y, sourceFloorCR.x, d);\n          float topRight = getImage(b, sourceFloorCR.y, sourceCeilCR.x, d);\n          float bottomRight = getImage(b, sourceCeilCR.y, sourceCeilCR.x, d);\n\n          vec2 fracCR = sourceFracIndexCR - vec2(sourceFloorCR);\n\n          float top = topLeft + (topRight - topLeft) * fracCR.x;\n          float bottom = bottomLeft + (bottomRight - bottomLeft) * fracCR.x;\n          float newValue = top + (bottom - top) * fracCR.y;\n          setOutput(newValue);\n        } else {\n          // Compute the coordinators of nearest neighbor point.\n          ivec2 sourceNearestCR = ivec2(floor(\n            sourceFracIndexCR + vec2(0.5,0.5)));\n          float newValue = getImage(b, sourceNearestCR.y, sourceNearestCR.x, d);\n          setOutput(newValue);\n        }\n      }\n    `}}const Spe={kernelName:aw,backendName:"webgl",kernelFunc:t=>{const{inputs:n,backend:e,attrs:r}=t,{image:s,boxes:o,boxInd:i}=n,{cropSize:a,method:l,extrapolationValue:u}=r,c=new _pe(s.shape,o.shape,a,l,u);return e.runWebGLProgram(c,[s,o,i],"float32")}};class LP{constructor(n,e,r){this.variableNames=["x"],this.outputShape=n;const s=n.length,o=e?"0.0":`getX(${BP(s,"coords")})`,i=n[n.length-1];let a="",l="";e?(a=r?"end != "+(i-1):"end != 0",l=r?"end + 1":"end - 1"):(a=r?`end + pow2 < ${i}`:"end >= pow2",l=r?"end + pow2":"end - pow2"),this.userCode=`\n      uniform float index;\n      void main() {\n        ${Wt(s)} coords = getOutputCoords();\n        int end = ${zP(s,"coords")};\n        float val = ${o};\n        int pow2 = int(pow(2.0, index));\n        if (${a}) {\n          int idx = ${l};\n          ${zP(s,"coords")} = idx;\n          val += getX(${BP(s,"coords")});\n        }\n        setOutput(val);\n      }\n    `}getCustomSetupFunc(n){return(e,r)=>{null==this.index&&(this.index=e.getUniformLocation(r,"index")),e.gl.uniform1f(this.index,n)}}}function BP(t,n){if(1===t)return`${n}`;if(2===t)return`${n}.x, ${n}.y`;if(3===t)return`${n}.x, ${n}.y, ${n}.z`;if(4===t)return`${n}.x, ${n}.y, ${n}.z, ${n}.w`;throw Error(`Cumulative sum for rank ${t} is not yet supported`)}function zP(t,n){if(1===t)return`${n}`;if(2===t)return`${n}.y`;if(3===t)return`${n}.z`;if(4===t)return`${n}.w`;throw Error(`Cumulative sum for rank ${t} is not yet supported`)}const Npe={kernelName:mm,backendName:"webgl",kernelFunc:function Epe(t){const{inputs:n,backend:e,attrs:r}=t,{x:s}=n,{axis:o,exclusive:i,reverse:a}=r,l=s.shape.length,u=xn([o],l);let c=s;null!=u&&(c=zr({inputs:{x:s},backend:e,attrs:{perm:u}}));const d=En(1,l)[0];if(d!==l-1)throw new Error(`WebGL cumsum shader expects an inner-most axis=${s.shape.length-1} but got axis=${o}`);const h=c.shape[d];let f=Jr({inputs:{x:c},backend:e});for(let p=0;p<=Math.ceil(Math.log2(h))-1;p++){const m=new LP(c.shape,!1,a),g=m.getCustomSetupFunc(p),y=f;f=e.runWebGLProgram(m,[f],f.dtype,g),e.disposeIntermediateTensorInfo(y)}if(i){const p=new LP(c.shape,i,a),m=f;f=e.runWebGLProgram(p,[f],f.dtype),e.disposeIntermediateTensorInfo(m)}if(null!=u){const m=zr({inputs:{x:f},backend:e,attrs:{perm:gu(u)}});return e.disposeIntermediateTensorInfo(f),e.disposeIntermediateTensorInfo(c),m}return f}},kpe={kernelName:lw,backendName:"webgl",kernelFunc:function Tpe(t){const{inputs:n,backend:e,attrs:r}=t,{x:s,weights:o}=n,{size:i,binaryOutput:a}=r;if(1===s.shape.length){const l=e.readSync(s.dataId),u=e.readSync(o.dataId),c=sP(l,u,o.dtype,o.shape,i);return e.makeTensorInfo([i],o.dtype,c)}if(2===s.shape.length){const l=e.bufferSync(s),u=e.bufferSync(o),c=ade(l,u,i,a);return e.makeTensorInfo(c.shape,o.dtype,c.values)}throw new Error(`Error in denseBincount: input must be at most rank 2, but got rank${s.shape.length}.`)}};class Ape{constructor(n,e,r){this.variableNames=["x"],this.outputShape=[],this.outputShape=n,this.blockSize=e,this.dataFormat=r,this.userCode=`\n    void main() {\n      ivec4 coords = getOutputCoords();\n      int b = coords[0];\n      int h = ${this.getHeightCoordString()};\n      int w = ${this.getWidthCoordString()};\n      int d = ${this.getDepthCoordString()};\n\n      int in_h = h / ${e};\n      int offset_h = imod(h, ${e});\n      int in_w = w / ${e};\n      int offset_w = imod(w, ${e});\n      int offset_d = (offset_h * ${e} + offset_w) *\n        ${this.getOutputDepthSize()};\n      int in_d = d + offset_d;\n\n      float result = ${this.getInputSamplingString()};\n      setOutput(result);\n    }\n  `}getHeightCoordString(){return"NHWC"===this.dataFormat?"coords[1]":"coords[2]"}getWidthCoordString(){return"NHWC"===this.dataFormat?"coords[2]":"coords[3]"}getDepthCoordString(){return"NHWC"===this.dataFormat?"coords[3]":"coords[1]"}getOutputDepthSize(){return"NHWC"===this.dataFormat?this.outputShape[3]:this.outputShape[1]}getInputSamplingString(){return"NHWC"===this.dataFormat?"getX(b, in_h, in_w, in_d)":"getX(b, in_d, in_h, in_w)"}}const $pe={kernelName:uw,backendName:"webgl",kernelFunc:function Rpe(t){const{inputs:n,backend:e,attrs:r}=t,{x:s}=n,{blockSize:o,dataFormat:i}=r;S(o>1,()=>`blockSize should be > 1 for depthToSpace, but was: ${o}`);const a=s.shape[0],d=("NHWC"===i?s.shape[1]:s.shape[2])*o,h=("NHWC"===i?s.shape[2]:s.shape[3])*o,f=("NHWC"===i?s.shape[3]:s.shape[1])/(o*o),m=new Ape("NHWC"===i?[a,d,h,f]:[a,f,d,h],o,i);return e.runWebGLProgram(m,[s],s.dtype)}};class VP{constructor(n,e=!1,r=null,s=!1,o=!1){this.variableNames=["x","W"],this.outputShape=n.outShape;const i=n.inHeight,a=n.inWidth,l=n.padInfo.top,u=n.padInfo.left,c=n.strideHeight,d=n.strideWidth,h=n.dilationHeight,f=n.dilationWidth,p=n.filterHeight,m=n.filterWidth,g=n.outChannels/n.inChannels;let y="",b="";r&&(y=s?`float activation(float a) {\n          float b = getPreluActivationWeightsAtOutCoords();\n          ${r}\n        }`:o?`float activation(float a) {\n          float b = getLeakyreluAlphaAtOutCoords();\n          ${r}\n        }`:`\n          float activation(float x) {\n            ${r}\n          }\n        `,b="result = activation(result);");const v=e?"result += getBiasAtOutCoords();":"";e&&this.variableNames.push("bias"),s&&this.variableNames.push("preluActivationWeights"),o&&this.variableNames.push("leakyreluAlpha"),this.userCode=`\n      ${y}\n\n      const ivec2 strides = ivec2(${c}, ${d});\n      const ivec2 pads = ivec2(${l}, ${u});\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords.x;\n        ivec2 xRCCorner = coords.yz * strides - pads;\n        int d2 = coords.w;\n        int d1 = d2 / ${g};\n        int q = d2 - d1 * ${g};\n\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        // Convolve x(?, ?, d1) with w(:, :, d1, q) to get y(yR, yC, d2).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        // TO DO(dsmilkov): Flatten the two for loops and vec4 the operations.\n        for (int wR = 0; wR < ${p}; wR++) {\n          int xR = xRCorner + wR * ${h};\n\n          if (xR < 0 || xR >= ${i}) {\n            continue;\n          }\n\n          for (int wC = 0; wC < ${m}; wC++) {\n            int xC = xCCorner + wC * ${f};\n\n            if (xC < 0 || xC >= ${a}) {\n              continue;\n            }\n\n            float xVal = getX(batch, xR, xC, d1);\n            float wVal = getW(wR, wC, d1, q);\n            dotProd += xVal * wVal;\n          }\n        }\n\n        float result = dotProd;\n        ${v}\n        ${b}\n        setOutput(result);\n      }\n    `}}class UP{constructor(n,e=!1,r=null,s=!1,o=!1){this.variableNames=["x","W"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=n.outShape;const i=n.inHeight,a=n.inWidth,l=n.padInfo.top,u=n.padInfo.left,c=n.strideHeight,d=n.strideWidth,h=n.dilationHeight,f=n.dilationWidth,p=n.filterHeight,m=n.filterWidth,g=m;let y="int xR; int xC; int xCOffset;";for(let w=0;w<p;w++)for(let _=0;_<m;_++)y+=`\n          vec4 xTexelR${w}C${2*_} = vec4(0.);\n          vec4 wR${w}C${_} = vec4(0.);\n          vec4 xR${w}C${_} = vec4(0.);`;for(let w=0;w<p;w++)for(let _=0;_<g;_++){const D=2*_;if(y+=`\n          xR = xRCorner + ${w*h};\n          xC = xCCorner + ${D*f};\n        `,1===d){if(D<m&&(y+=u%2==1?`\n                xCOffset = xC + 1;\n                if(xR >= 0 && xR < ${i} && xCOffset >= 0 && xCOffset < ${a}) {\n                  xTexelR${w}C${D} = getX(batch, xR, xCOffset, d1);\n\n                  // Need to manually clear unused channels in case\n                  // we're reading from recycled texture.\n                  if(xCOffset + 1 >= ${a}) {\n                    xTexelR${w}C${D}.zw = vec2(0.);\n                  }\n                } else {\n                  xTexelR${w}C${D} = vec4(0.);\n                }\n\n                xCOffset = xC + 1 - 2;\n                if(xR >= 0 && xR < ${i} && xCOffset >= 0 && xCOffset < ${a}) {\n                  vec4 previous = getX(batch, xR, xCOffset, d1);\n\n                  // Need to manually clear unused channels in case\n                  // we're reading from recycled texture.\n                  if(xCOffset + 1 >= ${a}) {\n                    previous.zw = vec2(0.);\n                  }\n\n                  xR${w}C${D} = vec4(previous.zw, xTexelR${w}C${D}.xy);\n                } else {\n                  xR${w}C${D} = vec4(0, 0, xTexelR${w}C${D}.xy);\n                }\n              `:`\n                if(xR >= 0 && xR < ${i} && xC >= 0 && xC < ${a}) {\n                  xTexelR${w}C${D} = getX(batch, xR, xC, d1);\n                } else {\n                  xTexelR${w}C${D} = vec4(0.);\n                }\n\n                xR${w}C${D} = xTexelR${w}C${D};\n              `,D+1<m)){const A=u%2==0?GR(f):f;f%2==0&&u%2==1||f%2!=0&&u%2!=1?(y+=`\n                  xCOffset = xC + ${u%2} + ${A};\n\n                  if(xR >= 0 && xR < ${i} &&\n                    xCOffset >= 0 && xCOffset < ${a}) {\n                    xTexelR${w}C${D+2} = getX(batch, xR, xCOffset, d1);\n                  }\n                `,f>1&&(y+=`\n                    xCOffset -= 2;\n                    if(xR >= 0 && xR < ${i} &&\n                      xCOffset >= 0 && xCOffset < ${a}) {\n                      xTexelR${w}C${D} = getX(batch, xR, xCOffset, d1);\n                    } else {\n                      xTexelR${w}C${D} = vec4(0.);\n                    }\n                  `),y+=`\n                  xR${w}C${D+1} = vec4(\n                    xTexelR${w}C${D}.zw, xTexelR${w}C${D+2}.xy);\n                `):y+=`\n                  xCOffset = xC + ${A};\n\n                  if(xR >= 0 && xR < ${i} &&\n                    xCOffset >= 0 && xCOffset < ${a}) {\n                    xTexelR${w}C${D+2} = getX(batch, xR, xCOffset, d1);\n                  }\n\n                  xR${w}C${D+1} = xTexelR${w}C${D+2};\n                `}}else D<m&&(y+=`\n              if(xR >= 0 && xR < ${i}) {\n            `,u%2==1?(y+=`\n                xCOffset = xC + 1 - ${d};\n                if(xCOffset >= 0 && xCOffset < ${a}) {\n                  xTexelR${w}C${D} = getX(batch, xR, xCOffset, d1);\n                } else {\n                  xTexelR${w}C${D} = vec4(0.);\n                }\n\n                if(xC + 1 >= 0 && xC + 1 < ${a}) {\n                  xTexelR${w}C${D+2} = getX(batch, xR, xC + 1, d1);\n                } else {\n                  xTexelR${w}C${D+2} = vec4(0.);\n                }\n\n                xR${w}C${D} = vec4(\n                  xTexelR${w}C${D}.zw, xTexelR${w}C${D+2}.zw);\n              `,D+1<m&&(y+=`\n                  vec4 final = vec4(0.);\n                  xCOffset = xC + 1 + ${d};\n                  if(xCOffset >= 0 && xCOffset < ${a}) {\n                    final = getX(batch, xR, xCOffset, d1);\n                  }\n                  xR${w}C${D+1} = vec4(xTexelR${w}C${D+2}.xy, final.xy);\n                `)):(y+=`\n                if(xC >= 0 && xC < ${a}) {\n                  xTexelR${w}C${D} = getX(batch, xR, xC, d1);\n                } else {\n                  xTexelR${w}C${D} = vec4(0.);\n                }\n\n                xCOffset = xC + ${d};\n                if(xCOffset >= 0 && xCOffset < ${a}) {\n                  xTexelR${w}C${D+2} = getX(batch, xR, xCOffset, d1);\n                } else {\n                  xTexelR${w}C${D+2} = vec4(0.);\n                }\n\n                xR${w}C${D} = vec4(\n                  xTexelR${w}C${D}.xy, xTexelR${w}C${D+2}.xy);\n              `,D+1<m&&(y+=`\n                  xR${w}C${D+1} = vec4(\n                    xTexelR${w}C${D}.zw, xTexelR${w}C${D+2}.zw);\n                `)),y+="}");D<m&&(y+=`\n            vec4 wTexelR${w}C${D} = getW(${w}, ${D}, d1, q);\n            wR${w}C${D} = vec4(wTexelR${w}C${D}.xz, wTexelR${w}C${D}.xz);\n          `,D+1<m&&(y+=`\n              vec4 wTexelR${w}C${D+1} = getW(${w}, ${D+1}, d1, q);\n              wR${w}C${D+1} =\n                vec4(wTexelR${w}C${D+1}.xz, wTexelR${w}C${D+1}.xz);`))}for(let w=0;w<p;w++)for(let _=0;_<m;_++)y+=`dotProd += xR${w}C${_} * wR${w}C${_};`;let b="",v="";r&&(b=s?`vec4 activation(vec4 a) {\n          vec4 b = getPreluActivationWeightsAtOutCoords();\n          ${r}\n        }`:o?`vec4 activation(vec4 a) {\n          vec4 b = getLeakyreluAlphaAtOutCoords();\n          ${r}\n        }`:`vec4 activation(vec4 x) {\n          ${r}\n        }`,v="result = activation(result);");const x=e?"result += getBiasAtOutCoords();":"";e&&this.variableNames.push("bias"),s&&this.variableNames.push("preluActivationWeights"),o&&this.variableNames.push("leakyreluAlpha"),this.userCode=`\n      ${b}\n\n      const ivec2 strides = ivec2(${c}, ${d});\n      const ivec2 pads = ivec2(${l}, ${u});\n\n      void main() {\n\n        ivec4 coords = getOutputCoords();\n        int batch = coords.x;\n        ivec2 xRCCorner = coords.yz * strides - pads;\n        int d2 = coords.w;\n        int d1 = d2;\n        int q = 0;\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        vec4 dotProd = vec4(0.);\n\n        ${y}\n\n        vec4 result = dotProd;\n        ${x}\n        ${v}\n        setOutput(result);\n      }\n    `}}const Ope={kernelName:gm,backendName:"webgl",kernelFunc:function Fpe(t){const{inputs:n,backend:e,attrs:r}=t,{x:s,filter:o}=n,{strides:i,pad:a,dilations:l,dimRoundingMode:u}=r;let c=l;null==c&&(c=[1,1]),S(ar(i,c),()=>`Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${i} and dilations '${c}'`);const d=Zn(s.shape,o.shape,i,c,a,u,!0);let h;return h=ne().getBool("WEBGL_PACK_DEPTHWISECONV")&&d.strideWidth<=2&&d.outChannels/d.inChannels==1?new UP(d):new VP(d),e.runWebGLProgram(h,[s,o],"float32")}};class Mpe{constructor(n){this.variableNames=["x","dy"],this.outputShape=n.filterShape,this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int wR = coords.x;\n        int wC = coords.y;\n        int d1 = coords.z;\n        int dm = coords.w;\n        int d2 = d1 * ${n.outChannels/n.inChannels} + dm;\n\n        float dotProd = 0.0;\n\n        // TO DO: Vec4 over the batch size\n        for (int b = 0; b < ${n.batchSize}; b++) {\n          for (int yR = 0; yR < ${n.outHeight}; yR++) {\n            int xR = wR + yR * ${n.strideHeight} - ${n.padInfo.top};\n\n            if (xR < 0 || xR >= ${n.inHeight}) {\n              continue;\n            }\n\n            for (int yC = 0; yC < ${n.outWidth}; yC++) {\n              int xC = wC + yC * ${n.strideWidth} - ${n.padInfo.left};\n\n              if (xC < 0 || xC >= ${n.inWidth}) {\n                continue;\n              }\n\n              float dyValue = getDy(b, yR, yC, d2);\n              float xValue = getX(b, xR, xC, d1);\n              dotProd += (xValue * dyValue);\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}class Ppe{constructor(n){this.variableNames=["dy","W"],this.outputShape=n.inShape;const e=n.filterHeight,r=n.filterWidth,l=n.outChannels/n.inChannels;this.userCode=`\n      const ivec2 pads = ivec2(${e-1-n.padInfo.top}, ${r-1-n.padInfo.left});\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d1 = coords[3];\n        ivec2 dyCorner = coords.yz - pads;\n        int dyRCorner = dyCorner.x;\n        int dyCCorner = dyCorner.y;\n\n        float dotProd = 0.0;\n\n        for (int wR = 0; wR < ${e}; wR++) {\n          float dyR = float(dyRCorner + wR) / ${n.strideHeight}.0;\n\n          if (dyR < 0.0 || dyR >= ${n.outHeight}.0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          int wRPerm = ${e} - 1 - wR;\n\n          for (int wC = 0; wC < ${r}; wC++) {\n            float dyC = float(dyCCorner + wC) / ${n.strideWidth}.0;\n\n            if (dyC < 0.0 || dyC >= ${n.outWidth}.0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            int wCPerm = ${r} - 1 - wC;\n\n            // TO DO: Vec4 over the channelMul\n            for (int dm = 0; dm < ${l}; dm++) {\n              int d2 = d1 * ${l} + dm;\n              float xValue = getDy(batch, idyR, idyC, d2);\n              float wValue = getW(wRPerm, wCPerm, d1, dm);\n              dotProd += xValue * wValue;\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}const Bpe={kernelName:cw,backendName:"webgl",kernelFunc:function Lpe(t){const{inputs:n,backend:e,attrs:r}=t,{x:s,dy:o}=n,{strides:i,dilations:a,pad:l,dimRoundingMode:u,filterShape:c}=r,d=Zn(s.shape,c,i,a,l,u,!0),h=new Mpe(d);return e.runWebGLProgram(h,[s,o],"float32")}},Vpe={kernelName:dw,backendName:"webgl",kernelFunc:function zpe(t){const{inputs:n,backend:e,attrs:r}=t,{dy:s,filter:o}=n,{strides:i,dilations:a,pad:l,dimRoundingMode:u,inputShape:c}=r,d=Zn(c,o.shape,i,a,l,u,!0),h=new Ppe(d);return e.runWebGLProgram(h,[s,o],"float32")}};class Upe{constructor(n){this.variableNames=["X"],this.outputShape=[n,n],this.userCode="\n      void main() {\n          ivec2 coords = getOutputCoords();\n          float val = coords[0] == coords[1] ? getX(coords[0]) : 0.0;\n          setOutput(val);\n      }\n    "}}const Hpe={kernelName:"Diag",backendName:"webgl",kernelFunc:function Wpe(t){const{inputs:n,backend:e}=t,{x:r}=n,s=[...r.shape,...r.shape],o=te(r.shape),i=Se({inputs:{x:r},backend:e,attrs:{shape:[o]}}),a=new Upe(o),l=e.runWebGLProgram(a,[i],i.dtype),u=Se({inputs:{x:l},backend:e,attrs:{shape:s}});return e.disposeIntermediateTensorInfo(i),e.disposeIntermediateTensorInfo(l),u}};class Gpe{constructor(n){this.variableNames=["x","W"],this.outputShape=n.outShape;const{inHeight:e,inWidth:r,padInfo:s,strideHeight:o,strideWidth:i,filterHeight:a,filterWidth:l,dilationHeight:u,dilationWidth:c}=n,{top:d,left:h}=s;this.userCode=`\n      const ivec2 strides = ivec2(${o}, ${i});\n      const ivec2 pads = ivec2(${d}, ${h});\n      const float neg_infinity = -3.4e38;\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords.x;\n        int d1 = coords.w;\n        ivec2 outTopLeftCorner =\n            coords.yz * strides - pads;\n        int hBeg = outTopLeftCorner.x;\n        int wBeg = outTopLeftCorner.y;\n\n        float curVal = neg_infinity;\n        for (int h = 0; h < ${a}; h++) {\n          int hIn = hBeg + h * ${u};\n\n          if (hIn >= 0 && hIn < ${e}) {\n            for (int w = 0; w < ${l}; w++) {\n              int wIn = wBeg + w * ${c};\n\n              if (wIn >= 0 && wIn < ${r}) {\n                float xVal = getX(batch, hIn, wIn, d1);\n                float wVal = getW(h, w, d1);\n\n                float val = xVal + wVal;\n                if (val > curVal) {\n                  curVal = val;\n                }\n              }\n            }\n          }\n        }\n\n        float result = curVal;\n        setOutput(result);\n      }\n    `}}const qpe={kernelName:ym,backendName:"webgl",kernelFunc:function jpe(t){const{inputs:n,backend:e,attrs:r}=t,{x:s,filter:o}=n,{strides:i,pad:a,dilations:l}=r,u=fh(s.shape,o.shape,i,a,"NHWC",l);let c;const d=new Gpe(u);c=e.runWebGLProgram(d,[s,o],"float32");const h=Se({inputs:{x:c},backend:e,attrs:{shape:u.outShape}});return e.disposeIntermediateTensorInfo(c),h}},Kpe=_t({opSnippet:"return (x >= 0.0) ? x : (exp(x) - 1.0);",packedOpSnippet:"\n  vec4 result;\n\n  result.r = (x.r >= 0.0) ? x.r : (exp(x.r) - 1.0);\n  result.g = (x.g >= 0.0) ? x.g : (exp(x.g) - 1.0);\n  result.b = (x.b >= 0.0) ? x.b : (exp(x.b) - 1.0);\n  result.a = (x.a >= 0.0) ? x.a : (exp(x.a) - 1.0);\n\n  return result;\n"}),Xpe={kernelName:Dd,backendName:"webgl",kernelFunc:Kpe},Qpe={kernelName:pw,backendName:"webgl",kernelFunc:t=>{const{inputs:n,backend:e}=t,{dy:r,y:s}=n,o=ne().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new Qh("\n  vec4 bGTEZero = vec4(greaterThanEqual(b, vec4(0.)));\n  return (bGTEZero * a) + ((vec4(1.0) - bGTEZero) * (a * (b + vec4(1.0))));\n",r.shape,s.shape):new Hu("return (b >= 1.0) ? a : a * (b + 1.0);",r.shape,s.shape);return e.runWebGLProgram(o,[r,s],r.dtype)}},Jpe=cr({opSnippet:"return float(a == b);",packedOpSnippet:"\n  return vec4(equal(a, b));\n",dtype:"bool"}),eme={kernelName:bm,backendName:"webgl",kernelFunc:Jpe},nme=_t({opSnippet:`\n  // Error function is calculated approximately with elementary function.\n  // See "Handbook of Mathematical Functions with Formulas,\n  // Graphs, and Mathematical Tables", Abramowitz and Stegun.\n  float p = ${pI};\n  float a1 = ${mI};\n  float a2 = ${gI};\n  float a3 = ${yI};\n  float a4 = ${bI};\n  float a5 = ${vI};\n\n  float sign = sign(x);\n  x = abs(x);\n  float t = 1.0 / (1.0 + p * x);\n  return sign * (1.0 - (((((a5*t + a4)*t) + a3)*t + a2)*t + a1)*t*exp(-x*x));\n`}),rme={kernelName:_d,backendName:"webgl",kernelFunc:nme},WP="return exp(x);",HP=_t({opSnippet:WP,packedOpSnippet:WP,cpuKernelImpl:cde}),sme={kernelName:Sd,backendName:"webgl",kernelFunc:HP};function b_(t){const{inputs:n,attrs:e,backend:r}=t,{dim:s}=e,{input:o}=n,i=o.shape.length,a=o.shape.slice();let l=s;return s<0&&(S(-(i+1)<=s,()=>`Axis must be in the interval [${-(i+1)}, ${i}]`),l=i+s+1),a.splice(l,0,1),Se({inputs:{x:o},backend:r,attrs:{shape:a}})}const ome={kernelName:vm,backendName:"webgl",kernelFunc:b_},GP="return exp(x) - 1.0;",ime=_t({opSnippet:GP,packedOpSnippet:GP,cpuKernelImpl:dde}),ame={kernelName:Ed,backendName:"webgl",kernelFunc:ime};class jP{constructor(n,e,r){this.variableNames=["real","imag"];const s=e[1];this.outputShape=e;const o=r?`2.0 * ${Math.PI}`:`-2.0 * ${Math.PI}`,i=r?`${s}.0`:"1.0";let a;if("real"===n)a="return real * expR - imag * expI;";else{if("imag"!==n)throw new Error(`FFT component must be either "real" or "imag", got ${n}.`);a="return real * expI + imag * expR;"}this.userCode=`\n      const float exponentMultiplier = ${o};\n\n      float unaryOpComplex(float real, float expR, float imag, float expI) {\n        ${a}\n      }\n\n      float mulMatDFT(int batch, int index) {\n        float indexRatio = float(index) / float(${s});\n        float exponentMultiplierTimesIndexRatio =\n            exponentMultiplier * indexRatio;\n\n        float result = 0.0;\n\n        for (int i = 0; i < ${s}; i++) {\n          // x = (-2|2 * PI / N) * index * i;\n          float x = exponentMultiplierTimesIndexRatio * float(i);\n          float expR = cos(x);\n          float expI = sin(x);\n          float real = getReal(batch, i);\n          float imag = getImag(batch, i);\n\n          result +=\n              unaryOpComplex(real, expR, imag, expI) / ${i};\n        }\n\n        return result;\n      }\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        setOutput(mulMatDFT(coords[0], coords[1]));\n      }\n    `}}function qP(t,n,e){const r=e.texData.get(t.dataId),s=te(t.shape),o=t.shape[t.shape.length-1],a=Se({inputs:{x:t},backend:e,attrs:{shape:[s/o,o]}}),l=a.shape,u=new jP("real",l,n),c=new jP("imag",l,n),d=[{dataId:r.complexTensorInfos.real.dataId,dtype:r.complexTensorInfos.real.dtype,shape:l},{dataId:r.complexTensorInfos.imag.dataId,dtype:r.complexTensorInfos.imag.dtype,shape:l}],h=e.runWebGLProgram(u,d,"float32"),f=e.runWebGLProgram(c,d,"float32"),p=Ji({inputs:{real:h,imag:f},backend:e});e.disposeIntermediateTensorInfo(h),e.disposeIntermediateTensorInfo(f);const m=Se({inputs:{x:p},backend:e,attrs:{shape:t.shape}});return e.disposeIntermediateTensorInfo(a),e.disposeIntermediateTensorInfo(p),m}const ume={kernelName:"FFT",backendName:"webgl",kernelFunc:function lme(t){const{inputs:n,backend:e}=t,{input:r}=n;return qP(r,!1,e)}};class cme{constructor(n,e){this.outputShape=[],this.variableNames=["x"],this.outputShape=n,this.userCode="\n      uniform float value;\n      void main() {\n        // Input can be obtained from uniform value.\n        setOutput(value);\n      }\n    "}getCustomSetupFunc(n){return(e,r)=>{null==this.valueLoc&&(this.valueLoc=e.getUniformLocationNoThrow(r,"value")),e.gl.uniform1f(this.valueLoc,n)}}}function v_(t){const{backend:n,attrs:e}=t,{shape:r,value:s}=e;let{dtype:o}=e;if(o=o||ld(s),"string"===o){const i=ru(o,te(r));return i.fill(s),n.makeTensorInfo(r,o,i)}{const i=new cme(r,s),a=i.getCustomSetupFunc(s);return n.runWebGLProgram(i,[],o,a)}}const dme={kernelName:gw,backendName:"webgl",kernelFunc:v_};class hme{constructor(n){this.variableNames=["Image"],this.outputShape=[];const e=n[2];this.outputShape=n,this.userCode=`\n        void main() {\n          ivec4 coords = getOutputCoords();\n          int x = coords[2];\n\n          int coordX = ${e} - x;\n          float outputValue;\n          if(coordX >= 0 && coordX < ${e}) {\n            outputValue = getImage(coords[0], coords[1], coordX, coords[3]);\n          } else {\n            outputValue = getImage(coords[0], coords[1], coords[2], coords[3]);\n          }\n          setOutput(outputValue);\n        }\n    `}}const fme={kernelName:yw,backendName:"webgl",kernelFunc:({inputs:t,backend:n})=>{const{image:e}=t,r=n,s=new hme(e.shape);return r.runWebGLProgram(s,[e],e.dtype)}},KP="return floor(x);",pme=_t({opSnippet:KP,packedOpSnippet:KP,cpuKernelImpl:hde}),mme={kernelName:Nd,backendName:"webgl",kernelFunc:pme},gme=cr({opSnippet:"\n  float s = sign(a) * sign(b);\n  int ia = round(a);\n  int ib = round(b);\n  if (ib != 0) {\n    // Windows (D3D) wants guaranteed non-zero int division at compile-time.\n    return float(idiv(ia, ib, s));\n  } else {\n    return NAN;\n  }\n",packedOpSnippet:"\n  ivec4 ia = round(a);\n  ivec4 ib = round(b);\n  bvec4 cond = notEqual(ib, ivec4(0));\n  ivec4 result = ivec4(0);\n  vec4 s = sign(a) * sign(b);\n\n  // Windows (D3D) wants guaranteed non-zero int division at compile-time.\n  if (cond[0]) {\n    result[0] = idiv(ia[0], ib[0], s[0]);\n  }\n  if (cond[1]) {\n    result[1] = idiv(ia[1], ib[1], s[1]);\n  }\n  if (cond[2]) {\n    result[2] = idiv(ia[2], ib[2], s[2]);\n  }\n  if (cond[3]) {\n    result[3] = idiv(ia[3], ib[3], s[3]);\n  }\n  return vec4(result);\n",dtype:"int32"}),yme={kernelName:Td,backendName:"webgl",kernelFunc:gme};class bme{constructor(n){this.variableNames=["A"];const e=Er(),[r,s]=n;this.outputShape=n,this.userCode=`\n      void main() {\n        ivec3 coords = getOutputCoords();\n        int texR = coords[0];\n        int texC = coords[1];\n        int depth = coords[2];\n        vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${s}.0, ${r}.0);\n\n        vec4 values = ${e.texture2D}(A, uv);\n        float value;\n        if (depth == 0) {\n          value = values.r;\n        } else if (depth == 1) {\n          value = values.g;\n        } else if (depth == 2) {\n          value = values.b;\n        } else if (depth == 3) {\n          value = values.a;\n        }\n\n        setOutput(floor(value * 255.0 + 0.5));\n      }\n    `}}class vme{constructor(n){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0;const e=Er(),[r,s]=n;this.outputShape=n,this.userCode=`\n      void main() {\n        ivec3 coords = getOutputCoords();\n        int texR = coords[0];\n        int texC = coords[1];\n        int depth = coords[2];\n\n        vec4 result = vec4(0.);\n\n        for(int row=0; row<=1; row++) {\n          for(int col=0; col<=1; col++) {\n            texC = coords[1] + row;\n            depth = coords[2] + col;\n\n            vec2 uv = (vec2(texC, texR) + halfCR) /\n                       vec2(${s}.0, ${r}.0);\n            vec4 values = ${e.texture2D}(A, uv);\n            float value;\n            if (depth == 0) {\n              value = values.r;\n            } else if (depth == 1) {\n              value = values.g;\n            } else if (depth == 2) {\n              value = values.b;\n            } else if (depth == 3) {\n              value = values.a;\n            }\n\n            result[row * 2 + col] = floor(value * 255.0 + 0.5);\n          }\n        }\n\n        ${e.output} = result;\n      }\n    `}}const xme={kernelName:Uw,backendName:"webgl",kernelFunc:function wme(t){const{inputs:n,backend:e,attrs:r}=t;let{pixels:s}=n;const{numChannels:o}=r,i=typeof HTMLVideoElement<"u"&&s instanceof HTMLVideoElement,a=typeof HTMLImageElement<"u"&&s instanceof HTMLImageElement,[l,u]=i?[s.videoWidth,s.videoHeight]:[s.width,s.height],c=[u,l],d=[u,l,o];(a||i)&&(null==ju&&(ju=document.createElement("canvas").getContext("2d")),ju.canvas.width=l,ju.canvas.height=u,ju.drawImage(s,0,0,l,u),s=ju.canvas);const h=e.makeTensorInfo(c,"int32");e.texData.get(h.dataId).usage=Qr.PIXELS,e.gpgpu.uploadPixelDataToTexture(e.getTexture(h.dataId),s);const f=ne().getBool("WEBGL_PACK")?new vme(d):new bme(d),p=e.runWebGLProgram(f,[h],"int32");return e.disposeData(h.dataId),p}};let ju;const Ime={kernelName:sg,backendName:"webgl",kernelFunc:function Cme(t){const{inputs:n,backend:e,attrs:r}=t,{x:s,filter:o,bias:i,preluActivationWeights:a}=n,{strides:l,pad:u,dataFormat:c,dilations:d,dimRoundingMode:h,activation:f,leakyreluAlpha:p}=r,m=si(c),g=Zn(s.shape,o.shape,l,d,u,h,!1,m);let y;const b=[];if(1!==g.filterHeight||1!==g.filterWidth||1!==g.dilationHeight||1!==g.dilationWidth||1!==g.strideHeight||1!==g.strideWidth||"SAME"!==g.padInfo.type&&"VALID"!==g.padInfo.type)if(ne().getBool("WEBGL_CONV_IM2COL")&&1===s.shape[0])y=PP({x:s,filter:o,convInfo:g,backend:e,bias:i,activation:f,preluActivationWeights:a,leakyreluAlpha:p});else{const x=null!=i,w=null!=a,_="leakyrelu"===f,D=f?My(f,!1):null,A=new OP(g,x,D,w,_),R=[s,o];if(i&&R.push(i),a&&R.push(a),_){const O=e.makeTensorInfo([],"float32",Oi(p,"float32"));R.push(O),b.push(O)}y=e.runWebGLProgram(A,R,"float32")}else y=MP({x:s,filter:o,convInfo:g,backend:e,bias:i,activation:f,preluActivationWeights:a,leakyreluAlpha:p});const v=Se({inputs:{x:y},backend:e,attrs:{shape:g.outShape}});return b.push(y),b.forEach(x=>e.disposeIntermediateTensorInfo(x)),v}},_me={kernelName:og,backendName:"webgl",kernelFunc:function Dme(t){const{inputs:n,backend:e,attrs:r}=t,{x:s,filter:o,bias:i,preluActivationWeights:a}=n,{strides:l,pad:u,dilations:c,dimRoundingMode:d,activation:h,leakyreluAlpha:f}=r,p=[];let m=c;null==m&&(m=[1,1]),S(ar(l,m),()=>`Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${l} and dilations '${m}'`);const g=Zn(s.shape,o.shape,l,m,u,d,!0),y=ne().getBool("WEBGL_PACK_DEPTHWISECONV")&&g.strideWidth<=2&&g.outChannels/g.inChannels==1,b=h?My(h,y):null,v=[s,o],x=null!=i,w=null!=a,_="leakyrelu"===h;if(x&&v.push(i),w&&v.push(a),_){const R=e.makeTensorInfo([],"float32",Oi(f,"float32"));v.push(R),p.push(R)}let D;D=y?new UP(g,x,b,w,_):new VP(g,x,b,w,_);const A=e.runWebGLProgram(D,v,"float32");return p.forEach(R=>e.disposeIntermediateTensorInfo(R)),A}};class Sme{constructor(n,e,r){this.sliceDim=n,this.strides=e,this.variableNames=["x","indices"],this.outputShape=r;const s=Wt(e.length),o=Wt(r.length);this.userCode=`\n        ${s} strides = ${s}(${this.strides});\n         void main() {\n          ${o} coords = getOutputCoords();\n          int flattenIndex = 0;\n          for (int j = 0; j < ${this.sliceDim}; j++) {\n            int index = round(getIndices(coords[0], j));\n            flattenIndex += index * ${this.sliceDim>1?"strides[j]":"strides"};\n          }\n          setOutput(getX(flattenIndex, coords[1]));\n        }\n      `}}const Nme={kernelName:bw,backendName:"webgl",kernelFunc:function Eme(t){const{inputs:n,backend:e}=t,{params:r,indices:s}=n,o=s.shape,i=o[o.length-1],[a,l,u,c]=fI(r,s),d=Se({inputs:{x:s},backend:e,attrs:{shape:[l,i]}}),h=Se({inputs:{x:r},backend:e,attrs:{shape:[te(r.shape)/u,u]}}),f=new Sme(i,c,[l,u]),p=e.runWebGLProgram(f,[h,d],h.dtype),m=Se({inputs:{x:p},backend:e,attrs:{shape:a}});return e.disposeIntermediateTensorInfo(d),e.disposeIntermediateTensorInfo(h),e.disposeIntermediateTensorInfo(p),m}};class Tme{constructor(n,e){this.variableNames=["A","indices"],this.outputShape=e,this.rank=e.length;const r=Wt(this.rank),s=function kme(t,n){const e=["resRC.x","resRC.y","resRC.z","resRC.w"],r=[];for(let s=0;s<t.length;s++)r.push(2===s?"int(getIndices(resRC.x, resRC.z))":`${e[s]}`);return r.join()}(n);this.userCode=`\n      void main() {\n        ${r} resRC = getOutputCoords();\n        setOutput(getA(${s}));\n      }\n    `}}const Rme={kernelName:wm,backendName:"webgl",kernelFunc:function Ame(t){const{inputs:n,backend:e,attrs:r}=t,{x:s,indices:o}=n,{axis:i,batchDims:a}=r,u=CI(s,o,ft(i,s.shape)[0],a),c=te(o.shape),d=[],h=Se({inputs:{x:s},backend:e,attrs:{shape:[u.batchSize,u.outerSize,u.dimSize,u.sliceSize]}}),f=Se({inputs:{x:o},backend:e,attrs:{shape:[u.batchSize,c/u.batchSize]}});d.push(h),d.push(f);const p=[u.batchSize,u.outerSize,c/u.batchSize,u.sliceSize];if(e.shouldExecuteOnCPU([s,o])||"string"===s.dtype){const b=e.bufferSync(f),v=e.bufferSync(h),x=fde(v,b,p);return d.forEach(w=>e.disposeIntermediateTensorInfo(w)),e.makeTensorInfo(u.outputShape,x.dtype,x.values)}const m=new Tme(h.shape,p),g=e.runWebGLProgram(m,[h,f],h.dtype);d.push(g);const y=Se({inputs:{x:g},backend:e,attrs:{shape:u.outputShape}});return d.forEach(b=>e.disposeIntermediateTensorInfo(b)),y}},$me=cr({opSnippet:"return float(a > b);",packedOpSnippet:"\n  return vec4(greaterThan(a, b));\n",cpuKernelImpl:pde,dtype:"bool"}),Fme={kernelName:Cm,backendName:"webgl",kernelFunc:$me},Ome=cr({opSnippet:"return float(a >= b);",packedOpSnippet:"\n  return vec4(greaterThanEqual(a, b));\n",dtype:"bool"}),Mme={kernelName:kd,backendName:"webgl",kernelFunc:Ome},Lme={kernelName:vw,backendName:"webgl",kernelFunc:function Pme(t){const{inputs:n,backend:e}=t,{input:r}=n;return qP(r,!0,e)}},Bme=_t({opSnippet:"return float(!isnan(x) && !isinf(x));",dtype:"bool"}),zme={kernelName:Rd,backendName:"webgl",kernelFunc:Bme},Vme=_t({opSnippet:"return float(isinf(x));",dtype:"bool"}),Ume={kernelName:$d,backendName:"webgl",kernelFunc:Vme},Wme=_t({opSnippet:"return float(isnan(x));",dtype:"bool"}),Hme={kernelName:Fd,backendName:"webgl",kernelFunc:Wme},Gme=cr({opSnippet:"return float(a < b);",packedOpSnippet:"\n  return vec4(lessThan(a, b));\n",cpuKernelImpl:mde,dtype:"bool"}),jme={kernelName:Dm,backendName:"webgl",kernelFunc:Gme},qme=cr({opSnippet:"return float(a <= b);",packedOpSnippet:"\n  return vec4(lessThanEqual(a, b));\n",dtype:"bool"}),Kme={kernelName:_m,backendName:"webgl",kernelFunc:qme},Yme={kernelName:ww,backendName:"webgl",kernelFunc:function Xme(t){const{backend:n,attrs:e}=t,{start:r,stop:s,num:o}=e,i=gde(r,s,o);return n.makeTensorInfo([i.length],"float32",i)}},Zme=_t({opSnippet:"if (x < 0.0) return NAN;\n  return log(x);",packedOpSnippet:"\n  vec4 result = log(x);\n  vec4 isNaN = vec4(lessThan(x, vec4(0.0)));\n  result.r = isNaN.r == 1.0 ? NAN : result.r;\n  result.g = isNaN.g == 1.0 ? NAN : result.g;\n  result.b = isNaN.b == 1.0 ? NAN : result.b;\n  result.a = isNaN.a == 1.0 ? NAN : result.a;\n\n  return result;\n",cpuKernelImpl:yde}),Qme={kernelName:Od,backendName:"webgl",kernelFunc:Zme},Jme=_t({opSnippet:"return log(1.0 + x);"}),ege={kernelName:Md,backendName:"webgl",kernelFunc:Jme},tge=cr({opSnippet:"return float(a >= 1.0 && b >= 1.0);",packedOpSnippet:"\n  return vec4(\n    vec4(greaterThanEqual(a, vec4(1.0))) *\n    vec4(greaterThanEqual(b, vec4(1.0))));\n",dtype:"bool"}),nge={kernelName:Sm,backendName:"webgl",kernelFunc:tge},rge=_t({opSnippet:"return float(!(x >= 1.0));"}),sge={kernelName:Em,backendName:"webgl",kernelFunc:rge},oge=cr({opSnippet:"return float(a >= 1.0 || b >= 1.0);",packedOpSnippet:"\n  return min(\n    vec4(greaterThanEqual(a, vec4(1.0))) +\n    vec4(greaterThanEqual(b, vec4(1.0))),\n    vec4(1.0));\n",dtype:"bool"}),ige={kernelName:Nm,backendName:"webgl",kernelFunc:oge};class age{constructor(n,e,r,s,o){this.variableNames=["x"],this.outputShape=[];const i=e,a=n[3]-1;let l;this.outputShape=n;const u=`float(${r}) + float(${s}) * sum`;l=.5===o?`inversesqrt(${u})`:1===o?`1.0/(${u})`:`exp(log(${u}) * float(-${o}));`,this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int r = coords[1];\n        int c = coords[2];\n        int d = coords[3];\n        float x = getX(b, r, c, d);\n        float sum = 0.0;\n        for (int j = -${i}; j <= ${i}; j++) {\n          int idx = d + j;\n          if (idx >= 0 && idx <=  ${a}) {\n            float z = getX(b, r, c, idx);\n            sum += z * z;\n          }\n        }\n        float val = x * ${l};\n        setOutput(val);\n      }\n    `}}class lge{constructor(n,e,r,s,o){this.variableNames=["x"],this.outputShape=[],this.packedInputs=!0,this.packedOutput=!0;const i=e,a=n[3]-1;let l;this.outputShape=n;const u=`float(${r}) + float(${s}) * sum`;l=.5===o?`inversesqrt(${u})`:1===o?`1.0/(${u})`:`exp(log(${u}) * float(-${o}));`,this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords.x;\n        int r = coords.y;\n        int c = coords.z;\n        int d = coords.w;\n\n        bool hasNextCol = d < ${this.outputShape[3]};\n        bool hasNextRow = c < ${this.outputShape[2]};\n\n        vec4 sum = vec4(0.);\n        vec4 xFragAtOutputCoords = getX(b, r, c, d);\n\n        vec4 xAtOutputCoords = vec4(\n          getChannel(xFragAtOutputCoords, vec2(c, d)),\n          hasNextCol ?\n            getChannel(xFragAtOutputCoords, vec2(c, d + 1)) : 0.0,\n          hasNextRow ?\n            getChannel(xFragAtOutputCoords , vec2(c + 1, d)) : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getChannel(xFragAtOutputCoords, vec2(c + 1, d + 1)) : 0.0\n        );\n\n        int firstChannel = d - ${i};\n        vec2 cache = vec2(0.);\n        if(firstChannel >= 0){\n          vec4 firstChannelFrag = getX(b, r, c, firstChannel);\n          cache.x = getChannel(firstChannelFrag, vec2(c, firstChannel));\n            if(hasNextRow){\n              cache.y = getChannel(firstChannelFrag, vec2(c + 1, firstChannel));\n            }\n        }\n\n        ivec2 depth = ivec2(d, d + 1);\n        for (int j = - ${i}; j <= ${i}; j++) {\n          ivec2 idx = depth + j;\n          bvec2 aboveLowerBound = greaterThanEqual(idx, ivec2(0));\n          bvec2 belowUpperBound = lessThanEqual(idx, ivec2(${a}));\n\n          bool depthInRange = aboveLowerBound.x && belowUpperBound.x;\n          bool depthPlusOneInRange = aboveLowerBound.y && belowUpperBound.y;\n\n          if(depthInRange || depthPlusOneInRange){\n            vec4 z = vec4(0.);\n            vec4 xFragAtCurrentDepth;\n            z.xz = cache.xy;\n            if(depthPlusOneInRange && hasNextCol){\n              xFragAtCurrentDepth = idx.y != d ?\n                getX(b, r, c, idx.y) : xFragAtOutputCoords;\n              z.y = getChannel(xFragAtCurrentDepth, vec2(c, idx.y));\n              if(hasNextRow){\n                z.w = getChannel(xFragAtCurrentDepth, vec2(c + 1, idx.y));\n              }\n            }\n            cache.xy = z.yw;\n            sum += z * z;\n          }\n        }\n        vec4 result = xAtOutputCoords * ${l};\n        setOutput(result);\n      }\n    `}}const uge={kernelName:Tm,backendName:"webgl",kernelFunc:t=>{const{inputs:n,backend:e,attrs:r}=t,{x:s}=n,{depthRadius:o,bias:i,alpha:a,beta:l}=r,u=ne().getBool("WEBGL_PACK_NORMALIZATION")?new lge(s.shape,o,i,a,l):new age(s.shape,o,i,a,l);return e.runWebGLProgram(u,[s],s.dtype)}};class cge{constructor(n,e,r,s,o){this.variableNames=["inputImage","outputImage","dy"],this.outputShape=[],this.outputShape=n,this.depth=n[3],this.depthRadius=e,this.bias=r,this.alpha=s,this.beta=o,this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int r = coords[1];\n        int c = coords[2];\n\n        float result = 0.0;\n        for (int d = 0; d < ${this.depth}; ++d) {\n          int depthBegin = int(max(0.0, float(d - ${e})));\n          int depthEnd = int(min(float(${this.depth}),\n              float(d + ${e} + 1)));\n\n          const int MIN_DEPTH_BEGIN = 0;\n          const int MAX_DEPTH_END = ${this.depth};\n\n          float norm = 0.0;\n          for (int k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; ++k) {\n            if (k < depthBegin){\n              continue;\n            }\n            else if (k >= depthBegin && k < depthEnd) {\n              norm += getInputImage(b, r, c, k) * getInputImage(b, r, c, k);\n            }\n            else {\n              break;\n            }\n          }\n\n          norm = float(${s}) * norm + float(${r});\n\n          for(int k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; ++k){\n            if (k < depthBegin){\n              continue;\n            }\n            else if (k >= depthBegin && k < depthEnd){\n              float dyi = -2.0 * float(${s})\n                * float(${o})\n                * getInputImage(b ,r ,c, k) * getOutputImage(b, r, c, d)\n                / norm;\n              if (k == d) {\n                dyi += pow(norm, -1.0 * ${o});\n              }\n              if (k == coords[3]) {\n                dyi *= getDy(b, r, c, d);\n                result += dyi;\n              }\n            }\n            else {\n              break;\n            }\n          }\n      }\n      setOutput(result);\n      }\n    `}}const dge={kernelName:Cw,backendName:"webgl",kernelFunc:t=>{const{inputs:n,backend:e,attrs:r}=t,{x:s,y:o,dy:i}=n,{depthRadius:a,bias:l,alpha:u,beta:c}=r,d=new cge(s.shape,a,l,u,c);return e.runWebGLProgram(d,[s,o,i],s.dtype)}};function XP(t){const{inputs:n,backend:e,attrs:r}=t,{x:s}=n,{reductionIndices:o,keepDims:i}=r,a=s.shape.length,l=ft(o,s.shape);let u=l;const c=xn(u,a),d=null!=c,h=e.shouldExecuteOnCPU([s]);let f=s;if(d){if(h){const v=e.texData.get(f.dataId).values,x=new Array(a);for(let D=0;D<x.length;D++)x[D]=s.shape[c[D]];const w=f_(v,s.shape,s.dtype,c,x);f=e.makeTensorInfo(x,s.dtype),e.texData.get(f.dataId).values=w}else f=Py(s,c,e);u=En(u.length,a)}lr("max",u,a);const[p,m]=Qn(f.shape,u);let y,g=p;if(i&&(g=vn(p,l)),h){const v=e.texData.get(f.dataId).values,x=bde(v,te(m),g,s.dtype);y=e.makeTensorInfo(g,s.dtype),e.texData.get(y.dataId).values=x}else y=function hge(t,n,e,r){const s=te(n),a=Se({inputs:{x:t},attrs:{shape:[te(t.shape)/s,s]},backend:r}),l=nl(a,t.dtype,"max",r),u=Se({inputs:{x:l},attrs:{shape:e},backend:r});return r.disposeIntermediateTensorInfo(a),r.disposeIntermediateTensorInfo(l),u}(f,m,g,e);return d&&e.disposeIntermediateTensorInfo(f),y}const fge={kernelName:km,backendName:"webgl",kernelFunc:XP},gge=cr({opSnippet:"\n  if (isnan(a)) return a;\n  if (isnan(b)) return b;\n\n  return max(a, b);\n",packedOpSnippet:"\n  vec4 result = vec4(max(a, b));\n  vec4 isNaN = min(vec4(isnan(a)) + vec4(isnan(b)), vec4(1.0));\n  \n  result.r = isNaN.r > 0. ? NAN : result.r;\n  result.g = isNaN.g > 0. ? NAN : result.g;\n  result.b = isNaN.b > 0. ? NAN : result.b;\n  result.a = isNaN.a > 0. ? NAN : result.a;\n\n  return result;\n",cpuKernelImpl:vde}),yge={kernelName:Pd,backendName:"webgl",kernelFunc:gge},vge={kernelName:Am,backendName:"webgl",kernelFunc:function bge(t){const{inputs:n,backend:e,attrs:r}=t,{x:s}=n;Yh(s,"maxPool");const{filterSize:o,strides:i,pad:a,dimRoundingMode:l}=r;S(ar(i,1),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${i} and dilations '1'`);const c=ks(s.shape,o,i,1,a,l);if(1===c.filterWidth&&1===c.filterHeight&&Mt(c.inShape,c.outShape))return Jr({inputs:{x:s},backend:e});const d=new Jh(c,"max",!1);return e.runWebGLProgram(d,[s],s.dtype)}},wge={kernelName:Rm,backendName:"webgl",kernelFunc:function xge(t){const{inputs:n,backend:e,attrs:r}=t,{x:s}=n,{filterSize:o,strides:i,pad:a,dataFormat:l,dimRoundingMode:u}=r,d=ri(s.shape,o,i,[1,1,1],a,u,l),h=new m_(d,"max",!1);return e.runWebGLProgram(h,[s],s.dtype)}};class Cge{constructor(n){this.variableNames=["dy","maxPos"],this.outputShape=n.inShape;const o=n.effectiveFilterHeight,i=n.effectiveFilterWidth;this.userCode=`\n      const ivec2 pads = ivec2(${o-1-n.padInfo.top}, ${i-1-n.padInfo.left});\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n\n        ivec2 dyRCCorner = coords.yz - pads;\n        int dyRCorner = dyRCCorner.x;\n        int dyCCorner = dyRCCorner.y;\n\n        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < ${o};\n          wR += ${n.dilationHeight}) {\n          float dyR = float(dyRCorner + wR) / ${n.strideHeight}.0;\n\n          if (dyR < 0.0 || dyR >= ${n.outHeight}.0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          for (int wC = 0; wC < ${i}; wC++) {\n            float dyC = float(dyCCorner + wC) / ${n.strideWidth}.0;\n\n            if (dyC < 0.0 || dyC >= ${n.outWidth}.0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            float dyValue = getDy(b, idyR, idyC, d);\n            int maxPosValue = ${o*i-1} - int(getMaxPos(b, idyR, idyC, d));\n\n            // Get the current value, check it against the value from the\n            // position matrix.\n            int curPosValue = wR * ${i} + wC;\n            float mask = float(maxPosValue == curPosValue ? 1.0 : 0.0);\n\n            dotProd += dyValue * mask;\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}class Ige{constructor(n){this.variableNames=["dy","maxPos"],this.outputShape=n.inShape;const l=n.effectiveFilterDepth,u=n.effectiveFilterHeight,c=n.effectiveFilterWidth;this.userCode=`\n      const ivec3 pads = ivec3(${l-1-n.padInfo.front}, ${u-1-n.padInfo.top}, ${c-1-n.padInfo.left});\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int ch = coords.u;\n\n        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;\n        int dyDCorner = dyCorner.x;\n        int dyRCorner = dyCorner.y;\n        int dyCCorner = dyCorner.z;\n\n        // Convolve dy(?, ?, ?, ch) with pos mask(:, :, :, d) to get\n        // dx(xD, xR, xC, ch).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n\n        for (int wD = 0; wD < ${l};\n           wD += ${n.dilationDepth}) {\n          float dyD = float(dyDCorner + wD) / ${n.strideDepth}.0;\n\n          if (dyD < 0.0 || dyD >= ${n.outDepth}.0 || fract(dyD) > 0.0) {\n            continue;\n          }\n          int idyD = int(dyD);\n\n          for (int wR = 0; wR < ${u};\n              wR += ${n.dilationHeight}) {\n            float dyR = float(dyRCorner + wR) / ${n.strideHeight}.0;\n\n            if (dyR < 0.0 || dyR >= ${n.outHeight}.0 ||\n                fract(dyR) > 0.0) {\n              continue;\n            }\n            int idyR = int(dyR);\n\n            for (int wC = 0; wC < ${c};\n                wC += ${n.dilationWidth}) {\n              float dyC = float(dyCCorner + wC) / ${n.strideWidth}.0;\n\n              if (dyC < 0.0 || dyC >= ${n.outWidth}.0 ||\n                  fract(dyC) > 0.0) {\n                continue;\n              }\n              int idyC = int(dyC);\n\n              float dyValue = getDy(batch, idyD, idyR, idyC, ch);\n              int maxPosValue = ${l*u*c-1} -\n                  int(getMaxPos(batch, idyD, idyR, idyC, ch));\n\n              // Get the current value, check it against the value from the\n              // position matrix.\n              int curPosValue =\n                  wD * ${u} * ${c} +\n                  wR * ${c} + wC;\n              float mask = float(maxPosValue == curPosValue ? 1.0 : 0.0);\n\n              dotProd += dyValue * mask;\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}const _ge={kernelName:Dw,backendName:"webgl",kernelFunc:function Dge(t){const{inputs:n,backend:e,attrs:r}=t,{dy:s,input:o}=n,i=o,{filterSize:a,strides:l,pad:u,dimRoundingMode:c}=r,h=ri(i.shape,a,l,[1,1,1],u,c),f=new m_(h,"max",!0),p=e.runWebGLProgram(f,[i],i.dtype),m=new Ige(h),g=e.runWebGLProgram(m,[s,p],i.dtype);return e.disposeIntermediateTensorInfo(p),g}},Ege={kernelName:Iw,backendName:"webgl",kernelFunc:function Sge(t){const{inputs:n,backend:e,attrs:r}=t,{dy:s,input:o,output:i}=n,a=o;Yh([o,i],"maxPoolGrad");const{filterSize:l,strides:u,pad:c,dimRoundingMode:d}=r,h=ks(a.shape,l,u,1,c,d),p=new Jh(h,"max",!0),m=e.runWebGLProgram(p,[a],a.dtype),g=new Cge(h),y=e.runWebGLProgram(g,[s,m],a.dtype);return e.disposeIntermediateTensorInfo(m),y}},Tge={kernelName:_w,backendName:"webgl",kernelFunc:({inputs:t,attrs:n,backend:e})=>{const{x:r}=t,{filterSize:s,strides:o,pad:i,includeBatchInIndex:a}=n,l=e;S(4===r.shape.length,()=>`Error in maxPool: input must be rank 4 but got rank ${r.shape.length}.`);const u=[1,1];S(ar(o,u),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${o} and dilations '${u}'`);const c=ks(r.shape,s,o,u,i),[d,h]=function Nge(t,n,e,r){let s=new Jh(e,"max",!1);const o=r.runWebGLProgram(s,[t],"float32");return s=new Jh(e,"max",!0,!0,n),[o,r.runWebGLProgram(s,[t],"float32")]}(r,a,c,l);return[d,h]}},Age={kernelName:$m,backendName:"webgl",kernelFunc:({inputs:t,attrs:n,backend:e})=>{const{x:r}=t,{keepDims:s,axis:o}=n,i=e,a=r.shape.length,l=ft(o,r.shape);let u=l;const c=xn(u,a),d=null!=c,h=i.shouldExecuteOnCPU([r]),f=[];let p=r;if(d){if(h){const x=i.texData.get(p.dataId).values,w=new Array(a);for(let A=0;A<w.length;A++)w[A]=r.shape[c[A]];const _=f_(x,r.shape,r.dtype,c,w);p=i.makeTensorInfo(w,r.dtype),i.texData.get(p.dataId).values=_}else p=Py(r,c,i);f.push(p),u=En(u.length,a)}lr("sum",u,a);const[m,g]=Qn(p.shape,u);let y=m;s&&(y=vn(m,l));const b=function kge(t,n,e,r){const s=te(n),a=Se({inputs:{x:t},attrs:{shape:[te(t.shape)/s,s]},backend:r}),l=nl(a,"float32","mean",r),u=Se({inputs:{x:l},attrs:{shape:e},backend:r});return r.disposeIntermediateTensorInfo(a),r.disposeIntermediateTensorInfo(l),u}(p,g,y,i);for(const v of f)i.disposeIntermediateTensorInfo(v);return b}},$ge={kernelName:Fm,backendName:"webgl",kernelFunc:function Rge(t){const{inputs:n,backend:e,attrs:r}=t,{x:s}=n,{axis:o,keepDims:i}=r,a=s.shape.length,l=ft(o,s.shape);let u=l;const c=xn(u,a);let d=s;null!=c&&(d=zr({inputs:{x:s},backend:e,attrs:{perm:c}}),u=En(u.length,s.shape.length)),lr("min",u,a);const[h,f]=Qn(d.shape,u),m=Se({inputs:{x:d},backend:e,attrs:{shape:[-1,te(f)]}}),g=nl(m,m.dtype,"min",e);let y;return y=Se(i?{inputs:{x:g},backend:e,attrs:{shape:vn(h,l)}}:{inputs:{x:g},backend:e,attrs:{shape:h}}),e.disposeIntermediateTensorInfo(m),e.disposeIntermediateTensorInfo(g),null!=c&&e.disposeIntermediateTensorInfo(d),y}},Mge=cr({opSnippet:"\n  if (isnan(a)) return a;\n  if (isnan(b)) return b;\n\n  return min(a, b);\n",packedOpSnippet:"\n  vec4 result = vec4(min(a, b));\n  vec4 isNaN = min(vec4(isnan(a)) + vec4(isnan(b)), vec4(1.0));\n  \n  result.r = isNaN.r > 0. ? NAN : result.r;\n  result.g = isNaN.g > 0. ? NAN : result.g;\n  result.b = isNaN.b > 0. ? NAN : result.b;\n  result.a = isNaN.a > 0. ? NAN : result.a;\n\n  return result;\n",cpuKernelImpl:xde}),Pge={kernelName:Ld,backendName:"webgl",kernelFunc:Mge};class Lge{constructor(n,e,r){this.variableNames=["x"],this.outputShape=e.map((c,d)=>c[0]+n[d]+c[1]);const s=n.length,o=Wt(s),i=e.map(c=>c[0]).join(","),a=e.map((c,d)=>c[0]+n[d]).join(","),l=["coords[0]","coords[1]","coords[2]","coords[3]"].slice(0,s),u="reflect"===r?0:1;this.userCode=1!==s?`\n      ${o} start = ${o}(${i});\n      ${o} end = ${o}(${a});\n\n      void main() {\n        ${o} outC = getOutputCoords();\n        for (int i = 0; i < ${s}; i++) {\n          if (outC[i] < start[i]) {\n            outC[i] = start[i] * 2 - outC[i] - ${u};\n          } else if(outC[i] >= end[i]) {\n            outC[i] = (end[i] - 1) * 2 - outC[i] + ${u};\n          }\n        }\n        ${o} coords = outC - start;\n        setOutput(getX(${l}));\n      }\n    `:`\n        int start = ${i};\n        int end = ${a};\n\n        void main() {\n          int outC = getOutputCoords();\n          if (outC < start) {\n            outC = start * 2 - outC - ${u};\n          } else if(outC >= end) {\n            outC = (end - 1) * 2 - outC + ${u};\n          }\n          setOutput(getX(outC - start));\n        }\n      `}}class Bge{constructor(n,e,r){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=e.map((p,m)=>p[0]+n[m]+p[1]);const s=n.length,o=Wt(s),i=e.map(p=>p[0]).join(","),a=e.map((p,m)=>p[0]+n[m]).join(","),l=Nr("rc",s),u=Nr("source",s),c=`${l[s-1]} < ${this.outputShape[s-1]}`,d=1===s?"source":`vec2(${u.slice(-2).join()})`,h="reflect"===r?0:1;let f="";if(1===s){const p=`\n        ${o} source = rc;\n        if (source < start) {\n          source = start * 2 - source - ${h};\n        } else if (source >= end) {\n          source = (end - 1) * 2 - source + ${h};\n        }\n        source -= start;\n      `;f=`\n        ${o} rc = outputLoc;\n        ${p}\n        result[0] = getChannel(getX(${u.join()}), ${d});\n        ${l[s-1]} += 1;\n        if(${c}) {\n          ${p}\n          result[1] = getChannel(getX(${u.join()}), ${d});\n        }\n      `}else{const p=`\n        ${o} source = rc;\n        ${o} lt = ${o}(lessThan(source, start));\n        ${o} gte = ${o}(greaterThanEqual(source, end));\n        ${o} orig = 1 - (lt + gte);\n        source = orig * source +\n                lt * (start * 2 - source - ${h}) +\n                gte * ((end - 1) * 2 - source + ${h});\n        source -= start;\n      `;f=`\n        ${o} rc = outputLoc;\n        ${p}\n        result[0] = getChannel(getX(${u.join()}), ${d});\n        ${l[s-1]} += 1;\n        if(${c}) {\n          ${p}\n          result[1] = getChannel(getX(${u.join()}), ${d});\n        }\n        rc = outputLoc;\n        ${l[s-2]} += 1;\n        if(${l[s-2]} < ${this.outputShape[s-2]}) {\n          ${p}\n          result[2] = getChannel(getX(${u.join()}), ${d});\n          ${l[s-1]} += 1;\n          if(${c}) {\n            ${p}\n            result[3] = getChannel(getX(${u.join()}), ${d});\n          }\n        }\n      `}this.userCode=`\n      const ${o} start = ${o}(${i});\n      const ${o} end = ${o}(${a});\n\n      void main() {\n        ${o} outputLoc = getOutputCoords();\n        vec4 result = vec4(0.);\n        ${f}\n        setOutput(result);\n      }\n    `}}const zge={kernelName:Om,backendName:"webgl",kernelFunc:({inputs:t,backend:n,attrs:e})=>{const{x:r}=t,{paddings:s,mode:o}=e,i=ne().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new Bge(r.shape,s,o):new Lge(r.shape,s,o);return n.runWebGLProgram(i,[r],r.dtype)}},Wge=cr({opSnippet:"if (b == 0.0) return NAN;\n  return mod(a, b);",packedOpSnippet:"\n  vec4 result = mod(a, b);\n  vec4 isNaN = vec4(equal(b, vec4(0.0)));\n  \n  result.r = isNaN.r > 0. ? NAN : result.r;\n  result.g = isNaN.g > 0. ? NAN : result.g;\n  result.b = isNaN.b > 0. ? NAN : result.b;\n  result.a = isNaN.a > 0. ? NAN : result.a;\n\n  return result;\n"}),Hge={kernelName:Bd,backendName:"webgl",kernelFunc:Wge};class Gge{constructor(n,e,r){this.variableNames=["probs"],this.outputShape=[n,r],this.userCode=`\n      uniform float seed;\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n\n        float r = random(seed);\n        float cdf = 0.0;\n\n        for (int i = 0; i < ${e-1}; i++) {\n          cdf += getProbs(batch, i);\n\n          if (r < cdf) {\n            setOutput(float(i));\n            return;\n          }\n        }\n\n        // If no other event happened, last event happened.\n        setOutput(float(${e-1}));\n      }\n    `}getCustomSetupFunc(n){return(e,r)=>{null==this.seedLoc&&(this.seedLoc=e.getUniformLocation(r,"seed")),e.gl.uniform1f(this.seedLoc,n)}}}const YP=cr({opSnippet:"\nif (a == b) {\n  return 1.0;\n};\nreturn a / b;",packedOpSnippet:"\n  // vec4 one = vec4(equal(a, b));\n  // return one + (vec4(1.0) - one) * a / b;\n  vec4 result = a / b;\n  if(a.x == b.x) {\n    result.x = 1.;\n  }\n  if(a.y == b.y) {\n    result.y = 1.;\n  }\n  if(a.z == b.z) {\n    result.z = 1.;\n  }\n  if(a.w == b.w) {\n    result.w = 1.;\n  }\n\n  return result;\n",checkOutOfBounds:!0}),jge={kernelName:Id,backendName:"webgl",kernelFunc:YP},ZP="return a - b;",QP=cr({opSnippet:ZP,packedOpSnippet:ZP,supportsComplex:!0,cpuKernelImpl:Nde}),qge={kernelName:th,backendName:"webgl",kernelFunc:QP};function JP(t){const{inputs:n,backend:e,attrs:r}=t,{logits:s}=n,{dim:o}=r,i=ft([o],s.shape),a=XP({inputs:{x:s},backend:e,attrs:{reductionIndices:i,keepDims:!1}}),l=vn(a.shape,i),u=Se({inputs:{x:a},backend:e,attrs:{shape:l}}),c=QP({inputs:{a:s,b:u},backend:e}),d=HP({inputs:{x:c},backend:e}),h=p_({inputs:{x:d},backend:e,attrs:{axis:i,keepDims:!1}}),f=Se({inputs:{x:h},backend:e,attrs:{shape:l}}),p=YP({inputs:{a:d,b:f},backend:e});return e.disposeIntermediateTensorInfo(a),e.disposeIntermediateTensorInfo(u),e.disposeIntermediateTensorInfo(c),e.disposeIntermediateTensorInfo(d),e.disposeIntermediateTensorInfo(h),e.disposeIntermediateTensorInfo(f),p}const Kge={kernelName:Qm,backendName:"webgl",kernelFunc:JP},Yge={kernelName:Sw,backendName:"webgl",kernelFunc:function Xge(t){const{inputs:n,backend:e,attrs:r}=t,{logits:s}=n,{numSamples:o,seed:i,normalized:a}=r,l=a?s:JP({inputs:{logits:s},backend:e,attrs:{dim:s.shape.length-1}}),d=new Gge(l.shape[0],l.shape[1],o),h=d.getCustomSetupFunc(i),f=e.runWebGLProgram(d,[l],"int32",h);return a||e.disposeIntermediateTensorInfo(l),f}},eL="return -x;",Qge={kernelName:Mm,backendName:"webgl",kernelFunc:function Zge(t){const{inputs:n,backend:e}=t,{x:r}=n;if(e.shouldExecuteOnCPU([r])){const o=e.texData.get(r.dataId),[i,a]=Cde(o.values,r.shape,r.dtype);return e.makeTensorInfo(a,r.dtype,i)}let s;return s=ne().getBool("WEBGL_PACK_UNARY_OPERATIONS")?new Wu(r.shape,eL):new Qi(r.shape,eL),e.runWebGLProgram(s,[r],r.dtype)}},Jge=HC,tye={kernelName:Ew,backendName:"webgl",kernelFunc:function eye(t){Iu("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");const{inputs:n,backend:e,attrs:r}=t,{boxes:s,scores:o}=n,{maxOutputSize:i,iouThreshold:a,scoreThreshold:l}=r,u=e.readSync(s.dataId),c=e.readSync(o.dataId),{selectedIndices:d}=Jge(u,c,i,a,l);return e.makeTensorInfo([d.length],"int32",new Int32Array(d))}},nye=GC,sye={kernelName:Nw,backendName:"webgl",kernelFunc:function rye(t){Iu("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");const{inputs:n,backend:e,attrs:r}=t,{boxes:s,scores:o}=n,{maxOutputSize:i,iouThreshold:a,scoreThreshold:l,padToMaxOutputSize:u}=r,c=e.readSync(s.dataId),d=e.readSync(o.dataId),{selectedIndices:h,validOutputs:f}=nye(c,d,i,a,l,u);return[e.makeTensorInfo([h.length],"int32",new Int32Array(h)),e.makeTensorInfo([],"int32",new Int32Array([f]))]}},oye=jC,aye={kernelName:Tw,backendName:"webgl",kernelFunc:function iye(t){Iu("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");const{inputs:n,backend:e,attrs:r}=t,{boxes:s,scores:o}=n,{maxOutputSize:i,iouThreshold:a,scoreThreshold:l,softNmsSigma:u}=r,c=e.readSync(s.dataId),d=e.readSync(o.dataId),h=i,f=a,p=l,m=u,{selectedIndices:g,selectedScores:y}=oye(c,d,h,f,p,m);return[e.makeTensorInfo([g.length],"int32",new Int32Array(g)),e.makeTensorInfo([y.length],"float32",new Float32Array(y))]}};class lye{constructor(n,e,r,s){this.variableNames=["indices"],this.outputShape=[n,e],this.userCode=`\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int index = round(getIndices(coords.x));\n        setOutput(mix(float(${s}), float(${r}),\n                      float(index == coords.y)));\n      }\n    `}}const uye={kernelName:Bm,backendName:"webgl",kernelFunc:t=>{const{inputs:n,backend:e,attrs:r}=t,{indices:s}=n,{depth:o,onValue:i,offValue:a}=r,l=te(s.shape),u=new lye(l,o,i,a),c=Se({inputs:{x:s},backend:e,attrs:{shape:[l]}}),d=e.runWebGLProgram(u,[c],s.dtype);e.disposeIntermediateTensorInfo(c);const f=Se({inputs:{x:d},backend:e,attrs:{shape:[...s.shape,o]}});return e.disposeIntermediateTensorInfo(d),f}};function Uy(t){const{inputs:n,backend:e}=t,{x:r}=n;if("complex64"===r.dtype){const s=nf({inputs:{input:r},backend:e}),o=Uy({inputs:{x:s},backend:e}),i=Vy({inputs:{input:r},backend:e}),a=Uy({inputs:{x:i},backend:e}),l=Ji({inputs:{real:o,imag:a},backend:e});return e.disposeIntermediateTensorInfo(s),e.disposeIntermediateTensorInfo(o),e.disposeIntermediateTensorInfo(i),e.disposeIntermediateTensorInfo(a),l}return v_({attrs:{shape:r.shape,dtype:r.dtype,value:"string"===r.dtype?"":0},backend:e})}const cye={kernelName:ng,backendName:"webgl",kernelFunc:Uy},dye={kernelName:Lm,backendName:"webgl",kernelFunc:function tL(t){const{inputs:n,backend:e}=t,{x:r}=n;if("string"===r.dtype)throw new Error("onesLike is not supported under string dtype");if("complex64"===r.dtype){const s=nf({inputs:{input:r},backend:e}),o=tL({inputs:{x:s},backend:e}),i=Vy({inputs:{input:r},backend:e}),a=Uy({inputs:{x:i},backend:e}),l=Ji({inputs:{real:o,imag:a},backend:e});return e.disposeIntermediateTensorInfo(s),e.disposeIntermediateTensorInfo(o),e.disposeIntermediateTensorInfo(i),e.disposeIntermediateTensorInfo(a),l}return v_({attrs:{shape:r.shape,dtype:r.dtype,value:1},backend:e})}},fye={kernelName:zm,backendName:"webgl",kernelFunc:function hye(t){const{inputs:n,backend:e,attrs:r}=t,{axis:s}=r;if(1===n.length)return b_({inputs:{input:n[0]},backend:e,attrs:{dim:s}});const o=n[0].shape,i=n[0].dtype;n.forEach(c=>{cs(o,c.shape,"All tensors passed to stack must have matching shapes"),S(i===c.dtype,()=>"All tensors passed to stack must have matching dtypes")});const a=[],u=FP({inputs:n.map(c=>{const d=b_({inputs:{input:c},backend:e,attrs:{dim:s}});return a.push(d),d}),backend:e,attrs:{axis:s}});return a.forEach(c=>e.disposeIntermediateTensorInfo(c)),u}};class pye{constructor(n,e,r){this.variableNames=["x"],this.outputShape=e.map((u,c)=>u[0]+n[c]+u[1]);const s=n.length,o=Wt(s),i=e.map(u=>u[0]).join(","),a=e.map((u,c)=>u[0]+n[c]).join(","),l=["coords[0]","coords[1]","coords[2]","coords[3]"].slice(0,s);this.userCode=1!==s?`\n      ${o} start = ${o}(${i});\n      ${o} end = ${o}(${a});\n      uniform float value;\n\n      void main() {\n        ${o} outC = getOutputCoords();\n        if (any(lessThan(outC, start)) || any(greaterThanEqual(outC, end))) {\n          setOutput(value);\n        } else {\n          ${o} coords = outC - start;\n          setOutput(getX(${l}));\n        }\n      }\n    `:`\n        int start = ${i};\n        int end = ${a};\n        uniform float value;\n\n        void main() {\n          int outC = getOutputCoords();\n          if (outC < start || outC >= end) {\n            setOutput(value);\n          } else {\n            setOutput(getX(outC - start));\n          }\n        }\n      `}getCustomSetupFunc(n){return(e,r)=>{null==this.valueLoc&&(this.valueLoc=e.getUniformLocationNoThrow(r,"value")),e.gl.uniform1f(this.valueLoc,n)}}}class mye{constructor(n,e,r){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=e.map((m,g)=>m[0]+n[g]+m[1]);const s=n.length,o=Wt(s),i=e.map(m=>m[0]).join(","),a=e.map((m,g)=>m[0]+n[g]).join(","),l=Nr("rc",s),u=Nr("source",s),c=`${l[s-1]} < ${this.outputShape[s-1]}`,d=1===s?"source":`vec2(${u.slice(-2).join()})`,h=[`${o} rc = outputLoc;`,`${l[s-1]} += 1;\n       if(${c}) {\n      `,1===s?"":`}\n       rc = outputLoc;\n       ${l[s-2]} += 1;\n       if(${l[s-2]} < ${this.outputShape[s-2]}) {`,1===s?"":`  ${l[s-1]} += 1;\n         if(${c}) {`],f=1===s?"rc < start || rc >= end":"any(lessThan(rc, start)) || any(greaterThanEqual(rc, end))";let p="";for(let m=0,g=1===s?2:4;m<g;m++)p+=`\n        ${h[m]}\n        if (${f}) {\n          result[${m}] = float(value);\n        } else {\n          ${o} source = rc - start;\n          result[${m}] = getChannel(getX(${u.join()}), ${d});\n        }\n      `;p+=1===s?"} ":"}}",this.userCode=`\n      const ${o} start = ${o}(${i});\n      const ${o} end = ${o}(${a});\n      uniform float value;\n\n      void main() {\n        ${o} outputLoc = getOutputCoords();\n        vec4 result = vec4(0.);\n        ${p}\n        setOutput(result);\n      }\n    `}getCustomSetupFunc(n){return(e,r)=>{null==this.valueLoc&&(this.valueLoc=e.getUniformLocationNoThrow(r,"value")),e.gl.uniform1f(this.valueLoc,n)}}}const nL=t=>{const{inputs:n,backend:e,attrs:r}=t,{x:s}=n,{paddings:o,constantValue:i}=r,a=ne().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new mye(s.shape,o,i):new pye(s.shape,o,i),l=a.getCustomSetupFunc(i);return e.runWebGLProgram(a,[s],s.dtype,l)},gye={kernelName:Vm,backendName:"webgl",kernelFunc:nL},vye=cr({opSnippet:"\n  if(a < 0.0 && floor(b) < b){\n    return NAN;\n  }\n  if (b == 0.0) {\n    return 1.0;\n  }\n  return (round(mod(b, 2.0)) != 1) ?\n      pow(abs(a), b) : sign(a) * pow(abs(a), b);\n",packedOpSnippet:"\n  // isModRound1 has 1 for components with round(mod(b, 2.0)) == 1, 0 otherwise.\n  vec4 isModRound1 = vec4(equal(round(mod(b, 2.0)), ivec4(1)));\n  vec4 multiplier = sign(a) * isModRound1 + (vec4(1.0) - isModRound1);\n  vec4 result = multiplier * pow(abs(a), b);\n\n  // Ensure that a^0 = 1, including 0^0 = 1 as this correspond to TF and JS\n  bvec4 isExpZero = equal(b, vec4(0.0));\n  result.r = isExpZero.r ? 1.0 : result.r;\n  result.g = isExpZero.g ? 1.0 : result.g;\n  result.b = isExpZero.b ? 1.0 : result.b;\n  result.a = isExpZero.a ? 1.0 : result.a;\n\n  vec4 isNaN = vec4(lessThan(a, vec4(0.0))) * vec4(lessThan(floor(b), b));\n  \n  result.r = isNaN.r > 0. ? NAN : result.r;\n  result.g = isNaN.g > 0. ? NAN : result.g;\n  result.b = isNaN.b > 0. ? NAN : result.b;\n  result.a = isNaN.a > 0. ? NAN : result.a;\n\n  return result;\n"}),xye={kernelName:Vd,backendName:"webgl",kernelFunc:vye},Cye={kernelName:kw,backendName:"webgl",kernelFunc:function wye(t){const{inputs:n,backend:e,attrs:r}=t,{x:s}=n,{axis:o,keepDims:i}=r,a=s.shape.length,l=[],u=ft(o,s.shape);let c=u;const d=xn(c,a);let f,h=s;if(null!=d&&(h=zr({inputs:{x:s},backend:e,attrs:{perm:d}}),c=En(c.length,a),l.push(h)),lr("prod",c,a),e.shouldExecuteOnCPU([h])){const p=e.texData.get(h.dataId).values,{outVals:m,outShape:g,outDtype:y}=Ide(h.shape,h.dtype,p,c);f=e.makeTensorInfo(g,y,m)}else{const[p,m]=Qn(h.shape,c),g=te(m),y=Se({inputs:{x:h},backend:e,attrs:{shape:[-1,g]}}),v=nl(y,Xw(s.dtype),"prod",e);f=Se({inputs:{x:v},backend:e,attrs:{shape:p}}),l.push(y),l.push(v)}if(i){l.push(f);const p=vn(f.shape,u);f=Se({inputs:{x:f},backend:e,attrs:{shape:p}})}return l.forEach(p=>e.disposeIntermediateTensorInfo(p)),f}},rL=t=>{const{backend:n,attrs:e}=t,{start:r,stop:s,step:o,dtype:i}=e,a=Dde(r,s,o,i);return n.makeTensorInfo([a.length],i,a)},Iye={kernelName:Aw,backendName:"webgl",kernelFunc:rL},Dye=_t({opSnippet:"return 1.0 / x;"}),_ye={kernelName:Ud,backendName:"webgl",kernelFunc:Dye},Eye=_t({opSnippet:"if (isnan(x)) return x;\n  return (x < 0.0) ? 0.0 : x;\n",packedOpSnippet:"\n  vec4 result = x * vec4(greaterThanEqual(x, vec4(0.0)));\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n"}),Nye={kernelName:Wd,backendName:"webgl",kernelFunc:Eye},kye=_t({opSnippet:"if (isnan(x)) return x;\n  return (x < 0.0) ? 0.0 : min(6.0, x);\n",packedOpSnippet:"\n  vec4 result = min(x, vec4(6.)) * vec4(greaterThanEqual(x, vec4(0.0)));\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n"}),Aye={kernelName:Hd,backendName:"webgl",kernelFunc:kye};class Rye{constructor(n,e,r,s,o){this.variableNames=["A"],this.outputShape=[];const[i,a,l,u]=n;this.outputShape=[i,e,r,u];const c=[s&&e>1?a-1:a,s&&r>1?l-1:l],d=[s&&e>1?e-1:e,s&&r>1?r-1:r];let h;h=o?"(vec2(yRC) + vec2(0.5)) * effectiveInputOverOutputRatioRC - vec2(0.5)":"vec2(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`\n      const vec2 effectiveInputOverOutputRatioRC = vec2(\n          ${c[0]/d[0]},\n          ${c[1]/d[1]});\n      const vec2 inputShapeRC = vec2(${a}.0, ${l}.0);\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        ivec2 yRC = coords.yz;\n\n        // Fractional source index.\n        vec2 sourceFracIndexRC = ${h};\n\n        // Compute the four integer indices.\n        ivec2 sourceFloorRC = ivec2(max(sourceFracIndexRC, vec2(0.0)));\n        ivec2 sourceCeilRC = ivec2(\n          min(inputShapeRC - 1.0, ceil(sourceFracIndexRC)));\n\n        float topLeft = getA(b, sourceFloorRC.x, sourceFloorRC.y, d);\n        float bottomLeft = getA(b, sourceCeilRC.x, sourceFloorRC.y, d);\n        float topRight = getA(b, sourceFloorRC.x, sourceCeilRC.y, d);\n        float bottomRight = getA(b, sourceCeilRC.x, sourceCeilRC.y, d);\n\n        vec2 fracRC = sourceFracIndexRC - vec2(sourceFloorRC);\n\n        float top = topLeft + (topRight - topLeft) * fracRC.y;\n        float bottom = bottomLeft + (bottomRight - bottomLeft) * fracRC.y;\n        float newValue = top + (bottom - top) * fracRC.x;\n\n        setOutput(newValue);\n      }\n    `}}class $ye{constructor(n,e,r,s,o){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[];const[i,a,l,u]=n;this.outputShape=[i,e,r,u];const c=[s&&e>1?a-1:a,s&&r>1?l-1:l],d=[s&&e>1?e-1:e,s&&r>1?r-1:r];let h;h=o?"(vec3(yRC) + vec3(0.5)) * effectiveInputOverOutputRatioRC - vec3(0.5)":"vec3(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`\n      const vec3 effectiveInputOverOutputRatioRC = vec3(\n          ${c[0]/d[0]},\n          ${c[1]/d[1]},\n          ${c[1]/d[1]});\n      const vec3 inputShapeRC = vec3(${a}.0, ${l}.0,\n                                     ${l}.0);\n\n      float getAValue(int b, int r, int c, int d) {\n        return getChannel(getA(b, r, c, d), vec2(c, d));\n      }\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        // Calculate values for next column in yRC.z.\n        ivec3 yRC = coords.yzz + ivec3(0, 0, 1);\n\n        // Fractional source index.\n        vec3 sourceFracIndexRC = ${h};\n\n        // Compute the four integer indices.\n        ivec3 sourceFloorRC = ivec3(max(sourceFracIndexRC, vec3(0.0)));\n        ivec3 sourceCeilRC = ivec3(\n          min(inputShapeRC - 1.0, ceil(sourceFracIndexRC)));\n\n        // Should we calculate next column and row elements in 2x2 packed cell.\n        bool hasNextCol = d < ${u-1};\n        bool hasNextRow = coords.z < ${r-1};\n\n        // In parallel, construct four corners for all four components in\n        // packed 2x2 cell.\n        vec4 topLeft = vec4(\n          getAValue(b, sourceFloorRC.x, sourceFloorRC.y, d),\n          hasNextCol ? getAValue(b, sourceFloorRC.x, sourceFloorRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceFloorRC.x, sourceFloorRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceFloorRC.x, sourceFloorRC.z, d + 1) : 0.0);\n\n        vec4 bottomLeft = vec4(\n          getAValue(b, sourceCeilRC.x, sourceFloorRC.y, d),\n          hasNextCol ? getAValue(b, sourceCeilRC.x, sourceFloorRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceCeilRC.x, sourceFloorRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceCeilRC.x, sourceFloorRC.z, d + 1) : 0.0);\n\n        vec4 topRight = vec4(\n          getAValue(b, sourceFloorRC.x, sourceCeilRC.y, d),\n          hasNextCol ? getAValue(b, sourceFloorRC.x, sourceCeilRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceFloorRC.x, sourceCeilRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceFloorRC.x, sourceCeilRC.z, d + 1) : 0.0);\n\n        vec4 bottomRight = vec4(\n          getAValue(b, sourceCeilRC.x, sourceCeilRC.y, d),\n          hasNextCol ? getAValue(b, sourceCeilRC.x, sourceCeilRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceCeilRC.x, sourceCeilRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceCeilRC.x, sourceCeilRC.z, d + 1) : 0.0);\n\n        vec3 fracRC = sourceFracIndexRC - vec3(sourceFloorRC);\n\n        vec4 top = mix(topLeft, topRight, fracRC.yyzz);\n        vec4 bottom = mix(bottomLeft, bottomRight, fracRC.yyzz);\n        vec4 newValue = mix(top, bottom, fracRC.x);\n\n        setOutput(newValue);\n      }\n    `}}const Oye={kernelName:Gm,backendName:"webgl",kernelFunc:function Fye(t){const{inputs:n,backend:e,attrs:r}=t,{images:s}=n,{alignCorners:o,halfPixelCenters:i,size:a}=r,[l,u]=a,c=ne().getBool("WEBGL_PACK_IMAGE_OPERATIONS")?new $ye(s.shape,l,u,o,i):new Rye(s.shape,l,u,o,i);return e.runWebGLProgram(c,[s],"float32")}};class Mye{constructor(n,e,r){this.variableNames=["dy"],this.outputShape=[],this.outputShape=e;const[,s,o]=e,[,i,a]=n,l=[r&&i>1?s-1:s,r&&a>1?o-1:o],u=[r&&i>1?i-1:i,r&&a>1?a-1:a],c=l[0]/u[0],d=l[1]/u[1],h=1/c,f=1/d,p=2*Math.ceil(h)+2,m=2*Math.ceil(f)+2;this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        int r = coords[1];\n        int c = coords[2];\n\n        float accumulator = 0.0;\n\n        const float heightScale = float(${c});\n        const float widthScale = float(${d});\n\n        const float invHeightScale = float(${h});\n        const float invWidthScale = float(${f});\n\n        const int winHeight = int(${p});\n        const int winWidth = int(${m});\n\n        // Compute bounds for where in dy we will look\n        float startRLerp = floor(float(r) * invHeightScale);\n        int startDyR = int(startRLerp - float(winHeight / 2));\n\n        float startCLerp = floor(float(c) * invWidthScale);\n        int startDyC = int(startCLerp - float(winWidth / 2));\n\n        // Loop over dy\n        for (int dyROffset = 0; dyROffset < winHeight; dyROffset++) {\n          int dyR = dyROffset + startDyR;\n\n          // Guard against the window exceeding the bounds of dy\n          if (dyR < 0 || dyR >= ${i}) {\n            continue;\n          }\n\n          for (int dyCOffset = 0; dyCOffset < winWidth; dyCOffset++) {\n            int dyC = dyCOffset + startDyC;\n\n            // Guard against the window exceeding the bounds of dy\n            if (dyC < 0 || dyC >= ${a}) {\n              continue;\n            }\n\n            float dxR = float(dyR) * heightScale;\n            int topDxRIndex = int(floor(dxR));\n            int bottomDxRIndex = int(min(ceil(dxR), ${s-1}.0));\n            float dxRLerp = dxR - float(topDxRIndex);\n            float inverseDxRLerp = 1.0 - dxRLerp;\n\n            float dxC = float(dyC) * widthScale;\n            int leftDxCIndex = int(floor(dxC));\n            int rightDxCIndex = int(min(ceil(dxC), ${o-1}.0));\n            float dxCLerp = dxC - float(leftDxCIndex);\n            float inverseDxCLerp = 1.0 - dxCLerp;\n\n            if (r == topDxRIndex && c == leftDxCIndex) {\n              // topLeft\n              accumulator +=\n                getDy(b, dyR, dyC, d) * inverseDxRLerp * inverseDxCLerp;\n            }\n\n            if (r == topDxRIndex && c == rightDxCIndex) {\n              // topRight\n              accumulator += getDy(b, dyR, dyC, d) * inverseDxRLerp * dxCLerp;\n            }\n\n            if (r == bottomDxRIndex && c == leftDxCIndex) {\n              // bottomLeft\n              accumulator += getDy(b, dyR, dyC, d) * dxRLerp * inverseDxCLerp;\n            }\n\n            if (r == bottomDxRIndex && c == rightDxCIndex) {\n              // bottomRight\n              accumulator += getDy(b, dyR, dyC, d) * dxRLerp * dxCLerp;\n            }\n          }\n        }\n        // End loop over dy\n\n        setOutput(accumulator);\n      }\n    `}}const Lye={kernelName:Fw,backendName:"webgl",kernelFunc:function Pye(t){const{inputs:n,backend:e,attrs:r}=t,{images:s,dy:o}=n,{alignCorners:i}=r,a=new Mye(o.shape,s.shape,i);return e.runWebGLProgram(a,[o],o.dtype)}};class Bye{constructor(n,e,r,s,o){this.variableNames=["A"],this.outputShape=[];const[i,a,l,u]=n;this.outputShape=[i,e,r,u];const c=[s&&e>1?a-1:a,s&&r>1?l-1:l],d=[s&&e>1?e-1:e,s&&r>1?r-1:r];let f;f=o?"max((vec2(yRC) + vec2(0.5)) * effectiveInputOverOutputRatioRC, vec2(0.0))":"vec2(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`\n      const vec2 effectiveInputOverOutputRatioRC = vec2(\n          ${c[0]/d[0]},\n          ${c[1]/d[1]});\n      const vec2 inputShapeRC = vec2(${a}.0, ${l}.0);\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        ivec2 yRC = coords.yz;\n\n        // Fractional source index.\n        vec2 sourceFracIndexRC = ${f};\n\n        // Compute the coordinators of nearest neighbor point.\n        ivec2 sourceNearestRC = ivec2(\n          min(inputShapeRC - 1.0, floor(sourceFracIndexRC + ${s?"0.5":"0.0"})));\n        float newValue = getA(b, sourceNearestRC.x, sourceNearestRC.y, d);\n\n        setOutput(newValue);\n      }\n    `}}const Vye={kernelName:Hm,backendName:"webgl",kernelFunc:function zye(t){const{inputs:n,backend:e,attrs:r}=t,{images:s}=n,{alignCorners:o,halfPixelCenters:i,size:a}=r,[l,u]=a,c=new Bye(s.shape,l,u,o,i);return e.runWebGLProgram(c,[s],s.dtype)}};class Uye{constructor(n,e,r){this.variableNames=["dy"],this.outputShape=[],this.outputShape=e;const[,s,o]=e,[,i,a]=n,l=[r&&i>1?s-1:s,r&&a>1?o-1:o],u=[r&&i>1?i-1:i,r&&a>1?a-1:a],c=l[0]/u[0],d=l[1]/u[1],h=1/c,f=1/d,p=2*Math.ceil(h)+2,m=2*Math.ceil(f)+2;this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        int r = coords[1];\n        int c = coords[2];\n\n        float accumulator = 0.0;\n\n        const float heightScale = float(${c});\n        const float widthScale = float(${d});\n\n        const float invHeightScale = float(${h});\n        const float invWidthScale = float(${f});\n\n        const int winHeight = int(${p});\n        const int winWidth = int(${m});\n\n        // Compute bounds for where in dy we will look\n        float startRLerp = floor(float(r) * invHeightScale);\n        int startDyR = int(floor(startRLerp - float(winHeight / 2)));\n\n        float startCLerp = floor(float(c) * invWidthScale);\n        int startDyC = int(floor(startCLerp - float(winWidth / 2)));\n\n        // Loop over dy\n        for (int dyROffset = 0; dyROffset < winHeight; dyROffset++) {\n          int dyR = dyROffset + startDyR;\n\n          // Guard against the window exceeding the bounds of dy\n          if (dyR < 0 || dyR >= ${i}) {\n            continue;\n          }\n\n          for (int dyCOffset = 0; dyCOffset < winWidth; dyCOffset++) {\n            int dyC = dyCOffset + startDyC;\n\n            // Guard against the window exceeding the bounds of dy\n            if (dyC < 0 || dyC >= ${a}) {\n              continue;\n            }\n\n            float sourceFracRow =\n              float(${l[0]}) *\n                (float(dyR) / float(${u[0]}));\n\n            float sourceFracCol =\n                float(${l[1]}) *\n                  (float(dyC) / float(${u[1]}));\n\n            int sourceNearestRow = int(min(\n                float(int(${s}) - 1),\n                ${r} ? float(round(sourceFracRow)) :\n                                  float(floor(sourceFracRow))));\n\n            int sourceNearestCol = int(min(\n                float(int(${o}) - 1),\n                ${r} ? float(round(sourceFracCol)) :\n                                  float(floor(sourceFracCol))));\n\n            if (r == sourceNearestRow && c == sourceNearestCol) {\n              accumulator += getDy(b, dyR, dyC, d);\n            }\n          }\n        }\n        // End loop over dy\n\n        setOutput(accumulator);\n      }\n    `}}const Hye={kernelName:$w,backendName:"webgl",kernelFunc:function Wye(t){const{inputs:n,backend:e,attrs:r}=t,{images:s,dy:o}=n,{alignCorners:i}=r,a=new Uye(o.shape,s.shape,i);return e.runWebGLProgram(a,[o],o.dtype)}};class Gye{constructor(n,e){this.variableNames=["x"];const r=n.length;if(r>4)throw new Error(`WebGL backend: Reverse of rank-${r} tensor is not yet supported`);if(this.outputShape=n,1===r)return void(this.userCode=`\n        void main() {\n          int coord = getOutputCoords();\n          setOutput(getX(${n[0]} - coord - 1));\n        }\n      `);const o=n.map((a,l)=>(a=>-1!==e.indexOf(a)&&1!==n[a]?`${n[a]} - coords[${a}] - 1`:`coords[${a}]`)(l)).join(","),i=Wt(r);this.userCode=`\n      void main() {\n        ${i} coords = getOutputCoords();\n        setOutput(getX(${o}));\n      }\n    `}}class jye{constructor(n,e){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0;const r=n.length;if(r>4)throw new Error(`WebGL backend: Reverse of rank-${r} tensor is not yet supported`);this.outputShape=n;const s=Nr("rc",r),o=`${s[r-1]} + 1 < ${this.outputShape[r-1]}`,i=`${s[r-2]} + 1 < ${this.outputShape[r-2]}`,a=Wt(r);function h(p){const m=n.map((b,v)=>function f(p,m){return-1!==e.indexOf(p)&&1!==n[p]?`${n[p]} - ${m[p]} - 1`:`${m[p]}`}(v,p));return`getChannel(getX(${m.join(",")}), vec2(${m.slice(-2).join(",")}))`}this.userCode=1===r?`\n        void main(){\n          int rc = getOutputCoords();\n          vec4 result = vec4(0.);\n          result.r = getChannel(getX(${n[0]} - rc - 1),\n            ${n[0]} - rc - 1);\n          if(${o}){\n              result.g = getChannel(getX(${n[0]} - (rc  + 1) - 1),\n                ${n[0]} - (rc  + 1) - 1);\n          }\n          setOutput(result);\n        }\n      `:`\n        void main() {\n          ${a} rc = getOutputCoords();\n          vec4 result = vec4(0.);\n          result.r = ${function l(p){return h(p)}(s.slice())};\n          if(${o}){\n            result.g = ${function u(p){return p[r-1]="("+p[r-1]+" + 1)",h(p)}(s.slice())};\n          }\n          if(${i}) {\n            result.b = ${function c(p){return p[r-2]="("+p[r-2]+" + 1)",h(p)}(s.slice())};\n            if(${o}) {\n              result.a = ${function d(p){return p[r-1]="("+p[r-1]+" + 1)",p[r-2]="("+p[r-2]+" + 1)",h(p)}(s.slice())};\n            }\n          }\n          setOutput(result);\n        }\n    `}}const Kye={kernelName:jm,backendName:"webgl",kernelFunc:function qye(t){const{inputs:n,backend:e,attrs:r}=t,{x:s}=n,{dims:o}=r,i=s.shape.length,a=ft(o,s.shape);if(0===i)return Jr({inputs:{x:s},backend:e});const l=ne().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new jye(s.shape,a):new Gye(s.shape,a);return e.runWebGLProgram(l,[s],s.dtype)}};class Xye{constructor(n,e){this.variableNames=["Image"],this.outputShape=[];const r=n[1],s=n[2];this.outputShape=n;let o="";o="number"==typeof e?`float outputValue = ${e.toFixed(2)};`:`\n        vec3 fill = vec3(${e.join(",")});\n        float outputValue = fill[coords[3]];`,this.userCode=`\n        uniform vec4 params;\n        void main() {\n          ivec4 coords = getOutputCoords();\n          int x = coords[2];\n          int y = coords[1];\n          float coordXFloat = (float(x) - params[0]) * params[3] -\n            (float(y) - params[1]) * params[2];\n          float coordYFloat = (float(x) - params[0]) * params[2] +\n            (float(y) - params[1]) * params[3];\n          int coordX = int(round(coordXFloat + params[0]));\n          int coordY = int(round(coordYFloat + params[1]));\n          ${o}\n          if(coordX >= 0 && coordX < ${s} && coordY >= 0 && coordY < ${r}) {\n            outputValue = getImage(coords[0], coordY, coordX, coords[3]);\n          }\n          setOutput(outputValue);\n        }\n    `}getCustomSetupFunc(n,e,r,s){return(o,i)=>{null==this.paramsLoc&&(this.paramsLoc=o.getUniformLocationNoThrow(i,"params")),o.gl.uniform4f(this.paramsLoc,n,e,r,s)}}}const Yye={kernelName:Ww,backendName:"webgl",kernelFunc:({inputs:t,attrs:n,backend:e})=>{const{image:r}=t,{radians:s,fillValue:o,center:i}=n,a=e,l=new Xye(r.shape,o),[u,c]=cI(i,r.shape[1],r.shape[2]),d=l.getCustomSetupFunc(u,c,Math.sin(s),Math.cos(s));return a.runWebGLProgram(l,[r],r.dtype,d)}},Zye=_t({opSnippet:"\n  // OpenGL ES does not support round function.\n  // The algorithm is based on banker's rounding.\n  float base = floor(x);\n  if ((x - base) < 0.5) {\n    return floor(x);\n  } else if ((x - base) > 0.5) {\n    return ceil(x);\n  } else {\n    if (mod(base, 2.0) == 0.0) {\n      return base;\n    } else {\n      return base + 1.0;\n    }\n  }\n"}),Qye={kernelName:Gd,backendName:"webgl",kernelFunc:Zye},Jye=_t({opSnippet:"return inversesqrt(x);",cpuKernelImpl:_de}),ebe={kernelName:jd,backendName:"webgl",kernelFunc:Jye};class sL{constructor(n,e,r,s,o,i,a=!0){this.variableNames=["updates","indices","defaultValue"],this.outputShape=i;const l=Wt(o.length),u=Wt(i.length);let c="";1===r?c="i":2===r&&(c="i, j");let h="";1===s?h="i":2===s&&(h="i, coords[1]"),this.userCode=`\n        ${l} strides = ${l}(${o});\n\n        void main() {\n          ${u} coords = getOutputCoords();\n          float sum = 0.0;\n          bool found = false;\n          for (int i = 0; i < ${n}; i++) {\n            int flattenedIndex = 0;\n            for (int j = 0; j < ${e}; j++) {\n              int index = round(getIndices(${c}));\n              flattenedIndex += index * ${e>1?"strides[j]":"strides"};\n            }\n            if (flattenedIndex == coords[0]) {\n              sum += getUpdates(${h});\n              found = true;\n            }\n          }\n          setOutput(mix(getDefaultValue(), sum, float(found)));\n        }\n      `}}const nbe={kernelName:Ow,backendName:"webgl",kernelFunc:function tbe(t){const{inputs:n,backend:e,attrs:r}=t,{indices:s,updates:o}=n,{shape:i}=r,{sliceRank:a,numUpdates:l,sliceSize:u,strides:c,outputSize:d}=Th(0,s,i),h=[d/u,u];if(0===d)return e.makeTensorInfo(i,s.dtype);const f=Se({inputs:{x:s},backend:e,attrs:{shape:[l,a]}}),p=Se({inputs:{x:o},backend:e,attrs:{shape:[l,u]}}),m=e.makeTensorInfo([],"float32",new Float32Array([0])),g=new sL(l,a,f.shape.length,p.shape.length,c,h),y=e.runWebGLProgram(g,[p,f,m],p.dtype),b=Se({inputs:{x:y},backend:e,attrs:{shape:i}});return e.disposeIntermediateTensorInfo(f),e.disposeIntermediateTensorInfo(p),e.disposeIntermediateTensorInfo(y),e.disposeIntermediateTensorInfo(m),b}};class rbe{constructor(n,e,r){let s,o;if(this.variableNames=["c","a","b"],this.outputShape=e,r>4)throw Error(`Where for rank ${r} is not yet supported`);if(1===r)o="resRC",s="resRC";else{const a=["resRC.x","resRC.y","resRC.z","resRC.w"],l=[],u=[];for(let c=0;c<e.length;c++)u.push(`${a[c]}`),c<n&&l.push(`${a[c]}`);s=l.join(),o=u.join()}const i=Wt(r);this.userCode=`\n      void main() {\n        ${i} resRC = getOutputCoords();\n        float cVal = getC(${s});\n        if (cVal >= 1.0) {\n          setOutput(getA(${o}));\n        } else {\n          setOutput(getB(${o}));\n        }\n      }\n    `}}const obe={kernelName:qm,backendName:"webgl",kernelFunc:function sbe(t){const{inputs:n,backend:e}=t,{condition:r,t:s,e:o}=n,i=new rbe(r.shape.length,s.shape,s.shape.length);return e.runWebGLProgram(i,[r,s,o],ds(s.dtype,o.dtype))}},abe=_t({opSnippet:`\n  // Stable and Attracting Fixed Point (0, 1) for Normalized Weights.\n  // see: https://arxiv.org/abs/1706.02515\n  float scaleAlpha = ${zg};\n  float scale = ${Vg};\n  return (x >= 0.0) ? scale * x : scaleAlpha * (exp(x) - 1.0);\n`}),lbe={kernelName:qd,backendName:"webgl",kernelFunc:abe},ube=_t({opSnippet:"return 1.0 / (1.0 + exp(-1.0 * x));"}),cbe={kernelName:Zd,backendName:"webgl",kernelFunc:ube},dbe=_t({opSnippet:"\n  if (isnan(x)) { return 0.0; }\n  return sign(x);\n"}),hbe={kernelName:Yd,backendName:"webgl",kernelFunc:dbe},pbe=_t({opSnippet:"if (isnan(x)) return x;\n  return sin(x);\n"}),mbe={kernelName:Kd,backendName:"webgl",kernelFunc:pbe},gbe=_t({opSnippet:"\n  float e2x = exp(x);\n  return (e2x - 1.0 / e2x) / 2.0;\n"}),ybe={kernelName:Xd,backendName:"webgl",kernelFunc:gbe},bbe=_t({opSnippet:"\n  float epsilon = 1.1920928955078125e-7;\n  float threshold = log(epsilon) + 2.0;\n\n  bool too_large = x > -threshold;\n  bool too_small = x < threshold;\n\n  float result;\n  float exp_x = exp(x);\n\n  if (too_large){\n    result = x;\n  }\n  else if (too_small){\n    result = exp_x;\n  }\n  else{\n    result = log(exp_x + 1.0);\n  }\n  return result;\n"}),vbe={kernelName:Qd,backendName:"webgl",kernelFunc:bbe},xbe={kernelName:Ym,backendName:"webgl",kernelFunc:t=>{const{inputs:n,backend:e,attrs:r}=t,{x:s}=n,{blockShape:o,paddings:i}=r;S(s.shape.length<=4,()=>"spaceToBatchND for rank > 4 with a WebGL backend not implemented yet");const a=o.reduce((y,b)=>y*b),l=[[0,0]];l.push(...i);for(let y=1+o.length;y<s.shape.length;++y)l.push([0,0]);const u=[],c=nL({inputs:{x:s},backend:e,attrs:{paddings:l,constantValue:0}}),d=Sh(c.shape,o,a,!1),h=Eh(d.length,o.length,!1),f=Nh(c.shape,o,a,!1),p=Se({inputs:{x:c},backend:e,attrs:{shape:d}}),m=zr({inputs:{x:p},backend:e,attrs:{perm:h}}),g=Se({inputs:{x:m},backend:e,attrs:{shape:f}});return u.push(c),u.push(p),u.push(m),u.forEach(y=>e.disposeIntermediateTensorInfo(y)),g}},Cbe={kernelName:Pw,backendName:"webgl",kernelFunc:function wbe(t){const{inputs:n,backend:e,attrs:r}=t,{sparseIndices:s,sparseValues:o,defaultValue:i}=n,{outputShape:a}=r,{sliceRank:l,numUpdates:u,strides:c,outputSize:d}=Th(0,s,a),f=new sL(u,l,s.shape.length,o.shape.length,c,[d,1],!1),p=e.runWebGLProgram(f,[o,s,i],o.dtype),m=Se({inputs:{x:p},backend:e,attrs:{shape:a}});return e.disposeIntermediateTensorInfo(p),m}},Dbe={kernelName:Zm,backendName:"webgl",kernelFunc:function Ibe(t){const{inputs:n,backend:e,attrs:r}=t,{x:s}=n,{numOrSizeSplits:o,axis:i}=r,a=ft(i,s.shape)[0],l=wI(s,o,a),c=new Array(s.shape.length).fill(0),d=s.shape.slice();return l.map(h=>{const f=[...d];f[a]=h;const p=ef({inputs:{x:s},backend:e,attrs:{begin:c,size:f}});return c[a]+=h,p})}},_be=_t({opSnippet:"return sqrt(x);"}),Sbe={kernelName:Jd,backendName:"webgl",kernelFunc:_be},Nbe={kernelName:Mw,backendName:"webgl",kernelFunc:_t({opSnippet:"return x * x;"})},oL="return (a - b) * (a - b);",Tbe=cr({opSnippet:oL,packedOpSnippet:oL}),kbe={kernelName:eh,backendName:"webgl",kernelFunc:Tbe},Rbe={kernelName:oh,backendName:"webgl",kernelFunc:function Abe({inputs:t,attrs:n,backend:e}){const{x:r}=t,o=new Qi(r.shape,`if (isnan(x)) return x;\n    return x > 0.0 ? 1.0 : float(${n.alpha});\n  `);return e.runWebGLProgram(o,[r],r.dtype)}};class $be{constructor(n,e,r){this.variableNames=["x"],this.outputShape=r;const s=r.length,o=Wt(r.length),i=Wt(r.length);let a="";if(1===s)a="coords * strides + begin";else{let l=0;a=r.map((u,c)=>(l++,1===r.length?`coords * strides[${c}] + begin[${c}]`:`coords[${l-1}] * strides[${c}] + begin[${c}]`)).join(",")}this.userCode=`\n      ${o} begin = ${o}(${n});\n      ${o} strides = ${o}(${e});\n\n      void main() {\n        ${i} coords = getOutputCoords();\n        setOutput(getX(${a}));\n      }\n    `}}const Obe={kernelName:Lw,backendName:"webgl",kernelFunc:function Fbe(t){const{inputs:n,backend:e,attrs:r}=t,{x:s}=n,{begin:o,end:i,strides:a,beginMask:l,endMask:u,ellipsisMask:c,newAxisMask:d,shrinkAxisMask:h}=r,{nonStrided:f,$begin:p,$strides:m,size:g,newShape:y,outShape:b}=vC(s.shape,o,i,a,l,u,c,d,h),v=Se({inputs:{x:s},backend:e,attrs:{shape:y}});let x;if(f){const _=ef({inputs:{x:v},backend:e,attrs:{begin:p,size:g}});x=Se({inputs:{x:_},backend:e,attrs:{shape:b}}),e.disposeIntermediateTensorInfo(_)}else if(b.some(_=>0===_))x=e.makeTensorInfo(b,s.dtype,[]);else if(e.shouldExecuteOnCPU([v])){const A=e.texData.get(v.dataId).values,R=yt(v.shape,v.dtype,A),O=Ede(b,R,m,p);x=e.makeTensorInfo(b,v.dtype,O.values)}else{const D=new $be(p,m,b);x=e.runWebGLProgram(D,[v],v.dtype)}const w=Se({inputs:{x},backend:e,attrs:{shape:b}});return e.disposeIntermediateTensorInfo(v),e.disposeIntermediateTensorInfo(x),w}},Mbe=_t({opSnippet:"return tan(x);"}),Pbe={kernelName:nh,backendName:"webgl",kernelFunc:Mbe},Lbe=_t({opSnippet:"\n  float e2x = exp(-2.0 * abs(x));\n  return sign(x) * (1.0 - e2x) / (1.0 + e2x);\n"}),Bbe={kernelName:rh,backendName:"webgl",kernelFunc:Lbe};class zbe{constructor(n,e){this.variableNames=["A"];const r=new Array(n.length);for(let i=0;i<r.length;i++)r[i]=n[i]*e[i];this.outputShape=r,this.rank=r.length;const s=Wt(this.rank),o=function Vbe(t){const n=t.length;if(n>5)throw Error(`Tile for rank ${n} is not yet supported`);if(1===n)return`imod(resRC, ${t[0]})`;const e=["resRC.x","resRC.y","resRC.z","resRC.w","resRC.u"],r=[];for(let s=0;s<t.length;s++)r.push(`imod(${e[s]}, ${t[s]})`);return r.join()}(n);this.userCode=`\n      void main() {\n        ${s} resRC = getOutputCoords();\n        setOutput(getA(${o}));\n      }\n    `}}function iL(t){const{inputs:n,backend:e,attrs:r}=t,{x:s}=n,{reps:o}=r;if("string"===s.dtype){const u=e.readSync(s.dataId).map(h=>iu(h)),c=yt(s.shape,s.dtype,u),d=Tde(c,o);return e.makeTensorInfo(d.shape,d.dtype,d.values)}const i=new zbe(s.shape,o);return e.runWebGLProgram(i,[s],s.dtype)}const Ube={kernelName:sh,backendName:"webgl",kernelFunc:iL},Hbe={kernelName:Bw,backendName:"webgl",kernelFunc:function Wbe(t){const{inputs:n,backend:e,attrs:r}=t,{x:s}=n,{k:o,sorted:i}=r,a=e.readSync(s.dataId),[l,u]=kde(a,s.shape,s.dtype,o,i);return[e.makeTensorInfo(l.shape,l.dtype,l.values),e.makeTensorInfo(u.shape,u.dtype,u.values)]}};class Gbe{constructor(n,e,r,s,o,i){this.variableNames=["Image","Transforms"],this.outputShape=i;const a="nearest"===r?1:2;let l;switch(s){case"constant":default:l=1;break;case"reflect":l=2;break;case"wrap":l=3;break;case"nearest":l=4}this.userCode=`\n            float mapCoord(float outCoord, float len) {\n              float inCoord = outCoord;\n              if(${l} == 2) {\n                if (inCoord < 0.0) {\n                  if (len <= 1.0) {\n                    inCoord = 0.0;\n                  } else {\n                    float sz2 = 2.0 * len;\n                    if (inCoord < sz2) {\n                      inCoord = sz2 * float(int(float(-inCoord / sz2))) +\n                      inCoord;\n                    }\n                    inCoord = inCoord < -len ? inCoord + sz2 : -inCoord - 1.0;\n                  }\n                } else if (inCoord > len - 1.0) {\n                  if (len <= 1.0) {\n                    inCoord = 0.0;\n                  } else {\n                    float sz2 = 2.0 * len;\n                    inCoord -= sz2 * float(int(float(inCoord / sz2)));\n                    if (inCoord >= len) {\n                      inCoord = sz2 - inCoord - 1.0;\n                    }\n                  }\n                }\n                return clamp(inCoord, 0.0, len - 1.0);\n              } else if (${l} == 3) {\n                if (inCoord < 0.0) {\n                  if (len <= 1.0) {\n                    inCoord = 0.0;\n                  } else {\n                    float sz = len - 1.0;\n                    inCoord += len * (float(int(float(-inCoord / sz))) + 1.0);\n                  }\n                } else if (inCoord > len - 1.0) {\n                  if (len <= 1.0) {\n                    inCoord = 0.0;\n                  } else {\n                    float sz = len - 1.0;\n                    inCoord -= len * float(int(float(inCoord / sz)));\n                  }\n                }\n                return clamp(inCoord, 0.0, len - 1.0);\n              } else if (${l} == 4) {\n                return clamp(outCoord, 0.0, len - 1.0);\n              } else {\n                return outCoord;\n              }\n            }\n\n            float readWithFillValue(int batch, int coordY, int coordX,\n              int channel) {\n              float outputValue;\n              if (0 <= coordY && coordY < ${n} && 0 <= coordX && coordX < ${e}) {\n                  outputValue = getImage(batch, coordY, coordX, channel);\n              } else {\n                outputValue = float(${o});\n              }\n              return outputValue;\n            }\n\n            void main() {\n              ivec4 coords = getOutputCoords();\n              float outputValue;\n              int batch = coords[0];\n              int x = coords[2];\n              int y = coords[1];\n              int channel = coords[3];\n              float xf = float(x);\n              float yf = float(y);\n              float a1 = getTransforms(batch, 0);\n              float a2 = getTransforms(batch, 1);\n              float a3 = getTransforms(batch, 2);\n              float b1 = getTransforms(batch, 3);\n              float b2 = getTransforms(batch, 4);\n              float b3 = getTransforms(batch, 5);\n              float c1 = getTransforms(batch, 6);\n              float c2 = getTransforms(batch, 7);\n              float projection = c1 * xf + c2 * yf + 1.0;\n              if (projection == 0.0) {\n                outputValue = float(${o});\n              } else {\n                float inX = (a1 * xf + a2 * yf + a3) / projection;\n                float inY = (b1 * xf + b2 * yf + b3) / projection;\n                float mapX = mapCoord(inX, float(${e}));\n                float mapY = mapCoord(inY, float(${n}));\n\n                if (${a} == 1) {\n                  int coordY = int(round(mapY));\n                  int coordX = int(round(mapX));\n                  outputValue = readWithFillValue(batch, coordY, coordX,\n                    channel);\n                } else {\n                  float yFloor = floor(mapY);\n                  float xFloor = floor(mapX);\n                  float yCeil = yFloor + 1.0;\n                  float xCeil = xFloor + 1.0;\n                  float valueYFloor = (xCeil - mapX) *\n                  readWithFillValue(batch, int(yFloor), int(xFloor), channel) +\n                  (mapX - xFloor) *\n                  readWithFillValue(batch, int(yFloor), int(xCeil), channel);\n                  float valueYCeil = (xCeil - mapX) *\n                  readWithFillValue(batch, int(yCeil), int(xFloor), channel) +\n                  (mapX - xFloor) *\n                  readWithFillValue(batch, int(yCeil), int(xCeil), channel);\n                  outputValue = (yCeil - mapY) * valueYFloor +\n                  (mapY - yFloor) * valueYCeil;\n                }\n              }\n              setOutput(outputValue);\n            }\n        `}}const qbe={kernelName:zw,backendName:"webgl",kernelFunc:function jbe(t){const{inputs:n,backend:e,attrs:r}=t,{image:s,transforms:o}=n,{interpolation:i,fillMode:a,fillValue:l,outputShape:u}=r,[c,d,h,f]=s.shape,[p,m]=u??[d,h],y=new Gbe(d,h,i,a,l,[c,p,m,f]);return e.runWebGLProgram(y,[s,o],"float32")}},Xbe={kernelName:Vw,backendName:"webgl",kernelFunc:function Kbe(t){const{inputs:n,attrs:e,backend:r}=t,{axis:s}=e,{x:o}=n;Yh(o,"unique"),console.warn("WARNING: ","UI might be locked temporarily as data is being downloaded");const i=r.readSync(o.dataId),{outputValues:a,outputShape:l,indices:u}=Ade(i,s,o.shape,o.dtype);return[r.makeTensorInfo(l,o.dtype,a),r.makeTensorInfo([u.length],"int32",u)]}},Zbe={kernelName:eg,backendName:"webgl",kernelFunc:function Ybe(t){const{inputs:n,backend:e,attrs:r}=t,{value:s}=n;let{axis:o}=r;o<0&&(o+=s.shape.length);const i=s,a=i.shape.length,l=s.shape[o],u=new Array(a-1);let c=0;for(let m=0;m<a;m++)m!==o&&(u[c++]=i.shape[m]);const d=[],h=new Array(a).fill(0),f=i.shape.slice();f[o]=1;const p=new Array(l);for(let m=0;m<p.length;m++){h[o]=m;const g=ef({inputs:{x:i},backend:e,attrs:{begin:h,size:f}}),y=Se({inputs:{x:g},backend:e,attrs:{shape:u}});p[m]=y,d.push(g)}return d.forEach(m=>e.disposeIntermediateTensorInfo(m)),p}};class Qbe{constructor(n,e){this.variableNames=["x","segmentIds"];const r=n.windowSize,s=n.batchSize,o=n.inSize,i=n.numSegments,a=i*Math.ceil(o/r);this.outputShape=[s,a];const c=4*Math.floor(r/4),d=r%4,h="\n        sumValue += dot(values, segFilter);\n    ";let f="";o%r>0&&(f=`\n        if (inIdx < 0 || inIdx >= ${o}) {\n          return initializationValue;\n        }\n      `);let p="";o%r>0&&(p=`\n        if (inIdx < 0 || inIdx >= ${o}) {\n          return -1.0;\n        }\n      `),this.userCode=`\n      const float initializationValue = 0.0;\n\n      float getValue(int batch, int inIdx) {\n        ${f}\n        return getX(batch, inIdx);\n      }\n\n      float getSegmentIdAtIndex(int inIdx) {\n        ${p}\n        return getSegmentIds(inIdx);\n      }\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n        int outIdx = coords[1];\n        int inOffset = int(floor(float(outIdx) / float(\n          ${i})) * float(${r}));\n        int currentSeg = int(mod(float(outIdx), float(${i})));\n\n        float sumValue = 0.0;\n\n        for (int i = 0; i < ${c}; i += 4) {\n          int inIdx = inOffset + i;\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            getValue(batch, inIdx + 3)\n          );\n\n          vec4 segFilter = vec4(\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 2)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 3)) == currentSeg ? 1 : 0\n          );\n\n          ${h}\n        }\n\n        int inIdx = inOffset + ${c};\n        if (${1===d}) {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            initializationValue,\n            initializationValue,\n            initializationValue\n          );\n\n          int inIdxSeg = int(getSegmentIdAtIndex(inIdx));\n\n          vec4 segFilter = vec4(\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\n            0,\n            0,\n            0\n          );\n\n          ${h}\n        } else if (${2===d}) {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            initializationValue,\n            initializationValue\n          );\n\n          vec4 segFilter = vec4(\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,\n              0,\n              0\n          );\n\n          ${h}\n        } else if (${3===d}) {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            initializationValue\n          );\n\n          vec4 segFilter = vec4(\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 2)) == currentSeg ? 1 : 0,\n            0\n          );\n\n          ${h}\n        }\n        setOutput(sumValue);\n      }\n    `}}const tve=[uge,dge,The,Ahe,Fhe,Phe,Bhe,Uhe,Hhe,jhe,Yhe,Qhe,tfe,sfe,dfe,afe,pfe,bfe,gfe,Cfe,Dfe,Sfe,Tfe,Ofe,Pfe,Ufe,Hfe,Kfe,Zfe,che,tpe,dpe,fpe,ope,ype,vpe,mpe,Cpe,Dpe,Spe,Npe,kpe,$pe,Bpe,Vpe,Ope,Hpe,qpe,Xpe,Qpe,eme,rme,sme,ome,ame,ume,dme,fme,mme,yme,xme,Ime,_me,Nme,Rme,Fme,Mme,uhe,Lme,epe,zme,Ume,Hme,hhe,jme,Kme,Yme,ege,Qme,nge,sge,ige,fge,wge,vge,_ge,Ege,Tge,yge,Age,$ge,Pge,zge,Hge,Yge,yhe,Qge,tye,sye,aye,Lfe,uye,dye,fye,gye,xye,phe,Cye,Iye,Bfe,jge,_ye,Aye,Nye,vhe,Oye,Lye,Vye,Hye,Kye,Yye,Qye,ebe,nbe,obe,lbe,cbe,hbe,mbe,ybe,Ffe,Kge,vbe,xbe,Cbe,Dbe,Sbe,Nbe,kbe,Rbe,Obe,qge,She,Pbe,Bbe,Ube,Hbe,qbe,Ehe,Xbe,Zbe,{kernelName:tg,backendName:"webgl",kernelFunc:function Jbe(t){const{inputs:n,backend:e,attrs:r}=t,{x:s,segmentIds:o}=n,{numSegments:i}=r,a=s.shape.length,l=[];let u=0;const c=xn([u],a);let d=s;null!=c&&(d=zr({inputs:{x:s},backend:e,attrs:{perm:c}}),l.push(d),u=En(1,a)[0]);const h=I2(d.shape,u,i),f=te([d.shape[u]]),p=Se({inputs:{x:d},backend:e,attrs:{shape:[-1,f]}});l.push(p);const m=Xw(s.dtype),g=(x,w,_,D,A)=>{const R=x.shape[0],O=x.shape[1],G=C2(O,A),j=new Qbe({windowSize:G,inSize:O,batchSize:R,numSegments:A},w),Q=e.compileAndRun(j,[x,_],D);if(l.push(Q),Q.shape[1]===A)return Q;const q=rL({backend:e,attrs:{start:0,stop:A,step:1,dtype:"float32"}}),Y=iL({inputs:{x:q},backend:e,attrs:{reps:[O/G]}});return l.push(q),l.push(Y),g(Q,w,Y,D,A)},b=Se({inputs:{x:g(p,"unsortedSegmentSum",o,m,i)},backend:e,attrs:{shape:h}});let v=b;if(null!=c){l.push(b);const x=gu(c);v=zr({inputs:{x:v},backend:e,attrs:{perm:x}})}return l.forEach(x=>e.disposeIntermediateTensorInfo(x)),v}},cye];for(const t of tve)jw(t);const ove={flipHorizontal:!1,outputStride:16,imageScaleFactor:1,maxNumBoxes:20,iouThreshold:.2,scoreThreshold:.6,modelType:"ssd320fpnlite",modelSize:"small",bboxLineWidth:"2",fontSize:17,basePath:"https://cdn.jsdelivr.net/npm/handtrackjs@latest/models/webmodel/",labelMap:{1:"open",2:"closed",3:"pinch",4:"point",5:"face",6:"pointtip",7:"pinchtip"},renderThresholds:null},ive={large:"base",medium:"fp16",small:"int8"},aL={open:"#374151",closed:"#B91C1C",pinch:"#F59E0B",point:"#10B981",face:"#3B82F6",pointtip:"#6366F1",pinchtip:"#EC4899"},lL={ssd320fpnlite:["StatefulPartitionedCall/Postprocessor/Slice","StatefulPartitionedCall/Postprocessor/ExpandDims_1"],ssd640fpnlite:["StatefulPartitionedCall/Postprocessor/Slice","StatefulPartitionedCall/Postprocessor/ExpandDims_1"],centernet512fpn:["Identity_4:0","Identity:0","Identity_2:0"]};function x_(){return(x_=J(function*(t){let n=Object.assign({},ove,t);const e=new cve(n);return yield e.load(),e})).apply(this,arguments)}function w_(){return(w_=J(function*(){if(!window.localStream)return!1;window.localStream.getTracks().forEach(t=>(t.stop(),!0))})).apply(this,arguments)}class cve{constructor(n){this.modelPath=n.basePath+n.modelType+"/"+(ive[n.modelSize]||"base")+"/model.json ",this.modelParams=n}load(){var n=this;return J(function*(){n.fps=0,n.model=yield function ore(t){return VD.apply(this,arguments)}(n.modelPath);const e=Nn([1,300,300,3],"int32"),r=yield n.model.executeAsync(e,lL[n.modelParams.modelType]);r.map(function(){var s=J(function*(o){return yield o.data()});return function(o){return s.apply(this,arguments)}}()),r.map(function(){var s=J(function*(o){return o.dispose()});return function(o){return s.apply(this,arguments)}}()),it(e)})()}detect(n){var e=this;return J(function*(){let r=Date.now();const[s,o]=function dve(t){return t instanceof an?[t.shape[0],t.shape[1]]:[t.height,t.width]}(n),i=uL(e.modelParams.imageScaleFactor,s,e.modelParams.outputStride),a=uL(e.modelParams.imageScaleFactor,o,e.modelParams.outputStride),l=U(()=>{const c=fX(n);return e.modelParams.flipHorizontal?c.reverse(1).resizeBilinear([i,a]).expandDims(0).toInt():c.resizeBilinear([i,a]).expandDims(0).toInt()}),u=e;return e.model.executeAsync(l,lL[e.modelParams.modelType]).then(function(c){l.dispose();let d=[];if("centernet512fpn"===u.modelParams.modelType){const f=c[0].dataSync(),p=c[1].arraySync(),m=c[2].dataSync();it(c),d=u.buildDetectObjectsCenternet(o,s,p[0],f,m),console.log(d)}else{const f=c[0].dataSync(),p=c[1].dataSync();it(c);const[m,g]=function hve(t,n,e){const r=[],s=[];for(let o=0;o<n;o++){let i=Number.MIN_VALUE,a=-1;for(let l=0;l<e;l++)t[o*e+l]>i&&(i=t[o*e+l],a=l);r[o]=i,s[o]=a}return[r,s]}(f,c[0].shape[1],c[0].shape[2]),y=function gX(){return F.backendName}();j$("cpu");const b=U(()=>{const x=Ih(p,[c[1].shape[1],c[1].shape[3]]);return Wa.nonMaxSuppression(x,m,u.modelParams.maxNumBoxes,u.modelParams.iouThreshold,u.modelParams.scoreThreshold)}),v=b.dataSync();b.dispose(),j$(y),d=u.buildDetectedObjects(o,s,p,m,v,g)}let h=Date.now();return u.fps=Math.round(1e3/(h-r)),d})})()}buildDetectedObjects(n,e,r,s,o,i){const a=o.length,l=[];for(let u=0;u<a;u++){const c=[];for(let g=0;g<4;g++)c[g]=r[4*o[u]+g];const d=c[0]*e,h=c[1]*n,f=c[2]*e,p=c[3]*n;c[0]=h,c[1]=d,c[2]=p-h,c[3]=f-d;const m=Math.round(i[o[u]])+1;l.push({bbox:c,class:m,label:this.modelParams.labelMap[m],score:s[o[u]].toFixed(2)})}return l}buildDetectObjectsCenternet(n,e,r,s,o){const i=[];for(let a=0;a<s.length;a++){const l=r[a],u=l[0]*e,c=l[1]*n,d=l[2]*e,h=l[3]*n;l[0]=c,l[1]=u,l[2]=h-c,l[3]=d-u;const f=Math.round(o[a])+1;i.push({bbox:l,class:f,label:this.modelParams.labelMap[f],score:s[a].toFixed(2)})}return i.slice(0,10)}getFPS(){return this.fps}setModelParameters(n){this.modelParams=Object.assign({},this.modelParams,n)}getModelParameters(){return this.modelParams}roundRect(n,e,r,s,o,i,a,l){if(typeof l>"u"&&(l=!0),typeof i>"u"&&(i=5),"number"==typeof i)i={tl:i,tr:i,br:i,bl:i};else{var u={tl:0,tr:0,br:0,bl:0};for(var c in u)i[c]=i[c]||u[c]}n.beginPath(),n.moveTo(e+i.tl,r),n.lineTo(e+s-i.tr,r),n.quadraticCurveTo(e+s,r,e+s,r+i.tr),n.lineTo(e+s,r+o-i.br),n.quadraticCurveTo(e+s,r+o,e+s-i.br,r+o),n.lineTo(e+i.bl,r+o),n.quadraticCurveTo(e,r+o,e,r+o-i.bl),n.lineTo(e,r+i.tl),n.quadraticCurveTo(e,r,e+i.tl,r),n.closePath(),a&&n.fill(),l&&n.stroke()}renderPredictions(n,e,r,s){r.clearRect(0,0,e.width,e.height),e.width=s.width,e.height=s.height,e.style.height=parseInt(e.style.width)*(s.height/s.width).toFixed(2)+"px",r.save(),this.modelParams.flipHorizontal&&(r.scale(-1,1),r.translate(-s.width,0)),r.drawImage(s,0,0,s.width,s.height),r.restore(),r.font="bold "+this.modelParams.fontSize+"px Arial";const o=this.modelParams.renderThresholds;for(let i=0;i<n.length;i++){const a=n[i];(!o||a.score>o[a.label])&&(r.beginPath(),r.fillStyle="rgba(255, 255, 255, 0.6)",r.fillRect(a.bbox[0]+1,a.bbox[1]+1,a.bbox[2]-1,1.5*this.modelParams.fontSize),r.lineWidth=this.modelParams.bboxLineWidth,this.roundRect(r,a.bbox[0],a.bbox[1],a.bbox[2],a.bbox[3],5,!1,!0),r.strokeStyle=aL[a.label],r.fillStyle=aL[a.label],r.stroke(),r.beginPath(),r.arc(a.bbox[0]+a.bbox[2]/2,a.bbox[1]+a.bbox[3]/2,2,0,2*Math.PI),r.fill(),r.stroke(),r.fillText(a.score+" | "+a.label,a.bbox[0]+5,a.bbox[1]+1.1*this.modelParams.fontSize))}r.fillStyle="rgba(255, 255, 255, 0.6)",this.roundRect(r,10,10,4.6*this.modelParams.fontSize,this.modelParams.fontSize+8,5,!0,!1),r.strokeStyle="#374151",r.fillStyle="#374151",r.font="bold "+this.modelParams.fontSize+"px Arial",r.fillText("FPS: "+this.fps,18,this.modelParams.fontSize+12)}dispose(){this.model&&this.model.dispose()}}function uL(t,n,e){const r=n*t-1;return r-r%e+1}class fve{constructor(n){this.prediction="None",this.prediction=n}getPrediction(){return this.prediction}}const pve=["htvideo"];let mve=(()=>{class t{constructor(){this.onPrediction=new Ir,this.SAMPLERATE=500,this.detectedGesture="None",this.width="400",this.height="400",this.model=null,this.runInterval=null,this.modelParams={flipHorizontal:!0,maxNumBoxes:20,iouThreshold:.5,scoreThreshold:.6}}ngOnInit(){(function ave(t){return x_.apply(this,arguments)})(this.modelParams).then(e=>{this.model=e,console.log("loaded")})}ngOnDestroy(){this.model.dispose()}startVideo(){return function lve(t){return new Promise(function(n,e){t||n({status:!1,msg:"please provide a valid video element"}),t.width=t.width||640,t.height=t.width*(t.videoHeight/t.videoWidth),t.style.height="20px",navigator.mediaDevices.getUserMedia({audio:!1,video:{facingMode:"user"}}).then(r=>{window.localStream=r,t.srcObject=r,t.onloadedmetadata=()=>{t.height=t.width*(t.videoHeight/t.videoWidth),t.style.height=parseInt(t.style.width)*(t.videoHeight/t.videoWidth).toFixed(2)+"px",t.play(),n({status:!0,msg:"webcam successfully initiated."})}}).catch(function(r){n({status:!1,msg:r})})})}(this.video.nativeElement).then(function(e){return e},e=>e)}startDetection(){this.startVideo().then(()=>{this.video.nativeElement.style.height="200px",console.log("starting predictions"),this.runInterval=setInterval(()=>{this.runDetection()},this.SAMPLERATE)},e=>{console.log(e)})}stopDetection(){console.log("stopping predictions"),clearInterval(this.runInterval),function uve(){w_.apply(this,arguments)}(this.video.nativeElement)}runDetection(){null!=this.model?this.model.detect(this.video.nativeElement).then(r=>{if(r.length<=0)return;let s=0,o=0,i=0,a=0;for(let l of r)"open"==l.label&&s++,"closed"==l.label&&o++,"point"==l.label&&i++,"pinch"==l.label&&a++;s>1?this.detectedGesture="Two Open Hands":1==s&&(this.detectedGesture="Open Hand"),o>1?this.detectedGesture="Two Closed Hands":1==o&&(this.detectedGesture="Closed Hand"),i>1?this.detectedGesture="Two Hands Pointing":1==i&&(this.detectedGesture="Hand Pointing"),a>1?this.detectedGesture="Two Hands Pinching":1==a&&(this.detectedGesture="Hand Pinching"),1==s&&1==o&&(this.detectedGesture="One Open One Closed"),1==i&&1==o&&(this.detectedGesture="One Point One Closed"),0==s&&0==o&&0==i&&0==a&&(this.detectedGesture="None"),this.onPrediction.emit(new fve(this.detectedGesture))},r=>{console.log("ERROR"),console.log(r)}):console.log("no model")}}return t.\u0275fac=function(e){return new(e||t)},t.\u0275cmp=il({type:t,selectors:[["app-handtracker"]],viewQuery:function(e,r){if(1&e&&LT(pve,5),2&e){let s;vx(s=function xx(){return function DH(t,n){return t[19].queries[n].queryList}(oe(),pS())}())&&(r.video=s.first)}},outputs:{onPrediction:"onPrediction"},decls:8,vars:0,consts:[[1,"videoLayout"],["id","htvideo","name","htvideo","autoplay","autoplay",1,"videobox"],["htvideo",""],["type","button",1,"btn","btn-inverse","btn-primary","videobtn",3,"click"]],template:function(e,r){1&e&&(yn(0,"div",0),Fn(1,"video",1,2),yn(3,"div")(4,"button",3),xa("click",function(){return r.startDetection()}),Hr(5,"Start Video"),Qt(),yn(6,"button",3),xa("click",function(){return r.stopDetection()}),Hr(7,"Stop Video"),Qt()()())},styles:[".videoLayout[_ngcontent-%COMP%]{display:flex;flex-direction:column;align-items:flex-end;margin-left:auto}.videobox[_ngcontent-%COMP%]{border:3px solid #FD7F20;border-color:#fd7f20;width:200px;height:200px}.videobtn[_ngcontent-%COMP%]{background-color:#010100;border-color:#fd7f20;color:#fd7f20;transition-duration:.4s;cursor:pointer}.videobtn[_ngcontent-%COMP%]:hover{background-color:#fd7f20;border-color:#010100;color:#010100}"]}),t})();function gve(t,n){if(1&t&&(yn(0,"button",16),Hr(1),Qt()),2&t){const e=Bl();$n(1),Nc(e.gesture)}}function yve(t,n){1&t&&(yn(0,"div",17)(1,"p",18),Hr(2,"Game Over :("),Qt()())}function bve(t,n){1&t&&Fn(0,"img",28)}function vve(t,n){1&t&&Fn(0,"img",29)}function xve(t,n){1&t&&Fn(0,"img",30)}function wve(t,n){1&t&&Fn(0,"img",31),2&t&&Fr("src",Bl(2).enemySprite,uv)}function Cve(t,n){1&t&&Fn(0,"img",32)}function Ive(t,n){1&t&&Fn(0,"img",33)}function Dve(t,n){if(1&t&&(yn(0,"div",19)(1,"div",20),Fn(2,"img",21),us(3,bve,1,0,"img",22),us(4,vve,1,0,"img",23),us(5,xve,1,0,"img",24),Qt(),yn(6,"div",20),us(7,wve,1,1,"img",25),us(8,Cve,1,0,"img",26),us(9,Ive,1,0,"img",27),Qt()()),2&t){const e=Bl();$n(3),Fr("ngIf",e.slashedE),$n(1),Fr("ngIf",e.guarded),$n(1),Fr("ngIf",e.healed),$n(2),Fr("ngIf",e.gameStarted),$n(1),Fr("ngIf",e.slashed),$n(1),Fr("ngIf",e.sparkled)}}function _ve(t,n){1&t&&(yn(0,"div",34),Fn(1,"img",35),Qt())}function Sve(t,n){if(1&t){const e=function YE(){return oe()}();yn(0,"div",36)(1,"div",7)(2,"button",37),xa("click",function(){return function lS(t){return Je.lFrame.contextLView=t,t[8]}(e),function uS(t){return Je.lFrame.contextLView=null,t}(Bl().enemyAttack())}),Hr(3,"Melee Attack"),Qt(),Fn(4,"img",38),yn(5,"button",39),Hr(6,"Self-Heal"),Qt(),Fn(7,"img",40),Qt(),yn(8,"div",7)(9,"button",39),Hr(10,"Magic Atttack"),Qt(),Fn(11,"img",41)(12,"img",41),yn(13,"button",39),Hr(14,"Self-Guard"),Qt(),Fn(15,"img",38)(16,"img",38),Qt()()}}function Eve(t,n){if(1&t&&(yn(0,"div",42)(1,"p"),Hr(2),Qt(),yn(3,"div",43),Fn(4,"img",44),Qt()()),2&t){const e=Bl();$n(2),Nc(e.displayText)}}const Nve=[{path:"",component:(()=>{class t{constructor(){this.gesture="",this.buffer=!1,this.listofMessages=["As an advanced spartan wizard warrior, life has been pretty easy for you. There have not been many times where you have been challenged. One day while you are in a bar, trying to drink your sorrows away, you overhear a nearby conversation.","Two missionaries are discussing a legendary treasure, 'The Golden Cucumber'. It is said that this item can grant its owner any wish. Becoming highly desirable, many warriors ventured out to claim this treasure, but not one has returned alive.","This peaks your interest, finally a worthy challenge. Coincidentally enough, the men's discussion provides you with the exact path and journey you must take to reach this plated vegetable. Through the mossy swamps, Up the devils mountain, and finally within the jewel castle resting in the clouds. Are you ready to begin your journey?","You begin within the swamps. Every turn is filled with mud, moisture, and dirt. Not to mention the smell. Suddenly, a man approaches you. 'Give me all your belongings right now!'. A bandit, and an armed one too. You engage.","After beating the bandit you finish traversing the swamps. That is when you arrive to the Devil's mountain. As you begin ascension, lost souls, taking the form of skeletons, rise up to impede your path to the peak. You engage.","As you finally reach the peak of Devil's mountain, you ascend to the clouds where you reach Jewel Castle. You see the Golden Cucumber, the only thing in your way is its guardian. There is only one thing left to do, you engage.","You have reached The Golden Cucumber! Congratulations, you now have a vegetable for some reason! Thank you so much for playing, hope you enjoyed :)"],this.messageCount=0,this.finishedMessages=!1,this.gameStarted=!1,this.gameOver=!1,this.gameWon=!1,this.inCombat=!1,this.slashed=!1,this.slashedE=!1,this.sparkled=!1,this.guarded=!1,this.healed=!1,this.audio=new Audio,this.playerHealth=100,this.enemyHealth=100,this.background="url(../../assets/images/tavern.gif)",this.enemySprite="",this.healthDisplay="hidden",this.soundInfo="Mute"}ngOnInit(){this.audio.src="../../assets/audio/Tavern.mp3",this.audio.load(),this.audio.play(),this.updateText()}prediction(e){this.gesture=e.getPrediction(),"Open Hand"==this.gesture&&!this.finishedMessages&&!this.buffer&&!this.inCombat&&this.updateText(),"Closed Hand"==this.gesture&&!this.buffer&&this.inCombat&&this.meleeAttack(),"Hand Pointing"==this.gesture&&!this.buffer&&this.inCombat&&this.healSelf(),"Two Open Hands"==this.gesture&&!this.buffer&&this.inCombat&&this.magicAttack(),"Two Closed Hands"==this.gesture&&!this.buffer&&this.inCombat&&this.guard(),"One Open One Closed"==this.gesture&&!this.buffer&&this.muteAudio(),"One Point One Closed"==this.gesture&&this.restart()}updateText(){0!=this.listofMessages.length?(this.messageCount+=1,5==this.messageCount?(this.gameStarted=!0,this.inCombat=!0,this.background="url(../../assets/images/pixelswamp.gif)",this.enemySprite="../../assets/images/Bandit.png",this.healthDisplay="visible",this.displayText="",this.audio.src="../../assets/audio/Swamp.mp3",this.audio.load(),this.audio.play()):7==this.messageCount?(this.inCombat=!0,this.background="url(../../assets/images/pixelMountain.gif)",this.enemySprite="../../assets/images/skele.png",this.enemyHealth=100,this.displayText="",this.audio.src="../../assets/audio/Mountain.mp3",this.audio.load(),this.audio.play()):9==this.messageCount?(this.inCombat=!0,this.background="url(../../assets/images/pixelheaven.gif)",this.enemySprite="../../assets/images/Angel.png",this.enemyHealth=100,this.displayText="",this.audio.src="../../assets/audio/Heaven.mp3",this.audio.load(),this.audio.play()):(this.displayText=String(this.listofMessages.shift()+" (Open Hand to Continue)"),this.playSoundEffect("../../assets/audio/Violin_Collision.wav"),this.buffer=!0,setTimeout(()=>{this.buffer=!1},1e3))):(this.finishedMessages=!0,this.displayText="",this.gameStarted=!1,this.gameWon=!0)}meleeAttack(){this.enemyHealth-=Math.floor(17*Math.random()+8),this.playSoundEffect("../../assets/audio/Crunch.mp3"),this.slashed=!0,setTimeout(()=>{this.slashed=!1},450),this.enemyHealth<=0?this.nextCycle():setTimeout(()=>{this.enemyAttack()},1e3),this.buffer=!0,setTimeout(()=>{this.buffer=!1},1e3)}healSelf(){this.playerHealth+=Math.floor(40*Math.random()+10),this.playerHealth>100&&(this.playerHealth=100),this.playSoundEffect("../../assets/audio/Soul.wav"),this.healed=!0,setTimeout(()=>{this.healed=!1},450),setTimeout(()=>{this.enemyAttack()},1e3),this.buffer=!0,setTimeout(()=>{this.buffer=!1},1e3)}magicAttack(){this.enemyHealth-=Math.floor(48*Math.random()+2),this.playSoundEffect("../../assets/audio/Violin_Death.wav"),this.sparkled=!0,setTimeout(()=>{this.sparkled=!1},450),this.enemyHealth<=0?this.nextCycle():setTimeout(()=>{this.enemyAttack()},1e3),this.buffer=!0,setTimeout(()=>{this.buffer=!1},1e3)}guard(){this.playSoundEffect("../../assets/audio/Error.wav"),this.guarded=!0,setTimeout(()=>{this.guarded=!1},450),this.buffer=!0,setTimeout(()=>{this.buffer=!1},1e3)}enemyAttack(){this.playerHealth-=Math.floor(17*Math.random()+8),this.playSoundEffect("../../assets/audio/Player_Hit.wav"),this.slashedE=!0,setTimeout(()=>{this.slashedE=!1},450),this.playerHealth<=0&&(this.gameOver=!0)}nextCycle(){this.inCombat=!1,this.updateText()}muteAudio(){0!==this.audio.volume?(this.soundInfo="Unmute",this.audio.volume=0):(this.soundInfo="Mute",this.audio.volume=1),this.buffer=!0,setTimeout(()=>{this.buffer=!1},1e3)}restart(){location.reload()}playSoundEffect(e){var r=new Audio;r.src=e,r.load(),r.play()}}return t.\u0275fac=function(e){return new(e||t)},t.\u0275cmp=il({type:t,selectors:[["app-home-page"]],decls:24,vars:17,consts:[[1,"topBtn","row"],[1,"col","col-sm"],["type","button",1,"btn","btn-lg","btn-block","btn-primary","attackBtn","topBtns"],["src","../../assets/images/CloseHand.png","alt","Sprite of a Closed Hand",1,"handSprite"],["src","../../assets/images/PointHand.png","alt","Sprite of a Pointed Hand",1,"handSprite"],[1,"col"],["src","../../assets/images/OpenHand.png","alt","Sprite of an Open Hand",1,"handSprite"],[1,"row"],[1,"col","col-md-4","health"],[1,"col","col-md-4",3,"onPrediction"],["type","button","class","btn btn-lg btn-block btn-primary handMove",4,"ngIf"],["class","textbox centeredText",4,"ngIf"],["class","row characters",4,"ngIf"],["style","display: flex; justify-content: center",4,"ngIf"],["class","fightbox",4,"ngIf"],["class","textbox",4,"ngIf"],["type","button",1,"btn","btn-lg","btn-block","btn-primary","handMove"],[1,"textbox","centeredText"],[2,"font-size","200%"],[1,"row","characters"],[1,"spriteContainer","col","col-2"],["src","../../assets/images/hero.png","alt","Hero Sprite",1,"hero"],["class","combatAnim","src","../../assets/images/undertale-slash-pixels.gif","alt","Slash animation","style","left: 35%;",4,"ngIf"],["class","combatAnim","src","../../assets/images/Guard.gif","alt","Guard animation","style","left: 25%;",4,"ngIf"],["class","combatAnim","src","../../assets/images/heal.gif","alt","Heal animation","style","left: 20%;",4,"ngIf"],["class","enemy","alt","Enemy Sprite",3,"src",4,"ngIf"],["class","combatAnim","src","../../assets/images/undertale-slash-pixels.gif","alt","Slash animation","style","left: 20%;",4,"ngIf"],["class","combatAnim","src","../../assets/images/MagicAttack.gif","alt","Magic attack animation","style","bottom: 30%;",4,"ngIf"],["src","../../assets/images/undertale-slash-pixels.gif","alt","Slash animation",1,"combatAnim",2,"left","35%"],["src","../../assets/images/Guard.gif","alt","Guard animation",1,"combatAnim",2,"left","25%"],["src","../../assets/images/heal.gif","alt","Heal animation",1,"combatAnim",2,"left","20%"],["alt","Enemy Sprite",1,"enemy",3,"src"],["src","../../assets/images/undertale-slash-pixels.gif","alt","Slash animation",1,"combatAnim",2,"left","20%"],["src","../../assets/images/MagicAttack.gif","alt","Magic attack animation",1,"combatAnim",2,"bottom","30%"],[2,"display","flex","justify-content","center"],["src","../../assets/images/GoldenCucumber.png","alt","Sprite of the Golden Cucumber"],[1,"fightbox"],["type","button",1,"btn","btn-lg","btn-block","btn-outline-primary","attackBtn","col","col-6",3,"click"],["src","../../assets/images/CloseHand.png","alt","Sprite of a Closed Hand",1,"attackSprite"],["type","button",1,"btn","btn-lg","btn-block","btn-outline-primary","attackBtn","col","col-6"],["src","../../assets/images/PointHand.png","alt","Sprite of a Pointed Hand",1,"attackSprite"],["src","../../assets/images/OpenHand.png","alt","Sprite of an Open Hand",1,"attackSprite"],[1,"textbox"],[1,"textIcon"],["src","../../assets/images/OpenHand.png","alt","Sprite of an Open Hand",1,"textHandSprite",2,"margin-bottom","10px","margin-right","10px"]],template:function(e,r){1&e&&(yn(0,"div")(1,"div",0)(2,"div",1)(3,"button",2),Hr(4,"Restart"),Qt(),Fn(5,"img",3)(6,"img",4),Qt(),yn(7,"div",5)(8,"button",2),Hr(9),Qt(),Fn(10,"img",3)(11,"img",6),Qt()(),yn(12,"div",7)(13,"h1",8),Hr(14),Qt(),yn(15,"h1",8),Hr(16),Qt(),yn(17,"app-handtracker",9),xa("onPrediction",function(o){return r.prediction(o)}),Qt()(),us(18,gve,2,1,"button",10),us(19,yve,3,0,"div",11),us(20,Dve,10,6,"div",12),us(21,_ve,2,0,"div",13),us(22,Sve,17,0,"div",14),us(23,Eve,5,1,"div",15),Qt()),2&e&&(Sc("background-image",r.background)("background-size","cover"),$n(9),Nc(r.soundInfo),$n(4),Sc("visibility",r.healthDisplay),$n(1),Tc("Current Health : ",r.playerHealth,"/100"),$n(1),Sc("visibility",r.healthDisplay),$n(1),Tc("Enemy Health : ",r.enemyHealth,"/100"),$n(2),Fr("ngIf",""!=r.gesture),$n(1),Fr("ngIf",r.gameOver),$n(1),Fr("ngIf",!r.gameOver),$n(1),Fr("ngIf",r.gameWon),$n(1),Fr("ngIf",""==r.displayText&&!r.gameOver&&r.gameStarted),$n(1),Fr("ngIf",""!=r.displayText&&!r.gameOver))},dependencies:[Jk,mve],styles:[".topBtn[_ngcontent-%COMP%]{position:fixed;margin-bottom:20px;transform:scale(.75)}.topBtns[_ngcontent-%COMP%]{width:100px;height:50px}.handSprite[_ngcontent-%COMP%]{width:50px;height:50px}.textHandSprite[_ngcontent-%COMP%]{width:30px;height:30px}.attackSprite[_ngcontent-%COMP%]{margin:10px 0;width:70px;height:50px}.characters[_ngcontent-%COMP%]{display:flex;justify-content:space-around}.spriteContainer[_ngcontent-%COMP%]{position:relative}.combatAnim[_ngcontent-%COMP%]{width:100%;height:100%;transform:scale(.7);position:absolute;top:0;left:0}.hero[_ngcontent-%COMP%], .enemy[_ngcontent-%COMP%]{margin-top:100px;width:300px;height:300px}.health[_ngcontent-%COMP%]{display:flex;justify-content:flex-end;align-self:center;background-color:#232323b3;color:#fd7f20;padding:25px 20px;font-style:italic;font-size:150%}.handMove[_ngcontent-%COMP%]{position:absolute;right:0}.textbox[_ngcontent-%COMP%]{border:3px solid orange;background-color:#010100;border-style:inset;color:#fd7f20;font-size:120%;margin-top:100px}.textbox[_ngcontent-%COMP%]   p[_ngcontent-%COMP%]{margin:10px}.textIcon[_ngcontent-%COMP%]{display:flex;justify-content:flex-end}.fightbox[_ngcontent-%COMP%]{display:flex;justify-content:space-around;flex:1;width:100%;border:3px solid orange;background-color:#010100;border-style:inset;box-sizing:border-box;color:#fd7f20;margin-top:100px}.attackBtn[_ngcontent-%COMP%], .handMove[_ngcontent-%COMP%]{margin:10px;background-color:#010100;border-color:#fd7f20;color:#fd7f20;transition-duration:.4s;cursor:pointer}.attackBtn[_ngcontent-%COMP%]:hover{background-color:#fd7f20;border-color:#010100;color:#010100}.centeredText[_ngcontent-%COMP%]{text-align:center;padding-top:30px;padding-bottom:30px;margin-top:450px}@media screen and (min-width: 720px){.textbox[_ngcontent-%COMP%]{font-size:150%}.health[_ngcontent-%COMP%]{font-size:175%}.topBtn[_ngcontent-%COMP%]{left:10%;transform:scale(1)}}@media screen and (min-width: 920px){.topBtn[_ngcontent-%COMP%]{left:20%}}@media screen and (min-width: 1280px){.textbox[_ngcontent-%COMP%]{font-size:175%}.health[_ngcontent-%COMP%]{font-size:220%}.topBtn[_ngcontent-%COMP%]{left:30%}}@media screen and (min-width: 1400px){.health[_ngcontent-%COMP%]{font-size:250%}.topBtn[_ngcontent-%COMP%]{left:38%}}"]}),t})()}];let Tve=(()=>{class t{}return t.\u0275fac=function(e){return new(e||t)},t.\u0275mod=ia({type:t}),t.\u0275inj=vi({imports:[zR.forRoot(Nve),zR]}),t})(),kve=(()=>{class t{constructor(){this.title="at-alternative-interaction-solution"}}return t.\u0275fac=function(e){return new(e||t)},t.\u0275cmp=il({type:t,selectors:[["app-root"]],decls:1,vars:0,template:function(e,r){1&e&&Fn(0,"router-outlet")},dependencies:[k0]}),t})(),Ave=(()=>{class t{}return t.\u0275fac=function(e){return new(e||t)},t.\u0275mod=ia({type:t,bootstrap:[kve]}),t.\u0275inj=vi({imports:[t6,Tve]}),t})();e6().bootstrapModule(Ave).catch(t=>console.error(t))},537:(ce,_e,B)=>{var he=B(123),st=B(786),X=B(516),Ze=B(868),be=B(902),Ce=B(576),ie=B(390);ie.alea=he,ie.xor128=st,ie.xorwow=X,ie.xorshift7=Ze,ie.xor4096=be,ie.tychei=Ce,ce.exports=ie},123:function(ce,_e,B){var he;!function(st,X,Ze){function be(I){var k=this,$=function P(){var I=4022871197;return function($){$=$.toString();for(var E=0;E<$.length;E++){var N=.02519603282416938*(I+=$.charCodeAt(E));N-=I=N>>>0,I=(N*=I)>>>0,I+=4294967296*(N-=I)}return 2.3283064365386963e-10*(I>>>0)}}();k.next=function(){var E=2091639*k.s0+2.3283064365386963e-10*k.c;return k.s0=k.s1,k.s1=k.s2,k.s2=E-(k.c=0|E)},k.c=1,k.s0=$(" "),k.s1=$(" "),k.s2=$(" "),k.s0-=$(I),k.s0<0&&(k.s0+=1),k.s1-=$(I),k.s1<0&&(k.s1+=1),k.s2-=$(I),k.s2<0&&(k.s2+=1),$=null}function Ce(I,k){return k.c=I.c,k.s0=I.s0,k.s1=I.s1,k.s2=I.s2,k}function ie(I,k){var $=new be(I),E=k&&k.state,N=$.next;return N.int32=function(){return 4294967296*$.next()|0},N.double=function(){return N()+11102230246251565e-32*(2097152*N()|0)},N.quick=N,E&&("object"==typeof E&&Ce(E,$),N.state=function(){return Ce($,{})}),N}X&&X.exports?X.exports=ie:B.amdD&&B.amdO?void 0!==(he=function(){return ie}.call(_e,B,_e,X))&&(X.exports=he):this.alea=ie}(0,ce=B.nmd(ce))},576:function(ce,_e,B){var he;!function(st,X,Ze){function be(P){var I=this,k="";I.next=function(){var E=I.b,N=I.c,z=I.d,W=I.a;return E=E<<25^E>>>7^N,N=N-z|0,z=z<<24^z>>>8^W,W=W-E|0,I.b=E=E<<20^E>>>12^N,I.c=N=N-z|0,I.d=z<<16^N>>>16^W,I.a=W-E|0},I.a=0,I.b=0,I.c=-1640531527,I.d=1367130551,P===Math.floor(P)?(I.a=P/4294967296|0,I.b=0|P):k+=P;for(var $=0;$<k.length+20;$++)I.b^=0|k.charCodeAt($),I.next()}function Ce(P,I){return I.a=P.a,I.b=P.b,I.c=P.c,I.d=P.d,I}function ie(P,I){var k=new be(P),$=I&&I.state,E=function(){return(k.next()>>>0)/4294967296};return E.double=function(){do{var W=((k.next()>>>11)+(k.next()>>>0)/4294967296)/(1<<21)}while(0===W);return W},E.int32=k.next,E.quick=E,$&&("object"==typeof $&&Ce($,k),E.state=function(){return Ce(k,{})}),E}X&&X.exports?X.exports=ie:B.amdD&&B.amdO?void 0!==(he=function(){return ie}.call(_e,B,_e,X))&&(X.exports=he):this.tychei=ie}(0,ce=B.nmd(ce))},786:function(ce,_e,B){var he;!function(st,X,Ze){function be(P){var I=this,k="";I.x=0,I.y=0,I.z=0,I.w=0,I.next=function(){var E=I.x^I.x<<11;return I.x=I.y,I.y=I.z,I.z=I.w,I.w^=I.w>>>19^E^E>>>8},P===(0|P)?I.x=P:k+=P;for(var $=0;$<k.length+64;$++)I.x^=0|k.charCodeAt($),I.next()}function Ce(P,I){return I.x=P.x,I.y=P.y,I.z=P.z,I.w=P.w,I}function ie(P,I){var k=new be(P),$=I&&I.state,E=function(){return(k.next()>>>0)/4294967296};return E.double=function(){do{var W=((k.next()>>>11)+(k.next()>>>0)/4294967296)/(1<<21)}while(0===W);return W},E.int32=k.next,E.quick=E,$&&("object"==typeof $&&Ce($,k),E.state=function(){return Ce(k,{})}),E}X&&X.exports?X.exports=ie:B.amdD&&B.amdO?void 0!==(he=function(){return ie}.call(_e,B,_e,X))&&(X.exports=he):this.xor128=ie}(0,ce=B.nmd(ce))},902:function(ce,_e,B){var he;!function(st,X,Ze){function be(P){var I=this;I.next=function(){var z,W,$=I.w,E=I.X,N=I.i;return I.w=$=$+1640531527|0,W=E[N+34&127],z=E[N=N+1&127],W^=W<<13,z^=z<<17,W=E[N]=(W^=W>>>15)^(z^=z>>>12),I.i=N,W+($^$>>>16)|0},function k($,E){var N,z,W,Qe,Rt,wt=[],In=128;for(E===(0|E)?(z=E,E=null):(E+="\0",z=0,In=Math.max(In,E.length)),W=0,Qe=-32;Qe<In;++Qe)E&&(z^=E.charCodeAt((Qe+32)%E.length)),0===Qe&&(Rt=z),z^=z<<10,z^=z>>>15,z^=z<<4,z^=z>>>13,Qe>=0&&(W=0==(N=wt[127&Qe]^=z+(Rt=Rt+1640531527|0))?W+1:0);for(W>=128&&(wt[127&(E&&E.length||0)]=-1),W=127,Qe=512;Qe>0;--Qe)z=wt[W+34&127],N=wt[W=W+1&127],z^=z<<13,N^=N<<17,wt[W]=(z^=z>>>15)^(N^=N>>>12);$.w=Rt,$.X=wt,$.i=W}(I,P)}function Ce(P,I){return I.i=P.i,I.w=P.w,I.X=P.X.slice(),I}function ie(P,I){null==P&&(P=+new Date);var k=new be(P),$=I&&I.state,E=function(){return(k.next()>>>0)/4294967296};return E.double=function(){do{var W=((k.next()>>>11)+(k.next()>>>0)/4294967296)/(1<<21)}while(0===W);return W},E.int32=k.next,E.quick=E,$&&($.X&&Ce($,k),E.state=function(){return Ce(k,{})}),E}X&&X.exports?X.exports=ie:B.amdD&&B.amdO?void 0!==(he=function(){return ie}.call(_e,B,_e,X))&&(X.exports=he):this.xor4096=ie}(0,ce=B.nmd(ce))},868:function(ce,_e,B){var he;!function(st,X,Ze){function be(P){var I=this;I.next=function(){var N,z,$=I.x,E=I.i;return N=$[E],z=(N^=N>>>7)^N<<24,z^=(N=$[E+1&7])^N>>>10,z^=(N=$[E+3&7])^N>>>3,z^=(N=$[E+4&7])^N<<7,N=$[E+7&7],$[E]=z^=(N^=N<<13)^N<<9,I.i=E+1&7,z},function k($,E){var N,W=[];if(E===(0|E))W[0]=E;else for(E=""+E,N=0;N<E.length;++N)W[7&N]=W[7&N]<<15^E.charCodeAt(N)+W[N+1&7]<<13;for(;W.length<8;)W.push(0);for(N=0;N<8&&0===W[N];++N);for(8==N&&(W[7]=-1),$.x=W,$.i=0,N=256;N>0;--N)$.next()}(I,P)}function Ce(P,I){return I.x=P.x.slice(),I.i=P.i,I}function ie(P,I){null==P&&(P=+new Date);var k=new be(P),$=I&&I.state,E=function(){return(k.next()>>>0)/4294967296};return E.double=function(){do{var W=((k.next()>>>11)+(k.next()>>>0)/4294967296)/(1<<21)}while(0===W);return W},E.int32=k.next,E.quick=E,$&&($.x&&Ce($,k),E.state=function(){return Ce(k,{})}),E}X&&X.exports?X.exports=ie:B.amdD&&B.amdO?void 0!==(he=function(){return ie}.call(_e,B,_e,X))&&(X.exports=he):this.xorshift7=ie}(0,ce=B.nmd(ce))},516:function(ce,_e,B){var he;!function(st,X,Ze){function be(P){var I=this,k="";I.next=function(){var E=I.x^I.x>>>2;return I.x=I.y,I.y=I.z,I.z=I.w,I.w=I.v,(I.d=I.d+362437|0)+(I.v=I.v^I.v<<4^E^E<<1)|0},I.x=0,I.y=0,I.z=0,I.w=0,I.v=0,P===(0|P)?I.x=P:k+=P;for(var $=0;$<k.length+64;$++)I.x^=0|k.charCodeAt($),$==k.length&&(I.d=I.x<<10^I.x>>>4),I.next()}function Ce(P,I){return I.x=P.x,I.y=P.y,I.z=P.z,I.w=P.w,I.v=P.v,I.d=P.d,I}function ie(P,I){var k=new be(P),$=I&&I.state,E=function(){return(k.next()>>>0)/4294967296};return E.double=function(){do{var W=((k.next()>>>11)+(k.next()>>>0)/4294967296)/(1<<21)}while(0===W);return W},E.int32=k.next,E.quick=E,$&&("object"==typeof $&&Ce($,k),E.state=function(){return Ce(k,{})}),E}X&&X.exports?X.exports=ie:B.amdD&&B.amdO?void 0!==(he=function(){return ie}.call(_e,B,_e,X))&&(X.exports=he):this.xorwow=ie}(0,ce=B.nmd(ce))},390:(ce,_e,B)=>{var he;!function(st,X){var N,Ze=this,be=256,P="random",I=X.pow(be,6),k=X.pow(2,52),$=2*k,E=255;function z(fe,ae,Ye){var Re=[],ke=wt(Rt((ae=1==ae?{entropy:!0}:ae||{}).entropy?[fe,Dn(st)]:fe??function In(){try{var fe;return N&&(fe=N.randomBytes)?fe=fe(be):(fe=new Uint8Array(be),(Ze.crypto||Ze.msCrypto).getRandomValues(fe)),Dn(fe)}catch{var ae=Ze.navigator,Ye=ae&&ae.plugins;return[+new Date,Ze,Ye,Ze.screen,Dn(st)]}}(),3),Re),Ve=new W(Re),mt=function(){for(var lt=Ve.g(6),Et=I,dt=0;lt<k;)lt=(lt+dt)*be,Et*=be,dt=Ve.g(1);for(;lt>=$;)lt/=2,Et/=2,dt>>>=1;return(lt+dt)/Et};return mt.int32=function(){return 0|Ve.g(4)},mt.quick=function(){return Ve.g(4)/4294967296},mt.double=mt,wt(Dn(Ve.S),st),(ae.pass||Ye||function(lt,Et,dt,Tt){return Tt&&(Tt.S&&Qe(Tt,Ve),lt.state=function(){return Qe(Ve,{})}),dt?(X[P]=lt,Et):lt})(mt,ke,"global"in ae?ae.global:this==X,ae.state)}function W(fe){var ae,Ye=fe.length,Re=this,ke=0,Ve=Re.i=Re.j=0,mt=Re.S=[];for(Ye||(fe=[Ye++]);ke<be;)mt[ke]=ke++;for(ke=0;ke<be;ke++)mt[ke]=mt[Ve=E&Ve+fe[ke%Ye]+(ae=mt[ke])],mt[Ve]=ae;(Re.g=function(lt){for(var Et,dt=0,Tt=Re.i,hr=Re.j,kn=Re.S;lt--;)Et=kn[Tt=E&Tt+1],dt=dt*be+kn[E&(kn[Tt]=kn[hr=E&hr+Et])+(kn[hr]=Et)];return Re.i=Tt,Re.j=hr,dt})(be)}function Qe(fe,ae){return ae.i=fe.i,ae.j=fe.j,ae.S=fe.S.slice(),ae}function Rt(fe,ae){var ke,Ye=[],Re=typeof fe;if(ae&&"object"==Re)for(ke in fe)try{Ye.push(Rt(fe[ke],ae-1))}catch{}return Ye.length?Ye:"string"==Re?fe:fe+"\0"}function wt(fe,ae){for(var Re,Ye=fe+"",ke=0;ke<Ye.length;)ae[E&ke]=E&(Re^=19*ae[E&ke])+Ye.charCodeAt(ke++);return Dn(ae)}function Dn(fe){return String.fromCharCode.apply(0,fe)}if(X["seed"+P]=z,wt(X.random(),st),ce.exports){ce.exports=z;try{N=B(914)}catch{}}else void 0!==(he=function(){return z}.call(_e,B,_e,ce))&&(ce.exports=he)}([],Math)},349:(ce,_e,B)=>{var he=B(300),st=B(650),X=B(100),Ze=B(69),be=B(120),Ce=B(703),ie=B(97);ie.alea=he,ie.xor128=st,ie.xorwow=X,ie.xorshift7=Ze,ie.xor4096=be,ie.tychei=Ce,ce.exports=ie},300:function(ce,_e,B){var he;!function(st,X,Ze){function be(I){var k=this,$=function P(){var I=4022871197;return function($){$=$.toString();for(var E=0;E<$.length;E++){var N=.02519603282416938*(I+=$.charCodeAt(E));N-=I=N>>>0,I=(N*=I)>>>0,I+=4294967296*(N-=I)}return 2.3283064365386963e-10*(I>>>0)}}();k.next=function(){var E=2091639*k.s0+2.3283064365386963e-10*k.c;return k.s0=k.s1,k.s1=k.s2,k.s2=E-(k.c=0|E)},k.c=1,k.s0=$(" "),k.s1=$(" "),k.s2=$(" "),k.s0-=$(I),k.s0<0&&(k.s0+=1),k.s1-=$(I),k.s1<0&&(k.s1+=1),k.s2-=$(I),k.s2<0&&(k.s2+=1),$=null}function Ce(I,k){return k.c=I.c,k.s0=I.s0,k.s1=I.s1,k.s2=I.s2,k}function ie(I,k){var $=new be(I),E=k&&k.state,N=$.next;return N.int32=function(){return 4294967296*$.next()|0},N.double=function(){return N()+11102230246251565e-32*(2097152*N()|0)},N.quick=N,E&&("object"==typeof E&&Ce(E,$),N.state=function(){return Ce($,{})}),N}X&&X.exports?X.exports=ie:B.amdD&&B.amdO?void 0!==(he=function(){return ie}.call(_e,B,_e,X))&&(X.exports=he):this.alea=ie}(0,ce=B.nmd(ce))},703:function(ce,_e,B){var he;!function(st,X,Ze){function be(P){var I=this,k="";I.next=function(){var E=I.b,N=I.c,z=I.d,W=I.a;return E=E<<25^E>>>7^N,N=N-z|0,z=z<<24^z>>>8^W,W=W-E|0,I.b=E=E<<20^E>>>12^N,I.c=N=N-z|0,I.d=z<<16^N>>>16^W,I.a=W-E|0},I.a=0,I.b=0,I.c=-1640531527,I.d=1367130551,P===Math.floor(P)?(I.a=P/4294967296|0,I.b=0|P):k+=P;for(var $=0;$<k.length+20;$++)I.b^=0|k.charCodeAt($),I.next()}function Ce(P,I){return I.a=P.a,I.b=P.b,I.c=P.c,I.d=P.d,I}function ie(P,I){var k=new be(P),$=I&&I.state,E=function(){return(k.next()>>>0)/4294967296};return E.double=function(){do{var W=((k.next()>>>11)+(k.next()>>>0)/4294967296)/(1<<21)}while(0===W);return W},E.int32=k.next,E.quick=E,$&&("object"==typeof $&&Ce($,k),E.state=function(){return Ce(k,{})}),E}X&&X.exports?X.exports=ie:B.amdD&&B.amdO?void 0!==(he=function(){return ie}.call(_e,B,_e,X))&&(X.exports=he):this.tychei=ie}(0,ce=B.nmd(ce))},650:function(ce,_e,B){var he;!function(st,X,Ze){function be(P){var I=this,k="";I.x=0,I.y=0,I.z=0,I.w=0,I.next=function(){var E=I.x^I.x<<11;return I.x=I.y,I.y=I.z,I.z=I.w,I.w^=I.w>>>19^E^E>>>8},P===(0|P)?I.x=P:k+=P;for(var $=0;$<k.length+64;$++)I.x^=0|k.charCodeAt($),I.next()}function Ce(P,I){return I.x=P.x,I.y=P.y,I.z=P.z,I.w=P.w,I}function ie(P,I){var k=new be(P),$=I&&I.state,E=function(){return(k.next()>>>0)/4294967296};return E.double=function(){do{var W=((k.next()>>>11)+(k.next()>>>0)/4294967296)/(1<<21)}while(0===W);return W},E.int32=k.next,E.quick=E,$&&("object"==typeof $&&Ce($,k),E.state=function(){return Ce(k,{})}),E}X&&X.exports?X.exports=ie:B.amdD&&B.amdO?void 0!==(he=function(){return ie}.call(_e,B,_e,X))&&(X.exports=he):this.xor128=ie}(0,ce=B.nmd(ce))},120:function(ce,_e,B){var he;!function(st,X,Ze){function be(P){var I=this;I.next=function(){var z,W,$=I.w,E=I.X,N=I.i;return I.w=$=$+1640531527|0,W=E[N+34&127],z=E[N=N+1&127],W^=W<<13,z^=z<<17,W=E[N]=(W^=W>>>15)^(z^=z>>>12),I.i=N,W+($^$>>>16)|0},function k($,E){var N,z,W,Qe,Rt,wt=[],In=128;for(E===(0|E)?(z=E,E=null):(E+="\0",z=0,In=Math.max(In,E.length)),W=0,Qe=-32;Qe<In;++Qe)E&&(z^=E.charCodeAt((Qe+32)%E.length)),0===Qe&&(Rt=z),z^=z<<10,z^=z>>>15,z^=z<<4,z^=z>>>13,Qe>=0&&(W=0==(N=wt[127&Qe]^=z+(Rt=Rt+1640531527|0))?W+1:0);for(W>=128&&(wt[127&(E&&E.length||0)]=-1),W=127,Qe=512;Qe>0;--Qe)z=wt[W+34&127],N=wt[W=W+1&127],z^=z<<13,N^=N<<17,wt[W]=(z^=z>>>15)^(N^=N>>>12);$.w=Rt,$.X=wt,$.i=W}(I,P)}function Ce(P,I){return I.i=P.i,I.w=P.w,I.X=P.X.slice(),I}function ie(P,I){null==P&&(P=+new Date);var k=new be(P),$=I&&I.state,E=function(){return(k.next()>>>0)/4294967296};return E.double=function(){do{var W=((k.next()>>>11)+(k.next()>>>0)/4294967296)/(1<<21)}while(0===W);return W},E.int32=k.next,E.quick=E,$&&($.X&&Ce($,k),E.state=function(){return Ce(k,{})}),E}X&&X.exports?X.exports=ie:B.amdD&&B.amdO?void 0!==(he=function(){return ie}.call(_e,B,_e,X))&&(X.exports=he):this.xor4096=ie}(0,ce=B.nmd(ce))},69:function(ce,_e,B){var he;!function(st,X,Ze){function be(P){var I=this;I.next=function(){var N,z,$=I.x,E=I.i;return N=$[E],z=(N^=N>>>7)^N<<24,z^=(N=$[E+1&7])^N>>>10,z^=(N=$[E+3&7])^N>>>3,z^=(N=$[E+4&7])^N<<7,N=$[E+7&7],$[E]=z^=(N^=N<<13)^N<<9,I.i=E+1&7,z},function k($,E){var N,W=[];if(E===(0|E))W[0]=E;else for(E=""+E,N=0;N<E.length;++N)W[7&N]=W[7&N]<<15^E.charCodeAt(N)+W[N+1&7]<<13;for(;W.length<8;)W.push(0);for(N=0;N<8&&0===W[N];++N);for(8==N&&(W[7]=-1),$.x=W,$.i=0,N=256;N>0;--N)$.next()}(I,P)}function Ce(P,I){return I.x=P.x.slice(),I.i=P.i,I}function ie(P,I){null==P&&(P=+new Date);var k=new be(P),$=I&&I.state,E=function(){return(k.next()>>>0)/4294967296};return E.double=function(){do{var W=((k.next()>>>11)+(k.next()>>>0)/4294967296)/(1<<21)}while(0===W);return W},E.int32=k.next,E.quick=E,$&&($.x&&Ce($,k),E.state=function(){return Ce(k,{})}),E}X&&X.exports?X.exports=ie:B.amdD&&B.amdO?void 0!==(he=function(){return ie}.call(_e,B,_e,X))&&(X.exports=he):this.xorshift7=ie}(0,ce=B.nmd(ce))},100:function(ce,_e,B){var he;!function(st,X,Ze){function be(P){var I=this,k="";I.next=function(){var E=I.x^I.x>>>2;return I.x=I.y,I.y=I.z,I.z=I.w,I.w=I.v,(I.d=I.d+362437|0)+(I.v=I.v^I.v<<4^E^E<<1)|0},I.x=0,I.y=0,I.z=0,I.w=0,I.v=0,P===(0|P)?I.x=P:k+=P;for(var $=0;$<k.length+64;$++)I.x^=0|k.charCodeAt($),$==k.length&&(I.d=I.x<<10^I.x>>>4),I.next()}function Ce(P,I){return I.x=P.x,I.y=P.y,I.z=P.z,I.w=P.w,I.v=P.v,I.d=P.d,I}function ie(P,I){var k=new be(P),$=I&&I.state,E=function(){return(k.next()>>>0)/4294967296};return E.double=function(){do{var W=((k.next()>>>11)+(k.next()>>>0)/4294967296)/(1<<21)}while(0===W);return W},E.int32=k.next,E.quick=E,$&&("object"==typeof $&&Ce($,k),E.state=function(){return Ce(k,{})}),E}X&&X.exports?X.exports=ie:B.amdD&&B.amdO?void 0!==(he=function(){return ie}.call(_e,B,_e,X))&&(X.exports=he):this.xorwow=ie}(0,ce=B.nmd(ce))},97:(ce,_e,B)=>{var he;!function(st,X){var N,Ze=this,be=256,P="random",I=X.pow(be,6),k=X.pow(2,52),$=2*k,E=255;function z(fe,ae,Ye){var Re=[],ke=wt(Rt((ae=1==ae?{entropy:!0}:ae||{}).entropy?[fe,Dn(st)]:fe??function In(){try{var fe;return N&&(fe=N.randomBytes)?fe=fe(be):(fe=new Uint8Array(be),(Ze.crypto||Ze.msCrypto).getRandomValues(fe)),Dn(fe)}catch{var ae=Ze.navigator,Ye=ae&&ae.plugins;return[+new Date,Ze,Ye,Ze.screen,Dn(st)]}}(),3),Re),Ve=new W(Re),mt=function(){for(var lt=Ve.g(6),Et=I,dt=0;lt<k;)lt=(lt+dt)*be,Et*=be,dt=Ve.g(1);for(;lt>=$;)lt/=2,Et/=2,dt>>>=1;return(lt+dt)/Et};return mt.int32=function(){return 0|Ve.g(4)},mt.quick=function(){return Ve.g(4)/4294967296},mt.double=mt,wt(Dn(Ve.S),st),(ae.pass||Ye||function(lt,Et,dt,Tt){return Tt&&(Tt.S&&Qe(Tt,Ve),lt.state=function(){return Qe(Ve,{})}),dt?(X[P]=lt,Et):lt})(mt,ke,"global"in ae?ae.global:this==X,ae.state)}function W(fe){var ae,Ye=fe.length,Re=this,ke=0,Ve=Re.i=Re.j=0,mt=Re.S=[];for(Ye||(fe=[Ye++]);ke<be;)mt[ke]=ke++;for(ke=0;ke<be;ke++)mt[ke]=mt[Ve=E&Ve+fe[ke%Ye]+(ae=mt[ke])],mt[Ve]=ae;(Re.g=function(lt){for(var Et,dt=0,Tt=Re.i,hr=Re.j,kn=Re.S;lt--;)Et=kn[Tt=E&Tt+1],dt=dt*be+kn[E&(kn[Tt]=kn[hr=E&hr+Et])+(kn[hr]=Et)];return Re.i=Tt,Re.j=hr,dt})(be)}function Qe(fe,ae){return ae.i=fe.i,ae.j=fe.j,ae.S=fe.S.slice(),ae}function Rt(fe,ae){var ke,Ye=[],Re=typeof fe;if(ae&&"object"==Re)for(ke in fe)try{Ye.push(Rt(fe[ke],ae-1))}catch{}return Ye.length?Ye:"string"==Re?fe:fe+"\0"}function wt(fe,ae){for(var Re,Ye=fe+"",ke=0;ke<Ye.length;)ae[E&ke]=E&(Re^=19*ae[E&ke])+Ye.charCodeAt(ke++);return Dn(ae)}function Dn(fe){return String.fromCharCode.apply(0,fe)}if(X["seed"+P]=z,wt(X.random(),st),ce.exports){ce.exports=z;try{N=B(778)}catch{}}else void 0!==(he=function(){return z}.call(_e,B,_e,ce))&&(ce.exports=he)}([],Math)},340:(ce,_e,B)=>{var he=B(471),st=B(992),X=B(657),Ze=B(583),be=B(929),Ce=B(83),ie=B(818);ie.alea=he,ie.xor128=st,ie.xorwow=X,ie.xorshift7=Ze,ie.xor4096=be,ie.tychei=Ce,ce.exports=ie},471:function(ce,_e,B){var he;!function(st,X,Ze){function be(I){var k=this,$=function P(){var I=4022871197;return function($){$=$.toString();for(var E=0;E<$.length;E++){var N=.02519603282416938*(I+=$.charCodeAt(E));N-=I=N>>>0,I=(N*=I)>>>0,I+=4294967296*(N-=I)}return 2.3283064365386963e-10*(I>>>0)}}();k.next=function(){var E=2091639*k.s0+2.3283064365386963e-10*k.c;return k.s0=k.s1,k.s1=k.s2,k.s2=E-(k.c=0|E)},k.c=1,k.s0=$(" "),k.s1=$(" "),k.s2=$(" "),k.s0-=$(I),k.s0<0&&(k.s0+=1),k.s1-=$(I),k.s1<0&&(k.s1+=1),k.s2-=$(I),k.s2<0&&(k.s2+=1),$=null}function Ce(I,k){return k.c=I.c,k.s0=I.s0,k.s1=I.s1,k.s2=I.s2,k}function ie(I,k){var $=new be(I),E=k&&k.state,N=$.next;return N.int32=function(){return 4294967296*$.next()|0},N.double=function(){return N()+11102230246251565e-32*(2097152*N()|0)},N.quick=N,E&&("object"==typeof E&&Ce(E,$),N.state=function(){return Ce($,{})}),N}X&&X.exports?X.exports=ie:B.amdD&&B.amdO?void 0!==(he=function(){return ie}.call(_e,B,_e,X))&&(X.exports=he):this.alea=ie}(0,ce=B.nmd(ce))},83:function(ce,_e,B){var he;!function(st,X,Ze){function be(P){var I=this,k="";I.next=function(){var E=I.b,N=I.c,z=I.d,W=I.a;return E=E<<25^E>>>7^N,N=N-z|0,z=z<<24^z>>>8^W,W=W-E|0,I.b=E=E<<20^E>>>12^N,I.c=N=N-z|0,I.d=z<<16^N>>>16^W,I.a=W-E|0},I.a=0,I.b=0,I.c=-1640531527,I.d=1367130551,P===Math.floor(P)?(I.a=P/4294967296|0,I.b=0|P):k+=P;for(var $=0;$<k.length+20;$++)I.b^=0|k.charCodeAt($),I.next()}function Ce(P,I){return I.a=P.a,I.b=P.b,I.c=P.c,I.d=P.d,I}function ie(P,I){var k=new be(P),$=I&&I.state,E=function(){return(k.next()>>>0)/4294967296};return E.double=function(){do{var W=((k.next()>>>11)+(k.next()>>>0)/4294967296)/(1<<21)}while(0===W);return W},E.int32=k.next,E.quick=E,$&&("object"==typeof $&&Ce($,k),E.state=function(){return Ce(k,{})}),E}X&&X.exports?X.exports=ie:B.amdD&&B.amdO?void 0!==(he=function(){return ie}.call(_e,B,_e,X))&&(X.exports=he):this.tychei=ie}(0,ce=B.nmd(ce))},992:function(ce,_e,B){var he;!function(st,X,Ze){function be(P){var I=this,k="";I.x=0,I.y=0,I.z=0,I.w=0,I.next=function(){var E=I.x^I.x<<11;return I.x=I.y,I.y=I.z,I.z=I.w,I.w^=I.w>>>19^E^E>>>8},P===(0|P)?I.x=P:k+=P;for(var $=0;$<k.length+64;$++)I.x^=0|k.charCodeAt($),I.next()}function Ce(P,I){return I.x=P.x,I.y=P.y,I.z=P.z,I.w=P.w,I}function ie(P,I){var k=new be(P),$=I&&I.state,E=function(){return(k.next()>>>0)/4294967296};return E.double=function(){do{var W=((k.next()>>>11)+(k.next()>>>0)/4294967296)/(1<<21)}while(0===W);return W},E.int32=k.next,E.quick=E,$&&("object"==typeof $&&Ce($,k),E.state=function(){return Ce(k,{})}),E}X&&X.exports?X.exports=ie:B.amdD&&B.amdO?void 0!==(he=function(){return ie}.call(_e,B,_e,X))&&(X.exports=he):this.xor128=ie}(0,ce=B.nmd(ce))},929:function(ce,_e,B){var he;!function(st,X,Ze){function be(P){var I=this;I.next=function(){var z,W,$=I.w,E=I.X,N=I.i;return I.w=$=$+1640531527|0,W=E[N+34&127],z=E[N=N+1&127],W^=W<<13,z^=z<<17,W=E[N]=(W^=W>>>15)^(z^=z>>>12),I.i=N,W+($^$>>>16)|0},function k($,E){var N,z,W,Qe,Rt,wt=[],In=128;for(E===(0|E)?(z=E,E=null):(E+="\0",z=0,In=Math.max(In,E.length)),W=0,Qe=-32;Qe<In;++Qe)E&&(z^=E.charCodeAt((Qe+32)%E.length)),0===Qe&&(Rt=z),z^=z<<10,z^=z>>>15,z^=z<<4,z^=z>>>13,Qe>=0&&(W=0==(N=wt[127&Qe]^=z+(Rt=Rt+1640531527|0))?W+1:0);for(W>=128&&(wt[127&(E&&E.length||0)]=-1),W=127,Qe=512;Qe>0;--Qe)z=wt[W+34&127],N=wt[W=W+1&127],z^=z<<13,N^=N<<17,wt[W]=(z^=z>>>15)^(N^=N>>>12);$.w=Rt,$.X=wt,$.i=W}(I,P)}function Ce(P,I){return I.i=P.i,I.w=P.w,I.X=P.X.slice(),I}function ie(P,I){null==P&&(P=+new Date);var k=new be(P),$=I&&I.state,E=function(){return(k.next()>>>0)/4294967296};return E.double=function(){do{var W=((k.next()>>>11)+(k.next()>>>0)/4294967296)/(1<<21)}while(0===W);return W},E.int32=k.next,E.quick=E,$&&($.X&&Ce($,k),E.state=function(){return Ce(k,{})}),E}X&&X.exports?X.exports=ie:B.amdD&&B.amdO?void 0!==(he=function(){return ie}.call(_e,B,_e,X))&&(X.exports=he):this.xor4096=ie}(0,ce=B.nmd(ce))},583:function(ce,_e,B){var he;!function(st,X,Ze){function be(P){var I=this;I.next=function(){var N,z,$=I.x,E=I.i;return N=$[E],z=(N^=N>>>7)^N<<24,z^=(N=$[E+1&7])^N>>>10,z^=(N=$[E+3&7])^N>>>3,z^=(N=$[E+4&7])^N<<7,N=$[E+7&7],$[E]=z^=(N^=N<<13)^N<<9,I.i=E+1&7,z},function k($,E){var N,W=[];if(E===(0|E))W[0]=E;else for(E=""+E,N=0;N<E.length;++N)W[7&N]=W[7&N]<<15^E.charCodeAt(N)+W[N+1&7]<<13;for(;W.length<8;)W.push(0);for(N=0;N<8&&0===W[N];++N);for(8==N&&(W[7]=-1),$.x=W,$.i=0,N=256;N>0;--N)$.next()}(I,P)}function Ce(P,I){return I.x=P.x.slice(),I.i=P.i,I}function ie(P,I){null==P&&(P=+new Date);var k=new be(P),$=I&&I.state,E=function(){return(k.next()>>>0)/4294967296};return E.double=function(){do{var W=((k.next()>>>11)+(k.next()>>>0)/4294967296)/(1<<21)}while(0===W);return W},E.int32=k.next,E.quick=E,$&&($.x&&Ce($,k),E.state=function(){return Ce(k,{})}),E}X&&X.exports?X.exports=ie:B.amdD&&B.amdO?void 0!==(he=function(){return ie}.call(_e,B,_e,X))&&(X.exports=he):this.xorshift7=ie}(0,ce=B.nmd(ce))},657:function(ce,_e,B){var he;!function(st,X,Ze){function be(P){var I=this,k="";I.next=function(){var E=I.x^I.x>>>2;return I.x=I.y,I.y=I.z,I.z=I.w,I.w=I.v,(I.d=I.d+362437|0)+(I.v=I.v^I.v<<4^E^E<<1)|0},I.x=0,I.y=0,I.z=0,I.w=0,I.v=0,P===(0|P)?I.x=P:k+=P;for(var $=0;$<k.length+64;$++)I.x^=0|k.charCodeAt($),$==k.length&&(I.d=I.x<<10^I.x>>>4),I.next()}function Ce(P,I){return I.x=P.x,I.y=P.y,I.z=P.z,I.w=P.w,I.v=P.v,I.d=P.d,I}function ie(P,I){var k=new be(P),$=I&&I.state,E=function(){return(k.next()>>>0)/4294967296};return E.double=function(){do{var W=((k.next()>>>11)+(k.next()>>>0)/4294967296)/(1<<21)}while(0===W);return W},E.int32=k.next,E.quick=E,$&&("object"==typeof $&&Ce($,k),E.state=function(){return Ce(k,{})}),E}X&&X.exports?X.exports=ie:B.amdD&&B.amdO?void 0!==(he=function(){return ie}.call(_e,B,_e,X))&&(X.exports=he):this.xorwow=ie}(0,ce=B.nmd(ce))},818:(ce,_e,B)=>{var he;!function(st,X){var N,Ze=(0,eval)("this"),be=256,P="random",I=X.pow(be,6),k=X.pow(2,52),$=2*k,E=255;function z(fe,ae,Ye){var Re=[],ke=wt(Rt((ae=1==ae?{entropy:!0}:ae||{}).entropy?[fe,Dn(st)]:fe??function In(){try{var fe;return N&&(fe=N.randomBytes)?fe=fe(be):(fe=new Uint8Array(be),(Ze.crypto||Ze.msCrypto).getRandomValues(fe)),Dn(fe)}catch{var ae=Ze.navigator,Ye=ae&&ae.plugins;return[+new Date,Ze,Ye,Ze.screen,Dn(st)]}}(),3),Re),Ve=new W(Re),mt=function(){for(var lt=Ve.g(6),Et=I,dt=0;lt<k;)lt=(lt+dt)*be,Et*=be,dt=Ve.g(1);for(;lt>=$;)lt/=2,Et/=2,dt>>>=1;return(lt+dt)/Et};return mt.int32=function(){return 0|Ve.g(4)},mt.quick=function(){return Ve.g(4)/4294967296},mt.double=mt,wt(Dn(Ve.S),st),(ae.pass||Ye||function(lt,Et,dt,Tt){return Tt&&(Tt.S&&Qe(Tt,Ve),lt.state=function(){return Qe(Ve,{})}),dt?(X[P]=lt,Et):lt})(mt,ke,"global"in ae?ae.global:this==X,ae.state)}function W(fe){var ae,Ye=fe.length,Re=this,ke=0,Ve=Re.i=Re.j=0,mt=Re.S=[];for(Ye||(fe=[Ye++]);ke<be;)mt[ke]=ke++;for(ke=0;ke<be;ke++)mt[ke]=mt[Ve=E&Ve+fe[ke%Ye]+(ae=mt[ke])],mt[Ve]=ae;(Re.g=function(lt){for(var Et,dt=0,Tt=Re.i,hr=Re.j,kn=Re.S;lt--;)Et=kn[Tt=E&Tt+1],dt=dt*be+kn[E&(kn[Tt]=kn[hr=E&hr+Et])+(kn[hr]=Et)];return Re.i=Tt,Re.j=hr,dt})(be)}function Qe(fe,ae){return ae.i=fe.i,ae.j=fe.j,ae.S=fe.S.slice(),ae}function Rt(fe,ae){var ke,Ye=[],Re=typeof fe;if(ae&&"object"==Re)for(ke in fe)try{Ye.push(Rt(fe[ke],ae-1))}catch{}return Ye.length?Ye:"string"==Re?fe:fe+"\0"}function wt(fe,ae){for(var Re,Ye=fe+"",ke=0;ke<Ye.length;)ae[E&ke]=E&(Re^=19*ae[E&ke])+Ye.charCodeAt(ke++);return Dn(ae)}function Dn(fe){return String.fromCharCode.apply(0,fe)}if(X["seed"+P]=z,wt(X.random(),st),ce.exports){ce.exports=z;try{N=B(42)}catch{}}else void 0!==(he=function(){return z}.call(_e,B,_e,ce))&&(ce.exports=he)}([],Math)},914:()=>{},410:()=>{},628:()=>{},778:()=>{},601:()=>{},792:()=>{},42:()=>{}},ce=>{ce(ce.s=912)}]);